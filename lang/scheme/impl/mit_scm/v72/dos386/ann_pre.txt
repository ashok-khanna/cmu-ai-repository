To: info-cscheme-dos@martigny.ai.mit.edu
Subject: Status report and test of mailing list
Reply-To: info-cscheme-dos-request@martigny.ai.mit.edu

No, we have not forgotten you.  We should be making the goodies
available early next week, probably Tuesday.

Here are some answers to questions that some of you have asked, and
also a description of the system (for those of you unfamiliar with
CScheme).


- Disk requirements:

They vary, depending on how full a development system you want to
install.  If you are only interested in debugging your own programs
(you are not interested in pretty printing PP, for example), you don't
need an editor, and are not terribly concerned about speed (i.e. the
interpreter is adequate), then you will need about 2.2 Mbytes of disk
space to hold a minimal system, however you may be better off using a
different implementation.  Our interpreter is big and somewhat clunky.
If you want debugging of system code and the compiler, you will need
more, at least 10 Mbytes, but I can't say exactly how much yet because
the most significant change to be made to the system is teach the
compiler how to produce significantly smaller debugging information
files.  They are currently enormous.  If, in addition, you want Edwin,
then you will need at least 5 Mbytes more.  If you want the works
(including sources, etc.) plan on 20 Mbytes+.


- OS/2 support:

We don't plan any.  Please don't try to convince us otherwise.  The
people currently doing this should be working on their PhD theses and
not on this, and have already spent too much time on something that
started as a hack.

However, if you are not uncomfortable with C, and know OS/2 moderately
well, it may be possible for you to do the work (we are willing to
answer questions).

We are currently using the Zortech C/C++ compiler to build the
"microcode" (the C part of the system).  Their compiler is supposed to
work under OS/2 as well.  However, there is some assembly language
code (to interface compiled scheme to interpreted scheme and C, and to
do some low-level keyboard I/O), which may not be trivial to port.


- Graphics support:

The short answer is "not yet".  We've tried to use Zortech's flash
graphics library, but have been marginally successful.  We will
probably remove the support before making the stuff available because
it is too unreliable to be useful, and is otherwise only taking up
space.  Whenever we have a real Windows interface (later this summer,
if all goes well), we will have graphics under Windows.  We are not
terribly interested in graphics outside of Windows.


- Getting the goodies if you don't have convenient FTP access:

For the alpha test, we can arrange something on a case-by-case basis
after we make the goodies available on the net.  If you cannot get the
stuff using the net, please send mail again to
info-cscheme-dos-request@zurich.ai.mit.edu when you see the
availability announcement and we'll arrange something then.  If you
have limited FTP access, we'd rather have you get the stuff that way
even if it means a little more work on your part (the extra work for
us is not constant, but linear on the number of people who want a
floppy distribution).

Once things settle, depending on demand, we will set up some standard
floppy distribution with an associated nuissance fee.


- Structure of the system:

The CScheme implementation consists of two major components, and two
major subsystems.

The "microcode" is the part written in C (and a little assembly
language).  It is called the microcode because it has evolved from an
emulator for the Scheme-81 chip.  It provides the garbage collector,
the Scode interpreter, and many primitives of the language (most
importantly those having to do with I/O).  This is the part of the
system that results in a DOS (or Unix) executable, but is useless by
itself, since it does not contain a reader (parser), compiler to
Scode, a read-eval-print loop, or an error system.  Currently, on DOS,
the executable (scheme.exe) is about 350 Kb, of which 50 Kb consists
of the Zortech flash graphics library which we may drop.


The runtime system is written in Scheme and provides all the support
that is needed to make the Scode interpreter usable (plus some more).
The runtime system includes the rest of the language primitives, the
user-level I/O system (ports and channels), the reader, the printer,
the compiler to Scode (usually called the syntaxer), the error and
interrupt systems, the debugger, the read-eval-print loop, and
assorted other facilities.  The runtime system is collected into a
file called a Scheme image or "band" usually named "runtime.com".
Under DOS, runtime.com is currently approx. 1.8 Mb.


The native-code compiler, called Liar, is an optional subsystem.  An
image containing the runtime system and Liar is usually called
compiler.com and takes up approx. 4.3 Mb.
The code produced by the compiler is adequate, not great, and is
pretty large.  The code is large not only because of inefficiencies in
the code, but also because of support for interrupts and GC, and for
mapping the compiled code back to the source and environment structure
to enable source-level debugging.  The compiler produces .com files
(an unfortunate choice for DOS, we know) and .inf files (an
unfortunate choice for OS/2, from what we gather).  The .com files are
the scheme executables (to be loaded into any scheme image, not to be
run independently), and the .inf files are the debugging information
files loaded on demand when source or reification of environment
structure for compiled code are needed.  The .inf files are currently
huge, but they should be manageable (probably not small) by the time
we distribute the stuff.


The Emacs-like editor, called Edwin, is another optional subsystem.
An image containing the runtime system and Edwin is usually called
edwin.com and takes up approx. 3.7 Mb.  Edwin is command-level
compatible with GNU Emacs (most of the key bindings are commands are
the same), but the "extension" language is Scheme (extended with
Edwin-specific facilities) rather than elisp.  The internal model for
the editor is also somewhat different, so elisp code cannot be
trivially trans-literated.  There is a project on the way to produce
an automatic elisp to Edwin Scheme translator.


As far as documentation is concerned, we will provide the current
(actually somewhat out of date) MIT Scheme Reference manual, the Unix
user's guide, and an addendum for DOS, plus some notes to highlight
the differences between the version released for Unix (that matches
the documentation) and the (newer) version released for DOS, and
installation notes.  Later this year there will be a newer manual
describing some of the additional facilities.
