; From whumeniu@DATAP.CA Fri Feb 11 11:55:13 EST 1994
; Article: 8278 of comp.lang.scheme
; Xref: glinda.oz.cs.cmu.edu comp.lang.scheme:8278
; Newsgroups: comp.lang.scheme
; Path: honeydew.srv.cs.cmu.edu!fs7.ece.cmu.edu!europa.eng.gtefsd.com!howland.reston.ans.net!math.ohio-state.edu!cyber2.cyberstore.ca!nntp.cs.ubc.ca!alberta!fantom!crs-sys!nextedm!spl4!cuugnet!renshawg
; From: whumeniu@DATAP.CA (Wade Humeniuk)
; Subject: Macroless Object System
; Originator: renshawg@cuug.ab.ca
; Sender: usenet@cuug.ab.ca
; Message-ID: <CL0wy4.Jxq@cuug.ab.ca>
; Date: Thu, 10 Feb 1994 19:32:27 GMT
; Organization: Sandwell Inc. Datap Systems Division
; Lines: 174
; 
; I was trying to use yasos.scm from slib with MacGambit and encountered
; some problems getting it going.  Gambit does not support R4RS
; define-syntax and slib was not behaving well, so I was trying to
; implement it using Gambit's ##define-macro.  I then thought, can I do
; this without macros?  The result is below.  It is not yasos, but is
; close to the intent.  This approach was motivated by:
; 
; - yasos
; - MacScheme's %object macro
; - Lack of R4RS hygenic macros
; - CLOS
; 
; If anyone has produced anything like this I would like to
; hear about it.  Any suggestions would be appreciated.
; 
; Wade Humeniuk
; whumeniu@datap.ca

;; Macroless object system

(define object? #f)
(define make-generic-method #f)
(define make-generic-predicate #f)
(define make-object #f)
(define make-method! #f)
(define get-method #f)
(define unmake-method! #f)
(define make-predicate! #f)

(let ()
  ;; Object Construction:
  ;;       0           1          2             3              4
  ;; #(object-tag get-method make-method! unmake-method! get-all-methods)

  (define object-tag "object")
  (define (removeq obj alist)
    (if (null? alist)
	alist
	(if (eq? (caar alist) obj)
	    (cdr alist)
	    (cons (car alist) (removeq obj (cdr alist))))))

  (define (get-all-methods obj)
    (if (object? obj)
	((vector-ref obj 4))
	(error "Cannot get methods on non-object: " obj)))

  (set! object?
	(lambda (obj) (and (vector? obj)
                           (eq? object-tag (vector-ref obj 0)))))
  (set! make-method!
        (lambda (obj generic-method method)
	  (if (object? obj)
	      (if (procedure? method)
		  (begin
		    ((vector-ref obj 2) generic-method method)
		    method)
		  (error "Method must be a procedure: " method))
	      (error "Cannot make method on non-object: " obj))))
  
  (set! get-method 
	(lambda (obj generic-method)
          (if (object? obj)
	      ((vector-ref obj 1) generic-method)
	      (error "Cannot get method on non-object: " obj))))
  
  (set! unmake-method!
        (lambda (obj generic-method)
	  (if (object? obj)
	      ((vector-ref obj 3) generic-method)
	      (error "Cannot unmake method on non-object: " obj))))
  
  (set! make-predicate! 
        (lambda (obj generic-predicate)
          (if (object? obj)
	      ((vector-ref obj 2) generic-predicate (lambda () #f))
	      (error "Cannot make predicate on non-object: " obj))))

  (set! make-generic-method
        (lambda exception-handler
          (define generic-method
            (lambda (obj . operands)
              (if (object? obj)
		  (let ((object-method ((vector-ref obj 1) generic-method)))
		    (if object-method
			(apply object-method operands)
			(error "Method not supported: " obj)))
		  (apply exception-handler (cons obj operands)))))
  
	  (if (not (null? exception-handler))
	      (if (procedure? (car exception-handler))
		  (set! exception-handler (car exception-handler))
		  (error "Exception Handler Not Procedure:"))
	      (set! exception-handler 
		    (lambda (obj . params) 
		      (error "Operation not supported: " obj))))
          generic-method))
  
  (set! make-generic-predicate
	(lambda ()
	  (define predicate (lambda (obj)
			      (if (object? obj)
				  ((vector-ref obj 2) predicate)
				  #f)))
	  predicate))
  
  (set! make-object 
        (lambda ancestors
          (define method-list 
            (apply append (map (lambda (obj) (get-all-methods obj)) ancestors)))
          (define (make-method! generic-method method)
            (set! method-list (cons (cons generic-method method) method-list))
            method)
          (define (unmake-method! generic-method) 
            (set! method-list (removeq generic-method method-list))
            #t)
          (define (all-methods) method-list)
          (define (get-method generic-method)
            (let ((method-def (assq generic-method method-list)))
              (if method-def (cdr method-def) #f)))
          (vector object-tag get-method make-method! unmake-method! all-methods)))
  )


;; Examples

(define value (make-generic-method (lambda (val) val)))
(define set-value! (make-generic-method))
(define invert (make-generic-method 
		(lambda (val)
		  (if (number? val) 
		      (/ 1 val)
		      (error "Method not supported:" val)))))

(define noop (make-generic-method))
(define inverter? (make-generic-predicate))

(define (make-integer x)  
  (define self (make-object))
  (make-method! self value (lambda () x))
  (make-method! self set-value!
		(lambda (new-value) 
		  (set! x new-value)))
  self)

(define (make-inverter)
  (define self (make-object (make-integer 1)))
  (define @value (get-method self value))
  (make-method! self invert (lambda () (/ 1 (@value))))
  (make-predicate! self inverter?)
  self)

(define invert! (make-generic-method))


(define x (make-inverter))

(make-method! x invert! (lambda () (set-value! x (/ 1 (value x)))))

(value x)   ;==> 1
(set-value! x 33) ;==> 33
(invert! x)   ;==> undefined
(value x)    ;==> 1/33

(unmake-method! x invert!)  ;==> undefined

(invert! x)  ;==>  ERROR: Method not supported: x

;;; *EOF*



