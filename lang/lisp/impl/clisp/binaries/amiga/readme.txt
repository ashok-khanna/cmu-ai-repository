Dear lisper,

This archive contains the Amiga version of CLISP as of 8th November 1993,
slightly modified on 11th of December. Please see the files clisp.man and
README too. Aminet archive names have been shortened to fit the 20 characters
limit.

There are two distinct binary versions of CLISP. These will be referred as
*-high and *-low. Depending on your machine, you'll be able to run one or the
other, or both, or - hopefully not - none.

o The *-low Version:

  + has been compiled with a 68000 in mind. It can only deal with a 16MB
    address space ranging from 0 to 0x00FFFFFF. It clears the upper 8 bits of
    a 32 bit address before putting it on the bus and won't forget to check
    the memory it gets from the system.

  * checks whether AllocMem(MEMF_ANY) returns memory in the above range. If
    not, and if the CPU is not a 68000, it uses MEMF_24BITDMA (MEMF_CHIP on
    pre-2.0 machines) to ensure that it does not get memory outside the 16MB
    address range. DMA-able memory is a bit too hard a requirement, but there
    are no other flags.

  + can be made to run on a A3000 or A4000 by patching the executable to load
    the code and data hunks into CHIP memory (24BITDMA would suffice with
    >=2.0, but one can't say that easily in the load hunk structure). The
    supplied ratom.rexx ARexx script can do this for you, but you really
    don't want to run CLISP out of CHIP memory now that there is the *-high
    version.

o The *-high version:

  + has been compiled for 68020 and higher, won't run on 68000 CPUs. It
    doesn't use the floating point coprocessor.

  + is able to deal with addresses from 0 to 0x07FFFFFF, thus working on A3000
    and A4000 machines. I have been told that GigaMem uses addresses between
    0x20000000 and 0x60000000. CLISP cannot run with that.

  * checks the memory it gets, reverting to MEMF_24BITDMA (>2.0, otherwise
    MEMF_CHIP), like above.

o The Lisp-part of CLISP is in the CLisp-*-Part2 archive, e.g. the compiler
  source can be found there. The archive also contains the compiled Lisp
  files (with the .fas extension), enabling you to easily build your own
  lispinit.mem file. You can generate own lispinit.mem file by executing
  lisp.run -x (LOAD"init.fas")(SAVEINITMEM) in a shell, or call (SAVEINITMEM)
  directly when in your Lisp world.

o The complete CLISP source can be found in the clispsrc-1993-11-08.tar.gz
  archive (see file ANNOUNCE). You need to have GNU-zip (gzip) and tar (or
  gtar) to be able to unpack it. I rearchived it for Aminet distribution into
  CLispsrc-931108.lha.

o If you start (REXX-LOOP), the only exit is the exit-loop.cl ARexx
  script. I'd like comments and ideas for improvements of the ARexx interface.

o CLISP now always allocates its own stack and should not cause MungWall or
  Enforcer hits. I don't know whether this stack allocation feature may cause
  compatibility issues with future Amigas.

o Slightly fixed Workbench Startup so that you can run it from workbench, but
  it will still only read project files from the current directory. I still
  need to add NameFromLock() for 1.3.

o The CSA-Derringer 030 board provides memory at location $08c00000. You'll
  need to patch lisp.run with ratom.rexx (as mentioned above) for CLISP to
  run under this configuration.

o The lisp.run executable contains symbolic information. I previously did
  this because I was using gcc-2.3.3 -O2 -fomit-frame-pointer which put
  several bugs in the compiler output. I corrected two of them by
  hand-patching the assembly files. Gcc-2.5.4 produces correct
  output. Symbolic information will help you report bugs.


Changes: (_PART_ of CHANGES.LOG in the source tree)

Important note
--------------

* Changed bytecode format. All .fas files generated by previous CLISP versions
  are invalid and must be recompiled.

User visible changes
--------------------

* X3J13 vote <108> is implemented: New packages COMMON-LISP and
  COMMON-LISP-USER.

* X3J13 vote <112> is implemented:
  LOAD binds the variables *LOAD-PATHNAME* and *LOAD-TRUENAME*, COMPILE-FILE
  binds the variables *COMPILE-FILE-PATHNAME* and *COMPILE-FILE-TRUENAME*.
  New variables *LOAD-PATHNAME*, *LOAD-TRUENAME*, *COMPILE-FILE-PATHNAME*,
  *COMPILE-FILE-TRUENAME*.

* X3J13 vote <26> is implemented: COMPILE-FILE has a keyword argument :PRINT.
  New variables *COMPILE-WARNINGS*, *COMPILE-VERBOSE*, *COMPILE-PRINT*.

* COMPILE-FILE now handles top-level forms as described in CLtL2 p. 90:
  The macroexpansion of a top-level form is considered a top-level form.
  When a top-level form is a PROGN, LOCALLY, COMPILER-LET, SYMBOL-MACROLET
  or MACROLET form, the subforms of its body are considered top-level forms
  too and are compiled separately.
  This allows things like
    (PROGN (DEFCONSTANT X 3141) (DEFUN GET-X () X))
  or
    (PROGN (DEFCLASS SHIP () ()) (DEFUN SHIP-P (X) (TYPEP X 'SHIP)))
  to work.
  Warning: If you want to inhibit this splitting into separate forms (for
  example, because several of the forms refer to the same uninterned symbol),
  you have to use (LET () (PROGN ...)) instead of (PROGN ...).

* X3J13 vote <144> is implemented: New macro DECLAIM.

* X3J13 vote <113> is implemented: The macro LOCALLY is now a special form.

* X3J13 vote <12> is partially implemented: Native CLOS. New package CLOS
  containing the macros
    DEFCLASS, DEFMETHOD, DEFGENERIC, GENERIC-FUNCTION, GENERIC-FLET,
    GENERIC-LABELS, WITH-SLOTS, WITH-ACCESSORS,
  the functions
    FIND-CLASS, (SETF FIND-CLASS), CLASS-OF, CLASS-NAME, (SETF CLASS-NAME),
    SLOT-VALUE, SLOT-BOUNDP, SLOT-MAKUNBOUND, SLOT-EXISTS-P,
    CALL-NEXT-METHOD, NEXT-METHOD-P,
    NO-APPLICABLE-METHOD, NO-PRIMARY-METHOD, NO-NEXT-METHOD,
    FIND-METHOD, ADD-METHOD, REMOVE-METHOD, COMPUTE-APPLICABLE-METHODS,
    METHOD-QUALIFIERS, FUNCTION-KEYWORDS, SLOT-MISSING, SLOT-UNBOUND,
    PRINT-OBJECT, DESCRIBE-OBJECT, MAKE-INSTANCE, INITIALIZE-INSTANCE,
    REINITIALIZE-INSTANCE, SHARED-INITIALIZE,
  the classes
    STANDARD-CLASS, STRUCTURE-CLASS, BUILT-IN-CLASS, STANDARD-OBJECT,
    STANDARD-GENERIC-FUNCTION, STANDARD-METHOD and all predefined classes,
  and the method combination
    STANDARD.
  See impnotes.txt for details. X3J13 vote <13> is implemented, too.

* X3J13 vote <63> is implemented: DESCRIBE receives the output stream as
  optional argument. New function CLOS:DESCRIBE-OBJECT.

* X3J13 vote <149> is implemented: The second argument to SUBSEQ may now
  be NIL. Thanks to Thomas Kirk.

* X3J13 vote <175> is implemented: TAILP now also works on dotted lists.

* X3J13 vote <124> is implemented: (DECLARE (OPTIMIZE (DEBUG ...))) is legal.

* The type specifier (EQL object), a synonym for (MEMBER object), is now
  implemented.

* New DEFSTRUCT option :INHERIT which is exactly like :INCLUDE except that it
  doesn't create new accessors for the inherited slots. Use this option to
  avoid the problems that occur when using the same :CONC-NAME for the new
  and the inherited structure.

* X3J13 vote <150> is mostly implemented: Reading and printing of symbols
  (and characters with bits or fonts attributes) is now affected by
  (READTABLE-CASE *READTABLE*), whose value may be one of :UPCASE, :DOWNCASE
  and :PRESERVE. New place READTABLE-CASE.

* X3J13 vote <89> is implemented: (SETF symbol) is now a valid syntax for a
  function name in (funname ...), (FUNCTION funname), (DEFUN funname ...),
  (COMPILE funname ...), (DISASSEMBLE funname), (ED funname), FLET, LABELS etc.
  New function FDEFINITION. The first argument to the functions FUNCALL and
  APPLY, denoting a function, may now also be a list (SETF symbol).

* X3J13 vote <173> is implemented: New special form SYMBOL-MACROLET. The
  macroexpansion environment passed to macro expanders and to MACROEXPAND-1,
  MACROEXPAND, GET-SETF-METHOD, GET-SETF-METHOD-MULTIPLE-VALUE now comprises
  both the variable environment and the function environment.
  New macro DEFINE-SYMBOL-MACRO.

* New macro PRINT-UNREADABLE-OBJECT.

* New macro DEFPACKAGE.

* New function FUNCTION-LAMBDA-EXPRESSION.

* X3J13 vote <5> is implemented: The value of *APPLYHOOK* must now be
  a function of two arguments.

* X3J13 vote <104> is implemented: COMPILE-FILE now binds *READTABLE*.

* X3J13 vote <161> is implemented: SHADOW now accepts strings as well
  as symbols.

* New special form LOAD-TIME-VALUE.

* The function DIR now sorts its output.

* A new place (DEFAULT-DIRECTORY) manages the "current directory".

* Amiga version: allow opening of "files" on special devices.

* Amiga version: (SETQ *PRINT-PRETTY* T) is set in config.lsp for faster
  output, otherwise most console or handle-stream output is done one character
  at a time, causing a lot of DOS packets traffic and making it really
  slow, especially in an EMACS shell buffer.

* Amiga version: detect 68000 CPU, for better use of present memory.

Bug Fixes
---------

* Fixed a serious bug in GCD on 16-bit processors: (GCD x y) with
  2^k - 2^(k-16) <= |x|,|y| < 2^k could cause a division by zero.

* Fixed a serious bug in the compiler: When compiling functions inline
  whose parameters are special variables, incorrect code could be generated.

* Fixed a bug in the compiler which caused the compiler to crash in some
  rare cases, notably when compiling Garnet-2.2.

* Fixed a bogus error message that occurred when storing an out-of-range
  integer into an array of element-type (UNSIGNED-BYTE 32).

* Fixed EXPORT and USE-PACKAGE: Don't signal a name conflict between the
  symbol being exported and a symbol accessible in the using package if
  the latter symbol is on the list of shadowing symbols of the using package.

* Fixed VECTOR-PUSH-EXTEND. It now works on vectors of dimension 0 and
  on bit-vectors.

* Fixed PRINT-UNREADABLE-OBJECT: Don't output adjacent spaces.

* Fixed a bug in the reader that caused an endless loop or endless recursion
  when resolving #n=/#n# references in objects that already contained cyclic
  data structures, e.g. when reading (#1=a #.'#2=(b . #2#) #1#).

* Fixed a bogus error message in the complex number reader.

* Fixed DEFUN such that
  (progn
    (flet ((bar (x) (+ x 10))) (defun bar (y) (if (zerop y) 1 (bar (1- y))))
    (bar 1)
  )
  returns 10 instead of 1.

* Fixed a bug in the compiler that caused the compiler to crash by endless
  recursion and stack overflow when compiling assignments to symbol macros.

* Fixed a bug: The string comparison functions STRING<, STRING>, STRING<=,
  STRING>=, STRING/=, STRING-LESSP, STRING-GREATERP, STRING-NOT-GREATERP,
  STRING-NOT-LESSP, STRING-NOT-EQUAL now return the index of the first mismatch
  instead of T.

* Fixed a bug: The functions REMOVE-DUPLICATES and DELETE-DUPLICATES produced
  an out-of-bounds error when called on a small sequence, with :FROM-END T
  argument and without :END argument.

* Fixed a bug in the compiler which caused the compiler to crash when
  compiling (CASE key ...) forms with constant key.

* Fixed a bug in the compiler which produced unloadable .fas files
  when compiling forms like (SETF ... (FUNCTION LIST)).

* Fixed a bogus error message in the AREF function.

* Fixed a bug in + that occasionally caused (- x x) to return a
  long-float zero which was not EQL to the other zeroes of type LONG-FLOAT.

* Fixed a bug: Correctly do round-to-even when adding two long-floats.

* Fixed a bug: The destructive sequence functions DELETE etc. failed to
  produce an error when called on a sequence of type LIST and with an :END
  argument larger than the list's length.

* Corrected the branch cuts of the complex ATAN and ATANH functions.

* Fixed a bug in + that caused the sign of (+ x y) to be wrong when x and y
  were double-floats satisfying  0 < x < -y  or  0 > x > -y .

* Fixed TRACE so that functions calling TRACE are correctly handled by
  COMPILE-FILE.

* 68000 and other versions: Fixed a bug in the low-level division algorithm.

* 68000/68020 versions: Fixed some bugs in the low-level number crunching
  routines.


*** /src.orig/spvw.d	Sun Oct 31 05:28:26 1993
--- /src/spvw.d	Fri Dec 10 17:58:01 1993
***************
*** 654,659 ****
--- 654,669 ----
      #define CPU_IS_68000  cpu_is_68000
    #endif
  
+   # Flag für AllocMem().
+   # Noch können wir Speicher außerhalb des 24-Bit- (26-Bit- bei AMIGA3000) Adreßraums nicht nutzen.
+   #define default_allocmemflag  MEMF_ANY
+   #if !defined(WIDE) && !defined(MC68000)
+     # Es kann sein, daß wir mit MEMF_ANY Speicher bekommen, den wir
+     # nicht nutzen können. Dann versuchen wir's nochmal.
+     # Auf dem 68000 gibt es solchen jedoch prinzipiell nicht.
+     local uintL retry_allocmemflag;  # wird in init_amiga() gesetzt.
+   #endif
+ 
    # Doppelt verkettete Liste aller bisher belegten Speicherblöcke führen:
    typedef struct MemBlockHeader { struct MemBlockHeader * next;
                                    #ifdef SPVW_PAGES
***************
*** 670,686 ****
    #endif
  
    # Speicher vom Betriebssystem holen:
!   local void* allocmem (uintL amount);
!   local void* allocmem(amount)
      var reg2 uintL amount;
      { amount = round_up(amount+offsetofa(MemBlockHeader,usable_memory),4);
-       #if defined(WIDE) || defined(AMIGA3000)
-         #define allocmemflag  MEMF_ANY
-       #else
-         # Noch können wir Speicher außerhalb des 26-Bit-Adreßraums nicht nutzen.
-         # Auf dem 68000 gibt es solchen jedoch prinzipiell nicht.
-         #define allocmemflag  (CPU_IS_68000 ? MEMF_ANY : MEMF_24BITDMA)
-       #endif
       {var reg1 void* address = AllocMem(amount,allocmemflag);
        if (!(address==NULL))
          { ((MemBlockHeader*)address)->size = amount;
--- 680,690 ----
    #endif
  
    # Speicher vom Betriebssystem holen:
!   local void* allocmem (uintL amount, uintL allocmemflag);
!   local void* allocmem(amount,allocmemflag)
      var reg2 uintL amount;
+     var reg3 uintL allocmemflag;
      { amount = round_up(amount+offsetofa(MemBlockHeader,usable_memory),4);
       {var reg1 void* address = AllocMem(amount,allocmemflag);
        if (!(address==NULL))
          { ((MemBlockHeader*)address)->size = amount;
***************
*** 726,733 ****
          { abort(); }
      }
  
!   #define malloc  allocmem
!   #define free    freemem
  
  #endif
  
--- 730,737 ----
          { abort(); }
      }
  
!   #define malloc(amount)  allocmem(amount,default_allocmemflag)
!   #define free  freemem
  
  #endif
  
***************
*** 3696,3701 ****
--- 3700,3720 ----
          }   }
          # Mit diesem Stück Speicher können wir nichts anfangen, wieder zurückgeben:
          free(addr);
+         #if defined(AMIGAOS) && !defined(WIDE) && !defined(MC68000)
+         # Wir machen einen zweiten Versuch mit veränderten Flags.
+         if (!(default_allocmemflag == retry_allocmemflag))
+           { addr = allocmem(need,retry_allocmemflag);
+             if (addr==NULL) return NULL;
+             # Intervall [addr,addr+need-1] muß in [0..2^oint_addr_len-1] liegen:
+             { var reg2 aint a = (aint)addr; # a = untere Intervallgrenze
+               if (pointable_usable_test(a))
+                 { a = round_down(a + need-1,bit(addr_shift)); # a = obere Intervallgrenze
+                   if (pointable_usable_test(a))
+                     { return addr; }
+             }   }
+             freemem(addr);
+           }
+         #endif
          return NULL;
        #endif
      }
***************
*** 6399,6404 ****
--- 6418,6427 ----
                       );
              exit(RETURN_FAIL);
            }
+         #if !defined(WIDE) && !defined(MC68000)
+           # MEMF_24BITDMA Flag erst ab Version 2.0 des Betriebssystems vorhanden.
+           retry_allocmemflag = CPU_IS_68000 ? MEMF_ANY : (SysBase->LibNode.lib_Version > 35 ? MEMF_24BITDMA : MEMF_CHIP);
+         #endif
        }
  
    # Rückgabe aller Ressourcen und Programmende:
*** /src.orig/lispbibl.d	Sun Nov 07 22:59:22 1993
--- /src/lispbibl.d	Sat Nov 13 07:38:54 1993
***************
*** 2487,2493 ****
    #define oint_addr_shift 0
    #define oint_addr_len 26
    #define oint_addr_mask 0x03FFFFFFUL
! #elif defined(AMIGA3000) || defined(UNIX_SYSV_UHC_2)
    # Bits 31..6 = Adresse/4, Bits 5..0 = Typcode
    #define oint_type_shift 0
    #define oint_type_len 6
--- 2487,2502 ----
    #define oint_addr_shift 0
    #define oint_addr_len 26
    #define oint_addr_mask 0x03FFFFFFUL
! #elif defined(AMIGA3000)
!   # Bits 31..6 = Adresse/2, Bits 5..0 = Typcode
!   #define oint_type_shift 0
!   #define oint_type_len 6
!   #define oint_type_mask 0x0000003FUL
!   #define oint_addr_shift 6
!   #define oint_addr_len 26
!   #define oint_addr_mask 0xFFFFFFC0UL
!   #define addr_shift 1
! #elif defined(UNIX_SYSV_UHC_2)
    # Bits 31..6 = Adresse/4, Bits 5..0 = Typcode
    #define oint_type_shift 0
    #define oint_type_len 6


Enjoy and send me all sorts of comments, bug reports and suggestions. Please
mention your (LISP-IMPLEMENTATION-VERSION) and system (especially memory
location) configuration when doing so.

      Joerg Hoehle.
hoehle@inf-wiss.uni-konstanz.de

