;;; Tue Mar 23 17:39:14 1993 by Mark Kantrowitz <mkant@GLINDA.OZ.CS.CMU.EDU>
;;; query.lisp -- 11797 bytes

;;; ********************************
;;; QUERY Package ******************
;;; ********************************
;;;
;;; The QUERY package provides 5 functions:
;;;    Y-OR-N-P, YES-OR-NO-P, Y-OR-N-P-WAIT, YES-OR-NO-P-WAIT, and QUERY
;;; The latter is similar in concept to the Symbolics FQUERY, but there are
;;; several major differences, including the ability to timeout with a 
;;; default value. The Y-OR-N-P-WAIT and YES-OR-NO-P-WAIT illustrate this
;;; ability. All five functions are built upon the same substrate.
;;;
;;;
;;; To Do:
;;;    Add wildcard choices (e.g., for "otherwise" clause)?
;;;    What to do if called within gnu-emacs as opposed to xterm? Needs some
;;;    general CBREAK-mode style fix. 
;;;
;;; *** Change Log:
;;; 23-MAR-93 mk    Created.
;;; 30-MAR-93 mk    Listing the choices now does (y or n) and (y, n, or h)
;;;                 instead of (y, n) and (y, n, h).
;;;  9-APR-93 mk    Fixed defpackage to work in Lucid.
;;; 10-AUG-93 mk    Added EOF-ERROR-P and EOF-VALUE parameters to QUERY and
;;;                 QUERY-INTERNAL.
;;; 28-DEC-93 mk    Changed internal-real-time-in-seconds to use
;;;                 get-universal-time -- uses fixnums only.
;;; 28-DEC-93 mk    Fixed use of defpackage to define the QUERY package
;;;                 correctly under Lucid.
;;; 28-DEC-93 mk    Added call to sleep in the busy-waiting, to make it nicer
;;;                 to multiprocessing Lisps.

(eval-when (compile load eval)
  (defpackage "QUERY" (:use #+:lucid "LISP" #-:lucid "COMMON-LISP")
    (:shadow "Y-OR-N-P" "YES-OR-NO-P") 
    (:export "QUERY" "Y-OR-N-P" "YES-OR-NO-P" 
	     "Y-OR-N-P-WAIT" "YES-OR-NO-P-WAIT")))

(in-package "QUERY")

;;; ********************************
;;; Global Variables ***************
;;; ********************************

(defparameter *y-or-n-p-choices*
    '(((T "Yes") #\y #\t #\space)
      ((NIL "No") #\n)
      ((:help "Help") #\h #\?)))
(defparameter *yes-or-no-p-choices*
    '((T "Yes")
      (NIL "No")
      (:help "Help" "h" "?")))

;;; The higher *sleep-amount* is, the less consing, but the lower the
;;; responsiveness.
(defparameter *sleep-amount* 0.1
    "Amount of time to sleep between checking query-io. In multiprocessing
     Lisps, this allows other processes to continue while we busy-wait. If
     0, skips call to SLEEP.")

(defparameter *timeout* 20)
(defparameter *y-or-n-p-wait-default* #\n)
(defparameter *yes-or-no-p-wait-default* "No")

;;; ********************************
;;; Reading with Timeouts **********
;;; ********************************
;;;
;;; Lots of Lisps, especially those that run on top of UNIX, do not get
;;; their input one character at a time, but a whole line at a time because
;;; of the buffering done by the UNIX system. This causes y-or-n-p-wait
;;; to not always work as expected. 
;;;
;;; I wish lisp did all its own buffering (turning off UNIX input line
;;; buffering by putting the UNIX into CBREAK mode). Of course, this means
;;; that we lose input editing, but why can't the lisp implement this? 
;;;
;;; Note that CMU CL's time functions cons too much, causing GC to thrash 
;;; itself to death. Thus the -WAIT functions really aren't practical
;;; in CMU CL because of their busy-waiting.
;;;
;;; We might get better results if we change this to use fixnums instead
;;; of floats.

(defun internal-real-time-in-seconds ()
  ;; We previously used (get-internal-real-time) instead of  
  ;; (get-universal-time) for higher precision. But that really isn't 
  ;; necessary in this application. So we switched to get-universal-time,
  ;; to avoid the floats.
;  (float (/ (get-internal-real-time) 
;	    internal-time-units-per-second))
  (get-universal-time))

(defun read-char-wait (&optional (timeout 20) input-stream
				 (eof-error-p t) eof-value
				 &aux peek)
  (do ((start (internal-real-time-in-seconds)))
      ((or (setq peek (listen input-stream)) 
	   (< (+ start timeout) (internal-real-time-in-seconds)))
       (when peek
	 ;; was read-char-no-hang
	 (read-char input-stream eof-error-p eof-value)))
    (unless (zerop *sleep-amount*)
      (sleep *sleep-amount*))))

(defun read-line-wait (&optional (timeout 20) input-stream 
				 (eof-error-p t) eof-value
				 &aux peek)
  (do ((start (internal-real-time-in-seconds)))
      ((or (setq peek (listen input-stream)) 
	   (< (+ start timeout) (internal-real-time-in-seconds)))
       (when peek
	 (read-line input-stream eof-error-p eof-value)))))

;;; ********************************
;;; Query Functions ****************
;;; ********************************
(defun QUERY (options &optional format-string &rest format-arguments)
  "QUERY is used for asking questions of the user. OPTIONS is a property-list
   containing the following keywords:
      :TYPE              :char or :line (how *query-io* is read)
      :CHOICES           A list containing entries of the form 
                         (<value> . <key>*) or ((<value> <print>) . <key>*), 
                         where <value> is the value to be returned, <key> is
                         a character or string, as the case may be, that is
                         used to select the <value>, and <print> is printed
                         when the value is selected.
      :BEEP              Specifies whether to ring the bell.
      :CLEAR-INPUT       If T, does a clear-input before querying.
      :FRESH-LINE        If T, starts on a fresh line before printing
                         the prompt.
      :LIST-CHOICES      If T, prints a list of the choices after the prompt.
      :HELP-STRING       A string to be printed if the user asks for help.
      :TIMEOUT           The number of seconds to wait, if using timeouts.
      :TIMEOUT-DEFAULT   The default value to use if the query times out.
      :STREAM            The stream to use. Defaults to *query-io*
      :SIGNAL-CONDITION  If T, will signal a condition of type QUERY-ERROR
                         before proceeding. If non-NIL but not T, uses the
                         value as the name of the condition. 
      :EOF-ERROR-P       If T (the default), signals an error if eof is
                         reached. If NIL, returns EOF-VALUE upon reaching eof
      :EOF-VALUE         Value returned if eof is reached and eof-error-p is
                         NIL."
  (apply #'query-internal 
	 :format-string format-string 
	 :format-arguments format-arguments
	 options))

(defun y-or-n-p (&optional format-string &rest format-arguments)
  "Y-OR-N-P prints the message, if supplied, and reads a character
   from *QUERY-IO* until the user types a Y or an N, returning T and
   NIL, respectively. Repeats the request if the user typed anything
   else. Also, if a H or ? is enterred, prints a brief help message.
   If you want a question mark at the end of the message, you must
   put it there yourself; Y-OR-N-P will not add it."
  (apply #'query
	 `(:type :char :choices ,*y-or-n-p-choices*
		 :help-string "Type \"y\" for yes or \"n\" for no. ")
	 format-string format-arguments))

(defun yes-or-no-p (&optional format-string &rest format-arguments)
  "YES-OR-NO-P prints the message, if supplied, rings the bell, and
   reads a line from *QUERY-IO* (ignoring whitespace) until the user
   types YES or NO, returning T and NIL, respectively. Repeats the
   request if the user typed anything else. Also, if HELP, H or ? is 
   enterred, prints a brief help message. If you want a question mark
   at the end of the message, you must put it there yourself;
   YES-OR-NO-P will not add it."
  (apply #'query
	 `(:type :line :choices ,*yes-or-no-p-choices*
		 :clear-input t :beep t
		 :help-string "Type \"yes\" for yes or \"no\" for no. ")
	 format-string format-arguments))

(defun y-or-n-p-wait (&optional (default *y-or-n-p-wait-default*) 
				(timeout *timeout*)
				format-string &rest format-arguments)
  "Y-OR-N-P-WAIT is like Y-OR-N-P, but will timeout after TIMEOUT seconds
   with DEFAULT as the default value."
  (apply #'query
	 `(:type :char :choices ,*y-or-n-p-choices*
		 :help-string "Type \"y\" for yes or \"n\" for no. "
		 :timeout ,timeout
		 :timeout-default ,default)
	 format-string format-arguments))

(defun yes-or-no-p-wait (&optional (default *yes-or-no-p-wait-default*)
				   (timeout *timeout*) 
				   format-string &rest format-arguments)
  "YES-OR-NO-P-WAIT is like YES-OR-NO-P, but will timeout after TIMEOUT seconds
   with DEFAULT as the default value."
  (apply #'query
	 `(:type :line :choices ,*yes-or-no-p-choices*
		 :clear-input t :beep t
		 :help-string "Type \"yes\" for yes or \"no\" for no. "
		 :timeout ,timeout
		 :timeout-default ,default)
	 format-string format-arguments))

(defun query-internal (&key format-string format-arguments
			    (type :char)
			    (choices *y-or-n-p-choices*)
			    (beep nil)
			    (clear-input nil)
			    (fresh-line nil fresh-line-p)
			    (list-choices t)
			    (help-string nil)
			    timeout
			    timeout-default
			    (stream *query-io*)
			    (signal-condition nil)
			    (eof-error-p t)
			    (eof-value nil))
  ;; Default :FRESH-LINE appropriately if the user didn't specify it as 
  ;; a keyword.
  (unless fresh-line-p
    ;; If QUERY is called with no format arguments, don't do a FRESH-LINE.
    ;; We assume that any message has been printed by other means.
    ;; If QUERY is called with format arguments, does do a FRESH-LINE.
    (if (null format-string)
	(setq fresh-line nil)
	(setq fresh-line t)))
  ;; Signal a condition, giving the program a chance to handle it.
  (when signal-condition
    ;; If SIGNAL-CONDITION was specified as T, signals an error of type
    ;; 'QUERY-ERROR. Otherwise it uses SIGNAL-CONDITION as the error.
    (signal (if (eq signal-condition t) 
		'query-error
		signal-condition)
	    :format-string format-string
	    :format-arguments format-arguments
	    :choices choices))
  ;; Clear-input, then beep, then freshline. Is the order correct?
  (loop
    ;; Clear the input stream and beep, if necessary.
    (when clear-input (clear-input stream))
    (when beep        (write-char #\bell stream) (finish-output stream))
    ;; format the prompt
    (when format-string
      (when fresh-line (fresh-line stream))
      (apply #'format stream format-string format-arguments)
      ;; We use FINISH-OUTPUT here to force it to print the message
      ;; before reading the reply. In CMU CL, for example, streams
      ;; are buffered, so using FORCE-OUTPUT could result in the
      ;; prompt being printed after the user types his or her reply.
      (finish-output stream))
    ;; list choices
    (when list-choices
      (let ((choices (mapcar #'cadr choices)))
	(when choices
	  ;; Changed it so that it does (y or n) and (y, n, or h) instead
	  ;; of (y, n) and (y, n, h). Ain't FORMAT wonderful?
	  (format stream " (［箕窿箕矧窿夯利［伙蔺窿蕃]}) "
		  choices)
	  ;; (format stream " (A窿ㄦ轵篝汨镩沐螬蝈篝汨镩沐螬ㄦ轭轶璀秕麴豸篝蝈犴┅┅换汨镲箦ㄦ戾è聃弪蝈徜汨狎糸礤秕糸礤秕舡溴驷蹯篝蝈犴屣姝弪蝻颦屣姝鲠祯濠戾è轭瘐ㄩ糸礤秕矧蝈徜汨狎麽轸糸礤秕篝蝈犴屣姝弪蝻颦屣姝鲠祯濠麒孱糸礤秕舡溴驷蹯ㄦ矧磲篝蝈犴窿ア糸礤秕舡溴驷蹯舂ㄦ轭轶璀秕麴豸篝蝈犴糸礤秕舡溴驷蹯舂蝈徜汨狎篝蝈犴屣姝弪蝻颦屣姝鲠祯濠┅ㄩㄡ钿铒屣姝弪蝻颦皓ㄥ轭瘐屣姝鲠祯濠蝈趱蝾骝镯聃弪轭翦蝾犰屣姝鲠祯濠轭瘐舂┅聃弪蝈徜扉铄糸礤秕糸礤秕舡溴驷蹯篝蝈犴屣姝弪蝻颦屣姝鲠祯濠戾è轭瘐ㄩ糸礤秕矧蝈徜扉铄麽轸糸礤秕篝蝈犴屣姝弪蝻颦屣姝鲠祯濠麒孱糸礤秕舡溴驷蹯ㄦ矧磲篝蝈犴窿ア糸礤秕舡溴驷蹯舂ㄦ轭轶璀秕麴豸篝蝈犴糸礤秕舡溴驷蹯舂蝈徜扉铄篝蝈犴屣姝弪蝻颦屣姝鲠祯濠┅ㄩㄡ钿铒屣姝弪蝻颦皓ㄥ轭瘐屣姝鲠祯濠蝈趱蝾骝镯聃弪轭翦蝾犰屣姝鲠祯濠轭瘐舂┅戾舄è轭瘐ㄣ狍豉疱ê汨狎聃弪蝈徜汨狎糸礤秕糸礤秕舡溴驷蹯篝蝈犴屣姝弪蝻颦屣姝鲠祯濠ê扉铄换物翦翳狒＼箴徙轶犰祜麇轭恒栳盹溴怩换铒轭红轭盹溴篝蜷铉趄轫Ж＼箴徙＼翎＼铄黛轭＼蝈趱蝾聃弪蝈徜扉铄糸礤秕糸礤秕舡溴驷蹯篝蝈犴屣姝弪蝻颦屣姝鲠祯濠┅┅换物翦阵弩汜箦轭箦铙轸轹磲翥璁ㄣ栾殂ㄦ轭轭瘐汨镩沐呼弩ㄥ汜箦豉疱ê汨狎＇灬礅溽ㄦ轭呼弩＇汨狎羼踽飑┅ê扉铄＇灬礅溽ㄦ轭呼弩＇篝蜷铉羼踽飑┅弘妁＇沅颟┅ㄣ镱è矧ㄡ钿篝蜷铉轭瘐舂篝蜷铉轭瘐躞弪豉疱铒翳轭桢祓篝蜷铉ㄡ钿汨镩沐ㄩ扉篝ㄣ狎汨镩沐┅ㄥㄣ狎ㄣ狎汨镩沐┅鸿屐皓ㄥㄣ狎汨镩沐鸿屐皓┅换涉桢祓轶蝈聃弩翦洮矧翳躞弪豉疱铒翳轭犷麇栳鲥换桢祓篝蜷铉痱轭箫礤桢祓麒孱桢祓篝蜷铉ㄦ蝈箬扉铄篝蝈犴ㄦ矧磲篝蝈犴桢祓篝蜷铉ㄦ轭轶璀秕麴豸篝蝈犴┅换娘瞌忮屦殒螬桢镱禊狍脲骘桢祓箦赳忮屦铋沆遽颦轭瘐骝弩璀扉铄扉篝汨镩沐舂ㄣ栾殂换婶骘躅汨镩沐犷鏖祆蝈趱蝾轸箦赳汨镩沐ㄣ狎汨镩沐┅麒孱扉篝汨镩沐换矧黩轸瀛篝蜷铉黩轸瀛汨狎ㄦ矧磲篝蝈犴立箦泔钿汨镩沐┅ㄦ轭轶璀秕麴豸篝蝈犴箦赳汨镩沐ㄣ狎汨镩沐┅蝈趱蝾骝镯聃弪轭翦蝾犰汨镩沐┅换萧桢蝼轶瀣麇蝈顼轭狎秕钿翳祜镳徵衢瞵怩换麇蝈溴骈铋翦禊顼轭麸忮屦沆遽颦轭瘐衄骝弩璀扉铄换犷扉篝汨镩沐螽箦赳忮屦沆遽颦轭瘐骝弩璀扉铄扉篝汨镩沐舂┅┅┅换换砒犴痨弩犷藻篝冕箦换｜换深翳骈蝮屮犴痨瀣麇糸礤秕舢沼乓ǔ背┖聃弪葫矧瞽瓠麽轸＼⒛秕麽铘轸竣娘秕麽铘轸瞵瑭馘沼乓ǔ贝┖聃弪葫矧瞽瓠麽轸＼⒛秕麽铘轸竣娘秕麽铘轸瞵瑭物紊沼乓ǔ钡┖聃弪葫矧瞽瓠麽轸＼⒛秕麽铘轸竣娘秕麽铘轸瞵瑭赠疱Ⅸ骘弩矧㈩骘铒娘秕麽铘轸瞵瑭馘翳轶镱糸礤秕沼乓ǔ倍┖聃弪葫矧瞽瓠麽轸＼⒛秕麽铘轸竣娘秕麽铘轸瞵瑭赠疱Ⅸ骘弩矧㈩骘铒娘秕麽铘轸瞵瑭物紊换畔篇