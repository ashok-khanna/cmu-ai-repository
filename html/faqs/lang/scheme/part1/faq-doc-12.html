
<!-- Mirrored from www.cs.cmu.edu/afs/cs/project/ai-repository/ai/html/faqs/lang/scheme/part1/faq-doc-12.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 22 Oct 2021 05:32:06 GMT -->
<HEAD>
<TITLE>FAQ: Scheme Frequently Asked Questions 1/2 [Monthly posting] - [1-14] Why is there no EVAL in Scheme?</TITLE>
</HEAD>
<BODY>
<H1>[1-14] Why is there no EVAL in Scheme?</H1>
<PRE>
The answer to this question is based on information provided by 
Guillermo J. Rozas and Aubrey Jaffer.

There are three major positions in the Scheme community regarding EVAL:

   1. No EVAL: EVAL is antithetical to a Pascal-like (compiler based,
      externally statically linked) implementation for Scheme, such as
      some people have or wish to see. 

   2. Single Argument: There is a single distinguished top-level
      environment, and EVAL always evaluates its argument there. 
      (This is the approach taken in Common Lisp, where EVAL evaluates
      its argument in the current dynamic environment and in a null
      lexical environment.) 

   3. Two Arguments: There are multiple environments in which
      the user might want to evaluate expressions, so EVAL should take
      two arguments, the second being an environment.  In particular,
      in some systems with first-class environments, there is no
      a-priori single distinguished top-level environment, and
      defaulting the environment does not fit those dialects well.

Not every dialect of Scheme has EVAL. Most do, but some with different
names and arguments. Jaffer's SLIB package uses LOAD as defined in
R4RS to define EVAL for those implementations that don't support EVAL
(e.g., by writing the code out to a file and then loading it).
Rozas's compromise proposal for EVAL was accepted for R5RS, but it is
unclear whether there will ever be a R5RS.
</PRE>
<A NAME=up HREF="faq.html">Go Back Up</A><P>
<A NAME=up HREF="faq-doc-11.html">Go To Previous</A><P>
<A NAME=up HREF="faq-doc-13.html">Go To Next</A><P>
</BODY>
