
<!-- Mirrored from www.cs.cmu.edu/afs/cs/project/ai-repository/ai/html/faqs/lang/oop/faq-doc-6.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 21 Oct 2021 15:06:19 GMT -->
<HEAD>
<TITLE>Comp.Object FAQ Version 1.0.5 (12-13) Announcement - Montage Database - brief product announcement</TITLE>
</HEAD>
<BODY>
<H1>Montage Database - brief product announcement</H1>
<PRE>
From: markh@montage.com (Mark Helfen)
Followup-To: sales@montage.com 
Organization: Montage Software, Inc.
Date: Wed, 10 Nov 1993 23:05:03 GMT

The Montage object-relational database management system 
(ORDBMS) is now available from Montage Software, Inc. 

The Montage object-relational database management system 
includes the Montage Server(tm) database engine, the Montage 
Viewer(tm) -- a new visualization tool that simplifies queries of 
complex data -- and Montage DataBlades(tm), specialized modules 
that extend the capabilities of the database for specific applications.  
Montage represents the commercialization of the seven-year 
POSTGRES research project.   

The Montage Server extends the relational database model through 
its ability to handle complex information, and the inclusion of object-
oriented facilities and capabilities.  It uses the familiar relational row-
column metaphor for all data, so that text, numbers and complex data 
are all viewed, managed, manipulated and queried the same way.   
The relational metaphor is extended to allow data of any size and 
complexity to be stored and accessed in the way that is most 
effective.   SQL, used to access and manage data, is extended with 
SQL3-based capabilities to allow the definition of user data types and 
functions.

The Montage Viewer uses visualization technology to organize 
information in visual terms -- by location, shape, color and intensity, 
for example.  Similar to a "flight simulator," the Montage Viewer allows 
the user to visually navigate through data, refining each step by 
"panning" and "zooming" with a mouse.  

A DataBlade is a combination of data types and functions that are 
designed to support a specific application.   Text, Spatial, and Image 
are the first of many DataBlades that will comprise a full-range of 
industry-specific products created by Montage, third parties and 
users based upon their own expertise.    

o     The Text DataBlade expands the database's functionality by 
adding new data types and functions that manage text and document 
libraries, as well as a providing a new access method (Doc-Tree) 
which provides exceptional search performance for text.  

o     The Image DataBlade supports image conversion, storage, 
manipulation, enhancement and management of more than 50 image 
formats, and performs automatic conversion of formats at the user's 
discretion.  

o     Points, lines, polygons and their spatial relationships are now 
supported in the relational model with the Spatial DataBlade.  The 
DataBlade defines nine basic spatial types and makes over 200 SQL 
functions available for use on spatial data, as well as supports the 
R-Tree access method for high speed navigation of spatial data.    

Montage Software was co-founded by Gary Morgenthaler of 
Morgenthaler Ventures and Dr. Michael Stonebraker of the University 
of California, Berkeley, .  Morgenthaler is Montage Software's 
chairman of the board and Stonebraker serves as the company's 
chief technology officer.    Morgenthaler and Stonebraker co-
founded Ingres Corporation (then called Relational Technology, 
Inc.), in 1980.    

FOR ADDITIONAL INFORMATION:

Montage Software Inc. can be contacted at:

email:                        sales@montage.com
phone:                        (510) 652-8000
fax:                          (510) 652-9688

Mailing Address:

Montage Software, Inc.
2000 Powell Street, Suite 1405
Emeryville, CA  94608

OO DATA MODEL
-------------

Research Systems
________________

&#62; AVANCE (SYSLAB)

An object-oriented, distributed database programming language.  Its
most interesting feature is the presence of system-level version
control, which is used to support schema evolution, system-level
versioning (as a way of improving concurrency), and objects with their
own notion of history.  System consists of programming language (PAL)
and distributed persistent object manager. 

REFERENCES: 
        Anders Bjornerstedt and Stefan Britts. "AVANCE: An
        Object Management System".  Proceedings of OOPSLA88.



&#62; CLOSQL (University of Lancaster)

Status:-
CLOSQL is a research prototype OODB designed primarily for prototyping 
various schema evolution and view mechanisms based on class versioning.
The system is built using CommonLISP. It would really only be of interest
to other parties as a research tool.

Requirements:-
Common LISP including CLOS standard. The Graphical user interface requires
the Harlequin LispWorks Tool-kit. The system was built on a Sun4 and
has not been tested on any other platform.

Features:-
As a prototype, CLOSQL is not robust enough to sell. The system is single
user and does not properly support persistence - that is, the data has to
be loaded and saved explicitly. The query language is quite good 
making good use of the functional nature of the environment. 
Methods (LISP and query language only), class versioning and
multiple inheritance are all supported in the data model. Type checking
information is held in the database, but is NOT enforced at present. The
GUI is notable for its support for schema evolution, but otherwise rather
ordinary.

Availability:-
Probably freely available, but as the project was part funded by an
industrial partner, some consultation with them would be necessary before
the system could be released.

References:-
[1]  Monk, S. R. and I. Sommerville, "A Model for Versioning of Classes 
in Object-Oriented Databases", Proceedings of BNCOD 10, Aberdeen. 
pp.42-58. 1992.

[2]  Monk, S. "The CLOSQL Query Language". Technical report No. SE-91-15. 
Computing Dept, Lancaster University, Lancaster, LA1 4YR, UK. 1991.

[3]  Monk, S., "A Model For Schema Evolution In Object-Oriented Database 
Systems", PhD thesis, Dept of Computing, Lancaster University, Lancaster
LA1 4YR, UK. 1992.

On Schema evolution (from original survey):
CLOSQL implements a class versioning scheme (like ENCORE), but employs a
conversion adaptation strategy.  Instances are converted when there is a
version conflict, but unlike ORION and GemStone, CLOSQL can convert instances
to older versions of the class if necessary.

        Aberdeen, Scotland. July, 1992.

Contacts;
Simon Monk:      srm@computing.lancaster.ac.uk
Ian Sommerville: is@computing.lancaster.ac.uk 


&#62; ConceptBase
                                 Version 3.1

The ConceptBase System

ConceptBase is a deductive object management system intended for
conceptual modeling and the coordination of design environments.  It
integrates techniques from deductive and object-oriented databases in
the logical framework of the language Telos.

Key features are

*  hybrid representation with frame-like objects, semantic nets and
   logical specifications

*  extensibility by metaclass hierarchies

*  declarative object-centered query language

*  persistent object management with roll-back capability

ConceptBase follows a client-server architecture.  Client programs can
connect to the ConceptBase server and exchange data via interprocess
communication.  The ConceptBase programming interface allows the users
to create their own client programs in C or Prolog.

The X11-based ConceptBase usage environment offers an extensible
palette of graphical, tabular and textual tools for editing and
browsing the knowledge base.  It includes the CoAuthor tool which
supports multiple author production of hypermedia documents.

ConceptBase Applications

ConceptBase has been developed with partial support from the ESPRIT
projects DAIDA and Compulog.  It serves as a central knowledge manager
in the DAIDA environment for data-intensive information systems.
Further applications range from configuration management, co-authoring
to requirements engineering, reverse engineering, business modeling,
and quality assurance systems.  ConceptBase is used by several research
institutions in Europe and North America for experimental purposes.

Availability

ConceptBase is available for research purposes in a Prolog version
(running under ProLog by BIM 3.1) or as a runtime system.  The
graphical usage environment of ConceptBase is based on the Andrew
toolkit release 5.1.

Version 3.2 (only available as runtime system) will be released in 
August 1993.

A four week test-version of ConceptBase V3.1 is available 
on the FTP server ftp.informatik.rwth-aachen.de in the 
directory pub/CB.  For running the ftp version you must ask for a 
key by email.


Technical Requirements

Machine:  SUN4/Sparc
Main memory:    at least 8 MB
Free swap space:        at least 30 MB
Free space on disk:     at least 18 MB
Operating System:       SUN OS 4.1.1
Environment:            X11 Release 5

Contact

Rene Soiron
RWTH Aachen --- Informatik V
Ahornstr. 55, D-52056 Aachen
Tel/Fax: +49 +241 80 21 501 / 80 21 529
email: CB@picasso.informatik.rwth-aachen.de


Also:
We have developed a deductive object-oriented database called
ConceptBase where everything (tokens, classes, meta-classes
,meta-meta-classes ,attributes, instantiations, specializations) is
treated as an object. That means that you may update the "schema"
(classes) at any time just as any other ordinary object.

The systems has (user-defined and builtin) integrity constraints that
prevent inconsistency (e.g. violation of ref.integrity).  Integrity
constraints in ConceptBase are (as in most other systems) static,
i.e., they are conditions that each database "state" must satisfy.

The data model we use does not distinguish schema level information
(i.e. classes) from instance level information. If you change for
example some classes and this change violates some integrity
constraints, e.g.  some instances now don't have the right attribute
types anymore, then you have the choice either to reject the update or
to change the existing DB. Currently, ConceptBase simply rejects such
updates.  We are thinking of exploiting abduction (see VLDB'90 article
of Kakas&#38;Mancarella) to make more clever reactions in the sense of
"reformatting" instances.

[Manfred Jeusfeld &#60;jeusfeld@forwiss.uni-passau.de&#62;]


&#62; COOL/COCOON (Ulm Universitaet)

The COCOON project was intended to extend the concepts and the
architecture of relational database management systems (DBMSs) beyond
nested relational to object-oriented ones. Based upon the nested
relational DBMS kernel DASDBS, we have built a prototype implementation
of the COCOON model. Key characteristics of COCOON are: generic,
set-oriented query and update operators similar to relational algebra
and SQL updates, respectively; object-preserving semantics of query
operators, which allows for the definition of updatable views; a
separation of the two aspects of programming language "classes": type
vs. collection; predicative description of collections, similar to
"defined concepts" in KL-One--like knowledge representation
languages; automatic classification of objects and views (positioning
in the class hierarchy); physical clustering of subobjects via the use
of nested relations as the internal storage structures; support for the
optimization of both, the physical DB design and query transformation,
by corresponding optimizers.

Project goals are:

- to develop a general formal framework for investigations of all
  kinds of schema changes in object-oriented database systems
  (including schema design, schema modification, schema tailoring, and
  schema integration);
- to find implementation techniques for evolving database schemas,
  such that changes on the logical level propagate automatically to
  adaptations of the physical level (without the need to modify all
  instances, if possible).

In their current paper [see below], schema evolution is used as
example of a general framework for change in OODBs, supporting change
on three levels of database objects: data objects, schema objects, and
meta-schema objects.

Contact: Markus Tresch &#60;tresch@informatik.uni-ulm.de&#62;


REFERENCES:
        M. Tresch and M.H. Scholl. "Meta Object Management
        and its Application to Database Evolution."  In
        _Proceedings of the Eleventh International
        Conference on the Entity-Relationship Approach",
        Karlsruhe, Germany, Oct 1992.  Springer Verlag (to
        appear).


&#62; Encore (Brown University)
email:bpe@browncs.brown.edu

Encore is an object-oriented database system targeted at large scale
software engineering applications which are involved in data modeling.
It was developed at Brown University in the late 1980s.  It is notable
for its special support for long-lived (ie. cooperative) transactions,
popular in design applications, and its support for class versioning.
Objects are never converted, rather, classes are versioned, and the
user can specify filters to make old-style instances appear as new
instances to new applications (and vice versa).


References/Additional Information:

 [] Mary F. Fernandez. OBSERVER: A storage system
    object-oriented applications. Technical Report CS-90-27,
    Brown University, Providence, RI, 1990.

 [] Mark F. Hornick and Stanley B. Zdonik. A shared, segmented
    memory system for an object-oriented database. ACM
    Transactions on Office Information Systems, 5(1):70--95,
    January 1987.

 [] Andrea H. Skarra and Stanley B. Zdonik. Type evolution in an
    object-oriented database. In Research Directions in
    Object-Oriented Programming, MIT Press Series in Computer
    Systems, pages 393--415. MIT Press, Cambridge, MA, 1987. An
    early version of this paper appears in the OOPSLA '86
    proceedings.

 [] Andrea H. Skarra and Stanley B. Zdonik. Concurrency control
    for cooperating transactions in an object-oriented database.
    In Won. Kim and Frederick H. Lochovsky, editors,
    Object-Oriented Concepts, Databases and Applications.
    Addison-Wesley, Reading, MA, 1989.

FTP: Complete source can be found in wilma.cs.brown.edu/pub/encore.tar.Z
See also APPENDIX E.


&#62; Exodus (University of Wisconsin)

EXODUS is a DBMS from the University of Wisconsin.  An overview,
excerpted from the abstract of [CDG+90] reads:

    EXODUS,   an   extensible database    system  project that is
    addressing  data management problems  posed  by  a variety of
    challenging new applications.  The  goal of the project is to
    facilitate   the   fast    development of   high-performance,
    application-specific  database  systems.     EXODUS  provides
    certain  kernel facilities,   including  a versatile  storage
    manager.  In addition, it provides an architectural framework
    for building  application-specific database systems; powerful
    tools   to  help  automate the  generation   of such systems,
    including  a   rule-based query optimizer generator    and  a
    persistent  programming  language;  and libraries  of generic
    software components (e.g., access methods) that are likely to
    be useful for many application domains.

The programming language is called E, an extension of C++. [RC89]

REFERENCES:
(see "ftp.cs.wisc.edu:exodus/bibliography" for a complete list)

[CDG+90] Michael J. Carey, David J. DeWitt, Goetz Graefe,
         David M. Haight, Joel E. Richardson, Daniel T. Schuh,
         Eugene J. Skekita, and Scott L. Vandenberg. The EXODUS
         extensible DBMS project:  An overview. In Stanley B.
         Zdonik and David Maier, editors, Readings in
         Object-Oriented Database Systems, Data Management
         Series. Morgan Kaufmann, San Mateo, CA, 1990. Also
         available as WISC-CS-TR 808.

[CDRS89] Michael J. Carey, David J. DeWitt, Joel E. Richardson,
         and Eugene J. Skekita. Storage management for objects
         in EXODUS. In Won. Kim and Frederick H. Lochovsky,
         editors, Object-Oriented Concepts, Databases and
         Applications, chapter 14. Addison-Wesley, Reading, MA,
         1989. After Carey et al. Object and File Management in
         the EXODUS Database System, Proceedings of the Twelveth
         International Conference on Very Large Data Bases,
         1986.

[GD87]   G. Graefe and D. DeWitt. The EXODUS optimizer
         generator. In U. Dayal and I. Traiger, editors,
         Proceedings of the SIGMOD International Conference on
         Management of Data, San Francisco, CA, May 1987.

[RC89]   Joel E. Richardson and Michael J. Carey. Persistence in
         the E language:  Issues and implementation. Software --
         Practice and Experience, 19(12):1115--1150, December
         1989.


FTP: source code, documentation and a complete bibliography can be
     found at ftp.cs.wisc.edu:exodus/

See also APPENDIX E.


On Schema Evolution (from original survey):
No solution for the problem of schema evolution is provided.
Emulation is rejected by the authors, who claim that the addition of a
layer between the EXODUS Storage Manager and the E program would
seriously reduce efficiency.  Automatic conversion, whether lazy or
eager, is also rejected, as it does not mesh well with the C++ data
layout.  To implement immediate references to other classes and
structures, C++ embeds class and structure instances within its
referent.  The resulting change in the size of the object might
invalidate remote pointer references.

        Joel E.  Richardson and Michael J.  Carey.  "Persistence
        in the E language: Issues and Implementation."  Appeared
        in "Software -- Practice and Experience",
        19(12):1115-1150, December 1989.


&#62; Machiavelli (University of Pennsylvania)

Machiavelli is a statically-typed programming language developed
at the University of Pennsylvania. Its most outstanding innovation 
is the use of conditional typing scheme in its type inference system. 
It does not address type evolution.

[communication with limsoon@saul.cis.upenn.edu]

[Note: Machiavelli is included in this summary because it
       previously incorporated persistence in its data model.]



&#62; MOOD4-PC: Material's/Miniature Object-Oriented Database Prototype for
             NEC/IBM-PC

is an object-oriented database system(OODBS) program developed in the
course of our research project MOOD. The aim of the project MOOD is to
develop a material database system to handle raw material data which
are produced and accumulated in materials research and referred to by
material experts when they face scientific or engineering problems
where the expected behavior of particular materials in particular
environments are crucial importance. We all know that the conventional
database systems do not fulfill this requirement, though they serves
well for bibliographic databases or fact databases which deals with
the standard properties of standard materials.

MOOD4-PC is written in Arity/Prolog and available in source and
executable form via anonymous ftp from:

   ~/pub/mood/mood4
   at mood.mech.tohoku.ac.jp [130.34.88.61]
   
    ~/pub/database/mood
    at ftp.uu.net [192.48.96.9]

    ~/pub/computing/databases/mood
    at src.doc.ic.ac.uk [146.169.2.1]

Although it is true enough to say that MOOD4 is a general purpose
OODBS, it may be appropriate to point out that MOOD4 is significantly
different from what is generally meant by the term, the
Object-Oriented Database System.

That is, OODBSs, in general, consist of two parts:

   (1) Disk storage manager
   (2) Database language to define and manipulate data objects to
       be stored to and retrieved from the disk.

The database language of OODBS is akin to the object-oriented
programming language such as Smalltalk or C++. You can enjoy the full
versatility of these general purpose programming language in writing
application programs with the database language.

As apparent from these, OODBSs, in general, are for programmers who
write application programs which serve end users' needs. MOOD, on the
other hands, is not; it is for end users. It is provided with a user
interface named the object editor or OE in short. With OE, we can;

  (1) Edit class definition objects and save them. This replaces the
      data definition language.

  (2) Edit data objects and save them.

  (3) Create query objects, let the system select data objects which
      match the queries, and browse them.

In the other words, we can do everything necessary to manage and use
database with OE. MOOD, therefore, needs no programming language and,
in fact, has none. In this regard, MOOD may better be categorized to
the OODBS application.

The architecture of MOOD as such is the consequence of the nature of
information to be dealt with in material database. If we describe the
nature with a single word, "variety" will be the one most appropriate. 
No fixed data structure can handle a handful of material data because
their contents differ from one to another. The feature of OODBS
relevant here is not the intimacy with programming languages but the
flexibility of data structure which allows us to construct data
objects with a variety of structures which match the variety in the
information to be dealt with. Upon inputting and retrieving data
objects, end users are forced to face this variety in data structure
since significant information is born in the structures of individual
representations.

Yet, we say that MOOD is a general purpose OODBS. This is not in the
sense that we can develop application programs on it, but in the
sense that it generally supports the essential capabilities of OODBS;

  (1) The abstract data type.

  (2) The nesting of structured data objects.

  (3) The class hierarchy.

  (4) The inheritance of attributes along the hierarchy.

  (5) Matching between objects along their structures with the
      knowledge of the class hierarchy.

For additional features of MOOD4, please consult its manual available
with the program. Although they are biased to the processing of
material data (or, more generally, scientific and technical data),
MOOD with these capabilities can be used in any application domain at
least by the stage where you are to examine how well the pieces of
information of interest are represented in OODBS and how well specific
items of interest are discriminated out from the database as such.

Questions and suggestions on this software which are ever welcome
indeed may be addressed to;
 
     Noboru Ono                                             
     Dept. of Machine Intelligence and Systems Engineering, 
     Faculty of Engineering, Tohoku University.            
     Tel:++22-216-8111,
     Fax:++22-216-8156,
     E-mail:ono@mood.mech.tohoku.ac.jp




&#62; OBST/STONE (Forschungszentrum Informatik [FZI], Karlsruhe, Germany)

The OBject System of Stone --- OBST

The persistent object management system OBST was developed by
Forschungszentrum Informatik (FZI) as a contribution to the STONE
project. This project (supported by grant no. ITS8902A7 from the
BMFT, i.e. the German Ministry for Research) aims at the development
of a software engineering environment for education purposes and is
carried out as a joint project of nine german universities and
research institutions.

An essential feature of STONE is that the object oriented paradigm 
is pursued consequently as a key concept. OBST is the common persistent
object store for all tools within the STONE environment. 


 Data Model
 ---------

The OBST data model can be characterized by the following properties:

 * Schema definition language syntactically similar to C++
 * Support of multiple inheritance
 * Generic classes
 * Abstract classes and methods
 * Distinction between public, protected, and private methods
 * Redefinition of methods
 * Overloading of methods

 Schemas and Containers
 ----------------------

Schemas are compiled by the OBST schema compiler. The compilation
results are instances of classes of the meta schema. From these
instances in a next step interfaces to different programming languages
can be generated. At present the C++ language binding is implemented,
interfaces to Lisp and other languages are planned.

Objects are stored in so-called containers. The container an object
belongs to is determined at the time of object creation and fixed
throughout the object's lifetime. Containers are the units of 
clustering, synchronization, and recovery. Objects can be referenced
by other objects across container boundaries.

 Incremental Loading
 -------------------

OBST provides a mechanism to incrementally load methods. This enables
programs to deal with objects whose type is defined after the program 
itself has been developed. This is useful in systems that provide for 
inheritance and it supports schema evolution. We used it e.g. for
programs that interpret the object base and call methods of the
found objects (for example the below mentioned browser).

 Prototype
 ---------

Since end 1990 the first prototype of OBST is available and is shipped
to interested universities and research institutions. The current
version is publicly available via FTP (see below) since March '92.
Our current mailing list (see below) comprises about 150 persons.

The system comes with the schema compiler, a library of predefined
classes (like Set&#60;Entity&#62;, List&#60;Entity&#62;, String, ...), a graphical
object browser (more a shell than a browser), the structurer and
flattener (STF), tclOBST, and all manuals. For STF and
tclOBST see below.

 Structurer and Flattener
 ------------------------

This is a tool to build objects from bytestrings and flatten objects
down to bytestrings. It is intended to be used when coupling UNIX
tools to the object management system. The user defines a grammar that
describes her objects. Afterwards, the structurer parses an ascii 
text according to the given grammar and creates an OBST object
structure that represents the corresponding parse tree.
The flattener does the inverse transformation, that means it generates
an ascii text from a given OBST object structure according to the given
grammar.

 tclOBST
 -------

tclOBST is a library which provides an embedding of OBST into the
interactive tool command language tcl, developed by John Ousterhout
at the University of Berkeley.
Based on the standard tcl shells, which are also comprised in the
tclOBST distribution, tclOBST offers interactive access to the complete
functionality modeled by OBST schemata.


 System Requirements
 -------------------

For the prototype's installation a C++ compiler (GNU g++ 1.37 or 
later 1.4* or 2.3.3 or AT&#38;T 2.0/2.1/3.01) and the X-Windows system 
(currently X11R4 or X11R5) for the graphical tools are required. 
Installation is well-tried on SUN 4/* systems and should be no problem 
on other UNIX machines, too.

 --------------------------------------------------------------------

For more information please mail to:

                Forschungszentrum Informatik (FZI)
                       STONE Projekt
                 Haid-und-Neu-Strasse 10-14
                     D-76131 Karlsruhe
                          Germany

or email to:  stone@fzi.de

Phone:        ++49-721-9654-601
Fax:          ++49-721-9654-609
Teletex:      721 190 fziKA

The OBST system is available via anonymous FTP from ftp.fzi.de
[141.21.4.3]. The system can be found in the directory /pub/OBST/OBST3-3.3

Sites interested in getting information about new OBST developments
are welcome to register in our mailing list. This can be done
by sending an email with subject "obst-mailing-list" and contents
"SUBSCRIBE &#60;firstname&#62; &#60;surname&#62; &#60;email-adr&#62;" to stone@fzi.de.
If the subscription was successful you will receive a confirmation.

Bug reports should contain a small example program with which the
bug can be reproduced, or at least a detailed description of the
observed phenomenon. 

Besides bug reports we are strongly interested in all experiences
our users make with OBST (e.g. sufficiency of data model, performance,
...) and in our users' application areas and the applications as
well. So, please don't hesitate to send us a short note.

Best regards and happy OBST programming.

   The OBST Team


 ---

BTW "Obst" is the German word for "fruit",
    so have a fruitful time with OBST!


&#62; Ode

                                 Ode 2.0
                       An Object-Oriented Database

       C++ Compatible, Fast Queries, Complex Application Modeling,
       Multimedia Support, and more

See APPENDIX E, Databases, for description.


&#62; Oggetto, University of Lancaster, UK.

Developed at the University of Lancaster, UK.  Summary NYI.

"Oggetto: An Object Oriented Database Layered on a Triple Store",
J.A. Mariani, The Computer Journal, V35, No 2, pp108-118, April 1992.


&#62; ORION (Now marketed as ITASCA)

ORION was a prototype OODBMS developed at MCC, an American consortium by Won
Kim and his group.  Won Kim has left MCC and formed a new company, UniSQL, in
Austin, with a new product of the same name.

See also entry under "ITASCA".

REFERENCES:

I have found nearly a dozen papers published by the ORION folks.
Overviews at various stages in its development and commercialization
can be found in:

[KBGW91] Won Kim, N. Ballou, J.F. Garza, and D.; Woelk. A
         distributed object-oriented database system supporting
         shared and private databases. ACM Transactions on
         Information Systems, 9(1):31--51, January 1991.

[KGBW90] W. Kim, J.F. Garza, N. Ballou, and D. Woelk.
         Architecture of the orion next-generation database
         system. IEEE Transactions on Knowledge and Data
         Engineering, 2(1):109--24, March 1990.

[KBCG89] Won Kim, Nat Ballou, Hong-Tai Chou, and Darrell Garza,
         Jorge F. Woelk. Features of the ORION object-oriented
         database system. In Won. Kim and Frederick H.
         Lochovsky, editors, Object-Oriented Concepts, Databases
         and Applications, chapter 11. Addison-Wesley, Reading,
         MA, 1989.

[KBC+88] Won Kim, N. Ballou, Hong-Tai Chou, J.F. Garza,
         D. Woelk, and J. Banerjee. Integrating an
         object-oriented programming system with a database
         system. In Proceedings of the ACM Conference on
         Objected-Oriented Programming:  Systems, Languages and
         Applications (OOPSLA), pages 142--152, San Diego, CA,
         September 1988. Published as ACM SIGPLAN Notices
         23(11).
         [Pointers to the previous papers documenting each of the
          advanced features listed above are cited therein.]


The paper most relevant to the issue of schema evolution is the
following:

[BKKK87] J. Banerjee, W. Kim, H-J. Kim, and H.F. Korth.
         Semantics and implementation of schema evolution in
         object-oriented databases. In U. Dayal and I. Traiger,
         editors, Proceedings of the SIGMOD International
         Conference on Management of Data, San Francisco, CA,
         May 1987.


You might also like to look at Kim's book, which provides a good
introduction to OODBMS, while focusing on the ORION work:

[Kim90]  Won Kim. Introduction to Object-Oriented Databases.
         Computer Systems. MIT Press, Cambridge, MA, 1990.


&#62; OTGen (Carnegie Mellon University/UMass Amherst)

OTGen is a design for a system to support schema evolution in
object-oriented databases.  The chief contribution of OTGen is support
for programmer extensibility of transformation functions to allow a
system to support a wide range of schema changes, not just those that
can be easily automated.  While OTGen was never implemented, it is
based on the implementation of TransformGen, a system to support the
evolution of the specialized databases used by Gandalf programming
environments.  For more information on OTGen and TransformGen, please
see: 

Barbara Staudt Lerner and A. Nico Habermann, "Beyond Schema Evolution
    to Database Reorganization", in Proceedings of the Joint ACM 
    OOPSLA/ECOOP '90 Conference on Object-Oriented Programming:
    Systems, Languages, and Applications, Ottawa, Canada, October
    1990, 67-76. 

Barbara Staudt, Charles Krueger, and David Garlan, TransformGen:
    Automating the Maintenance of Structure-Oriented Environments, 
    Computer Science Department Carnegie-Mellon University, Technical 
    Report CMU-CS-88-186, November 1988.

David Garlan, Charles W. Krueger, and Barbara J. Staudt, "A Structural
    Approach to the Maintenance of Structure-Oriented Environments",
    in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering
    Symposium on Practical Software Development Environments, Palo
    Alto, California, December 1986, 160-170.

Contact:
Barbara Lerner
blerner@cs.umass.edu


&#62; VODAK

Research in the framework of VODAK focuses on an extensible data
model and database programming language, an advanced transaction
model, object-oriented query language, and support for multimedia data.

The VODAK Data Model Language VML

Usually database models lack mechanisms for extending them with
additional modeling primitives. This limitation does not allow the
adaptation of the models for specific application needs, e.g. database
integration, multimedia document handling, hypertext modeling, etc.

The VODAK Model Language VML  homogeneously integrates the concept of
metaclasses and the separation of types and classes with other
object-oriented concepts such as properties, methods, inheritance, and
object identity. Complex nested data structures can be defined using
the set, array, tuple, and dictionary type constructors. VML supports
its own programming language for implementing methods, specifying
transactions and an ad hoc query language.

In VML classes are used to organize a set of objects corresponding to
real world entities and relationships between them. Object types define
the structure of objects and the operations defined on these
structures.  They are associated with classes in order to determine the
structure and behavior of the class' instances. Metaclasses are first
class objects whose instances are classes. Metaclasses are associated
with three object types: an (optional) own-type extending their own
behavior, an instance-type specifying the behavior of their instances
(which are classes), and an  instance-instance-type specifying the
behavior of the instances of their instances.  Metaclasses can be
organized in an instantiation hierarchy of arbitrary depth.

This approach leads to an open, adaptable data model which provides for
the specification of additional modeling primitives at a meta layer of
the database schema. The concept of metaclasses and the separation of
classes and types allow to determine the structure and behavior of
objects and the individual inheritance behavior via semantic
relationships between arbitrary objects already at the meta layer
independently from the specifications given at the application layer
for the application specific classes.


The VODAK Transaction Model

In VODAK, we focus on two specific problems of transaction management.

1. Operations to read and edit (hyper)documents are typically complex,
interactive and of long duration. A high degree of concurrency is
required to reduce the number and length of times a transaction is
blocked.

2. A publication environment has to handle existing database systems
for using and modifying remote information and documents.  Transaction
managers of existing systems, i.e. concurrency control and recovery,
have to be integrated in a transparent way utilizing the functionality
of existing managers.

Our transaction model is based on open nested transactions. Compared to
conventional flat transactions, nested transactions allow more
concurrency and are more flexible for recovery.  A nested transaction
is a tree-like structure, dynamically built up by the call of
subtransactions until a bottom implementation level is encountered.

We extended the open nested model from a fixed calling hierarchy of
operations in a layered system (multi-level transactions) to an
arbitrary calling hierarchy of operations in an object-oriented system.
Commutativity of operations is applied to system defined VODAK methods,
and to methods of user defined object types.  For the second type of
operations, we developed a framework to specify commutativity and
inverse operations in VML.

Query Processing

Although nearly all object-oriented data models proposed so far include
behavioral aspects, most object-oriented query languages, algebras and
query optimization strategies simply adapt relational concepts since
they focus on the complex structures of objects and neglect the
behavior. We claim that this approach is not sufficient since it does
not reflect the much richer semantics methods can carry which have to
be taken into account for really efficient query processing. The quite
straightforward approach we consider is to integrate methods in an
algebraic framework for query processing and to make there partial
knowledge about methods available in the form of equivalences. We
integrate algebraic set operators with methods defined in database
schemas within an object-oriented data model. We investigate the impact
on the architecture of the query processor when the algebra becomes an
extendible component in query processing.

Multimedia Support

The V3 Video Server was built as a demonstration showing a multimedia
application developed on top of the VODAK database management system.
The V3 Video Server allows a user to interactively store, retrieve,
manipulate, and present analog and short digital video clips. A video
clip consists of a sequence of pictures and corresponding sound.
Several attributes like author, title, and a set of keywords are
annotated.

In the future, the VODAK DBMS will be enhanced with new built-in
functionality for multimedia datatypes. Therefore, existing components
of VODAK must be changed and new ones must be added to support time
dependencies, high data volumes, and user interaction.

Query Processing

Although nearly all object-oriented data models proposed so far include
behavioral aspects, most object-oriented query languages, algebras and
query optimization strategies simply adapt relational concepts since
they focus on the complex structures of objects and neglect the
behavior. We claim that this approach is not sufficient since it does
not reflect the much richer semantics methods can carry which have to
be taken into account for really efficient query processing. The quite
straightforward approach we consider is to integrate methods in an
algebraic framework for query processing and to make there partial
knowledge about methods available in the form of equivalences. We
integrate algebraic set operators with methods defined in database
schemas within an object-oriented data model. We investigate the impact
on the architecture of the query processor when the algebra becomes an
extendible component in query processing.

The VODAK Prototype

The system architecture consists of a central database environment and
several external database environments to which the user wants to have
integrated access. Each of these environments consists of an object
manager, a message handler, a transaction manager, and a communication
manager. In addition to these components an external database
environment includes a database interface module which realizes the
access to an external database system.

The DBMS components are currently built on top of DAMOKLES and will be
in the near future on top of ObjectStore.

A first version of a C++ based prototype of VODAK is available for Sun
Sparc Stations under certain conditions.  It implements all the
features specified in including e.g. metaclasses, transactions, and
remote message execution.

References

P. Muth, T. Rakow, W. Klas, E. Neuhold:  A Transaction Model for an
Open Publication Environment.  A. K. Elmagarmid (Ed.): Database
Transaction Models for Advanced Applications. Morgan Kaufmann
Publishers, San Mateo, Calif., 1992.

Wolfgang Klas, Karl Aberer, Erich Neuhold Object-Oriented Modeling for
Hypermedia Systems using the VODAK Modeling Language (VML) to appear
in: Object-Oriented Database Management  Systems, NATO ASI Series,
Springer Verlag Berlin Heidelberg, August 1993.

Karl Aberer, Gisela Fischer Object-Oriented Query Processing: The
Impact of Methods on Language, Architecture and Optimization
Arbeitspapiere der GMD No. 763, Sankt Augustin, July 1993.

T.C. Rakow, P. Muth The V3 Video Server: Managing Analog and Digital
Video Clips, Sigmod 93, Washington, DC.

For further information contact

{aberer,muth,rakow,klas}@darmstadt.gmd.de

  GMD-IPSI                                             
  Dolivostr. 15                                                           
  D-64293 Darmstadt
  GERMANY    
                                    
  FAX: +49-6151-869 966   


Commercial Systems
__________________

&#62; ArtBASE  (Object-Oriented Data Model)

by:     ArtInAppleS Ltd.
        Kremelska 13
        845 03 Bratislava
        SLOVAKIA
        Phone: x42-7-362-889
        fax:   x42-7-777 779
        EMail: artbase.support@artinapples.cs

Distributor for Germany:
        ARS NOVA Software GmbH
        Stettener Strasse 32/3
        73732 Esslingen a.N.
        Germany
        Phone: x49-711 3704001
        Fax:   x49-711 3704001
        EMail: info@arsnova.stgt.sub.org

Languages: Objectworks\Smalltalk by ParcPlace Systems, Inc.

Platforms: Unix, PC Windows, Macintosh

Features:
- Fully implemented in Objectworks\Smalltalk
  (ArtBASE is delivered with source code)

- ArtBASE extents Smalltalk of persistency. Persistent objects are handled the
  same way as transient objects.

- Optimistic and pessimistic concurrency control.

- Transactions, including long lived transactions

- User concept with access restrictions

- storing of classes and methods in the database - entire applications 
  may be stored in an ArtBASE database, including the data AND the 
  application classes

- Currently, a single user version is available. The Distributed Multi User Server Version
  will be presented at the OOPSLA'93 at Washington D.C. in September 1993 for Unix
  environments and PCs.

- Existing applications can be turned to database applications very easily using ArtBASE


&#62; EasyDB (Objective Systems, Sweden)

EasyDB features a (programming language independent) Data Definition
Language (DDL) for the definition of schemas.  It relies on the
Entity-Attribute-Relationship model.  Data Manipulation Languages
(DML) include a Navigational Query language (NQL) embedded in a host
language (C available now, Ada in January '93), and a generic C++
class library.

On Schema Evolution (from original survey):
The schema may be freely extended with new items (types, domains,
attributes, entities, relationships etc.). Deletion of items is not
allowed.

Data created with an older schema may co-exist with newer data. Old
applications need not be recompiled when the schema is updated.
Attempts by newer applications to access `older' data in an
inconsistent way are detected and reported via an exception handling
system.

[Tomas Lundstrom &#60;tomas@os.se&#62;]

Objective Systems SF AB (Ericsson)
Box 1128
S-164 22 Kista, Sweden
tel : +46-8-703-4591
fax : +46-8-750-8056
contact: Jaan Habma, jaan@os.se


&#62; GemStone (Servio Logic)

First introduced in 1987, Servio's GemStone is the oldest commercial ODBMS
available today. GemStone is particularly well suited for use in complex
multi-user, multi-platform client/server applications. It supports
concurrent access from multiple external languages, including Smalltalk-80,
Smalltalk/V, C++ and C. GemStone also provides a dialect of Smalltalk as an
internal DML, which can execute methods or entire applications in the
database.

Servio also offers GeODE (GemStone Object Development Environment), an
object database application development environment which allows developers
to build complete object applications visually, without writing code. With
GeODE's visual programming tools, programming an application is a matter of
wiring together graphical representations of encapsulated code blocks. A
simple extension mechanism promotes the re-use of code, thereby increasing
the speed of program development. Also, association of application user
interface elements with database objects is established through simple
graphical tools. GeODE applications are stored and run in the GemStone
database, and so are both self-porting and network-aware, and can be
accessed externally from any of the GemStone language interfaces. Because
of GemStone's network architecture, Geode applications can operate easily
in a client/server environment.


 ==============================================================================

GEMSTONE

GemStone is a highly scalable client-multiserver database for commercial
applications. GemStone's features include:

o  Active Database -- GemStone allows database application developers to
   write methods which are stored and executed directly in the database.
   These methods can be accessed either internally, or from external client
   applications. This can significantly reduce network traffic and allow
   applications to take advantage of the superior compute power of the
   server. This also eliminates the need to rebuild and re-deploy
   applications whenever application or business processing rules change.
   This in turn allows for centralized code development and management,
   architecture-independent code that ports itself to new platforms,
   reduced network usage, and true client/server applications that share
   compute load between client and server machines.

o  Concurrent Support for Multiple Languages -- GemStone provides
   concurrent support for applications developed in Smalltalk, C++, C or
   GeODE. All applications, regardless of language, can have simultaneous
   access to the same database objects.

o  Flexible multi-user transaction control -- Multiple users can
   operate in the database simultaneously, with a variety of transaction
   control modes available.

o  Object-level security -- Authorization control can be applied to any
   object in the database, allowing for fine tuning of object security.

o  Dynamic schema and object evolution -- GemStone supports schema
   modification through class versioning and allows full migration of
   objects between versions of their classes with a simple message send.
   Migration is fully customizable and is undoable.

o  Production Services -- GemStone delivers the full suite of features
   required in any production-ready networked database including online
   backup, rapid recovery, referential integrity, sophisticated concurrency
   control, and event signals and notifiers.

o  Scalability -- In a recent independent benchmark, GemStone scaled to
   support more than 1,000 simultaneous log-ins and 100 concurrent active
   users on a mid-sized SMP server.

o  Legacy Gateways -- GemStone incorporates gateways or data bridges
   that allow object applications to integrate legacy data, whether in SQL,
   IMS, VASM or other formats. The level of integration between GemStone
   and legacy data and applications can range from simple query access to
   extensive read-write interoperability.


 ==============================================================================

GEODE

GeODE is a comprehensive environment for rapidly designing, building and
deploying production-quality commercial object applications. Its design
promotes code reuse in a team programming environment for increased
productivity. GeODE consists of six main elements:

o  Visual Application Manager -- Provides centralized management
   of each application and its component parts, and a namespace for
   addressing known objects.

o  Visual Schema Designer -- Allows the development of database schema
   visually, making the process more interactive and intuitive than with
   object-oriented programming languages. It also provides analysis tools
   for examining an existing schema.

o  Visual Forms Designer -- The Forms Designer reads GemStone class
   definitions and an associated data dictionary to automatically create
   default forms suitable for simple data entry. These forms can be rapidly
   customized, using a wide selection of user interface components and
   field types, which include image and sound support, and a large set of
   form design aids. The list of field types can be extended interactively.

o  Visual Program Designer -- The Visual Program Designer allows developers
   to visually create and modify the behavior of an application without
   having to write code. Programs are created by connecting visual program
   blocks to field blocks drawn from the forms created in the Forms
   Designer. A large collection of predefined program blocks is provided
   with GeODE, and users can extend the catalog in any of a number of
   simple ways. Code-based programming can be integrated routinely.

o  Developer Class Library - GeODE comes standard with more than 480
   classes and thousands of methods, and is easily extended for handling
   specialized applications. In a team environment, some programmers can
   develop visual applications while others write new methods that are
   encapsulated into visual program blocks for easy reuse.

o  Developer Tools -- GeODE includes tools for debugging, browsing and
   inspecting applications. Included in this set of tools are several
   debuggers, browsers, inspectors, an object clipboard, an image editor,
   and a code profiler for performance analysis.


 ==============================================================================

PLATFORMS

GemStone release 3.2 and GeODE 2.0 and all language interfaces are
available for UNIX workstations and servers from SUN, HP, IBM, Sequent, and
DEC. Client-only support is available in a number of languages for Windows
3.1, OS/2 and Macintosh. Servio is an active member in the Object
Management Group and the ANSI Smalltalk standardization committee. Servio
supports SUN ODMG, ANSI C++ and intends to comply fully with the emerging
standards.

 ==============================================================================

REFERENCES

  [Maier, et al. 84] D. Maier, J. Stein, A. Otis, A. Purdy, ``Development
  of an object-oriented DBMS'' Report CS/E-86-005, Oregon Graduate Center,
  April 86 - ACM 0-89791-204-7/86/0900-0472

  R.G.G. Cattell: Object Data Management - Object-Oriented and Extended
  Relational Database Systems; Addison-Wesley. ISBN 0-201-53092-9

  Robert Bretl, David Maier, Allan Otis, Jason Penney, Bruce Schuchardt,
  Jacob Stein, E. Harold Williams, Monty Williams. "The GemStone Data
  Management System." Chapter 12 of "Object-Oriented Concepts, Databases
  and Applications", by Kim and Lochovsky.


 ==============================================================================

CONTACTS

 === Headquarters - San Jose ====

Servio Corporation
2085 Hamilton Avenue
Suite 200
San Jose  CA  95125

Tel: 800-243-9369
Tel: 408-879-6200
Fax: 408-369-0422

 === Chicago ====

Servio Corporation
8410 Bryn Mawr
Suite 400
Chicago  IL  60631

Tel: 312-380-1310
Fax: 312-380-1308

 ===  New York ====

Servio Corporation
1120 Avenue of the Americas
4th Floor
New York  NY  10036

Tel: 212-626-6680
Fax: 212-626-6684

 === Dallas ====

Servio Corporation
14875 Preston Road
Suite 550
Dallas  TX  75240

Tel: 214-980-7073
Fax: 214-980-2949

 === Europe/UK ====

Servio UK
Criterion House
Beauchamp Court, Victors Way
Barnet  EN5 5TZ  England

Tel: +44 81 447-0800
Fax: +44 81 447-0577

 === Japan ====

Servio Corporation
Daito-Eiwa Building, 7F
5-11 Nihonbashi-Hakozakicho
Chuo-ku  Tokyo 103  Japan

Tel: +81 3 3660-1910
Fax: +81 3 3663-3287

 =====================
 === Distributors ====
 =====================

 === Germany, Austria, Switzerland ====

ObjectOriented System Technologies
Baroper Str. 337
Dortmund  50  W-4600
Germany

Tel: +49 231 975 990
Fax: +49 231 975 99-20

 === Japan ====

Japan Information Processing Co., Ltd.
6-7 Kabutocho, Nihonbashi
Chuo-ku  Tokyo 103  Japan

Tel: +81 3 3668-6170
Fax: +81 3 3668-1428

 ---

Nexus Technology K.K.
Suite 901
Botan 3-11-1
Koto-ku  Tokyo 135  Japan

Tel: +81 3 3660-1910
Fax: +81 3 3663-3287

 === Taiwan ====

Anco Technologies
11-1F, 76 Tun Hwa S. Road, Sec. 2
Taipei
Taiwan, R.O.C.

 === Italy ====

Etnoteam S.P.A.
Via Adelaide Bono Cairoli 34
Milano  20127  Italy

Tel: +39 2 261 621
Fax: +39 2 261 10755

 === England ====

AI International Ltd.
1 Parkview Road
Berkhamsted
Herts  HP4 2EY  England

Tel: +44 442 876 722
Fax: +44 442 877 997

 ==== Mexico ====

TEIX, Sistemas de Informacion
Estrategica S.A. de C.V.
Antonio M. Anza No. 43
Col Roma  Mexico D.F.  06700

Tel: +52 5 564-7146


&#62; ITASCA
                       ITASCA ODBMS V2.2

                      Itasca Systems, Inc.
                       7850 Metro Parkway
                      Minneapolis, MN 55425
                        sales@itasca.com
                         (612) 851-3155

                          Sandy Miezwa
                         (612) 851-3169

Introduction

Itasca Systems develops, markets, and supports ITASCA, a distributed 
active object database management system and related tools. The initial 
research work for ITASCA occurred in the Object-Oriented and Distributed 
Systems Lab at the Microelectronics and Computer Technology 
Corporation (MCC) in Austin, Texas. The research was known as the 
ORION prototypes. 

The ITASCA Distributed ODBMS is a language neutral, full-featured, active 
object database that supports data access from various object
languages. ITASCA allows clients to transparently access data that is
distributed among multiple servers.  ITASCA supports full dynamic schema
modification that can be performed during any phase of the software
lifecycle.  Applications written in dissimilar and incompatible languages,
such as C++ and CLOS, share objects through ITASCA. ITASCA stores methods
inside the database, promoting reusability and maintainability.  The only
commercial ODBMS based upon the MCC Orion technology, ITASCA is considered
by many to be the most feature-rich ODBMS on the market today.

This overview describes release 2.2 of the ITASCA Distributed Object 
Database Management System. It describes how ITASCA functions, 
outlines its implementation features, and explains some of the system 
benefits. 


History of ITASCA

ITASCA is based on a series of object database research prototypes. Work 
on these prototypes began in 1985 at the Microelectronics and Computer 
Technology Corporation (MCC) Object-Oriented and Distributed Systems 
Laboratory. MCC released the first prototype, ORION-1, in May, 1987, as 
a single-user system. MCC extended ORION-1 to the ORION-1SX 
prototype system and released it to the shareholder companies in April, 
1988. ORION-1SX was a multi-user system with a multi-client, single 
server architecture. The third prototype, ORION-2, introduced a distributed, 
object-oriented architecture for a multi-user environment. MCC released 
the third prototype to shareholder companies in July, 1989. ORION-2 has a 
multi-client, multi-server architecture. Having met its objectives, MCC 
stopped all work on ORION at that time. Over five million dollars was spent
for the three generations of prototypes.

The ITASCA product is an extension and commercialization of the ORION-2
prototype from MCC. Itasca Systems has added major enhancements and
features, improved the performance, and strengthened the code. It now runs
on UNIX systems from multiple vendors. ITASCA is an industrial-strength,
documented product, fully supported by Itasca Systems, Inc. Itasca Systems
continues to develop tools and other products to work with ITASCA.


Overview

ITASCA employs a distributed architecture with private and shared objects 
spread across UNIX-based computers on a local-area network. The 
ITASCA model follows the object-oriented view that uniformly models any 
real-world entity as an object. Each object has a unique identifier along with 
a state and behavior. Attributes represent the state of an object. Methods 
(code) define the behavior of an object. A class object collects objects that 
share the same set of attributes and methods. Subclasses derive from 
existing classes. The resulting schema, or database definition, is a class 
hierarchy. Each subclass inherits all the attributes and methods of its 
superclasses. ITASCA supports multiple inheritance. A subclass may derive 
from more than one superclass. 

One of the breakthroughs of object-oriented technology is the reusability of 
code. ITASCA allows for the active management of both reusable code and 
data in an integrated system. Developers may write applications in C++,
CLOS, C or Common Lisp. This means ITASCA is language neutral. Objects 
stored using one programming language can be accessed by other 
programming languages. It also means an application program need not be
written in an object-oriented language. 

The ITASCA database management system has features belonging to most any 
database system. This includes persistent storage for data and schema, 
concurrency control and locking, transaction management, multiple 
security levels, and logging and recovery for both CPU and disk media 
failure. Additional features of ITASCA include dynamic schema 
modification, long-duration transactions, shared and private databases, 
distributed version control, distributed transaction management, distributed 
query management, distributed change notification, object migration, and 
an extensible architecture.

Shared and private databases exist in a distributed environment in ITASCA. 
The shared database is distributed across workstations (sites) in a network. 
An ITASCA server controls the partition of the shared database at each site. 
ITASCA clients provide transparent access to the various partitions of the 
shared database. The architecture allows any number of private databases at 
each distributed database site. Data can move between private and shared 
databases. Private databases allow private data that is not shared with other 
users of the database.

ITASCA stores the schema redundantly at each site to improve 
performance. The schema storage also includes code in the form of 
methods. Management of schema updates is automatic for all sites. This 
includes sites that were off-line during any changes. Automatic distribution 
of schema changes, including method code changes, simplifies database 
administration.

ITASCA stores each instance of data in one site. The system or a user may 
move the data from one site to another to improve data locality. Access to 
moved data remains transparent. There is no need for a user or application 
to know the specificlocation of data in the ITASCA distributed database. 
ITASCA will automatically find the location of the data. This simplifies 
distributed application development. The developer can rely on ITASCA 
finding data in the distributed database.

No single site acts as a master site, thus ITASCA's architecture has no 
single point of failure. ITASCA has neither a central data server nor a 
central name server. This is important for maintaining a database system 
with high availability in a networked workstation environment.

ITASCA supports dynamic schema modification to create a flexible 
environment for changing or customizing a database system. Authorized 
users can add and remove attributes or change the subclass/superclass 
relationship at any time. Authorized users can also add or remove partitions 
of the shared database at any time. All this can be done interactively without 
affecting other parts of the ITASCA database at the time changes occur to 
the schema. There is no need to "bring the system down" or off-load/reload 
data to restructure the database. Dynamic schema modification can 
significantly reduce maintenance costs. It also is useful in environments 
where change to data definitions are normal or relatively frequent.

ITASCA has a sophisticated security authorization technique tied to the 
class hierarchy. It supports both positive and negative authorizations at any 
level in the class hierarchy. For example, granting access to all objects but 
one requires only two authorizations: a global grant followed by a specific 
denial. Authorization extends to classes, instances of classes, attributes, 
and methods. Also, inheritance of authorization reduces the work of database 
administration. 

Long-duration transactions allow users to check objects out of the shared, 
distributed database into their private databases. Users can then change the 
objects in the private databases without affecting the shared database or 
other users. These changes can be committed to the private database. Then, 
at any later time, the user can check the updated object or objects back into 
the shared database.

ITASCA supports version control of objects. A new version of an object 
promotes the original or parent object to restrict further changes to the 
parent. ITASCA also supports alternate versions such that multiple versions 
can have the same parent. Promoting an object version to a released status 
restricts any deletion of the object. ITASCA uses generic versions to 
dynamically reference the most recent or default version of an object 
without any intervention by a user or application.

Change notification in ITASCA is either flag-based or message-based. 
Flag-based notification will identify an updated object upon querying the 
object for such information. It is a passive notification scheme. Message-
based notification, on the other hand, is an active notification scheme. It 
will execute a method (or code) upon an update or other change to an object. 
Such methods can send mail messages or invoke other methods or 
programs. 

Memory management in ITASCA uses both page and object buffers. 
ITASCA has a traditional database page buffer scheme that contains pages 
with multiple objects. Desired objects move from the page buffer to an 
object buffer. The object buffer then provides ITASCA with enhanced in-
memory performance because it contains only frequently-referenced 
objects. 


&#62; Matisse

OODBMS FEATURES LIST:

An Industrial Strength Open Semantic Object Database

Performance
-       Symmetric, Fine Grain, Multi-Threaded Architecture
-       Parallel and Asynchronous Disk I/O
-       Automatic Disk Optimization through Dynamic Clustering
-       High Speed OLTP Environment
Reliability
-       24 Hour - Mission Critical Operation
-       Media Fault Tolerant (Object Replication)
-       Transparent On-line Recovery
Database Administration
-       Full On-line Administration (No Down Time)
-       On-line Incremental or Full Back-Up
-       Dynamically Increase Database Size -   On-line
-       Full On-line Monitoring
Data Management and Consistency
-       Dynamic Schema Evolution
-       Consistent Database Reads without Locking
-       Historical Versioning, both Schema and Data Objects
-       Built-in Enforced Referential Integrity
-       Object Level Implicit or Explicit Locking
Scalability
-       Hundreds of Concurrent On-line Users
-       Hundreds of Gigabytes Per Database
-       From Few Bytes to Four Gigabytes for Each Object
-       Up to Four Giga-objects Per Database
Object Model
-       Full Object Oriented Model
-       User Extensible Object Meta-Schema
-       Support for Complex, Highly Dynamic, Variable Sized Objects
-       Multiple Inheritance
Intelligent Objects
-       Triggers at Object, Attribute, or at Relationship Level
-       Consistency Rules at Object, Attribute, or at Relationship Level
-       Customizable Intelligent Object Indexing
-       Automatic Inverse Relationships
Open Systems
-       Open C, C++ API
-       Supports Any Commercial Development Tool and Language
-       No Proprietary Tool Required
-       Heterogeneous Cross Platform Client/Server Architecture

For Information on MATISSE, Contact one of the following offices:

USA:
ODB, an Intellitic International Company
238 Broadway
Cambridge, MA  02139
Phone:(617) 354-4220
Fax: (617) 547-5420
email:  info@odb.com

EUROPE:
INTELLITIC INTERNATIONAL
12-14 rue du Fort de Saint-Cyr
Montigny-le-Bretonneux
78182 Saint Quentin en Yvelines Cedex France
Phone:   33(1) 30.14.54.30
Fax:    33 (1) 30.14.54.40

JAPAN:
SGN CO. LTD.
Urban Toranomon Building
16-4 Toranomon
Minato-Ku Tokyo 105 Japan
Phone:   81 (3) 3593.34.31
Fax:   81 (3) 3593.34.32


&#62; NeoAccess

A cross-platform object-oriented database engine based on C++. It allows
developers to embed the power of a fully-functional object-oriented database
system into their applications. All of the data contained in the database,
including indices, can be in a single file, so users can treat a database
file as they would a standard document file. The programming model is
designed to keep visible complexity to a minimum while providing a
feature-rich foundation on which to build and enhance applications.

NeoAccess has taken a different approach toward the issues surrounding object
persistence than have other solutions that have been offered. We believe that
objects should be viewed as having a set of properties with a pliable state.
With NeoAccess persistent objects are provided with persistence and sharing
properties. These properties allow objects to maintain an association with a
file. This association, which can be built and broken freely, allowing
objects to migrate freely between disk and memory. The API to these
properties address issues such as adding or deleting the object from a file,
sorting and indexing, locating and later freeing the object in memory, object
sharing, and maintaining relationships between objects.

NeoAcces
s with has been fully integrated into standard application frameworks such as
Borland's ObjectWindows and MacApp 3.0 and the THINK Class Library on the
Macintosh. A single source tree can be used to build the engine in all
development environments. Database files are binary-compatible across
platforms so users on different types of machines can share data without
conversion.

Contact:
Bob Krause
NeoLogic Systems
1373 Third Avenue
San Francisco, CA 94122
(415) 566-9207


&#62; O2 (INRIA/O2 Technology)

This is an entry on schema evolution.  General papers on O2 are included.

We have implemented in O2 schema updates in our first release but
without NO IMPACT on the database (we have a design to implement
deferred update, but it is a paper design). However, users manage to
convert their instances by hand, using their O2 programs written
themselves, and with the aid of the following tools:

1- There is a set of predefined classes whose instances contain
   objects representing a schema (i.e., a Meta-schema). These classes
   may be used in a conversion program, they may even be extended by
   the programmer.

2- There is a save-restore program that allows to take an O2 database,
   save it on a file or a tape in a logical way (i.e., independent of
   the physical format of objects on disk), and restore it again on a
   (perhaps new release) of the system, in an empty database.
   Currently, when saving a database its schema is also saved. The
   next extension to this save/restore program will be to save the
   database without saving its schema, and then restore the database
   on a new version of that schema. The restore program will be able
   to perform automatically some conversions like "add attribute" or
   "delete attribute".


Schema updates with impact on the database will be implemented in future 
releases.

[Fernando Velez &#60;fernando@o2tech.fr&#62;]


For more information on O2, consult the following REFERENCES:

        Francois Bancilhon, Claude Delobel, Paris
        Kanellakis.  "Building an Object-Oriented Database
        System: The Story of O2".  Morgan Kaufmann Series
        in Data Management Systems, San Mateo, Calif., 1992.
        
        F. Bancilhon, G. Barbette, V. Benzaken, C. Delobel,
        S. Gamerman, C. Lecluse, P. Pfeffer, P. Richard,
        and F. Velez.  "The Design and Implementation of
        O2, and Object-Oriented Database System".
        Advances in Object-Oriented Database Systems,
        Springer Verlag. (Lecture Notes in Computer Science
        series, Number 334.)

        C. Lecluse, P. Richard, and F. Velez. "O2, an
        Object-Oriented Data Model".  Proceedings of
        SIGMOD88.  Also appears in Zdonik and Maier,
        "Readings in Object-Oriented Database Systems",
        Morgan Kaufmann, 1990.

 ==== Corporate headquarters:
O2 Technology
7 Rue du Parc de clagny
78035 Versailles Cedex
France
tel : 33 1 30 84 77 77
fax : 33 1 30 84 77 90

[They have many other contacts worldwide]


&#62; Objectivity/DB (Objectivity)

Introduction:

Objectivity/DB has a fully distributed client/server architecture that
transparently manages objects distributed across heterogeneous environments and
multiple databases.  It provides an application interface that uses transparent
indirection to ensure integrity and provides a single logical view of all
information, with all operations working transparently on any database on the
network, with scalable performance as users and objects increase.  A
higher-level Object Definition Language (ODL) is available as well as a C
functional interface, integrated C++ interface, and SQL++.


Objectivity/DB

Objectivity/DB [Reference:  Technical Overview, Objectivity, 1993], a product
of Objectivity, Inc. of Menlo Park, CA, provides an integrated C++ programming
interface with an emphasis on the DBMS engine for robustness and scalability
from workgroups to enterprise-wide production applications.  In production use
today with more than 50,000 end users licensed, it supports a fully
distributed, rather than central-server, architecture, with all operations
working transparently over a mixture of multiple databases, schemas, users, and
computers, and over heterogeneous hardware, operating systems, and networks. 
The language interface includes a C++ class library interface, soon to be ODMG;
a C function library; and SQL++, supporting query predicates with either SQL or
C++ syntax, interactively or programmatically.  Over forty administrative and
GUI tools provide both an interactive and programmatic interface, and a
messaging backplane allows third party tools integration at four different
levels, with a list of partners at all levels.

One of the key architectural concepts of Objectivity/DB is an object reference
mechanism that ensures data integrity.  Unlike traditional ODBMSs that use
direct pointers, which become invalid after commit and hence lead to crashes
and corrupt databases, Objectivity/DB uses an indirection to guarantee safe
reference.  Transparent to the user, this indirection requires an extra test
and pointer dereference, or a couple of cycles, which is not measurable in most
applications.  However, it ensures integrity of all references, even across
transaction boundaries, resulting in production quality robustness.  Also, it
provides object level granularity for the object manager, allowing it to move,
cluster, and swap objects as necessary, one of the keys required for
scalability in objects and users.  Finally, it allows object-level granularity
for current features, such as heterogeneity and versioning, and future
extensions, such as object-level security.

A higher-level Object Definition Language (ODL) is provided that allows
declaration of modeling concepts such as bi-directional associations, behavior
of associations between objects as they version (move, copy drop), and
propagation of methods across associations.  These then result in automatically
generated methods and declarations for both C++ and C.  The standard C++ API
allows application programmers to work with any standard compilers and
debuggers, with no extra pre-processors, providing ODBMS capabilities via
overloading C++ operators (new, -&#62;, etc.), and declarations via provided
classes (for references, etc.).

Workgroup through enterprise-wide and cross-enterprise computing is supported
via a distributed client/server architecture that provides a single logical
view over multiple databases on heterogeneous machines.  The user sees a
logical view of objects connected to objects and need not worry that one object
is in a database on a Sun workstation, while another may be in a database under
Windows or VMS.  All operations work transparently across this environment,
including atomic transactions with two-phase commit, propagating methods, and
versioning.  Objects may be moved between databases and platforms without
affecting working applications or requiring changes to the applications. 
Multiple schemas may be created, without affecting other users or databases,
and may be used simultaneously with shared schemas, allowing local groups to
define their own models but still connect to other groups.  Databases may be
detached from this shared environment (federated database) and used on portable
devices, reconnected or moved to different (compatible) environment, or
distributed as parts or image libraries.  Gateways to RDBMSs are provided via
third-party integration with Persistence Software, and more generally to any
foreign data store, as long as the user installs the appropriate access
methods, extending the single-logical-view to include read/write access to
arbitrary foreign data stores.  Together, these allow delegation of
responsibilities to the appropriate users, integration with existing systems,
and gradual migration toward full enterprise-wide sharing.

The on-demand object manager directly and automatically manages object access
and buffering, rather than relying on system facilities such as virtual memory
or user manual get/put calls.  Mechanisms used include multiple buffer pools
locally and remotely, b-trees, hashing, scoped names, keys, and iterators, with
distributed catalogues for schemas and databases.  A direct connection is
established between the user and the objects used, so that users do not
conflict unless and until they are competing for the same objects, thus
avoiding the traditional central-server bottleneck.  Short transactions are
based on traditional (transient) locks, owned by the process, and group
together an arbitrary set of operations.  Long transactions are based on
persistent locks, owned by the user, and provide the same arbitrary grouping. 
Default concurrency is two-phase locking and serialization, but extensions
available include MROW, or multiple-readers concurrent with one-writer, and
allow users to lock with or without wait or with timed waits, to implement more
sophisticated mechanisms.

Objects may be modeled using C++ structures augmented by classes provided such
as strings, dictionaries, and relationship management, as well as some
particular domain libraries.  A simple object is a C++ class (or C structure)
with associated access methods.  A complex object may include multiple varrays,
each being a dynamically varying sized array of arbitrary structure.  A
composite object is any network of related objects that acts as a single
object, both structurally and behaviorally, via propagation of behaviors to
component objects.  Any number of composite objects may be contained in
composite objects, and a single object may participate in any number of
composites.  The relationship mechanism supports uni- and bi-directional
relationships, one-to-one, one-to-many, and many-to-many.  Versioning is
supported at object granularity, may be turned on or off at any time for each
object, may be restricted to linear or allow branching with multiple writers. 
References to versioned objects may be to a specific version or to the default
version, which may be separately specified by a method and may allow multiple
defaults.  Schema and object evolution are supported via versioning of the
type-defining objects.  Each time a type definition is changed, its defining
object is versioned, allowing arbitrary changes.  Objects may then be instances
of the old or new type version.  Object evolution or upgrading to the new type
version is supported  by the user writing conversion methods which are
installed and invoked by the system.

ANSI SQL query is supported in the SQL++ product.  Predicate syntax may be
either C++ or SQL.  The ODBC and SQL Access Group (SAG) protocols are
supported.  Queries may be invoked programatically or interactively, with ad
hoc support.  Access to object features is available via methods and traversal
of relationships.

Over forty administrative and developer tools are provided, each with both an
interactive and programmatic interface.  These include GUI object and type
browsers, query browsers, report generator, tools to examine and force short
and long locks, to move objects and databases, etc.  On-line incremental backup
provides a consistent network-wide snapshot, including referential integrity
across all databases, and runs incremental and full database backups with no
need to acquiesce the databases and no interference with active applications. 
All tools are built around a messaging backplane, which supports four levels of
integration with user and third-party tools.  Integrated products include HP
SoftBench (full operational level), CenterLine's ObjectCenter (tool level), 
Persistence RDBMS gateway, PTech and ProtoSoft Design and Analysis (language
level), and XVT and UIM/X (compatibility level).

Objectivity/DB is resold by Digital Equipment Corporation as DEC Object/DB,
providing a multi-billion-dollar second source vendor.  Over 50,000 end users
are licensed in production use, with applications including real-time
telecommunications, aerospace, defense, case, CAD/CAM, CIM, manufacturing, oil
&#38; gas, process control, transportation, multi-media, case, document management,
financial analysis, and corporate information management.  Platform support
includes all Sun, all DEC (including VMS, alpha, OSF-1), HP/9000 series (both
68xxx and PA-RISC), IBM RS/6000, NCR 3300, SGI, Windows 3.1, and Windows NT.

On Schema Evolution (from original survey):
In the just-released Version 2.0 (shipping Oct 92), schema evolution
is supported via dynamic versioning of type-defining objects [ie.
class versions -- SMC], and via a step-by-step approach that allows
conversion of instance data via user-provided conversion methods.
Also, a full dynamic type manager interface is available for doing
fancier things.

Contact:

Drew Wade
Objectivity, Inc.
800 El Camino Real
Menlo Park, CA  94025 USA
drew@objy.com
1(415)688-8000 voice
1(415)325-0939 fax
admin ass't:  Vickie Clements (vickie@objy.com)
information:  info@objy.com


&#62; ObjectStore (Object Design)

Entry on Schema Evolution only:

ObjectStore does not provide schema evolution as yet but it has
promised to provide schema evolution in the next release.
[h.subramanian@trl.OZ.AU]

ObjectStore is an ODBMS produced by Object Design, Inc.  Release 2,
which is in beta test now, supports schema evolution.  The kinds of
evolution supported include change of a data member's type, addition
and removal of data members, and change in inheritance structure.
There are default transformations built in, (e.g. from int to float),
and user-defined transformations may be run also.

Approximately $5-8K

[Ian Schmidt, Object Design, Inc. &#60;schmidt@odi.com&#62;]

        
&#62; Ontos [formerly VBase] (Ontologic)

Entry on schema evolution only:

*Ontos provides schema evolution. It allows any class to be modified.
*The major drawback is that data does not migrate ie., instances are
*not modified to adopt to the new class definition. So schema changes
*can be done only on classes that do not contain instances and do not
*have sub classes that contain instances.
*[h.subramanian@trl.OZ.AU]

*As a system for experiments, we are currently using ONTOS from
*Ontologic Inc.  Unfortunately, there is no transparent concept of
*schema evolution for populated database. Thus, we still investigate
*how it works.

ONTOS has a version of ONTOS for OS/2.  Approximately $11K. Others I don't know


&#62; OpenODB (Hewlett-Packard)

OpenODB is an advanced object-oriented database management system
(ODBMS) from Hewlett-Packard for your complex commercial application
needs.  With OpenODB, you can take advantage of new object-oriented
features combined with a robust database management system.  This
combination of capabilities is unique in the industry.

OpenODB's object-oriented features will help to reduce your development
and maintenance costs by more intuitively representing your business
problems. Also, OpenODB stores code as well as data.  This means that
your application will be simpler and code as well as data can be shared
between multiple users and applications.

OpenODB's database management features ensure the integrity, security
and availability of your stored code and data.  At the same time,
OpenODB protects your existing data, applications and training
investment by allowing you to access existing data and applications
using the object-oriented structured query language (OSQL).

Hewlett-Packard's OpenODB product uses a client/server architecture, 
enabling you to efficiently utilize your available computing power.  
OpenODB's clients use the programmatic interface to access information on 
the server.

OpenODB is composed of the following client and server components:

OpenODB Clients

o        Interactive Object-Oriented SQL (IOSQL)
         This interface allows you to interactively enter all object-
         oriented SQL (OSQL) statements, facilitating rapid prototyping
         and testing.  IOSQL provides basic query, administration and
         editing capabilities.

o        Graphical Browser
         The Graphical Browser is a tool that allows you to graphically
         explore your database schema and contents.  This tool is
         designed to increase the speed of application development by
         making it easier for you to find reusable code stored in
         OpenODB.

o        Programmatic Interface
         You can write OpenODB applications using any programming
         language that can be linked with C (C++, COBOL, FORTRAN,
         Pascal).  The programmatic interface uses OSQL statements
         passed as parameters and does not require preprocessors.

o        User Applications and Tools
         These are the OpenODB clients you will develop using IOSQL,
         the Graphical Browser and the Programmatic Interface.

OpenODB Server Components

o        Object Manager
         The Object Manager executes OSQL calls made by the OpenODB
         clients.  The Object Manager processes requests and accesses
         data and code from the internal data storage manager
         (Relational Storage Manager) or passes the request to a
         subsystem outside of OpenODB (External Functions).

o        Relational Storage Manager
         OpenODB uses a relational database as its storage manager for
         internally stored data and code.  The relational database
         performs the physical file management and database functions
         such as multiuser concurrency, transaction management, and
         recovery.  Relational database tools are available to help you
         perform online backup and recovery, manage physical
         distribution of files, maximize availability and change
         database parameters.

o        External Functions

         External functions allow you to access data and code stored
         outside of OpenODB, regardless of data format or location.
         They are implemented by you as subroutines written in general-
         purpose programming languages and compiled outside of OpenODB.
         With external functions, you can encapsulate existing
         applications.  External functions can be called by any OSQL
         statement, allowing you to use this remote data and
         application code like any other object.

OpenODB Object Model

In OpenODB, the object-oriented model is based upon three components:
objects, types and functions.  These terms are defined as follows in
OpenODB:

     Objects are a combination of data and stored code that operate on
     the data.

     Types allow you to classify similar objects.

     Functions operate on data in the database and also define the
     behavior of that data in the database.  OpenODB supports the
     following three  types of user-defined functions:

  *      Stored functions define attributes and relationships that are
         stored in the database.

  *      OSQL-based functions define attributes and relationships that
         are  retrieved or calculated with OSQL statements.

  *      External functions are a reference to code or data stored
         outside of OpenODB.

OpenODB Language

You create and manipulate objects, types and functions using OpenODB's
object-oriented structured query language (OSQL).  OSQL is a functional
language that is a semantic superset of SQL, the structured query
language used for relational databases.  OSQL is a complete language
with statements that allow you to define and manipulate your OpenODB
database, specify authorization by individuals or groups, define
transactions, embed program logic within functions, and administer your
database.

Using OSQL, you can create the following schema:

                           +---------------+
Type                       |   Employee    | Name, Salary, Picture,
                           +---------------+ SalaryDeduction, WorksFor,
                  +----------------|----------------+ DisplayPicture
         +----------------+               +-----------------+
Subtype  |    Manager     | Manages       |    Programmer   | Languages
         +----------------+               +-----------------+

                         OpenODB Schema Diagram

Creating Types and Functions

The first step is to create basic types and functions using the CREATE
TYPE statement, and to create additional functions using the CREATE
FUNCTION statement.  Next, using the simple OSQL statements shown in
Table 2, you can create specific objects.

   Create a user-defined type called Employee with three stored
   functions:

        CREATE TYPE Employee
          FUNCTIONS (Name CHAR,
                     Salary FLOAT,
                     Picture BINARY);

   Create type Programmer, a subtype of Employee. Also define the
   stored function Languages on Programmer:

        CREATE TYPE Programmer SUBTYPE OF Employee
          FUNCTIONS (Languages SETTYPE(CHAR));

   Create type Manager, a subtype of Employee.  Also define the stored
   function Manages on Manager:

        CREATE TYPE Manager SUBTYPE OF Employee
          FUNCTIONS (Manages SETTYPE(Employee));

   Create an OSQL-based function SalaryDeduction on Employee:

        CREATE FUNCTION SalaryDeduction (Employee e) -&#62; FLOAT AS OSQL
           SELECT (0.3 * Salary (e));

   Create an OSQL-based function WorksFor on Employee to define the
   relationship with Manager:

        CREATE FUNCTION WorksFor (Employee e) -&#62; Manager AS OSQL
           SELECT mgr
            FOR EACH Manager mgr
            WHERE e IN Manages(mgr);

   Create an external function on Employee to display the employee's
   picture:

        CREATE FUNCTION DisplayPicture (CHAR Name) -&#62; CHAR AS EXTERNAL
          SIMPLEEXTFUN('DisplayPicture $Name');

Creating Objects

  Put data into three stored functions defined on the Programmer type:

        CREATE OBJECT AS Programmer
         FUNCTIONS (Name, Salary, Languages)
         :bob ('Bob Cox', 55000, SET('PL/1', 'C')),
         :sue ('Sue Smith', 65000, SET('COBOL'));

  Put data into three stored functions defined on the Manager type:
        CREATE OBJECT AS Manager
         FUNCTIONS (Name, Salary, Manages)
         :al ('Al Ott', 70000, SET(:bob,:sue)),
         :jim ('Jim Hill', 100000, SET());

  Put data into three stored functions using a reference to another
  object:

        CREATE OBJECT AS Manager
         FUNCTIONS (Name, Salary, Manages)
         :chris ('Chris Jones', 80000, SET(:al,:jim));

SQL-like Queries

  Select Bob's salary:

        SELECT Salary (:bob);
          Result: 55000

  Select the names of the employees that Al manages:

        SELECT Name(Manages(:al));
          Results: 'Bob Cox'
                   'Sue Smith'

  Select the names of all managers:

        SELECT Name (m)
         FOR EACH Manager m;
            Results: 'Al Ott'
                     'Jim Hill'
                     'Chris Jones'

NOTE:  The ":" denotes a temporary variable (e.g. :bob) defined in your
application to store a reference to your OpenODB object.

Development of New Applications Faster Using OpenODB, you can directly
model your business information in an intuitive way.  You can also
reuse code stored in OpenODB to reduce your application backlog and
improve your productivity.  To help you develop new applications
faster, OpenODB provides the following features:

Object Identity Each object stored in OpenODB has a system-provided,
unique handle called an object identifier (OID).  OIDs reduce
duplication of information and relieve you from creating unique keys to
identify stored information in the database.

Complex Objects With OpenODB you can construct complex objects from
simpler objects.  Complex objects relieve your application code from
managing the relationships between simple objects.

Referential Integrity Since OpenODB has knowledge of the relationships
between objects, it can manage referential integrity on your behalf.
That is, if objects referenced by other objects are deleted, the system
removes all dependencies.  You can specify whether or not to "cascade"
changes or to just delete the immediate dependency.  For instance, if
you delete the Employee 'Bob Cox', the function call
(Name(Manages(:al))) will return just 'Sue Smith'.  The result is a
simplified database schema and simplified application code that can be
developed more quickly since you do not need to manage referential
integrity explicitly.

User-defined Data Types In addition to the primitive data types you can
construct user-defined data types in OpenODB rather than in your
application code.  User-defined types give you more flexibility and
lead to more manageable, clearer code.

Type Hierarchy Types can be organized in a hierarchy.  This hierarchy
of types and related functions allows you to minimize the translation
from your business model to your OpenODB schema.  The hierarchy also
enables a type to inherit functions defined on "parents", eliminating
duplication of functions.  You will be able to more quickly move from
application design to implementation.

Multiple Inheritance Functions defined on a type can be inherited by
one or more subtypes.  By inheriting rather than redefining functions,
you can easily extend the functionality of your application.

Overloaded Functions Multiple functions can have the same name with
different implementations.  In your application, all you need to do is
call a function (e.g. Salary). OpenODB will determine which code
(Salary for Employee or Salary for Manager) to execute based upon the
parameter passed at run-time.  As a result, your application code is
simplified since the logic for determining which function to execute is
now in OpenODB.

Late Binding OpenODB supports functions that are resolved at run-time.
Late binding allows you more flexibility in application development and
gives you the full power of overloaded functions as described above.
Late binding also shields your applications from changes to functions
since these changes can be made online and the new function definition
resolved at run-time.

Reduced Maintenance Costs OpenODB allows you to add new functionality
and make schema changes to your OpenODB database at run-time, often
without changing your application code or even stopping the database
system.  The following OpenODB features will help reduce your
maintenance costs:

Dynamic Schema Modification You can create new functions and types in
OpenODB at runtime.  You can also change the implementation of
functions without having to recompile your applications.

Dynamic Typing You can dynamically change the type of an object without
having to destroy and recreate the object.  This is possible because an
object can belong to more that one type.

Encapsulation OpenODB supports the combination of data and user-defined
functions.  Since OpenODB only allows access to your data through these
functions, your application is protected from changes to the function
implementation and you have control over how users access information
in OpenODB.  Encapsulation allows you to modify the function body
without changing your application code.

Procedural Language OSQL includes programming flow statements,
including IF/THEN/ELSE, FOR and WHILE.  The procedural language allows
OpenODB functions to be quite complex, simplifying your application
code.  By moving application code into the database, you can now share
the code and get all of the benefits of sharing data, such as
consistency, security and integrity.

For example...

Create a Procedure

  Convert all managers to programmers that have less than a specified
  number of employees:

   CREATE FUNCTION MgrToEng (INTEGER minemps) -&#62; BOOLEAN
     AS OSQL
        BEGIN
          FOR m IN Manager DO
             IF (COUNT(Manager (m)) &#60; minemps)
             THEN
                BEGIN
                  ADD TYPE Programmer TO m;
                  REMOVE TYPE Manager FROM m;
                END
             ENDIF;
         END;

Executing a Procedure

Applications are simplified since the implementation of functions can
now be stored in OpenODB.  Simply call a function, passing a parameter:

  CALL MgrToEng(3);

Protection of Existing Investments OpenODB coexists with your current
data and applications, allowing you to build upon existing
functionality.  Also, OpenODB's object-oriented SQL (OSQL) is easy to
learn if you already know Structured Query Language (SQL).

External Functions Using external functions, you can access distributed
data and code stored outside of OpenODB, regardless of data format or
location.  This simplified view of your enterprise allows you to more
easily develop complex applications that integrate your existing data
and applications.  For instance, you can develop an OpenODB application
that accesses data stored in other databases (e.g. ALLBASE/SQL,
TurboImage or DB2) as well as in flat files.  OpenODB acts as an
integrator so that your application just needs to know OSQL.  OSQL
statements may actually call functions that access data and encapsulate
code stored outside of OpenODB.

OSQL If you already know SQL, you can quickly be productive using
OpenODB's OSQL. OSQL uses syntax that is similar to SQL, the semantics
are a superset of SQL, and both query languages are set-based, that is
they retrieve sets of information based upon queries, as shown in
earlier examples.

Optimize Performance and Availability OpenODB, with the help of the
underlying relational storage manager, gives you flexibility in
managing the performance of your system and maximizing the availability
of information for your users.

High Availability
OpenODB maximizes the availability of your information by providing:
* dual logging, to ensure the integrity of your log file
* switch log, to automatically switch to a second log file if the
  original log file is damaged or becomes full
* dynamic file expansion, to automatically expand the size of your
  system file if it becomes full
* online backup of the database, to backup the database while it is
  being accessed OpenODB will also take advantage of available system
  features such as disc mirroring.

Multiuser Concurrency Control OpenODB is designed to support hundreds
of users accessing the same information while guaranteeing the
integrity of that information.

Compiled Functions To improve runtime performance, functions are
compiled and can be cached.

Access Methods on Stored Data Indexes are automatically defined on
object identifiers (OIDs) for you when you create types and functions.
These indexes help provide quick access to information stored in your
OpenODB ODBMS.  You can also define your own indexes.

Clustering Related functions can be stored close to each other in order
to improve performance.

Additional Features

Authorization You can control access to OpenODB at the database and
function levels based on individuals or a group of users. Authorization
statements provide you a flexible way to control access to types and
functions in OpenODB.

Client/Server Architecture Clients communicate with the OpenODB server
over a network.  The interface between the clients and the server is
transparent to you as a user.  The clients and server can also reside
on the same machine.

Multimedia OpenODB allows you to store large, unformatted data in
binary format.  Some examples include graphics, images or voice.  You
can also define functions in OpenODB to manipulate this multimedia
information.  For example, you can store a picture as well as the
function to display the picture.

Native Language Support You can store 8-bit and 16-bit character data
in OpenODB.

Persistent Data and Code OpenODB allows you to save data as well as
code between application sessions.

Primitive Data Types OpenODB supports a number of primitive data types,
shown in the OpenODB Feature Summary below.  You can also create your
own user-defined data types.

Recovery OpenODB has a robust logging and recovery facility.  In case
of a failure, OpenODB can handle rollback or rollforward recovery to a
particular time, using your log file to recreate saved work.

Transaction Management OpenODB ensures the logical and physical
integrity of your database by giving you complete control over the unit
of work to be performed within a single transaction.  With this
control, you can save or rollback a transaction (throw away temporary
work) at your discretion.  Savepoints are supported so that you can
rollback parts of a transaction.

System Environment The OpenODB server and all clients are available on
HP-UX 8.0 or later versions for the HP9000 Series 300/400/700/800
systems and for MPE XL 4.0 or later versions for the HP3000 Series 900
systems.  Client software will also be supported using X terminals.
You will need 16 Mbytes of main memory (32 Mbytes recommended), at
least 15 Mbytes disc space for installation and approximately 10 Mbytes
DISC space for each new OpenODB database.

Software Requirements To use OpenODB, you need to have a TCP/IP
transport and ARPA Berkeley Services.  To use the OpenODB Graphical
Browser, you need to have X-Window X11.

Ordering Information The software includes:  OpenODB clients (IOSQL,
Graphical Browser, Programmatic Interface) and the 1-8 user license for
the OpenODB server (Object Manager, Runtime ALLBASE/SQL and External
Functions).  You must specify a media option for the HP9000 systems.

         Product Number  Product Description
         B2466A          OpenODB Developer Release for HP9000 S300/S400
         B2468A          OpenODB Developer Release for HP9000 S700
         B2470A          OpenODB Developer Release for HP9000 S800
         B2472A          OpenODB Developer Release for HP3000 S900

Documentation, Online Support, Training and Consulting The OpenODB
Developer Release includes documentation for all systems.  The OpenODB
Developer Release also includes online support, training and
consulting.   These services will be arranged when you place an order
for the product.

OBJECT-ORIENTED FEATURES                 CLIENT INTERFACES
Complex Objects                          Interactive OSQL
Dynamic Schema Modification              Graphical Browser
Dynamic Typing                           Programmatic Interfaces: C
Encapsulation                            linkable languages (C++,
External Functions                       COBOL, FORTRAN, Pascal)
Functions (Stored Code or Methods)
Late Binding                             OSQL STATEMENTS
Multiple Inheritance                     Add/Remove Type To/From Object
Object Identity (OID)                    Add/Remove User
Overloaded Functions                     Call Function
Type (Class) Hierarchy                   Change Password
User-defined Data Types                  Create/Delete Function
                                         Create/Delete Object
DBMS FEATURES                            Create/Delete Type
Access Methods on Stored Data            Create/Delete User/Group
Authorization (Security)                 Grant/Revoke
Client/Server                            If/Then/Else, While, For
Clustering                               Implement Function
Compiled Function                        Open/Fetch/Close Cursor
Declarative Query Language (OSQL)        Select
High Availability                        Update
Multimedia
Multiuser Concurrency Control            PRIMITIVE DATA TYPES
Native Language Support                  Binary
Persistence                              Boolean
Primitive Data Types                     Character
Procedural Language                      Date
Recovery                                 Datetime
Referential Integrity                    Decimal
Transaction Management                   Floating Point
                                         Integer
                                         Interval
                                         Long Binary (Large)
                                         Small Integer
                                         Time

                            OpenODB Feature Summary 



HP OpenODB Price Guide

SUMMARY:

   Description                        U.S. List Price

1. Developer's Bundle                         $105,000
2. Evaluator's Bundle                           $5,000
3. Learning Version                            $10,000
4. Training Course                       $2,500/person
5. Consulting                      $3,500/day or Quote
6. Reference Manual                               $250

DETAILED DESCRIPTION:

1. Developer's Bundle

Contents:
A) OpenODB software (1-64 User License for 1 Server Platform)
B) OpenODB documentation
C) 5 passes to the OpenODB Training Course
D) 5 days of on-site consulting
E) Phone and software update support for 6 months

U.S. List Price: $105,000/bundle

Product Numbers:
B2472A (for HP 3000 Series 900 with MPE/iX)

B2468A (for HP 9000 Series 700 with HP-UX)

B2470A (for HP 9000 Series 800 with HP-UX)

Notes:
A) OpenODB documentation includes the OpenODB Reference Manual, ALLBASE/SQL
   Handbook of DBA Tasks, and Up and Running with ALLBASE/SQL.
B) The OpenODB Training Course is delivered in Cupertino, California and takes
   4 days.
C) Consulting is provided at the customer's site with a maximum of two trips.
D) Phone support is provided directly from the HP OpenODB factory consulting
   team in Cupertino, California.  Phone and software update support can be
   purchased at the end of the first 6 months at the rate of $6,900 per year.
E) Volume End User (VEU) and Educational discounts apply to the entire list
   price.
F) The Developer's Bundle is available on HP 3000 Series 900 or HP 9000 Series
   700 and 800 computers.


2. Evaluator's Bundle

Contents:
A) 3 months use of OpenODB software (1-64 User License for 1 Server Platform)
B) OpenODB documentation
C) 1 pass to the OpenODB Training Course
D) Phone support for 3 months

U.S. List Price:  $5,000/bundle

Product Numbers:
B3178A (for HP 9000 Series 700 with HP-UX)

B3179A (for HP 9000 Series 800 with HP-UX)

Notes:
A) The OpenODB software is shipped when the product is ordered.  The OpenODB
   software will stop running 3 months after it is installed.
B) OpenODB documentation includes the OpenODB Reference Manual, ALLBASE/SQL
   Handbook of DBA Tasks, and Up and Running with ALLBASE/SQL.
C) The OpenODB Training Course is delivered in Cupertino, California and takes
   4 days.
D) Phone support is provided directly from the HP OpenODB factory consulting
   team in Cupertino, California.
E) Volume End User and Educational discounts apply to the entire list price.
F) The Evaluator's Bundle is only available on HP 9000 Series 700 or 800
   computers.

3. Learning Version

Contents:
A) OpenODB learning version software (Single User License for 1 Platform)
B) OpenODB documentation

U.S. List Price:  $10,000/license

Product Numbers:
B3181A (for HP 9000 Series 700 with HP-UX)

B3182A (for HP 9000 Series 800 with HP-UX)

Notes:
A) This special single user version is intended for students, researchers, and
   technical evaluators who wish to learn about the Object-oriented SQL (OSQL)
   interface language and OpenODB product.  The learning version software runs
   on one computer for one user application (i.e. no client/server mode).
B) OpenODB documentation includes the OpenODB Reference Manual, ALLBASE/SQL
   Handbook of DBA Tasks, and Up and Running with ALLBASE/SQL.
C) Volume End User and Educational discounts apply to the list price.
D) The Learning Version is available on HP 9000 Series 700 and 800 computers.
E) Phone and software update support for the Learning Version can be
   purchased at the rate of $1,500 per year.


4. OpenODB Training Course

Contents:
A) 1 pass to the OpenODB Training Course
B) OpenODB documentation
C) Class notes and OSQL case study examples

U.S. List Price:  $2,500/person

Product Number:
B3184A

Notes:
A) The OpenODB Training Course is delivered in Cupertino, California and takes
   4 days.
B) OpenODB documentation includes the OpenODB Reference Manual, ALLBASE/SQL
   Handbook of DBA Tasks, and Up and Running with ALLBASE/SQL.
C) The OpenODB Training Course includes hands on experience with the OpenODB
   software through a case study approach.
D) No standard discounts apply.


5. OpenODB Consulting

Contents:
A) 1 person on the customer's site for technical consulting

U.S. List Price:  $3,500/day + zone charge/trip

Product Number:
B3186A

Notes:
A) For details about this consulting, see the OpenODB Consulting Fact Sheet.
B) The zone charges per trip are: $1000 in North America, $2000 in Europe,
   and $3000 in the Far East and South America.

   Consulting that does not require travel will not have a zone charge.
C) Special quotes are available for projects longer than one week.
D) No standard discounts apply.


6. OpenODB Reference Manual

Contents:
A) OpenODB Reference Manual
B) The right to make up to 5 additional copies of the OpenODB Reference Manual
   for internal use only.

U.S. List Price:  $250/manual &#38; right to copy

Product Number:    B3185A

Notes:
A) No standard discounts apply

Mark Boronkay
OpenODB Consultant
boronkay@cup.hp.com



&#62; POET &#60;Persistent Objects and Extended Database Technology&#62;  (BKS Software)

C++ Language Support

o    tight semantic integration with C++
o    any C++ object or structure can be made persistent by adding the 
     persistent keyword
o    storing and reading a C++ object does not change its state or behavior
o    full support for C++ encapsulation, object identity,  inheritance, and 
     polymorphy
o    C++ pointers and references are automatically converted to database 
     references when storing objects
o    database references are automatically converted to C++ pointers and 
     references when reading objects
o    all database definition is done through a small extension to C++ 
     declaration syntax

Database Functionality
navigation, queries, sorting, indexes, single-user operation, multi-user
operation using client/server architecture, flexible locking for objects
and sets, nested transactions, watch &#38; notify for objects and sets,
event handling, database size limited only by hard disk size

C++ Language Extensions
persistence, indexes, transient data elements in persistent classes, sets,
dependent objects

PTXX-Precompiler
automatically converts extended C++ class declarations into ANSI 2.0 code,
registers classes in the class dictionary, provides class versioning

Predefined C++ Classes
date, time, strings, and BLOBS (binary large objects)

Portability
all platforms are source-code compatible, any POET database may be read by
any computer full support for heterogeneous networks

Platforms
Available for MS-DOS / MS-Windows (Borland C++, Microsoft), 
OS/2 (Borland C++), Novell, Macintosh MPW, and various Unix 
systems, including NeXT (NeXTStep) and Sun OS (Sun C++).

How to Contact Us:
BKS has offices in Santa Clara, Hamburg, and Berlin.  Silicon 
River, Limited, is responsible for POET in the United Kingdom.  

Santa Clara:    (North America, Australia, Asia)

BKS Software
4633 Old Ironsides Drive  Suite 110
Santa Clara, CA 95054
Phone:  408 / 748 - 3403
Fax:    408 / 748 - 9060

Contact Person: jrobie@netmbx.netmbx.de (Jonathan Robie)


&#62; Statice (Symbolics)

From: fischerm@darmstadt.gmd.de (Markus Fischer)
Newsgroups: comp.databases.object,comp.lang.lisp
</PRE>
<A NAME=up HREF="faq.html">Go Back Up</A><P>
<A NAME=up HREF="faq-doc-5.html">Go To Previous</A><P>
<A NAME=up HREF="faq-doc-7.html">Go To Next</A><P>
</BODY>
