
<!-- Mirrored from www.cs.cmu.edu/afs/cs/project/ai-repository/ai/html/faqs/lang/oop/faq-doc-30.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 21 Oct 2021 15:06:19 GMT -->
<HEAD>
<TITLE>Comp.Object FAQ Version 1.0.5 (12-13) Announcement - Re: Dynamic Objects</TITLE>
</HEAD>
<BODY>
<H1>Re: Dynamic Objects</H1>
<PRE>
From: gregor@parc.xerox.com (Gregor Kiczales)
In-Reply-To: rjh@geodesic.com's message of 25 Aug 93 21:52:56 GMT
Message-ID: &#60;GREGOR.93Sep3093506@calvin.parc.xerox.com&#62;
Organization: Xerox Palo Alto Research Center
References: &#60;16C357BF0.MFARMER@utcvm.utc.edu&#62; &#60;1993Aug25.215256.8031@midway.uchicago.edu&#62;
Date: 3 Sep 93 09:35:06

Earlier in this series of messages, Craig Chambers and others mentioned
his ECOOP'93 paper on predicate classes, which provide a powerful handle
on some of the problems that have been mentioned in this series of
messages, specifically, how dynamic changes to an object or its context
can be harnessed to reliably effect the object's (message receipt)
behavior.  As I see it, predicate classes are a key step towards solving
one of the most frustrating problems of OO programming: the struggle
over whether to encode some difference among objects in the value of a
slot (that is one of its parts) or in the object's `method table' (class
or that which it is one-of).

A closely related problem, that has also come up in this series of
messages, is how so-called factory objects can dynamically select the
behavior of the objects they create.  We have developed a new OO
language concept called Traces, that can be used to make much more
powerful factory objects, as well as handle some of the things predicate
classes do.  The two ideas are similar in that they both make behavior
selection a much more dynamic phenomena.

My ISOTAS'93 paper presents the concept of Traces and shows it
application to some problems.  This paper is available for anonymous FTP
from ftp.parc.xerox.com, in the /pub/mops directory.  The file is
traces.ps.

Gregor

Following is the abstract from the paper:
  
Object-oriented techniques are a powerful tool for making a system
end-programmer specializable.  But, in cases where the system not only
accepts objects as input, but also creates objects internally,
specialization has been more difficult.  This has been referred to as
the ``make isn't generic problem.''  We present a new \oo{} language
concept, called traces, that we have used successfully to support
specialization in cases that were previously cumbersome.
  
The concept of traces makes a fundamental separation between two kinds
of inheritance in \oo{} languages: inheritance of default implementation
-- an aspect of code sharing; and inheritance of specialization, a
sometimes static, sometimes dynamic phenomenon.


&#62;44 C++ coding standard
</PRE>
<A NAME=up HREF="faq.html">Go Back Up</A><P>
<A NAME=up HREF="faq-doc-29.html">Go To Previous</A><P>
<A NAME=up HREF="faq-doc-31.html">Go To Next</A><P>
</BODY>
