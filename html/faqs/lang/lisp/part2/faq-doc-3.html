
<!-- Mirrored from www.cs.cmu.edu/afs/cs/project/ai-repository/ai/html/faqs/lang/lisp/part2/faq-doc-3.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 22 Oct 2021 05:31:20 GMT -->
<HEAD>
<TITLE>FAQ: Lisp Frequently Asked Questions 2/7 [Monthly posting] - [2-3] What is the equivalent of EXPLODE and IMPLODE in Common Lisp?</TITLE>
</HEAD>
<BODY>
<H1>[2-3] What is the equivalent of EXPLODE and IMPLODE in Common Lisp?</H1>
<PRE>
Hopefully, the only reason you need to do this is as part of trying to port
some old MacLisp code to Common Lisp.  These functions predated the
inclusion of strings as a first-class data type in Lisp; symbols were used
as strings, and they ere EXPLODEd to allow the individual characters to be
manipulated in a list.

Probably the best approximations of these are:

   (defun explode (object)
     (loop for char across (prin1-to-string object)
           collect (intern (string char))))

   (defun implode (list)
     (read-from-string (coerce (mapcar #'character list) 'string)))

An alternate definition of EXPLODE which uses MAP instead of LOOP is:

   (defun explode (object)
     (map 'list #'(lambda (char) 
                    (intern (string char)))
          (prin1-to-string object)))

The creation of N conses of garbage to process a string of N
characters is a hideously inefficient way of doing the job.  Rewrite
EXPLODE code with PRIN1-TO-STRING, or better STRING if the arguments
are symbols without funny characters.  For IMPLODE, try to make its
caller use strings and try to make the result usable as a string to
avoid having to call INTERN or READ-FROM-STRING.
</PRE>
<A NAME=up HREF="faq.html">Go Back Up</A><P>
<A NAME=up HREF="faq-doc-2.html">Go To Previous</A><P>
<A NAME=up HREF="faq-doc-4.html">Go To Next</A><P>
</BODY>
