
<!-- Mirrored from www.cs.cmu.edu/afs/cs/project/ai-repository/ai/html/faqs/ai/constraints/part2/faq-doc-3.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 22 Oct 2021 05:30:33 GMT -->
<HEAD>
<TITLE>comp.constraints FAQ 2/2 Frequently Asked Questions [Monthly posting] - [2-3] Free and Commercial Constraint Systems</TITLE>
</HEAD>
<BODY>
<H1>[2-3] Free and Commercial Constraint Systems</H1>
<PRE>

See the comp.lang.prolog, comp.lang.lisp, comp.ai and comp.lang.scheme
FAQs and Resource Guides for possibly more up-to-date and complete
information.

Note on costs: there is a difference between FREE software (which may
have restrictions attached), Public Domain software (FREE-PD), CHEAP
software (arbitrarily and approximately: less than 100 pounds or 200
dollars or 300 deutschmarks), shareware (CHEAP-SH), and software which
is COMMERCIAL [to avoid calling it non-cheap or expensive]. Some
software may not be available for commercial use, although commercial
enterprises may be able to use it for their own research. These are
labelled C=N/A. Costs may also vary depending on whether the customer
is (A) academic, (E) Eastern European, or (C) a commercial enterprise.
So each section here will have a header of the following form:
[COST A=CHEAP,E=FREE,C=PRICE]. If something has the same cost for all
groups, I abbreviate the entry to e.g. [COST FREE-PD].

Warning: there is no guarantee that this information is correct and it
should not be treated as implying some kind of contract either on my
part (FAQ maintainer) or on the part of the supplier. Please notify me
of errors.

   AKL:					[COST A=E=FREE,C=N/A]
AKL (previously Andorra Kernel Language, now Agent Kernel Language) is
a concurrent constraint programming language that supports both
Prolog-style programming and committed choice programming. Its control
of don't-know nondeterminism is based on the Andorra model, which has
been generalised to also deal with nondeterminism encapsulated in
guards and aggregates (such as bagof) in a concurrent setting. See, for
example,

 Sverker Janson and Seif Haridi, "Programming Paradigms of the Andorra
 Kernel Language", in Proceedings of ILPS'91. MIT Press, 1991.

 Torkel Franzen, "Logical Aspects of the Andorra Kernel Language", SICS
 Research Report R91:12, Swedish Institute of Computer Science, 1991.

 Torkel Franzen, Seif Haridi, and Sverker Janson, "An Overview of the
 Andorra Kernel Language", In LNAI (LNCS) 596, Springer-Verlag, 1992.

 Sverker Janson, Johan Montelius, and Seif Haridi, "Ports for Objects
 in Concurrent Logic Programs", in Research Directions in Concurrent
 Object-Oriented Programming, MIT Press, 1993 (forthcoming).

The above papers on AKL are available from &#60;<A NAME=id3 HREF="ftp://<a name=id4 href=/"ftp://sics.se/pub/ccp/papers&#62;</A>">sics.se:/pub/ccp/papers&#62;">ftp://<A NAME=id5 HREF="ftp://sics.se/pub/ccp/papers></A></A>">sics.se:/pub/ccp/papers&#62;</A></A></A>.
An (as yet non-released) prototype implementation of AKL is available
for research purposes (contact sverker@sics.se).

   ALE:					[COST FREE-PD]
ALE (Attribute Logic Engine), a public domain system written in
Prolog, integrates phrase structure parsing and constraint logic
programming with typed feature structures as terms. Types are arranged
in an inheritance hierarchy and specified for the features and value
types for which they are appropriate. Grammars may also interleave
unification steps with logic program goal calls (as can be done in
DCGs), thus allowing parsing to be interleaved with other system
components. While ALE was developed to handle HPSG grammars, it can
also execute PATR-II grammars, DCG grammars, Prolog, Prolog-II, and
LOGIN programs, etc. Grammars and programs are specified with a version
of Rounds-Kasper Attribute Value Logic with macros and variables. ALE
supports lexical rules and empty categories for grammars, using a
bottom-up, breadth-first dynamic chart parser. ALE supports last call
optimization, negation by failure and cuts in definite clauses, which
may be used independently or integrated into grammars. The system is
available free for research purposes, from Bob Carpenter
&#60;carp@lcl.cmu.edu&#62;.

   BERTRAND:				[COST CHEAP-SH]
Bertrand is the language described by Leler in his book (see section
[1-6]). See [1-5] PTF for more details.

   BULL SOLVER:				[COST COMMERCIAL]
See ILOG SOLVER.

   CFSQP:				[COST A=E=FREE,C=FREEish]
See FSQP.

   CHARME:				[COST COMMERCIAL]
CHARME was a commercial product from Bull. The latest version is called
BULL SOLVER, but see also ILOG SOLVER.

   CHIP:				[COST COMMERCIAL]
CHIP V4 (Constraint Handling In Prolog) is designed as an extension to
Prolog offering three constraint solving domains: Integers, Rationals
and Booleans. The system was originally developed at ECRC in Munich and
now extended by the same team at COSYTEC in Paris. CHIP V4 includes
extensions to the three domains: symbolic constraints, update demons
and cumulative constraints. The system is available with optional
interfaces for X11 and DOS graphics (XGIP), Oracle or Ingres database
connection (QUIC), C language interface (CLIC) and embedded application
interface (EMC). CHIP V4 is written completely in C, and is available
on a range of workstations including SunSparc IBM RS6000, HP 9000/700,
Decstations and PC386/486 (Dos 5.0). An academic discount is offered
for educational and research purposes. For more information contact
COSYTEC, Parc Club Orsay Universite 4 rue Jean Rostand, 91893 Orsay
Cedex, France, phone +33-1-60-19-37-38, fax +33-1-60-19-36-20 or email
&#60;cosytec@cosytec.fr&#62;.

   CHR:					[COST FREE with ECLIPSE]
Constraint Handling Rules (CHRs) is a library of ECLiPSe [see separate
entry] for writing custom constraint systems in a high-level language.
CHRs is essentially a committed-choice language consisting of guarded
rules that rewrite constraints into simpler ones until they are
solved. The usual formalisms to describe a constraint theory, i.e.
inference rules, rewrite rules, sequents, first-order axioms, can be
expressed as CHR programs in a straightforward way. The CHR release
includes a full colour demo involving geometric constraints, a compiler
(into ECLiPSe), two debuggers, a runtime system and 18 constraint
solvers. There are solvers for lists, sets, trees, terms, finite and
infinite domains, booleans, linear polynomials over reals and
rationals, for incremental path consistency, and for terminological and
temporal reasoning. CHR documentation is available by anonymous ftp
from <A NAME=id6 HREF="ftp://ftp.ecrc.de/pub/eclipse/doc">ftp.ecrc.de:/pub/eclipse/doc</A> in the extensions-manual. You can
also ftp a technical report describing constraint handling rules (file
ECRC-92-18.ps.Z in directory pub/ECRC_tech_reports/reports) and their
application to temporal and terminological reasoning (files
ECRC-94-05.ps.Z and ECRC-94-06.ps.Z). For more information on CHRs
contact Thom Fruehwirth (thom@ecrc.de).

   CIAL 1.0 (Beta)			[COST FREE]
CIAL is an interval constraint logic programming language. The main
difference between CIAL and other CLP(Interval) languages is that a
linear constraint solver, which is based on preconditioned interval
Gauss-Seidel method, is embedded in CIAL in addition to the interval
narrowing solver. The main motivations for a linear solver are:
* Pure interval narrowing fails to narrow the intervals to any useful
  width even for such simple systems as {X+Y=5, X-Y=6}. Interval
  splitting may help but is costly.
* Pure interval narrowing cannot always detect inconsistency or halt
  (in a reasonable time). A simple example is {A+1=D, A+B=D, A&#62;0, B&#60;0}.
* Efficient linear constraint solver is also important to the study of
  efficient non-linear constraint-solving. Recent results show that
  interval Newton method works better than pure interval narrowing for
  solving non-linear constraints, but may require to solve many linear
  constraints in order to give the best results.
This version of CIAL prototype is implemented as an extension to CLP(R)
v1.2 and tested on Sun Sparc machines. You should have obtained CLP(R)
from IBM prior to installing CIAL. Our distribution is in the form of
patches to the CLP(R) sources. [See entry on CLP(R) below].

E-mail cial@cs.cuhk.hk to request CIAL, and for more details.

[FAQ maintainer's note: I have deleted most of the references provided,
for space reasons, if they are in well-known journals and conferences;
the CIAL team have not simply cited only their own work. MBJ.]

C.K. Chiu and J.H.M. Lee. Towards practical interval constraint solving
in logic programming. (To appear) In Proceedings of the Eleventh
International Logic Programming Symposium, Ithaca, USA, Nov.1994.

J.H.M. Lee and T.W. Lee. A WAM-based abstract machine for interval
constraint logic programming and the multiple-trailing problem.
Proceedings Sixth IEEE International Conference on Tools with
Artificial Intelligence, New Orleans, Nov 1994.


   CLP(BNR):				[COST ???]
CLP(BNR) [Constraint Logic Programming with Booleans Naturals and
Reals] is an experimental CLP Language developed at the Bell-Northern
Research Computing Research Lab. CLP(BNR) is a Prolog-based language
that incorporates an arc-consistency propagation algorithm on
interval-bounded constraints which handles general algebraic
constraints over continuous, integer and boolean variables. This allows
programmers to express systems of non-linear equations on real
intervals that can be arbitrarily mixed with integer and boolean
constraints equations. For more information on CLP(BNR) contact
Andre' Vellino &#60;vellino@bnr.ca&#62; (613)763-7513, fax (613)763-4222
Bell-Northern Research, Box 3511, Station C, Ottawa, CANADA K1Y 4H7
See also section [1-6] for papers by Benhamou/ Older/ Vellino.

   CLP(F):		NON-LINEAR	[unavailable]
This extension of CLP(Intervals) has an underlying domain that consists
of boolean, integers, reals, real-valued functions of one variable, and
vectors of domain elements. Function variables are constrained by
functional equations and by putting interval constraints on the values
of their derivatives at points and intervals. The system can be used to
solve constraint problems involving ordinary differential equations.
Contact Tim Hickey &#60;tim@cs.brandeis.edu&#62;

Reference:
[1] T. Hickey. CLP(F) and Constrained ODE's, T. Proceedings of the 1994
Workshop on Constraints and Modelling, Ithica, NY, November, 1994.
Available at: <A NAME=id7 HREF="ftp://ftp.ecrc.de/pub/faculty/tim/Papers/islp94.ps">ftp://ftp.ecrc.de/pub/faculty/tim/Papers/islp94.ps</A>

   CLP(FD):				[COST FREE]
CLP(FD) 2.2 is a constraint logic programming language over Finite
Domains. It is based on the wamcc Prolog compiler which translates
Prolog to C. It provides several constraints "a la CHIP" on Finite
Domains and Booleans and some facilities to build new constraints.
clp(FD) is 4 times faster than CHIP v3.2 on average.  Available from
 <A NAME=id8 HREF="ftp://ftp.inria.fr/INRIA/Projects/ChLoE/LOGIC_PROGRAMMING/clp_fd">ftp.inria.fr:/INRIA/Projects/ChLoE/LOGIC_PROGRAMMING/clp_fd</A>
Requires GNU C (gcc) version 2.4.5 or higher. Ported to Sparc
workstations, PC under linux, sony mews, dec ultrix, portable generally
to 32-bit machines with gcc. See also under WAMCC, below. For more
details, contact the author Daniel Diaz &#60;Daniel.Diaz@inria.fr&#62; INRIA
Rocquencourt, FRANCE.

   CLP(R):				[COST A=FREE,E=FREE,C=N/A]
					[Commercial users: see next section]
CLP(R) is a constraint logic programming language with real-arithmetic
constraints. The implementation contains a built-in constraint solver
which deals with linear arithmetic and contains a mechanism for
delaying nonlinear constraints until they become linear. Since CLP(R)
subsumes PROLOG, the system is also usable as a general-purpose logic
programming language. It includes facilities for meta-programming with
constraints. The system consists of a compiler, byte-code emulator,
and constraint solver. CLP(R) is written entirely in C and runs on
Suns, Vaxen, MIPS-based machines (Decstations, Silicon Graphics), IBM
RS6000s and PS2s. Includes MS-DOS support. It is available free from
IBM for academic and research purposes only. For more information,
write to Joxan Jaffar, H1-D48, IBM Thomas J. Watson Research Center,
P.O. Box 704, Yorktown Heights, NY 10598, or send email to
joxan@watson.ibm.com or joxan@yktvmh.bitnet. Current version 1.2.

   CLP(R):				[COST CHEAP]
CLP(R) is a constraint system from Monash University for VAX, Sun, and
Pyramid (Unix). Costs $150. For more information, write to Monash
University, CLP(R) Distribution, Department of Computer Science,
Clayton, Victoria 3168, Australia, or send email to
clp@moncsbruce.oz.au. [Although the system is still available, it has
not been maintained or supported for about 5 years, and it will remain
that way.]

   COOLDRAW:				[COST FREE-PD]
A constraint-based drawing package from the same stable as ThingLabII.
See information on the Seattle ftp site in section [1-5].

   CONTAX:				[COST FREE-PD]
Public domain constraint system written by Manfred Meyer
&#60;meyer@dfki.uni-kl.de&#62;. [More details soon.]

   CU-PROLOG:				[COST FREE]
cu-Prolog is an experimental constraint logic programming language
available free from Japan's Institute for New Generation Computer
Technology (ICOT). Unlike most conventional CLP systems, cu-Prolog
allows user-defined predicates as constraints and is suitable for
implementing a natural language processing system based on the
unification-based grammar. For example, the cu-Prolog developers
implemented a JPSG (Japanese Phrase Structure Grammar) parser in
cu-Prolog with the JPSG Working Group (the chairman is Prof. GUNJI,
Takao of Osaka University) at ICOT. cu-Prolog is a complete
implementation of Constraint Unification (cu), hence the name.
cu-Prolog is implemented in C for BSD UNIX 4.2/3. Professor Sirai of
Chukyo-University has also implemented cu-Prolog for the Apple
Macintosh and DJ's GPP (80386/486 MS-DOS machine with the DOS
extender). Available free by anonymous ftp: see section [1-5].

   DELTABLUE:				[COST FREE-PD]
A constraint-solving algorithm. See information on the Seattle ftp site
in section [1-5]. See paper by Freeman-Benson et al in section [1-6].

   ECHIDNA:				[COST FREE]
Echidna is an object oriented constraint logic programming language
developed by the Intelligent Systems Lab at Simon Fraser University
between 1990 and 1993. Constraints in Echidna include finite domain
constraints (as in CHIP) and disjoint real interval domain constraints.
Real domains are implemented by interval hierarchies which allow for
the representation of domains with disjoint sets of intervals.
Hierarchical domains also allow control of the precision of constraint
processing. Since complete search procedures exist for all levels of
precision, it is possible to quickly search through regions with no
solutions at low precision. Where low precision constraint processing
indicates a possible solution, precision can be increased to ensure
convergence on a real solution.
Echidna supports a form of incremental intelligent backtracking for
multiple user queries which provides an effective interactive
mixed-initiative control regime. Users can issue and selectively
retract queries to arrive at a solution to their problem.
Development and support for Echidna v1.0 were halted in 1993. For more
information, go to &#60;<A NAME=id9 HREF="http://fas.sfu.ca/cs/research/groups/ISL/>">http://fas.sfu.ca/cs/research/groups/ISL/&#62;</A> or
&#60;<A NAME=id10 HREF="ftp://ftp.fas.sfu.ca/pub/css/esl/echidna>">ftp://ftp.fas.sfu.ca/pub/css/esl/echidna&#62;</A> or contact Bill Havens
&#60;havens@cs.sfu.ca&#62;. See:

[1] W.S. Havens: Intelligent Backtracking in the Echidna CLP Reasoning
System, International Journal of Expert Systems: Research and
Applications 5(4), 1992, M. Harandi (ed.), Jai Press, London, 21-45.

[2] Greg Sidebottom and W.S. Havens: Hierarchical Arc Consistency for
Disjoint Real Intervals in Constraint Logic Programming. Computational
Intelligence 8(4), 1992. 601-623. Also available as
&#60;<A NAME=id11 HREF="ftp://ftp.fas.sfu.ca/pub/cs/theses/1993/GregSidebottomMSc.ps>">ftp://ftp.fas.sfu.ca/pub/cs/theses/1993/GregSidebottomMSc.ps&#62;</A>.

   ECLIPSE:				[COST A=FREE,E=FREE,C=see below]
ECLiPSe (ECRC Logic Programming System) combines the functionalities of
several ECRC systems, including Sepia, MegaLog and CHIP. ECLiPSe
includes a Prolog compiler with extended functionality that is Quintus
and SICStus compatible, a tightly connected database system based on
the BANG file system, a CLP system, and an interface to the Tcl/Tk X11
toolkit. The BANG database can store not only relations, but also any
Prolog structures and programs. The CLP system contains several
libraries with various types of constraint handling schemes, including
atomic finite domains, linear rational constraints, CHR (constraint
handling rules) and Propia (generalised propagation). See also the
separate entry for CHR.] It also supports writing further extensions
like new user-defined constraints or complete new constraint solvers.
ECLiPSe also includes a profiler, user-definable syntax, metaterms as
first-class citizens, coroutining, and unlimited precision integer and
rational numbers. ECLiPSe is available free of charge for all academic
and government-sponsored organizations. Commercial users may obtain
ECliPSe for DM 7000, but for research purposes only. It is distributed
in binary form for Sun-3, Sparc, and many other types of machine. Send
orders or requests for further information to eclipse_request@ecrc.de
or write to ECRC, Arabellastrasse 17, 81925 Munich, Germany. The
ECLiPSe documentation (ASCII and dvi) and some shareware packages
ported to ECliPSe are now available on WWW at URL
&#60;<A NAME=id12 HREF="http://www.ecrc.de/eclipse/eclipse.html>">http://www.ecrc.de/eclipse/eclipse.html&#62;</A> and also by anonymous ftp
from <A NAME=id13 HREF="ftp://ecrc.de/pub/eclipse">ecrc.de:/pub/eclipse</A>. To subscribe to the eclipse_users@ecrc.de
mailing list, send mail to eclipse_request@ecrc.de.

   ECRC SEPIA:				[COST FREE with ECLIPSE]
See ECLIPSE. SEPIA is no longer delivered as a stand-alone system, but
as a part of ECLiPSe.

   FSQP/CFSQP:				[COST A=E=FREE,C=FREEish]
FSQP (Feasible SQP; FORTRAN; developed by J.L. Zhou and A.L. Tits) and
CFSQP (C version of same, with enhancements; port and enhancements due
to C.T. Lawrence) are software packages aimed at solving constrained
optimization problems, including constrained minimax problems (where
the max is taken over a finite number of smooth functions). (C)FSQP's
main distinguishing feature is that all the iterates it generates
satisfy the constraints, except for nonlinear equality constraints, for
which mere "semi-feasibility" is maintained (given a scalar constraint
h(x)=0, if h(x0)&#60;=0 (resp. &#62;=0), then h(xk)&#60;=0 (resp. &#62;=0) for all k.)
This is of value in many engineering related problems. Extensive
numerical tests show that FSQP's efficiency is comparable to that of
the most popular (non-"feasible") codes. Detailed User's Manuals are
available. (C)FSQP is available free of charge to academic and other
non-profit organizations (as well as, for an evaluation period, to
for-profit organizations) but may not be redistributed without the
authors' approval. To obtain FSQP or CFSQP, please contact Andre Tits
(andre@eng.umd.edu).

   GARNET:				[COST FREE]
The Garnet system is a fully functional user interface development
environment and toolkit implemented on top of a comprehensive one-way
constraint system. It is in CommonLisp for X/11. All widgets and other
user interface elements are implemented using the constraint. The
constraints are implemented as part of the object system, and the
object system with constraints can be used independently of the
user-interface components, if desired. Garnet is available for free by
anonymous FTP from a.gp.cs.cmu.edu (128.2.242.7). Retrieve
/usr/garnet/garnet/README. More information on Garnet is available from
<A NAME=id14 HREF="http://www.cs.cmu.edu:8001/Web/Groups/garnet/garnet-home.html">http://www.cs.cmu.edu:8001/Web/Groups/garnet/garnet-home.html</A> or in the
newsgroup comp.windows.garnet or e-mail garnet@cs.cmu.edu. See also [1-5]
PTF for more details. See also Multi-GArnet, below.

   GOEDEL:				[COST FREE]
Goedel is intended to be a declarative successor to Prolog.
It is defined as supporting certain constraint domains, but these are
not yet implemented. See the comp.lang.prolog FAQ for more details.

   ICOT language CU-PROLOG:
See entry CU-PROLOG.

   ICOT language CAL in ESP:		[COST FREE]
To execute this system, SIMPOS Ver.7 must be running on your PSI.
CAL is a sequential constraint logic programming language which can
deal with various constraints including non-linear polynomial
equations.
In the CAL system, you can use Context. A context is a constraint set.
A new context is created whenever the constraint set is changed. The
history of changing contexts is manipulated by the Context Tree, and
Current Context is the target of the context manipulation. You can
set a context on the context tree arbitrarily as the current context.
Functions include finding real roots:
The query "find" computes real roots of the univariate equations
and returns one solution. The user can obtain other solutions by
backtrack, and branches of the context tree are created.
The CAL system has 4 constraint solvers,
 (1) Algebraic constraint solver
 (2) Boolean constraint solver
 (3) Linear constraint solver
 (4) Set constraint solver
Available free by anonymous ftp: see section [1-5].

 A. Aiba, K. Sakai, Y. Sato, D. J. Hawley, and R. Hasegawa:
 Constraint Logic Programming Language CAL. In Proceedings of the
 International Conference on Fifth Generation Computer Systems 1988,
 November 1988.

 Contrainte Avec Logique version 2.12 User's manual
 Institute for New Generation Computer Technology,
 in preparation.

   ICOT language CAL Common ESP version written in CESP:   [COST FREE]
Same as CAL in ESP, but can run on Unix, needing: UNIX machine, Emacs
CESP, C language compiler, GNU MP, 50Mbyte disk, 16Mbyte memory
Available free by anonymous ftp: see section [1-5].


   CAL:		NON-LINEAR
CAL was developed at ICOT (Institute for New Generation Computer
Technology) in a Japanese national project, Fifth Generation Computer
Project. CAL utilizes Buchberger algorithm to deal with linear and
non-linear algebraic equation constraints. See previous entries for more
details or contact Akira Aiba &#60;aiba@icot.or.jp&#62;

References:
[1] Ko Sakai, Akira Aiba. CAL : A Theoretical Background of Constraint
Logic Programming and Its Application. Journal of Symbolic Computation
(1989) 8, pp. 589 -- 603


   ICOT language Hierarchical CLP Language CHAL:	[COST FREE]
You need the SIMPOS/ESP environment to run CHAL.
Hierarchical Constraint Logic Programming Language: CHAL A hierarchical
constraint logic programming language processor which introduces
hierarchy in terms of strength of constraints.  Hierarchical constraint
logic programming language CHAL consists of constraint hierarchy solver
which manipulates various strength of constraints in various domains
and constraint language processor.
An Extension of Constraint Logic Programming Language Usual constraint
logic programming languages output nothing if there is no solution for
given constraints. On the other hand, by introducing hierarchy of
strength in constraints, CHAL ignores some weak constraints in order to
output some better solutions. This function is important in planning
and design problems.
Available free by anonymous ftp: see section [1-5].

   ICOT language PCHAL:			[COST FREE]
Hierarchical Constraint Parallel Solver: P-CHAL
Similar to CHAL, above.
Parallel Solving of Constraint Hierarchy: P-CHAL reduces computational
costs by a bottom-up calculation of maximal consistent sets and
parallel processing of GDCC.
Available free by anonymous ftp: see section [1-5].

   ICOT language Knowledge Representation Language Quixote: [COST FREE]
Main documentation in Japanese.
Quixote is a DOOD (Deductive Object-Oriented Database) system
developed at ICOT. The following are outstanding Quixote features.
1. Object identity defined over extended terms (object terms).
2. Constraints in terms of subsumption relation among object terms.
3. Property inheritance among objects.
4. Modularized and hierarchical knowledge bases defined by modules
and rule inheritance between them.
5. Queries having additional assertions to knowledge bases, and
answers with assumed constraints.
Available free by anonymous ftp: see section [1-5].

Kazumasa Yokota, Deductive Object-Oriented Databases, Computer
Software, Vol.9, No.4, pp3--18, 1992 (in Japanese).

Hideki Yasukawa, Hiroshi Tsuda, and Kazumasa Yokota,
Object, Properties, and Modules in QUIXOTE,
Proc. of FGCS92, pp257--268, 1992.

Quixote Ver.III consists of (1) Quixote client on UNIX with C,
X-Window(X11R5), and GNU-Emacs, and (2) Quixote server on PIM/PIMOS
with KL1. Both UNIX workstation (such as SS2) and PIM/PSI are required
to run this version of Quixote.

   ICOT language Micro Quixote (Version 0.5):		[COST FREE]
Micro Quixote is another implementation of the language Quixote. It is
implemented with C. It eliminates many features of Quixote, and only
implements core feature of Quixote. However, it's small, and easy to
install. And more, it is expected that Micro Quixote could run on other
operating systems apart from Unix.
Available free by anonymous ftp: see section [1-5].

   ICOT language GDCC (Guarded Definite Clauses with Constraints):
					[COST FREE]
GDCC is the parallel constraint logic programming experimental system.
GDCC has been developed on PIMOS and runs only on PIMOS. Therefore,
PIMOS needs to be installed on your machine before GDCC is installed.
Includes linear constraints, boolean constraints, and the find utility
(Algebraic constraint solver) which is used to find approximate real
roots from the results of solving algebraic constraints.
Available free by anonymous ftp: see section [1-5].

   GDCC:	NON-LINEAR
GDCC was developed at ICOT in a Japanese national project, Fifth
Generation Computer Project. GDCC utilizes Buchberger algorithm to
deal with linear and non-linear algebraic equation constraints.
Different from CAL, GDCC is a parallel CLP language based on cc
paradigm. There are two versions of GDCC, one is a system written in
KL1, a parallel logic programming language, that runs on a parallel
inference machine called PIM developed in the project, and the other
is a system written in KLIC that is a KL1 language processor for UNIX
workstations. See previous entry or contact Akira Aiba &#60;aiba@icot.or.jp&#62;

References:
[1] Satoshi Terasaki, David J. Hawley, Hiroyuki Sawada, Ken Satoh,
Satoshi Menju, Tarou Kawagishi, Noboru Iwayama, and Akira Aiba.
Parallel Constraint Logic Programming Language GDCC and Its Parallel
Constraint Solvers. International Conference on Fifth Generation
Computer Systems 1922, Tokyo

[2] Hiroyuki Sawada, Satoshi Terasaki, and Akira Aiba. Parallel
Computation of Groebner Bases on Distributed Memory Machines. Journal
of Symbolic Computation, Vol.18, No.3, pp.207--222, September 1994.


   IF/Prolog 5.0			[COST COMMERCIAL]
IF/Prolog 5.0 is a full ISO-compliant Prolog which incorporates
constraint solving technology. IF/Prolog is available on ALL UNIX
systems, VMS, OSF/1, MS-Windows and Mainframes. Constraint domains
include Boolean constraints, Rational terms, Linear terms, Equations
and Inequations, Finite Domain Constraints and Co-routines. Interfaces
to standard software packages and other programming languages including
C, C++ and FORTRAN, SQL (Ingres, Oracle and Informix) and X11 (Motif
and Athena widgetsets). IF/Prolog has full screen X11 and Windows based
debuggers and online hypertext help and quick reference guide.
IF/Prolog 5.0 is available on ALL UNIX, OSF/1, VMS and MS-Windows, OS/2
platforms. There is a 50% accademic discount and demo licences are
avilaible. Further information contact: Annette Kolb (marketing) or
Dr. Andrew Verden (technical) at IF Computer GmbH, Ludwig-Thoma-Weg
11a, D-82065 Baierbrunn, tel +49 89 7936 0037, fax +49 89 7936 0039.
E-mail prolog@mch.sni.de

   ILOG SCHEDULE:			[COST COMMERCIAL]
ILOG SCHEDULE is an add-on to ILOG SOLVER, used to develop finite
capacity scheduling applications. ILOG SCHEDULE includes a natural
object model for representing schedules in terms of activities and
resources used and shared by these activities. Three categories of
constraints are predefined:
 - TEMPORAL CONSTRAINTS. Users may link any two activities together
   by any type of precedence constraint. Minimum and maximum delays
   between activities can be imposed.
 - CAPACITY CONSTRAINTS. Unary resources represent resources of
   capacity one. Volumetric resources represent resource pools of
   non-differentiated resources. State resources represent situations
   where an activity uses a resource only under specific conditions.
   The capacity of a resource can be constrained either at each time
   unit or over given time periods.
 - RESOURCE UTILIZATION CONSTRAINTS. An activity may require, consume,
   provide and produce resources, in an amount represented either
   as a constant or as an ILOG SOLVER variable. This allows the
   representation of the case where the duration of the activity
   varies with the amount of resources assigned to the activity.
ILOG SCHEDULE is available on the same platforms as ILOG SOLVER. For
further information and contact addresses, see entry on ILOG SOLVER.

   ILOG SOLVER:				[COST COMMERCIAL]
[Ilog and Bull have agreed to sell the same thing under different
names. Charme Object and Ilog Solver have been merged. M Jampel.]
ILOG SOLVER (formerly called PECOS) is a highly efficient C++ class
library that implements constraint programming. SOLVER has been used
to develop fielded applications handling large problems in areas such
as job shop scheduling, timetabling, configuration, transport,
logistic planning, network routing, and frequency allocation.
SOLVER implements integer variables, floating point variables, Boolean
variables, and set variables. Constraints include =, &#60;=, &#62;=, &#60;, &#62;, +,
-, *, /, subset, superset, union, intersection, member, Boolean or,
Boolean and, Boolean not, Boolean xor, cardinality, element, generic
constraints, and meta constraints (conjunction and disjunction of
constraints, order among constraints). Non-linear constraints can be
solver by interval approximation methods. You can add new constraints
to SOLVER by deriving new C++ classes. SOLVER provides a backtracking
search and a branch-and-bound algorithm together with a large number of
search strategies. SOLVER also provides C++ classes and functions that
implement non-deterministic programming.
SOLVER is available on most Unix platforms and on MS-Windows. For
further information, please contact:
- In the USA and Canada:        - Outside the USA:
  ILOG, Inc.                      ILOG SA
  2005 Landings Drive             9, rue de Verdun, BP 85,
  Mountain View, CA 94303.        94253 Gentilly Cedex, France
  Phone: +415 390-9000            Phone: +33 1 4908 3500
  e-mail: info@ilog.com           e-mail: info@ilog.fr
  URL: http://www.ilog.com        URL: http://www.ilog.fr

   LIFE:				[COST FREE]
LIFE (Logic, Inheritance, Functions, and Equations) is an experimental
programming language with a powerful facility for structured type
inheritance. It reconciles styles from functional programming, logic
programming, and object-oriented programming. It subsumes the
functionality of its precursor languages LOGIN and Le_Fun, and may be
seen as an extension of Prolog. The syntax of Wild_LIFE has been kept
as close as possible to that of the Edinburgh standard for Prolog.
LIFE offers natively high-level abstraction facilities and convenient
data and control structures particularly well-suited for AI
programming. LIFE implements a constraint logic programming language
with equality (unification) and entailment (matching) constraints over
order-sorted feature terms. The interplay of unification and matching
provides an implicit coroutining facility thanks to an automatic
suspension mechanism. This allows interleaving interpretation of
relational and functional expressions which specify structural
dependencies on objects. The Wild_LIFE interpreter is the first
implementation of the LIFE language available to the general public.
It is a product of the Paradise project at Digital Equipment
Corporation's Paris Research Laboratory (DEC PRL). Wild_LIFE runs on
DECstations (Ultrix), SparcStations and RS/6000 systems and should be
portable to other Unix workstations. It is implemented in C, and
includes an interface to X Windows. Wild_LIFE is available by anonymous
ftp from <A NAME=id15 HREF="ftp://gatekeeper.dec.com/pub/plan">gatekeeper.dec.com:/pub/plan</A> as the file Life.tar.Z. To be
added to the mailing list (life-users@prl.dec.com), send mail to
life-request@prl.dec.com. Send bug reports to life-bugs@prl.dec.com.
See also [1-5] PTF for more details.

   NEWTON:		NON-LINEAR	[unavailable]
The constraint group at Brown University has developed a CLP language
called Newton to solve
 - systems of nonlinear equations and inequalities
 - unconstrained optimization
 - constrained optimization
The language uses interval arithmetic and is based on a box-consistency
on various interval extensions. It is competitive with continuation
methods on their benchmarks, outperforms all interval methods we know
of, and has solved traditional benchmarks from numerical analysis
containing hundreds of variables. Contact Pascal Van Hentenryck
&#60;pvh@cs.brown.edu&#62;

References:
[1] F. Benhamou, D. McAllister, P. Van Hentenryck. CLP(Interval)
Revisited, in ILPS'94, Ithaca, NY, November 1994.

[2] P. Van Hentenryck, D. McAllister, D. Kapur. Solving Polynomial
System using A branch and Prune Approach. Forthcoming.

[3] P. Van Hentenryck, L. Michel. The Design and Implementation of
Newton. In CCP'95, Venice, Italy, May 1995.


   NICOLOG:				[COST FREE]
Nicolog is a CLP language with the capabilities of CLP(BNR) and most
of the capabilities of cc(FD). Constraints in Nicolog are compiled
into a generalization the indexical constraints found in cc(FD) and
clp(FD). This generalization of indexical constraints is called
projection constraints. Projection constraints add conditional
operators which allow the implementation of the cardinality, blocking
implication, and constructive disjunction constraints found in cc(FD).
Nicolog has a very simple implementation (5000 lines of Prolog for the
compiler and 5000 lines of C++ for the extended WAM emulator) and yet
runs as fast as emulator based CLP languages such as cc(FD) and CLP(BNR).
Moreover, the possibility of programming directly in projection
constraints makes Nicolog more flexible than other CLP systems. For
more information, go to &#60;<A NAME=id16 HREF="http://fas.sfu.ca/cs/research/groups/ISL/>">http://fas.sfu.ca/cs/research/groups/ISL/&#62;</A> or
&#60;<A NAME=id17 HREF="ftp://ftp.fas.sfu.ca/pub/css/esl/nicolog>">ftp://ftp.fas.sfu.ca/pub/css/esl/nicolog&#62;</A> or contact Greg Sidebottom
&#60;gsidebot@mprgate.mpr.ca&#62; or see
&#60;<A NAME=id18 HREF="ftp://ftp.fas.sfu.ca/pub/cs/theses/1993/GregSidebottomPhD.ps>">ftp://ftp.fas.sfu.ca/pub/cs/theses/1993/GregSidebottomPhD.ps&#62;</A>.

   OPBDP:				[COST FREE]
opbdp is an implicit enumeration algorithm for solving linear 0-1
optimization problems, including a bunch of heuristics for selecting a
branching literal.  Several preprocessing techniques (coefficient
reduction, fixing, equation detection). Preprocessed problem can
written to a file readable by CPLEX and lp_solve. Technical report
included. If your favorite linear-programming based solver fails on
your problem you might give opbdp a chance. Needs a C++ compiler which
supports templates. Contact Peter Barth (barth@mpi-sb.mpg.de).
<A NAME=id19 HREF="ftp://ftp.mpi-sb.mpg.de/pub/guide/staff/barth/opbdp/">ftp://ftp.mpi-sb.mpg.de/pub/guide/staff/barth/opbdp/</A>
<A NAME=id20 HREF="http://www.mpi-sb.mpg.de/~barth">http://www.mpi-sb.mpg.de/~barth</A>

   OMEGA:				[COST FREE]
Version 0.90 of the Omega Calculator and Omega Library is now
available, including source code. The Omega library/calculator
manipulates sets of integer tuples and relations between integer
tuples. Some examples include:

{ [i,j] : 1 &#60;= i,j &#60;= 10};
{ [i] -&#62;[i,j] : 1 &#60;= i &#60; j &#60;= 10};
{ [i,j] -&#62;[j,j'] : 1 &#60;= i &#60; j &#60; j' &#60;= n};

The conditions describing a set or tuple can be an formulas can
described by an arbitrary Presburger formula. Relations and sets can be
combined using functions such as composition, intersection, union and
difference. It also provides routines to generate code to iterate over
the points in an integer tuple set. The Omega library provides a
high-level, C++ interface to our routines. The Omega calculator is a
text-based interface to the Omega library. Omega is available for
anonymous ftp from ftp.cs.umd.edu:pub/omega/omega_library. More
information is available by email from omega@cs.umd.edu on the www at
<A NAME=id21 HREF="http://www.cs.umd.edu/projects/omega/">http://www.cs.umd.edu/projects/omega/</A>.

   OZ:					[COST FREE]
Oz is a concurrent constraint programming language designed for
applications that require complex symbolic computations, organization
into multiple agents, and soft real-time control. It is based on a new
computation model providing a uniform foundation for higher-order
functional programming, constraint logic programming, and concurrent
objects with multiple inheritance. From functional languages Oz
inherits full compositionality, and from logic languages Oz inherits
logic variables and constraints (including feature and finite domain
constraints). Search in Oz is encapsulated (no backtracking) and
includes one, best and all solution strategies.
DFKI Oz is an interactive implementation of Oz featuring a programming
interface based on GNU Emacs, a concurrent browser, an object-oriented
interface to Tcl/Tk, powerful interoperability features (sockets, C,
C++), an incremental compiler, a garbage collector, and support for
stand-alone applications. Performance is competitive with commercial
Prolog and Lisp systems. DFKI Oz is available for many platforms
running Unix/X, including Sparcs and 486 PCs. Applications DFKI Oz has
already been used for include simulations, multi-agent systems, natural
language processing, virtual reality, graphical user interfaces,
scheduling, placement problems, and configuration.
Version 1.0 of DFKI Oz (January 23, 1995) is available by anonymous ftp
from <A NAME=id22 HREF="ftp://ps-ftp.dfki.uni-sb.de/pub/oz">ps-ftp.dfki.uni-sb.de:/pub/oz</A>, or through the WWW from
	<A NAME=id23 HREF="http://ps-www.dfki.uni-sb.de/">http://ps-www.dfki.uni-sb.de/</A>
Tutorials, reference manuals, and research papers are available from
the same sources. You may start with "A Survey of Oz" (8 pages) and
continue with "An Oz Primer" (110 pages). For specific questions mail
oz@dfki.uni-sb.de. To join the Oz users mailing list, contact
oz-users-request@dfki.uni-sb.de.

   PROFIT: 				[COST FREE]
ProFIT (Prolog with Features Inheritance and Templates) is an extension
of Prolog with sorted feature structures (including multi-dimensional
inheritance), finite domains, feature search, cyclic terms, and
templates. ProFIT works as a pre-processor, which takes a file
containing a ProFIT program as input, and gives a file with a Prolog
program as output. Sorted feature terms and finite domains are
compiled into a Prolog term representation, and the usual Prolog term
unification is used at runtime, so that there is no slowdown through a
unification algorithm, and no meta-interpreter is needed. ProFIT uses
the same techniques for compiling sorted feature terms and finite
domains into Prolog terms as the Core Langauge Engine of SRI Cambridge
and the Advanced Linguistic Engineering Platform (ALEP 2.2) by the
European Community, BIM, and Cray Systems. ProFIT is not a grammar
formalism (although it is motivated by NLP), although it provides some
ingredients that are considered typical of grammar formalisms. The goal
of ProFIT is to provide these datatypes without enforcing any
particular theory of grammar, parsing or generation. ProFIT can be used
to extend your favourite Prolog-based grammar formalism, parser and
generator with the expressive power of sorted feature terms. Cyclic
terms can be printed out and a user-configurable pretty-printer for
feature terms is provided. ProFIT is available free of charge by
anonymous ftp from <A NAME=id24 HREF="ftp://coli.uni-sb.de/pub/profit">coli.uni-sb.de:/pub/profit</A>
Implemented in Sicstus Prolog (2.1 #9) by Gregor Erbach, Univ.
Saarlandes, Saarbruecken, Germany &#60;erbach@coli.uni-sb.de&#62;
&#60;<A NAME=id25 HREF="http://coli.uni-sb.de/~erbach>">http://coli.uni-sb.de/~erbach&#62;</A>

   PROLOG III:				[COST COMMERCIAL]
Prolog III was the first commercial Constraint Logic Programming
language. It incorporates all the main features of PROLOG II+, but
also gives the user the ability to express constraints over various
different domains. In particular the fundamental concept of constraint
resolution allows for numerical processing and also a complete
treatment of Boolean algebra, in a logic programming style. Version
1.5 of PROLOG III is available on wide range of platforms including PC,
MAC, UNIX, ULTRIX, VMS, NeXTSTEP, ALPHA OSF1. For more information,
write to PrologIA, Luminy - case 919 - 13288 MARSEILLE cedex 09 -
FRANCE or contact Fabienne LELEU : ph (33) 91 26 86 36 fax (33) 91 41
96 37 e-mail prologia@prologianet.univ-mrs.fr

   PROLOG IV:		NON-LINEAR ?	[COST COMMERCIAL]
Prolog IV is an ISO-compliant replacement for the Prolog III language.
It incorporates all the main features of Prolog III with some important
changes. Prolog IV allows programmers to express a wide variety of
constraints over real and rationnal numbers, integers (finite domains),
booleans and lists. In addition to expressing classical linear
programming problems on discrete and continuous quantities this permits
among other things the adressing of mixed real/integers problems and
the use of boolean operations to formalize constraint disjunctions.
The algorithms include a non-optimised algorithm for lists (different
from Prolog III), Gauss and Simplex algorithms for equations and linear
inequalities over rationals, and an interval method for approximate
solving of non-linear constraints over reals. The compiler is
integrated into a complete graphic programming environnment featuring
the following tools: project editor, multi-window text editor, grapher,
debugger, and on-line help.
Prolog IV is available on Unix Platforms (for about $11400) and
PC's with Windows (about $6400). These prices include two days of
training. For sales, contact Fabienne LELEU, Case 919 - Luminy 13288
Marseille cedex 09, France. Phone +33 91 26 86 36 - Fax +33 91 41 96
37. Email: prologia@prologianet.univ-mrs.fr For more information, you
can contact Andre Touraivane, Prologia Director of Research at the
same address, or email touraivane@prologianet.univ-mrs.fr

   QUAD-CLP(R):		NON-LINEAR	[COST FREE]
QUAD-CLP(R) is an experimental constraint logic programming system
developed in the course of PhD research by Gilles Pesant. The CLP(R)
version 1.1 source code was used as a platform for the implementation.
The system provides a further treatment of non-linear _arithmetic_
constraints over the reals as opposed to delaying them unconditionally.
It concentrates on quadratic constraints, rewriting them so that they
can actually be decided upon or generating a conservative approximation
of them (while still delaying them), potentially improving control over
the computation. In both cases the idea is to fall back on linear
constraints, more easily handled.
QUAD-CLP(R)'s incomplete solver for non-linear constraints caters for
problems of respectable size which require a certain amount of
reasoning on these constraints but cannot afford the prohibitive cost
of a complete treatment. Contact Gilles Pesant &#60;pesant@IRO.UMontreal.CA&#62;
<A NAME=id26 HREF="ftp://ftp.iro.umontreal.ca/pub/incognito/Logiciels/QUAD_CLP_R/">ftp://ftp.iro.umontreal.ca/pub/incognito/Logiciels/QUAD_CLP_R/</A>
The file "qclpr_tar.Z" contains the whole package: executable file
(for Sparc/SunOS and Sparc/Solaris platforms), some rudimentary pages
information and a directory containing examples.

Reference:
[1] G. Pesant, M. Boyer. QUAD-CLP(R): Adding the Power of Quadratic
Constraints. Principles and Practice of Constraint Programming:
Proceedings of the Second International Workshop (Rosario, Orcas
Island, Washington, USA) (Alan Borning, ed.), Lecture Notes in Computer
Science, vol. 874, Springer-Verlag, Rosario, Orcas Island, Washington,
USA, 1994, pp. 95--108.

   QUANTUM LEAP:			[COST COMMERCIAL or CHEAP]
					[See last paragraph]
The Quantum Leap Problem Solving Engine (PSE) works like a community of
competing and cooperating experts - each one using a different
methodology to obtain the best solution to a problem. Users employ the
Problem Representation Facility (PRF), an object based, graphical
interface, to build statements of their problems. Quantum Leap employs
a coordinated team of optimization methods, including: Linear
Programming, Quadratic Programming, Generalized Reduced Gradient,
Conjugate Direction, Evolutionary Programming, Simulated Annealing,
Zoomed Enumeration, Logical Reduction, Pseudo Boltzman, and Heuristic
Search. It also offers an object-oriented, tabular, multidimensional
representation, with inheritance and self-reference, both numeric and
symbolic constructs, an English-like language, internal and external
(C) user defined functions, and many built-in aggregates and numeric
functions. It has a Client-Server Architecture, with the PSE
implemented locally, on another LAN node, or remotely. A multi-PSE
version finds faster solutions to many problems via parallel
processing. Users can define multiple objectives, and priorities among
goals. The system finds "Best Balanced" points for infeasible problems,
and multiple solutions to some problems. APIs are available that allow
a compiled model to be used as a stand-alone application. Quantum
Development wants you to solve your problem, then grant the right to
publish your approach! In return, you become a member of the LEAPER
program, use Quantum Leap for only shipping and materials cost. Leapers
will receive the LEAPER LETTER, a moderated news-list for exchange of
technical information. To receive more information, send email to
leapers@qdc.com. The body of the note should contain, as the first
line: GET &#60;offer&#62;. Or contact Joseph Elad (President) jelad@qdc.com
or Wenming Kuai wkuai@qdc.com. Phone USA (302) 798-0899, fax (302)
798-6813.

   RISC-CLP(REAL):	NON-LINEAR	[unavailable]
RISC-CLP(Real) is a logic programming language with constraints over
the real numbers and exact arithmetic. The core-solver of the language
is the partial Quantifier Elimination Algorithm for real closed fields.
This is an improvement of the original quantifier elimination algorithm
due to Collins'. RISC-CLP also employs the Groebner Basis algorithm of
Buchberger. The system was intended as a study of a CLP solver based on
purely algebraic methods, generally too slow for such an application,
and is not meant for distribution. The interpreter and the solver are
implemented on top of the computer algebra system SACLIB in C language.
Contact Hoon Hong &#60;Hoon.Hong@risc.uni-linz.ac.at&#62; (SACLIB and GROEBNER
are available at <A NAME=id27 HREF="ftp://ftp.risc.uni-linz.ac.at/">ftp://ftp.risc.uni-linz.ac.at</A> and
http://www.risc.uni-linz.ac.at)

References:
[1] H. Hong. Non-linear real Constrains in Constraint Logic
Programming. International Conference on Algebraic and Logic
Programming, Springer Lecture Notes in Computer Science 632, 201-212.
1992.

[2] H. Hong. RISC-CLP(Real): Constraint Logic Programming over Real
Numbers. Constraint Logic Programming: Selected Research. Eds. F.
Benhamou and A. Colmerauer. MIT Press. 1993.


   SCREAMER:				[COST FREE]
Screamer is an extension of Common Lisp that adds support for
nondeterministic programming. Screamer consists of two levels. The
basic nondeterministic level adds support for backtracking and undoable
side effects. On top of this nondeterministic substrate, Screamer
provides a comprehensive constraint programming language in which one
can formulate and solve mixed systems of numeric and symbolic
constraints. Together, these two levels augment Common Lisp with
practically all of the functionality of both Prolog and constraint
logic programming languages such as CHiP and CLP(R). Furthermore,
Screamer is fully integrated with Common Lisp. Screamer programs can
coexist and interoperate with other extensions to Common Lisp such as
CLOS, CLIM and Iterate.

In several ways Screamer is more efficient than other implementations
of backtracking languages. The overhead to support backtracking is only
paid for those portions of the program which use the backtracking
primitives. Deterministic portions of user programs pass through the
Screamer to Common Lisp transformation unchanged. If only small
portions of your programs utilize the backtracking primitives, Screamer
can produce more efficient code than compilers for languages in which
backtracking is more pervasive.

Screamer is fairly portable across most Common Lisp implementations.
Screamer is available from <A NAME=id28 HREF="ftp://ftp.ai.mit.edu/pub/screamer.tar.Z">ftp.ai.mit.edu:/pub/screamer.tar.Z</A>. Contact
Jeffrey Mark Siskind &#60;qobi@ai.mit.edu&#62; for further information.

   SCREAMER TOOL REPOSITORY		[COST FREE]
There is a tools repository (ftp site) for user-contributed Screamer
code: <A NAME=id29 HREF="ftp://ftp.cis.upenn.edu/pub/screamer-tools">ftp.cis.upenn.edu:/pub/screamer-tools</A>. The repository is also
accessible at <A NAME=id30 HREF="http://www.cis.upenn.edu/~screamer-tools/home.html">http://www.cis.upenn.edu/~screamer-tools/home.html</A>
Questions about the repository to screamer-repository@cis.upenn.edu.

   SEL:					[COST FREE]
SEL is a declarative set processing language. Its main features are
subset and equational program clauses, pattern matching over sets,
support for efficient iteration and point-wise/incremental computation
over sets, the ability to define transitive closures through circular
constraints, meta-programming and simple higher-order programming, and
a modest user-interface including tracing. The language seems
well-suited to a number of problems in graph theory, program analysis,
and discrete mathematics. The SEL compiler is written in Quintus Prolog
and the run-time system is written in C. It generates WAM-like code,
extended to deal with set-matching, memoization, and the novel control
structure of the language. SEL is available by anonymous FTP from
<A NAME=id31 HREF="ftp://ftp.cs.buffalo.edu/users/bharat/SEL2/">ftp.cs.buffalo.edu:/users/bharat/SEL2/</A>. The FTP release comes with a
user manual, bibliography of papers (including .dvi files), several
sample programs, and source code. For further information, write to
Bharat Jayaraman &#60;bharat@cs.buffalo.edu&#62;.

   SEPIA:				[COST FREE with ECLIPSE]
See ECLIPSE (also see 'ECRC SEPIA').

   SICSTUS PROLOG:			[COST A=CHEAP,E=??,C=COMMERCIAL]
SICStus Prolog is a Unix prolog by SICS. It is portable to most UNIX
machines (Berkeley UNIX is preferred over System V). SICS Aurora and
Echo is a parallel emulator for Sequent Balance, Sequent Symmetry,
Encore Multimax, and BBN Butterfly (Unix). For more information, write
to SICS, Swedish Institute of Computer Science, P.O. Box 1263, S-164
28 KISTA, Sweden, call +46 8 752 15 02, fax +46 8 751 72 30, or send
email to sicstus-request@sics.se or sicstus@sics.se. Bug reports
and tech support questions should be sent to sicstus-bug@sics.se.
To subscribe to the users group and implementors mailing list, send
email to sicstus-users-request@sics.se.

   SKYBLUE:				[COST FREE-PD]
A constraint-solving algorithm. See information on the Seattle ftp site
in section [1-5]. See paper by Freeman-Benson et al in section [1-6].

   STEELE'S CONSTRAINT SYSTEM:		[COST FREE]
Chris Hanson's implementation of Steele's constraint system is
available by ftp from <A NAME=id32 HREF="ftp://martigny.ai.mit.edu/archive/cph/constraint.tar">martigny.ai.mit.edu:/archive/cph/constraint.tar</A>
or <A NAME=id33 HREF="ftp://nexus.yorku.ca/pub/scheme/new/constraint.tar.Z">nexus.yorku.ca:/pub/scheme/new/constraint.tar.Z</A>. A compressed
version is also stored there. The software is source code for MIT
Scheme. It should run in release 7.1.3. Most of the MIT Scheme
dependencies could be eliminated, but it also uses the following
procedures which aren't in standard Scheme: error, bkpt, macros,
dynamic binding, and string output ports. The code corresponds pretty
closely to Guy Steele's PhD thesis implementation, which you can obtain
in printed form from the MIT AI Lab publications office as AI-TR-595
for $15.00 (email publications@ai.mit.edu for more information). For
more information, send email to Chris Hanson
&#60;cph@martigny.ai.mit.edu&#62;.

   THINGLABII				[COST FREE-PD]
ThingLabII is a constraint-based package. See information on the Seattle
ftp site in section [1-5].

   TOUPIE:				[COST FREE]
Toupie is a finite domain $\mu$-calculus interpreter designed by A.
Rauzy &#60;rauzy@labri.u-bordeaux.fr&#62;. It uses Decision Diagrams to
represent relations and formulas. Decision Diagrams are an extension of
the BDD first introduced by Bryant. The original propositional
$\mu$-calculus interpreter was designed to express properties of finite
states machines. In addition to classical connectives of the
propositional calculus, it provides the two quantifications and the
possibility to define relations as least or greatest fixpoints of
equations. Toupie is a $\mu(\cal FD)$ interpreter, i.e. an extension to
finite domains handling numerical linear constraints. This language has
been successfuly used for abstract interpretation of Prolog, analysis
of mutual exclusion algorithms, classical logic puzzles and
model-checking a recent presentation can be found in ESOP'94 "Symbolic
Model Checking and Constraint Logic Programming: a Cross-
Fertilization". [Information kindly supplied by Marc-Michel
Corsini &#60;Marc.Corsini@labri.u-bordeaux.fr&#62;.]

   TRILOGY:				[COST CHEAP]
Trilogy is a constraint system developed by Complete Logic Systems. It
costs $100. For more information, write to Complete Logic Systems, Inc,
741 Blueridge Avenue, V7R 2J5, North Vancouver BC, Canada, or call
604-986-3234. [Does the company still exist?]

   VS TRILOGY:				[COST COMMERCIAL]
VS Trilogy is a Prolog compiler available from Vertical Software for
$395. For more information, write to Vertical Software Ltd., 14-636
Clyde Ave, W. Vancouver, BC, V7T 1E1, Canada, call 604-925-0321, or fax
604-688-8479.

   WAMCC:				[COST FREE]
WAMCC 2.2 is a WAM-based Prolog to C compiler. It conforms more or
less to the Edinburgh standard, and includes most of the usual built-in
predicates, a top-level, a Prolog debugger and a WAM debugger. It is
designed to be easily extended (for example see clp(FD)). WAMCC's
speed is halfway between SICStus emulated and SICStus native code on a
Sparc (1.5 times faster and 1.5 times slower, respectively). It
requires GCC 2.4.5 or higher and has been tested on Sparc workstations.
It should be easily ported to 32-bit machines with GCC. WAMCC is
available free by anonymous ftp from
<A NAME=id34 HREF="ftp://ftp.inria.fr/INRIA/Projects/ChLoE/LOGIC_PROGRAMMING/wamcc/">ftp.inria.fr:/INRIA/Projects/ChLoE/LOGIC_PROGRAMMING/wamcc/</A>
For more information, write to Daniel Diaz &#60;Daniel.Diaz@inria.fr&#62;,
INRIA Rocquencourt, FRANCE.

----------------------------------------------------------------
;;; *EOF*
</PRE>
<A NAME=up HREF="faq.html">Go Back Up</A><P>
<A NAME=up HREF="faq-doc-2.html">Go To Previous</A><P>
</BODY>
