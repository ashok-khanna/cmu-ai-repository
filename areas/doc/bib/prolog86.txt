
	   SOME RECENT PAPERS AND BOOKS IN ENGLISH
	      ON PROLOG AND LOGIC PROGRAMMING
	(Obtained from DIALOG databases by Steacie Science Library)

TI- One cornerstone in the mathematical foundations for a system of
    fuzzy-logic programming
AU- Schwartz, D.
CS- Dept. of Comput. Sci., Florida State Univ., Tallahassee, FL, USA
CS- <Sponsor> IEEE
JN- Second Conference on Artificial Intelligence Applications: The
    Engineering of Knowledge-Based Systems (Cat. No.85CH2215-2) 618-20
PY- 1985
CD- <US Copyright Clearance Center Code> CH2215-2/85/0000-0618$01.00
CL- Miami Beach, FL, USA
CY- 11-13 Dec. 1985
PU- IEEE Comput. Soc. Press Washington, DC, USA
PG- xvii+685
BN- 0 8186 0688 6
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- THEORETICAL; 
RF- 7
AB- A semantically complete axiomatization is established for a formal
    theory of semantic equivalence that is based on Zadeh's concept of
    fuzzy linguistic variable. As such, the work provides part of the
    foundation for an eventual implementation of fuzzy-logic programming,
    perhaps in the form of a 'fuzzy extension' of the Prolog programming
    language. The theorem proved should bear much the same relation to any
    such future implementation as do the well-known semantic completeness
    theorems for first-order logic to the current implementations of Prolog
DE- equivalence classes; formal logic; fuzzy set theory; logic programming;
    PROLOG
ID- fuzzy-logic programming; semantically complete axiomatization; semantic
    equivalence; fuzzy linguistic variable; Prolog; first-order logic
 
TI- Interpretive structural modeling system in PROLOG
AU- Ohuchi, A.; Kaji, I.
CS- Dept. of Electr. Eng., Hokkaido Univ., Sapporo, Japan
CS- <Sponsor> IEEE
JN- IEEE 1985 Proceedings of the International Conference on Cybernetics
    and Society (Cat. No.85CH2253-3) 908-12
PY- 1985
CD- <US Copyright Clearance Center Code> CH2253-3/85/0000-0908$01.00
CL- Tucson, AZ, USA
CY- 12-15 Nov. 1985
PU- IEEE New York, USA
PG- 1115
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- THEORETICAL; 
RF- 5
AB- The method of interpretive structural modeling (ISM) proposed by J.N.
    Warfield (1976) is based on the theory of binary matrices. It is well
    known that there exists a one-to-one correspondence between the binary
    relaxation and the first-order logic. A method for constructing a
    flexible ISM based on the first-order logic is described. The method is
    much simpler than the binary matrix approach. The result is used to
    implement an ISM system on a 16-bit personal computer in PROLOG. This
    program reveals that the new approach contains interesting
    possibilities
DE- formal logic; logic programming; PROLOG
ID- logic programming; PROLOG; interpretive structural modeling; binary
    matrices; binary relaxation; first-order logic
 
TI- Prolog for expert systems: An evaluation
AU- Helm, A.R.; Marriott, K.; Lassez, C.
CS- Dept. of Comput. Sci., Melbourne Univ., Parkville, Vic., Australia
AU- <Editor> Karna, K.N.
CS- <Sponsor> IEEE; MITRE Corp.; AIAA
JN- Expert Systems in Government Symposium (Cat. No.85CH2225-1) 284-94
PY- 1985
CD- <US Copyright Clearance Center Code> CH2225-1/85/0000-0284$01.00
CL- McLean, VA, USA
CY- 24-25 Oct. 1985
PU- IEEE Comput Soc. Press Washington, DC, USA
PG- xxiii+694
BN- 0 8186 0686 X
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- BIBLIOGRAPHY; PRACTICAL; 
RF- 53
AB- Through two case studies, TEAS and MARLOWE, Prolog is evaluated both as
    a language for writing expert systems shells and as a language for
    knowledge representation. These systems were chosen because they
    represent two different classes of expert system. TEAS uses exact
    inference and is concerned with representing government legislation.
    MARLOWE is used for white collar crime risk analysis and is an example
    of systems that reason with uncertain data or knowledge where both the
    domain and the expert's knowledge may be imprecise
DE- expert systems; logic programming; PROLOG
ID- Prolog; expert systems; TEAS; MARLOWE; expert systems shells; knowledge
    representation; exact inference; government legislation; white collar
    crime risk analysis
 
TI- Heuristic circuit simulation using PROLOG
AU- Gullichsen, E.
CS- Dept. of Comp. Sci., Victoria Univ., BC, Canada
JN- Integration VLSI J. (Netherlands) vol.3, no.4 283-318
PY- Dec. 1985
CD- <US Copyright Clearance Center Code> 0167-9260/85/$3.30
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- THEORETICAL; 
RF- 22
AB- Through the use of the logic programming language PROLOG, digital logic
    circuitry can be conveniently represented in predicate calculus in a
    manner amenable to various forms of computation. Axioms define the
    behavior of primitive gates in a given technology, and implications
    hierarchically characterize the behavior of non-primitive modules.
    Simulation of circuitry proceeds by theorem proving, viewed as
    constraint satisfaction. A PROLOG-based simulator is presented for the
    investigation of heuristics to efficiently solve problems of 'backward'
    simulation which arise in a number of areas, such as reasoning about
    fault isolation. The heuristic simulator can also serve as the basis
    for an elegant implementation of Roth's D-algorithm. An appendix lists
    the PROLOG source code for the heuristic goal-directed combinational
    circuit simulator
DE- digital simulation; heuristic programming; logic CAD; logic programming
    ; PROLOG listings; switching theory; theorem proving
ID- CAD; computer-aided design; source code listing; nonprimitive modules;
    PROLOG listings; PROLOG; logic programming language; digital logic
    circuitry; predicate calculus; theorem proving; constraint satisfaction
    ; fault isolation; heuristic simulator; D-algorithm
 
TI- The use of PROLOG in computer-aided design
AU- Gero, J.S.
CS- Comput. Appl. Res. Unit, Sydney Univ., NSW, Australia
AU- <Editor> Scrivener, S.A.R.
JN- Computer-aided design and manufacture. State of the art report 11-24
PY- 1985
PU- Pergamon Infotech Maidenhead, Berks., England
DT- BOOK CHAPTER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 6
AB- Computer-aided design has progressed from initially being concerned
    with analysis to a greater emphasis on interactive graphics for
    description and documentation. New directions point to an expanded role
    for computer-aided design, using knowledge engineering tools of
    symbolic inference. Programming in logic-PROLOG provides the means to
    encode and manipulate knowledge as inference. A brief introduction to
    PROLOG is presented with an explanation of how it works. It is shown
    how the knowledge in design codes can be programmed in PROLOG, then
    design synthesis using production rules is described and an
    implementation in PROLOG presented. Expert systems in PROLOG are also
    discussed
DE- CAD; expert systems; knowledge engineering; logic programming; PROLOG
ID- expert systems; PROLOG; computer-aided design; interactive graphics;
    documentation; knowledge engineering tools; symbolic inference; design
    synthesis; production rules
 
TI- Deductive data base tools
AU- Topor, R.W.; Keddis, T.; Wright, D.W.
CS- Dept. of Comput. Sci., Melbourne Univ., Parkville, Vic., Australia
JN- Aust. Comput. J. (Australia) vol.17, no.4 163-73
PY- Nov. 1985
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 36
AB- A deductive database is a database in which data can be represented
    both explicitly by facts and implicitly by general rules. The use of
    typed first order logic as a definition and manipulation language for
    such databases is advocated and illustrated by examples. Such a
    language has a well-understood theory and provides a uniform notation
    for data, queries, integrity constraints, views and programs. The
    authors present algorithms for implementing domains, for using atoms
    with named attributes, for evaluating queries, and for checking
    integrity constraints. The implementation is by translation into Prolog
    and can be performed using a standard Prolog system. The paper assumes
    some familiarity with relational databases, logic and Prolog
DE- logic programming; PROLOG; relational databases
ID- database management; query language; logic programming; data base tools
    ; deductive database; typed first order logic; manipulation language;
    integrity constraints; algorithms; atoms; attributes; Prolog;
    relational databases; logic
 
TI- Automating control for logic programs
AU- Naish, L.
CS- Dept. of Comput. Sci., Melbourne Univ., Parkville, Vict., Australia
JN- J. Logic Program. (USA) vol.2, no.3 167-83
PY- Oct. 1985
CD- <US Copyright Clearance Center Code> 0743-1066/85/$03.30
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 23
AB- A model for the coroutined execution of PROLOG programs is presented,
    and two control primitives are described. Heuristics for the control of
    data-base and recursive procedures are given, which lead to algorithms
    for generating control information. These algorithms can be
    incorporated into a preprocessor for logic programs. It is argued that
    automatic generation should be an important consideration when
    designing control primitives and is a significant step towards
    simplifying the task of programming
DE- logic programming; PROLOG
ID- database procedures; coroutined execution; PROLOG programs; control
    primitives; recursive procedures; control information; preprocessor;
    automatic generation
 
TI- N-PROLOG: an extension of PROLOG with hypothetical implication. II.
    Logical foundations, and negation as failure
AU- Gabbay, D.M.
CS- Dept. of Comput., Imperial Coll., London, England
JN- J. Logic Program. (USA) vol.2, no.4 251-83
PY- Dec. 1985
CD- <US Copyright Clearance Center Code> 0743-1066/85/$03.30
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- THEORETICAL; 
RF- 4
AB- This continuation paper investigates the logical properties of N-PROLOG
    and the way it relates to classical logic and the classical
    quantifiers. The author also introduces negation as failure into
    N-PROLOG. He gives practical examples of using logic to control the
    execution of programs in N-PROLOG and examines the validity of the
    thesis: algorithm=logic+(control in) logic. He claims that success in
    the N-PROLOG computation of a goal G from the database P means
    logically that the truth of G follows from P in intuitionistic logic
    and also introduces an additional computational rule called the restart
    rule (allowing one to replace, at any time of the computation, the
    current goal by the original goal)
DE- logic programming; PROLOG
ID- N-PROLOG; PROLOG; hypothetical implication; Logical foundations;
    negation; logical properties; classical logic; classical quantifiers;
    intuitionistic logic; restart rule
 
TI- Programming in logic. I
AU- Covington, M.
CS- Adv. Comput. Methods Center, Georgia Univ., Athens, GA, USA
JN- PC Tech J. (USA) vol.3, no.12 82-95
PY- Dec. 1985
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
AB- The basics of Prolog are discussed. With Prolog the user supplies only
    the facts; the computer finds the solution. A simple query is outlines.
    Prolog is often used as the basis for expert systems and a listing is
    provided of a simple car fault diagnosis expert system program as an
    example. List processing is discussed. The limitations of Prolog are
    mentioned, Finally Prolog's suitability for the next generation of
    computers is discussed
DE- expert systems; logic programming; PROLOG; PROLOG listings
ID- Prolog; simple query; expert systems
 
TI- Prolog-ELF incorporating fuzzy logic
AU- Ishizuka, M.; Kanai, N.
CS- Inst. of Ind. Sci., Tokyo Univ., Japan
JN- New Generation Comput. (Japan) vol.3, no.4 479-86
PY- 1985
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; THEORETICAL; 
RF- 14
AB- Prolog-ELF incorporating fuzzy logic and several useful functions into
    Prolog has been implemented as a basic language for building knowledge
    systems with uncertainty or fuzziness. Prolog-ELF inherits all the
    desirable basic features of Prolog. In addition to assertions with
    truth-values between 1.0 and 0.5 (0 for exceptional cases), fuzzy sets
    can be very easily manipulated. An application of fuzzy logical
    database is illustrated
DE- formal logic; fuzzy set theory; logic programming; PROLOG
ID- uncertainty; VAX-11 implementation; Pascal application; fuzzy logic;
    Prolog-ELF; knowledge systems; fuzzy sets; fuzzy logical database
 
TI- Complex indeterminates in Prolog and its application to discourse
    models
AU- Mukai, K.; Yasukawa, H.
CS- ICOT Res. Center, Inst. for New Generation Comput. Technol., Tokyo,
    Japan
JN- New Generation Comput. (Japan) vol.3, no.4 441-66
PY- 1985
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; THEORETICAL; 
RF- 22
AB- Complex indeterminates and their notation are introduced into Prolog.
    The syntax and semantics of the new language are described. The
    language builds in an extension to the usual unification. Detailed
    examples are given to demonstrate discourse models based on situation
    semantics in the proposed language. Discourse, connective and resource
    situations are included in the examples
DE- data structures; formal logic; logic programming; natural languages;
    programming languages; PROLOG
ID- logic programming; natural language processing; parameterized type;
    programming language CIL; Horn clause base language; complex
    indeterminates; Prolog; syntax; semantics; unification; discourse
    models; connective; resource situations
 
TI- Machine tongues. X. Prolog
AU- Balaban, M.; Murray, N.V.
CS- Dept. of Comput. Sci., State Univ. of New York, Albany, NY, USA
JN- Comput. Music J. (USA) vol.9, no.3 7-12
PY- Fall 1985
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 13
AB- Logic programming (e.g., Prolog) has been characterized by Kowalski
    (1974) as the application of logic and inference toward the
    representation and manipulation of knowledge by computers. This paper
    aims to explain these concepts
DE- logic programming; PROLOG
ID- logic programming; Prolog
 
TI- Modular logic programming of compilers
AU- Ganzinger, H.; Hanus, M.
CS- Fachbereich Inf., Dortmund Univ., Germany
CS- <Sponsor> IEEE
JN- 1985 Symposium on Logic Programming (Cat. No.85CH2205-3) 242-53
PY- 1985
CD- <US Copyright Clearance Center Code> CH2205-3/85/0000-0242$01.00
CL- Boston, MA, USA
CY- 15-18 July 1985
PU- IEEE Comput. Soc. Press Washington, DC, USA
PG- x+271
BN- 0 8186 0636 3
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; THEORETICAL; 
RF- 36
AB- It is demonstrated that the use of predicates more general than
    functions may significantly improve the modularity of compiler
    specifications. This observation motivates a technique for modular
    first-order predicate logic specifications of compilers. These
    specifications, when placed in the context of a few very basic standard
    predicates, can be directly executed by Prolog systems. The authors
    also discuss the relationship between attribute grammar specifications
    of compilers as used frequently in metacompilation and Horn-clause
    logic as basis of Prolog programming
DE- logic programming; program compilers; PROLOG
ID- modular logic programming; compilers; predicates; modularity; logic
    specifications; attribute grammar specifications; metacompilation;
    Horn-clause logic; Prolog programming
 
TI- Logic programming and graph rewriting
AU- Gallier, J.H.; Raatz, S.
CS- Dept. of Comput. & Inf. Sci., Pennsylvania Univ., Philadelphia, PA, USA
CS- <Sponsor> IEEE
JN- 1985 Symposium on Logic Programming (Cat. No.85CH2205-3) 208-19
PY- 1985
CD- <US Copyright Clearance Center Code> CH2205-3/85/0000-0208$01.00
CL- Boston, MA, USA
CY- 15-18 July 1985
PU- IEEE Comput. Soc. Press Washington, DC, USA
PG- x+271
BN- 0 8186 0636 3
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- THEORETICAL; 
RF- 19
AB- A theorem-proving method based on graph rewriting is presented. This
    procedure can also be used as an interpreter for a class of logic
    programs, and a prototype system, Hornlog, has been written. The method
    used in Hornlog is new, and is based on the linear-time algorithm for
    proving the unsatisfiability of a propositional Horn clause of W.P.
    Dowling and J.H. Gallier (1984). It applies to a class of first-order
    formulas which is a proper superset of the class of clauses handled by
    Prolog interpreters. In particular, negative Horn clauses used as
    assertions (which do not use the negation by failure semantics) and
    queries consisting of disjunctions of negations of Horn clauses are
    allowed. Hence, this procedure may return indefinite answers
    (disjunctions). This method also appears to have an immediate parallel
    interpretation
DE- graph theory; logic programming; PROLOG
ID- logic programming; graph rewriting; theorem-proving method; interpreter
    ; prototype system; Hornlog; linear-time algorithm; propositional Horn
    clause; Prolog
 
TI- Recursive unsolvability of determinacy, solvable cases of determinacy
    and their applications to Prolog optimization
AU- Sawamura, H.; Takeshima, T.
CS- Fujitsu Ltd., Shizuoka, Japan
CS- <Sponsor> IEEE
JN- 1985 Symposium on Logic Programming (Cat. No.85CH2205-3) 200-7
PY- 1985
CD- <US Copyright Clearance Center Code> CH2205-3/85/0000-0200$01.00
CL- Boston, MA, USA
CY- 15-18 July 1985
PU- IEEE Comput. Soc. Press Washington, DC, USA
PG- x+271
BN- 0 8186 0636 3
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; THEORETICAL; 
RF- 21
AB- The determinacy of a predicate call (goal) plays very important roles
    in optimizing the nondeterministic logic programming language, Prolog.
    By the determinacy of a predicate call, it is understood that at most
    one clause of its defining clauses succeeds when it is called, and it
    never succeeds again when it is backtracked. It is shown here that the
    problem of whether for any predicate it is deterministic or not is
    recursively unsolvable, and the implications of this result are
    examined. The concepts of a-determinacy and r-determinacy, as solvable
    cases of determinacy are introduced. These concepts are mutually
    defined, and their properties are examined. On the basis of these
    concepts, three applications to Prolog optimization are described,
    namely, the inline expansion, the automatic cut insertion, and the
    simplification of a sequence of conjuncts
DE- logic programming; optimisation; PROLOG
ID- recursive unsolvability; backtracking; determinacy; Prolog optimization
    ; logic programming language; predicate call; a-determinacy;
    r-determinacy; inline expansion; automatic cut insertion
 
TI- A microcoded unifier for Lisp machine Prolog
AU- Carlsson, M.
CS- Dept. of Comput. Sci., Uppsala Univ., Sweden
CS- <Sponsor> IEEE
JN- 1985 Symposium on Logic Programming (Cat. No.85CH2205-3) 162-71
PY- 1985
CD- <US Copyright Clearance Center Code> CH2205-3/85/0000-0162$01.00
CL- Boston, MA, USA
CY- 15-18 July 1985
PU- IEEE Comput. Soc. Press Washington, DC, USA
PG- x+271
BN- 0 8186 0636 3
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; THEORETICAL; 
RF- 36
AB- A technique for structure copying unification, amenable to microcoded
    implementations, is presented. The technique is based on a coded
    representation of terms. The representation encodes variable
    annotations and whether a variable occurrence is a
    void/first/subsequent occurrence. The codes are chosen to be suitable
    for dispatch hardware. The unifier optionally handles cyclic structures
    and has an optional occur check. Alternatives to the sequential
    computation model of Prolog are introduced by defining noncanonical
    terms as objects of abstract data types. Unification is an operation
    that is defined separately for each individual abstract data type,
    making alternative computational models such as demand-driven and
    data-flow computations fully available from compiled code
DE- codes; logic programming; PROLOG
ID- encoding; demand drive computations; microcoded unifier; Lisp machine
    Prolog; structure copying unification; coded representation; dispatch
    hardware; cyclic structures; optional occur check; sequential
    computation model; noncanonical terms; abstract data types; data-flow
    computations
 
TI- The declarative semantics of logical read-only variables
AU- Levi, G.; Palamidessi, C.
CS- Dipartimento di Inf., Pisa Univ., Italy
CS- <Sponsor> IEEE
JN- 1985 Symposium on Logic Programming (Cat. No.85CH2205-3) 128-37
PY- 1985
CD- <US Copyright Clearance Center Code> CH2205-3/85/0000-0128$01.00
CL- Boston, MA, USA
CY- 15-18 July 1985
PU- IEEE Comput. Soc. Press Washington, DC, USA
PG- x+271
BN- 0 8186 0636 3
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 17
AB- The authors consider the declarative (model-theoretic and fixed-point)
    semantics of Horn clause logic with read-only variables. The logic
    language considered is Concurrent Prolog without the commit operator.
    The results can be considered as a first step toward a mathematical
    characterization of Concurrent Prolog programs. The declarative
    semantics proposed is equivalent to the operational semantics and is
    based on a new notion of Herbrand interpretation, which allows one to
    characterize values which can only be consumed. A slight extension of
    Concurrent Prolog read-only variables is first considered. The
    variables are easier to handle from the semantics viewpoint and still
    have synchronization power. The model construction is then sketched for
    the Concurrent Prolog case
DE- logic programming; PROLOG; synchronisation
ID- model theoretic semantics; fixed-point semantics; declarative semantics
    ; logical read-only variables; Horn clause logic; Concurrent Prolog;
    mathematical characterization; declarative semantics; operational
    semantics; Herbrand interpretation; synchronization
 
TI- Concurrent Prolog compiler on top of Prolog
AU- Ueda, K.; Chikayama, T.
CS- NEC Corp., Kawasaki, Japan
CS- <Sponsor> IEEE
JN- 1985 Symposium on Logic Programming (Cat. No.85CH2205-3) 119-26
PY- 1985
CD- <US Copyright Clearance Center Code> CH2205-3/85/0000-0119$01.00
CL- Boston, MA, USA
CY- 15-18 July 1985
PU- IEEE Comput. Soc. Press Washington, DC, USA
PG- x+271
BN- 0 8186 0636 3
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 14
AB- A Concurrent Prolog compiler, whose target language is (sequential)
    Prolog, was implemented in Prolog. The object program obtained can
    further be compiled into machine codes by a Prolog compiler. Due to the
    similarity among the source, target and implementation languages, the
    compiler and the run-time support were small and very rapidly
    developed. Benchmark tests showed that (twice) compiled Concurrent
    Prolog programs ran 2.7 to 4.4 times faster and 2.7 to 5.3 times slower
    than comparable Prolog programs running on the interpreter and
    compiler, respectively, of the same Prolog system. After these
    experiments, the concurrent Prolog compiler was modified to obtain a
    compiler of the new parallel logic programming language, GHC (guarded
    Horn clauses), and almost the same efficiency was achieved. These
    compilers will serve for parallel logic programming
DE- logic programming; parallel processing; program compilers; PROLOG
ID- sequential Prolog; source languages; target languages; Concurrent
    Prolog compiler; target language; machine codes; implementation
    languages; run-time support; interpreter; parallel logic programming
    language; guarded Horn clauses
 
TI- A sequential implementation of Concurrent Prolog based on the shallow
    binding scheme
AU- Miyazaki, T.; Takeuchi, A.; Chikayama, T.
CS- ICOT Res. Center, Tokyo, Japan
CS- <Sponsor> IEEE
JN- 1985 Symposium on Logic Programming (Cat. No.85CH2205-3) 110-18
PY- 1985
CD- <US Copyright Clearance Center Code> CH2205-3/85/0000-0110$01.00
CL- Boston, MA, USA
CY- 15-18 July 1985
PU- IEEE Comput. Soc. Press Washington, DC, USA
PG- x+271
BN- 0 8186 0636 3
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; THEORETICAL; 
RF- 15
AB- The authors present an efficient implementation on sequential computers
    of Concurrent Prolog, which is one of the stream-and-parallel logic
    programming languages. The key issues of the implementation are the
    scheduling of suspended computation and OR-parallel evaluation of
    clauses in order to select one clause for the goal resolution. The
    solution to the first problem is briefly explained. The second problem
    is divided into two subproblems: realization of multiple environments
    for clauses executed in parallel and realization of value access
    control, which is necessary when guards are deeply nested. The proposed
    implementation scheme is based on the so-called shallow binding scheme
    and introduced two new low level constructs, a trail cell and a local
    environment number. The former realizes multiple environments and the
    latter realizes value-access control
DE- logic programming; programming environments; PROLOG
ID- sequential implementation; Concurrent Prolog; shallow binding scheme;
    sequential computers; logic programming languages; scheduling;
    OR-parallel evaluation; multiple environments; value access control;
    trail cell; local environment number; value-access control
 
TI- Concurrent Prolog in a multi-process environment
AU- Lee, R.K.S.; Gobel, R.
CS- Dept. of Comput. Sci., Waterloo Univ., Ont., Canada
CS- <Sponsor> IEEE
JN- 1985 Symposium on Logic Programming (Cat. No.85CH2205-3) 100-9
PY- 1985
CD- <US Copyright Clearance Center Code> CH2205-3/85/0000-0100$01.00
CL- Boston, MA, USA
CY- 15-18 July 1985
PU- IEEE Comput. Soc. Press Washington, DC, USA
PG- x+271
BN- 0 8186 0636 3
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 12
AB- Concurrent Prolog is a simple yet powerful transformation of Prolog
    that incorporates concurrency, communication, synchronization and
    indeterminacy. The authors report on the development of a computation
    model for Concurrent Prolog which uses processes communicating via
    message-passing. A prototype implementation, Port Prolog, has been
    programmed in Waterloo Port, a multiprocess programming environment
    that supports concurrent activities. The Port Prolog computation model
    defines the process structure, communication paths, binding
    environment, and synchronization procedures for Concurrent Prolog. The
    interpreter is a model. Some performance measurements made with the
    prototype are summarized
DE- logic programming; programming environments; PROLOG
ID- multiprocess environment; Concurrent Prolog; communication;
    synchronization; indeterminacy; computation model; message-passing;
    Port Prolog; Waterloo Port; process structure; communication paths;
    binding environment; interpreter
 
TI- Unification-free execution of logic programs
AU- Maluszynski, J.; Komorowski, H.J.
CS- Dept. of Comput. & Inf. Sci., Linkoping Univ., Sweden
CS- <Sponsor> IEEE
JN- 1985 Symposium on Logic Programming (Cat. No.85CH2205-3) 78-86
PY- 1985
CD- <US Copyright Clearance Center Code> CH2205-3/85/0000-0078$01.00
CL- Boston, MA, USA
CY- 15-18 July 1985
PU- IEEE Comput. Soc. Press Washington, DC, USA
PG- x+271
BN- 0 8186 0636 3
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; THEORETICAL; 
RF- 13
AB- The authors give a sufficient condition to replace run-time unification
    Prolog programs by term matching. This is useful since term matching
    can be accomplished in log/sup 2/-time on a parallel machine. The class
    of programs satisfying this condition is non-trivial. The concepts and
    methods introduced open possibilities for static analysis of run-time
    properties of logic programs. A methodology for using the condition as
    a programmer's tool is suggested and experiments with its
    implementations are reported
DE- logic programming; PROLOG
ID- unification free execution; logic programs; Prolog programs; term
    matching; parallel machine; static analysis; programmer's tool
 
TI- All solutions predicates in Prolog
AU- Naish, L.
CS- Dept. of Comput. Sci., Melbourne Univ., Parkville, Vic., Australia
CS- <Sponsor> IEEE
JN- 1985 Symposium on Logic Programming (Cat. No.85CH2205-3) 73-7
PY- 1985
CD- <US Copyright Clearance Center Code> CH2205-3/85/0000-0073$01.00
CL- Boston, MA, USA
CY- 15-18 July 1985
PU- IEEE Comput. Soc. Press Washington, DC, USA
PG- x+271
BN- 0 8186 0636 3
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; THEORETICAL; 
RF- 9
AB- It is generally agreed that an all-solutions predicate is a useful
    extension to Prolog. There are a great number of implementations of
    such predicates, but all of those which are known lack a well-defined
    declarative semantics. All can be used to implement non-logical
    predicates, such as var. One specification of the semantics of an
    all-solutions predicate appears in the literature, but the author shows
    that this leads to inefficiency if implemented correctly. The author
    surveys the current implementations and discusses their deficiencies.
    He also develops an improved specification of the semantics and shows
    how this can be implemented efficiently, using a sound implementation
    of inequality. An application to the implementation of negation as
    failure is also discussed
DE- logic programming; PROLOG
ID- nonlogical predicates; Prolog; declarative semantics; all-solutions
    predicate
 
TI- A meta-level extension of Prolog
AU- Bowen, K.A.; Weinberg, T.
CS- Dept. of Comput. & Inf. Sci., Syracuse Univ., NY, USA
CS- <Sponsor> IEEE
JN- 1985 Symposium on Logic Programming (Cat. No.85CH2205-3) 48-53
PY- 1985
CD- <US Copyright Clearance Center Code> CH2205-3/85/0000-0048$01.00
CL- Boston, MA, USA
CY- 15-18 July 1985
PU- IEEE Comput. Soc. Press Washington, DC, USA
PG- x+271
BN- 0 8186 0636 3
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; THEORETICAL; 
RF- 5
AB- A metalevel extension of Prolog is described which continues the work
    of K.A. Bowen & R.A. Kowalski (1982). It reifies not only theories and
    formulas but also proofs and search spaces (and, implicitly,
    substitutions), and introduces concurrency constructs. Its use in
    programming a metalevel approach to the problem of faulty circuit
    diagnosis is described. This approach appears to provide a logically
    sound programming formalism sufficiently powerful to write clear
    reliable programs for experimental and applied artificial intelligence
DE- artificial intelligence; logic programming; PROLOG
ID- meta-level extension; Prolog; proofs; search spaces; concurrency
    constructs; faulty circuit diagnosis; artificial intelligence
 
TI- An experiment in programming with full first-order logic
AU- Umrigar, Z.D.; Pitchumani, V.
CS- Dept. of Electr. & Comput. Eng., Syracuse Univ., NY, USA
CS- <Sponsor> IEEE
JN- 1985 Symposium on Logic Programming (Cat. No.85CH2205-3) 40-7
PY- 1985
CD- <US Copyright Clearance Center Code> CH2205-3/85/0000-0040$01.00
CL- Boston, MA, USA
CY- 15-18 July 1985
PU- IEEE Comput. Soc. Press Washington, DC, USA
PG- x+271
BN- 0 8186 0636 3
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; THEORETICAL; 
RF- 10
AB- Prolog is often unsound, incomplete and restricted to a proper subset
    of first-order logic. The authors have experimented with an extension
    to Prolog called Full-Prolog (F-Prolog) which removes these
    deficiencies and encompasses full first-order logic. F-Prolog is very
    similar in its interfaces and basic algorithms to the Prolog technology
    theorem prover (PTTP). Unfortunately, F-Prolog does not use Prolog
    technology in its implementation but is implemented using Prolog.
    Consequently, it is several orders of magnitude slower than a PTTP
    would be. However, F-Prolog does provide some experience in programming
    with PTTP, once a PTTP becomes available. This approach adds virtually
    no overhead to the execution of programs which use only pure Prolog,
    but the programmer must explicitly switch between Prolog and F-Prolog
DE- logic programming; PROLOG
ID- programming; full first-order logic; Full-Prolog; F-Prolog; Prolog
    technology theorem prover
 
TI- Semi-intelligent backtracking of Prolog based on static data dependency
    analysis
AU- Chang, J.-H.; Despain, A.M.
CS- Div. of Comput. Sci., California Univ., Berkeley, CA, USA
CS- <Sponsor> IEEE
JN- 1985 Symposium on Logic Programming (Cat. No.85CH2205-3) 10-21
PY- 1985
CD- <US Copyright Clearance Center Code> CH2205-3/85/0000-0010$01.00
CL- Boston, MA, USA
CY- 15-18 July 1985
PU- IEEE Comput. Soc. Press Washington, DC, USA
PG- x+271
BN- 0 8186 0636 3
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 12
AB- A static data dependency analysis (SDDA) for Prolog programs is
    described. The outputs from the SDDA are a collection of data
    dependency graphs, one for each clause in Prolog program. From data
    dependency graphs, intelligent backtracking can be compiled and run
    with little overhead. This scheme is described for the Prolog machine.
    It includes modification of the hardware and compiler. The scheme is
    simulated, and it is shown to be very effective for improving
    performance
DE- logic programming; program compilers; PROLOG
ID- semiintelligent backtracking; Prolog; static data dependency analysis;
    data dependency graphs; hardware; compiler
 
TI- Directions for logic programming
AU- Kowalski, R.
CS- Dept. of Comput., Imperial Coll., London Univ., England
CS- <Sponsor> IEEE
JN- 1985 Symposium on Logic Programming (Cat. No.85CH2205-3) 2-7
PY- 1985
CD- <US Copyright Clearance Center Code> CH2205-3/85/0000-0002$01.00
CL- Boston, MA, USA
CY- 15-18 July 1985
PU- IEEE Comput. Soc. Press Washington, DC, USA
PG- x+271
BN- 0 8186 0636 3
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; THEORETICAL; 
RF- 29
AB- The author concentrates on three problems: the discontinuity between
    declarative and procedural uses of logic programming, the elimination
    of extralogical features from Prolog and destructive assignment. The
    problem of destructive assignment is highlighted by an analysis of the
    use of extralogical features in Prolog. Such an analysis also motivates
    extension of the simple notion of logic programming as Horn clauses
    with backward reasoning. Extensions are needed both of expressive power
    and problem-solving strategies. Just as important, are the
    methodological problems which arise with most Prolog and pure logic
    programming. The main problem here is the discontinuity between
    declarative and procedural modes of use. Some of these problems might
    be alleviated by program transformations. Much of the past success of
    logic programming is based upon the success of Prolog. Careful study of
    the problems of Prolog is one of the best guides, therefore, both to
    the more general problems of logic programming and to the future
    directions logic programming might take
DE- logic programming; PROLOG
ID- logic programming; discontinuity; extralogical features; Prolog; Horn
    clauses; problem-solving strategies; program transformations
 
TI- PROLOG execution in Simula
AU- Lamy, J.-F.; Vaucher, J.
CS- Dept. d'inf. et de Recherche Oper., Montreal Univ., Ont., Canada
JN- Proceedings of the Thirteenth SIMULA Users' Conference 61-71
PY- 1985
CL- Calgary, Alta., Canada
CY- 28-30 Aug. 1985
PU- SIMULA Oslo, Norway
PG- ii+133
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 9
AB- Object-oriented design has allowed the authors to build an extremely
    modular inference engine for PROLOG, a nonprocedural language based on
    logic. The prototype includes most techniques used in prominent PROLOG
    implementations, but expressed with high-level language constructs. The
    authors make extensive use of the class/sub-class concepts to emulate
    compilation. The Search of the solution space is expressed elegantly
    via coroutines. The resident garbage collector manages PROLOG variable
    bindings and reclaims stack frames automatically when terminal
    recursivity occurs. The resulting interpreter is a good vehicle for
    experimentation of intelligent search strategies
DE- logic programming; PROLOG; simulation languages
ID- compiler emulation; PROLOG execution; Simula; modular inference engine;
    nonprocedural language; PROLOG implementations; high-level language
    constructs; garbage collector; reclaims stack frames; terminal
    recursivity; intelligent search strategies
 
TI- About the role of control information in natural language question
    answering systems
AU- Hess, M.
CS- Seminar of Gen. Linguistics, Zurich Univ., Switzerland
AU- <Editor> Dahl, V.; Saint-Dizier, P.
CS- <Sponsor> Univ. Rennes I; Groupe Bull; American Assoc. Artificial
    Intelligence; Simon Fraser Univ
JN- Natural Language Understanding and Logic Programming. Proceedings of
    First International Workshop 165-80
PY- 1985
CL- Rennes, France
CY- 18-20 Sept. 1984
PU- North-Holland Amsterdam, Netherlands
PG- xi+243
BN- 0 444 87714 2
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 24
AB- Most existing natural language question answering systems written in a
    logic programming language such as Prolog make use of only one
    component of the information expressed in the questions, viz. the logic
    component. However, (many) Natural Language sentences also convey
    control information. If this type of information is ignored the
    interpreter must use an input-independent, in most cases fixed, control
    regime and can not always generate useful replies. The authors draw
    attention to a few such cases in the context of logic programming: word
    oppositions like those between 'what' and 'which' determining whether a
    generalised solution or a fully evaluated solution is required; topic
    and comment in queries and DB entries and their use in guiding the
    search; restrictive and non-restrictive relative clauses and their use
    in interleaving data acquisition and query evaluation models. They give
    a very short outline of a suitable query evaluator. The problem of
    actually parsing questions is not dealt with here
DE- database management systems; logic programming; natural languages;
    PROLOG
ID- restrictive relative clauses; data acquisition modes; artificial
    intelligence; control information; natural language question answering
    systems; logic programming language; Prolog; logic component; control
    information; interpreter; DB entries; non-restrictive relative clauses;
    query evaluation models; query evaluator; parsing questions
 
TI- Hiding complexity from the casual writer of parsers
AU- Dahl, V.
CS- Dept. of Comput. Sci., Simon Fraser Univ., Burnaby, BC, Canada
AU- <Editor> Dahl, V.; Saint-Dizier, P.
CS- <Sponsor> Univ. Rennes I; Groupe Bull; American Assoc. Artificial
    Intelligence; Simon Fraser Univ
JN- Natural Language Understanding and Logic Programming. Proceedings of
    First International Workshop 1-19
PY- 1985
CL- Rennes, France
CY- 18-20 Sept. 1984
PU- North-Holland Amsterdam, Netherlands
PG- xi+243
BN- 0 444 87714 2
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 29
AB- Describes how logic programming can be exploited for automating great
    portion of the parser-writing process. Starts by describing how to
    write parsers in Prolog, the most widespread logic programming
    language, and then goes on to logic-based metagrammars. Shows how they
    can be used as a means for hiding from the user not only the deductive
    steps that automate most of the procedural concerns in parsing, but
    also the arguments otherwise needed for string manipulation, for
    context-sensitivity and transformations, for gapping phenomena, and for
    building syntactic and semantic structure from the sentence being
    parsed. The article is self contained, and controversial areas and
    unsolved problems in this very new field are also pointed out
DE- grammars; logic programming; program compilers; PROLOG
ID- syntactic structure; logic programming; parser-writing process; parsers
    ; Prolog; logic programming language; logic-based metagrammars; parsing
    ; string manipulation; context-sensitivity; transformations; gapping
    phenomena; semantic structure; sentence
 
TI- Prolog
AU- Adelsberger, H.H.
CS- Dept. of Comput. Sci., Texas A&M Univ., College Station, TX, USA
AU- <Editor> Greer Lavery, R.
JN- Modeling and Simulation on Microcomputers: 1985 57-9
PY- 1985
CL- San DIego, CA, USA
CY- 24-26 Jan. 1985
PU- Soc. Comput. Simulation La Jolla, CA, USA
PG- x+174
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- GENERAL,REVIEW; 
RF- 8
AB- The Prolog programming language is based on the Horn clause and
    predicate calculus. The author briefly discusses the basics of
    programming in Prolog covering: facts; questions and variables; rules;
    lists; and recursion. The author then discusses the qualities of Prolog
    that make it a good simulation language and then briefly describes
    three languages based on Prolog: T-Prolog; Parlog; and V-Goss
DE- logic programming; PROLOG; simulation languages
ID- Prolog; programming language; facts; rules; lists; recursion;
    simulation language; T-Prolog; Parlog; V-Goss
 
TI- Some global optimizations for a PROLOG compiler
AU- Mellish, C.S.
CS- Sussex Univ., Brighton, England
JN- J. Logic Program. (USA) vol.2, no.1 43-66
PY- April 1985
CD- <US Copyright Clearance Center Code> 0743-1066/85/$03.30
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 17
AB- This paper puts forward the suggestion that many PROLOG programs are
    not radically different in kind from programs written in conventional
    languages. For these programs, it should be possible for a PROLOG
    compiler to produce code of similar efficiency to that of other
    compilers. Moreover, there is no reason why reasonable efficiency
    should not be obtained without special-purpose hardware. A number of
    possible optimizations that can be made on the basis of a static,
    global analysis of programs are presented, together with techniques for
    obtaining such analyses. These have been embodied in working programs.
    Timing figures for experimental extensions to the POPLOG PROLOG
    compiler are presented to make it plausible that such optimizations can
    indeed make a difference to program efficiency
DE- logic programming; program compilers; PROLOG
ID- static analysis; global optimizations; PROLOG compiler; global analysis
    ; POPLOG PROLOG compiler
 
TI- Logic programming and PROLOG: a tutorial
AU- Davies, R.E.
CS- Dept. of Electr. Eng. & Comput. Sci., Santa Clara Univ., CA, USA
JN- IEEE Software (USA) vol.2, no.5 53-62
PY- Sept. 1985
CD- <US Copyright Clearance Center Code> 0740-7459/85/0900-0053$01.00
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 26
AB- Logic programming offers significant advantages for the massively
    parallel computer systems of the future. The potential of PROLOG to
    implement those advantages is examined. First, the author reviews the
    concepts of logic programming; these include: Horn clauses, semantics,
    nondeterminism and invertibility. Next, the PROLOG language is
    described. Finally, comments on possible improvements and efficiency
    are included
DE- logic programming; PROLOG
ID- PROLOG; parallel computer systems; logic programming; Horn clauses;
    semantics; nondeterminism; invertibility
 
 
TI- A model and an implementation of a logic programming environment
AU- Komorowski, H.J.; Omori, S.
CS- Aiken Computation Lab., Harvard Univ., Cambridge, MA, USA
CS- <Sponsor> ACM
JN- SIGPLAN Not. (USA) vol.20, no.7 191-8
PY- July 1985
CD- <US Copyright Clearance Center Code> 0-89791-165-2/85/006/0191$00.75
CT- Procedings of the ACM SIGPLAN 85 Symposium on Language Issues in
    Programming Environments
CL- Seattle, WA, USA
CY- 25-28 June 1985
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 30
AB- It has been claimed that logic programming offers outstanding
    possibilities for new concepts in programming environments. This
    summary describes current work on a generic software engineering shell
    for logic programming. The authors use reflection and the amalgamation
    of meta-level language with the object level to express and support the
    incremental character of specifying/programming. An important facet of
    the shell is that they formalize some aspects of programming
    methodology and provide heuristics for avoiding errors. These
    heuristics formalize what experienced programmers may already know. The
    shell bears similarities to an expert system since it has explanation
    mechanisms and provides programming-knowledge acquisition. Currently,
    it supports single user Prolog programming and runs in C-Prolog. The
    shell is generic in that it provides support for activities ranging
    from artificial intelligence programming to formal specification
    development
DE- logic programming; programming environments; PROLOG; software
    engineering
ID- logic programming environment; software engineering shell; reflection;
    amalgamation; meta-level language; heuristics; expert system;
    programming-knowledge acquisition; Prolog programming; C-Prolog;
    artificial intelligence; formal specification
 
TI- An environment for logic programming
AU- Francez, N.; Goldenberg, S.; Pinter, R.Y.; Tiomkin, M.; Tsur, S.
CS- IBM Israel Sci. Center, Haifa, Israel
CS- <Sponsor> ACM
JN- SIGPLAN Not. (USA) vol.20, no.7 179-90
PY- July 1985
CD- <US Copyright Clearance Center Code> 0-89791-165-2/85/006/0179$00.75
CT- Procedings of the ACM SIGPLAN 85 Symposium on Language Issues in
    Programming Environments
CL- Seattle, WA, USA
CY- 25-28 June 1985
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 12
AB- The authors describe a programming environment for Prolog, a common
    logic programming language. The services offered by the system assist a
    Prolog user in the tasks of composing, editing, and storing logic
    (rule-based) programs, as well as in the control of their execution for
    debugging purposes. In order to facilitate effective debugging of
    Prolog programs, they propose a new model of computation that can
    handle both pure Prolog and impure (side-effect causing) Prolog
    operations quite gracefully. This model employs two stacks representing
    the state of a computation with respect to the two major activities of
    Prolog execution: recursion and backtracking. This representation, in
    addition to being quite clear and intuitive, is easy to display on a
    terminal's screen and can be further processed. They also describe a
    Prolog oriented editor with which the user may easily create and update
    Prolog source programs and, further, inspect states of computation as
    generated by the debugger
DE- logic programming; program debugging; programming environments; PROLOG;
    text editing
ID- environment; logic programming; programming environment; Prolog;
    composing; editing; storing; debugging; recursion; backtracking; Prolog
    oriented editor
 
TI- A deterministic PROLOG fixpoint semantics
AU- Fitting, M.
CS- Dept. of Math. & Comput. Sci., Herbert H. Lehman Coll., Bronx, NY, USA
JN- J. Logic Program. (USA) vol.2, no.2 111-18
PY- July 1985
CD- <US Copyright Clearance Center Code> 0743-1066/85/$03.30
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- THEORETICAL; 
RF- 4
AB- A fixpoint semantics for PROLOG is presented that takes into account
    PROLOG's deterministic control structure as well as its logic features.
    It is applied to prove the correctness of a prime-number program based
    on the sieve of Eratosthenes, a program whose behavior depends
    critically on the sequential nature of PROLOG
DE- logic programming; programming theory; PROLOG
ID- program correctness proving; fixpoint semantics; PROLOG; deterministic
    control structure; logic features; prime-number program; sieve of
    Eratosthenes
 
TI- PROLOG program transformations and tree manipulation algorithms
AU- Nakagawa, H.
CS- Dept. of Inf. Eng., Yokohama Nat. Univ., Japan
JN- J. Logic Program. (USA) vol.2, no.2 77-91
PY- July 1985
CD- <US Copyright Clearance Center Code> 0743-1066/85/$03.30
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 12
AB- Since PROLOG programs are regarded not only as declarative predicates
    but also as procedural programs, it is reasonable that a clear
    declarative PROLOG program is first written and then transformed into a
    possibly unclear but efficient procedural program. The author presents
    a PROLOG program transformation method especially for a binary-tree
    manipulation program. By using a list as intermediate representation, a
    procedural tree manipulation program can be derived from a declarative
    one. In addition some heuristic knowledge for writing a tree
    manipulation algorithm from processes of PROLOG program transformation
    is found. These processes may be useful for automatic programming
DE- logic programming; PROLOG; trees (mathematics)
ID- tree manipulation algorithms; declarative predicates; procedural
    programs; PROLOG program transformation method; binary-tree
    manipulation program; heuristic knowledge; automatic programming
 
TI- Fifth generation computing: introducing micro-PROLOG into the classroom
AU- Ennals, R.; Briggs, J.
CS- Dept. of Comput., Imperial Coll., London, England
JN- J. Educ. Comput. Res. (USA) vol.1, no.1 97-111
PY- 1985
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 23
AB- The international computer industry is embarked on the construction of
    a new fifth generation of computers that intended to be more accessible
    to the human user. The Japanese Fifth Generation project is based on
    the use of logic programming. The authors describe their use of logic
    programming in school classrooms since 1980 and give an account of
    different styles of introduction for wide-ranging educational
    applications, using readily available personal computers. Emphasis is
    placed on clear description and explanation of knowledge areas rather
    than on the behavior of the computer. This provides an introduction to
    the use of logic and the declarative style of programming in the
    context of the traditional school of curriculum
DE- educational computing; logic programming; microcomputer applications;
    PROLOG
ID- fifth generation computing; micro-PROLOG; logic programming; school
    classrooms; educational applications; personal computers; traditional
    school of curriculum
 
TI- PROLOG: a logical AI choice
AU- Naylor, C.
JN- PC: Indep. Guide IBM Pers. Comput. (UK Ed.) (GB) vol.2, no.8 88-93
PY- Aug. 1985
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; PRODUCT REVIEW; 
AB- Discusses the basics of PROLOG and then reviews two versions of PROLOG
    available from Expert Systems International Prolog-1, a standard
    version of PROLOG and Prolog-2 a professional version for producing
    marketable programs, it includes windows and other extras
DE- expert systems; logic programming; programming; PROLOG
ID- programming; PROLOG; Expert Systems International; Prolog-1; Prolog-2
 
TI- The importance of PROLOG
AU- Ennals, R.
CS- Dept. of Comput., Imperial Coll. of Sci. & Technol., London, England
AU- <Editor> Griffiths, M.; Tagg, E.D.
JN- Role of Programming in Teaching Informatics. Proceedings of the IFIP
    TC3 Working Conference on Teaching Programming 93-101
PY- 1985
CL- Paris, France
CY- 7-9 May 1984
PU- North-Holland Amsterdam, Netherlands
PG- x+212
BN- 0 444 87664 2
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 47
AB- This paper attempts an analysis of the importance of PROLOG in the
    context of teaching computing, drawing on the diversity of approaches
    and traditions that already exist in the field of logic programming and
    its applications
DE- computer science education; logic programming; PROLOG; teaching
ID- PROLOG; teaching computing; logic programming
 
TI- Implementation techniques for PROLOG databases
AU- Clocksin, W.F.
CS- Comput. Lab., Cambridge Univ., England
JN- Software-Pract. & Exper. (GB) vol.15, no.7 669-75
PY- July 1985
CD- <US Copyright Clearance Center Code> 0038-0644/85/070669-07$01.00
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 10
AB- All clauses comprising a PROLOG program are stored in a database from
    which they can be removed later. Other long-term data structures are
    represented as clauses and are also stored and removed from the same
    database. Implementation techniques for the manipulation of clauses are
    not well known, and a lack of information has led to incorrect and
    incomplete implementations. Further previously unresolved issues are
    apparent when considering the storage of compiled clauses. The author
    describes the way database manipulations are performed in PROLOG-X, a
    new compiler-based PROLOG system. He also introduces a new technique
    for storing the source form of compiled clauses
DE- data structures; logic programming; program compilers; PROLOG; storage
    management
ID- implementation techniques; logic programming; garbage collection;
    PROLOG databases; data structures; storage; compiled clauses; database
    manipulations; PROLOG-X; compiler-based PROLOG system
 
TI- Logic programming
AU- Kowalski, R.
CS- Imperial Coll., London, England
JN- BYTE (USA) vol.10, no.8 161-77
PY- Aug. 1985
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- GENERAL,REVIEW; 
RF- 5
AB- Logic programming combines the use of logic that is congenial to human
    thinking and logic that is sufficiently goal-oriented to be implemented
    by computer. It provides a general framework within which many widely
    differing languages can be developed. It gives scope to the development
    of both declarative and procedural computer languages as well as to
    sequential and parallel implementations. Prolog is the first and most
    important logic-programming language, and it provides a tantalizing
    preview of the more powerful logic-programming languages of the future
DE- logic programming; PROLOG
ID- declarative language; procedural language; goal oriented logic;
    sequential implementations; parallel implementations; Prolog;
    logic-programming
 
TI- The University of Salford LISP/PROLOG system
AU- Bailey, D.
CS- Salford Univ., Manchester, England
JN- Software-Pract. & Exper. (GB) vol.15, no.6 595-609
PY- June 1985
CD- <US Copyright Clearance Center Code> 0038-0644/85/060595-15$01.50
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 9
AB- This paper describes a joint implementation of the LISP and PROLOG
    languages (with the emphasis in this paper on the latter) for the PRIME
    range of minicomputers. Both languages may be compiled or interpreted
    as required. Several novel techniques for PROLOG compilation are
    discussed
DE- LISP; logic programming; program compilers; program interpreters;
    programming environments; PROLOG
ID- language interface; garbage collection; LISP; PRIME; minicomputers;
    PROLOG compilation
 
TI- The paradigm of logic programming in a civil engineering environment
AU- Coelho, H.
CS- Centro de Inf., Lab. Nacional de Engenharia Civil, Lisboa, Portugal
JN- Comput. & Artif. Intell. (Czechoslovakia) vol.4, no.2 115-24
PY- 1985
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 30
AB- PROLOG, a particular realization of the logic programming notion, was
    selected at LNEC in 1975 as an experimental framework to enlarge the
    scope, flexibility and versatility of civil engineering computer
    programs. After nine years of research, either on PROLOG
    implementations side or on putting PROLOG in practice, some conclusions
    are drawn and the author argues the case for logic programming in
    general: logic, namely predicate logic, is a method and a tool. It is a
    method because it is a useful language for representing knowledge
    (program specification, programming, model human problem solving,
    natural language representation, and symbolic manipulation). It is a
    tool because it is a programming language: a higher level and more
    human oriented than other formalisms specifically developed for
    computers
DE- civil engineering computing; expert systems; knowledge engineering;
    logic programming; PROLOG
ID- logic programming; civil engineering environment; PROLOG; predicate
    logic; representing knowledge; programming language
 
TI- Bounded buffer communication in concurrent Prolog
AU- Takeuchi, A.; Furukawa, K.
CS- ICOT Res. Center, Inst. for New Generation Comput. Technol., Tokyo,
    Japan
JN- New Generation Comput. (Japan) vol.3, no.2 145-55
PY- 1985
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- THEORETICAL; 
RF- 7
AB- Concurrent Prolog is a logic-based parallel programming language which
    was designed and implemented experimentally in Prolog by E. Shapiro
    (1983). The authors examine the expressive power of a communication
    mechanism based on shared logical variables and show that the language
    can express both unbounded buffer and bounded buffer stream
    communication only by shared logical variables and read-only
    annotation. They also present the abstraction technique which hides
    buffer control such as unbounded and bounded inside stream operations
    and makes it invisible from user programs
DE- buffer storage; logic programming; parallel processing; programming
    theory; PROLOG
ID- protected data; bounded buffer communication; concurrent Prolog;
    parallel programming language; communication mechanism; shared logical
    variables; buffer stream communication; read-only annotation;
    abstraction technique; buffer control
 
TI- Background on Prolog: a high level logic programming language
JN- Comput. Compacts (Netherlands) vol.2, no.5-6 165-6
PY- Nov. 1984-Jan. 1985
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- GENERAL,REVIEW; PRACTICAL; 
AB- Programming in Prolog involves declaring facts about objects and their
    relationships; defining rules about objects and their relationships;
    and asking questions about objects and their relationships. Having
    shown how this works with a simple example the article discusses some
    uses of Prolog. Finally the key events in the history of Prolog are
    given
DE- history; logic programming; PROLOG
ID- Prolog; high level logic programming language; declaring facts;
    relationships; defining rules; history
 
TI- A tour of PROLOG
AU- Cortesi, D.E.
JN- Dr. Dobb's J. (USA) vol.10, no.3 44-63
PY- March 1985
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 3
AB- PROLOG is described from a programmer's perspective. The article is
    intended to allow a programmer to make sense of PROLOG listings.
    Alongside the main discussion is a description of PROLOG syntax. The
    particular aspects discussed are the difference between familiar
    procedural languages and the descriptive language PROLOG, assertions,
    queries, descriptive programming, descriptive arithmetic, formal
    nomenclature, item types, list notation, recursive description, list
    operations, the ability to reverse, programs for sets, trees and
    sorting, storing data, and the meta-variable
DE- logic programming; PROLOG
ID- PROLOG syntax; descriptive language; assertions; queries; descriptive
    programming; descriptive arithmetic; formal nomenclature; item types;
    list notation; recursive description; list operations
 
TI- Programming in logic
AU- Malpas, J.
CS- Pulsetrain, New York, NY, USA
JN- Dr. Dobb's J. (USA) vol.10, no.3 36-41
PY- March 1985
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
AB- Discusses the nature of logic programming and the development of
    PROLOG. Some of the features of PROLOG are: it can express knowledge,
    it describes not simulates, it does not use destructive assignment,
    PROLOG statements have both declarative and procedural interpretations,
    and PROLOG can be used to implement a meta-language. Some applications
    of logic programming are briefly discussed. An appendix discusses the
    logic used in PROLOG, a model of symbolic logic created by Frege. There
    are two varieties of logic discussed-propositional logic and first
    order predicate logic. Some sources of various implementations of
    PROLOG are given
DE- artificial intelligence; logic programming; PROLOG
ID- Horn clause; AI; artificial intelligence; ICOT; logic programming;
    PROLOG; procedural interpretations; meta-language; symbolic logic;
    Frege; propositional logic; first order predicate logic
 
TI- ELIMINATING UNWANTED LOOPS IN PROLOG
AU- COVINGTON, M.A.
CS- ADV. COMPUT. METHODS CENTER, GEORGIA UNIV., ATHENS, GA, USA
JN- SIGPLAN NOT. (USA) VOL.20, NO.1 20-6
PY- JAN. 1985
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 3
AB- MODIFICATIONS TO PROLOG ARE PROPOSED THAT MAKE IT POSSIBLE TO EXPRESS
    TRANSITIVE AND SYMMETRICAL RELATIONS AND BICONDITIONALS. THIS IS DONE
    BY BLOCKING RECURSION UNDER CIRCUMSTANCES THAT WOULD LEAD TO INFINITE
    LOOPS
DE- PROLOG; LOGIC PROGRAMMING
ID- TRANSITIVE RELATIONS; UNWANTED LOOPS; PROLOG; SYMMETRICAL RELATIONS;
    BICONDITIONALS; BLOCKING RECURSION; INFINITE LOOPS
 
TI- DATA-FLOW BASED EXECUTION MECHANISMS OF PARALLEL AND CONCURRENT PROLOG
AU- ITO, N.; SHIMIZU, H.; KISHI, M.; KUNO, E.; ROKUSAWA, K.
CS- INST. FOR NEW GENERATION COMPUT. TECHNOL., TOKYO, JAPAN; 
JN- NEW GENERATION COMPUT. (JAPAN) VOL.3, NO.1 15-41
PY- 1985
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 19
AB- THE AUTHORS ATTEMPT TO SHOW THAT THEIR MACHINE ARCHITECTURE BASED ON
    THE DATA FLOW MODEL IS SUITABLE FOR TWO TYPES OF LOGIC PROGRAMMING
    LANGUAGES WITH DIFFERENT AIMS: PARALLEL PROLOG AND CONCURRENT PROLOG.
    THE DATA FLOW MODEL CAN NATURALLY IMPLEMENT PARALLEL COMPUTATION, AND
    IT HAS CLOSE SIMILARITY TO THESE LANGUAGES. UNIFICATION AND
    NONDETERMINISTIC CONTROL, TWO BASIC FUNCTIONS OF THESE LANGUAGES, ARE
    REPRESENTED BY DATA FLOW GRAPHS AND INTERPRETED BY THE MACHINE. SEVERAL
    REPRESENTATIONS OF VARIABLES, THAT FACILITATE THE DEVELOPMENT OF
    PARALLEL UNIFICATION AND NONDETERMINISTIC CONTROL MECHANISMS FOR THESE
    LANGUAGES, AND THE UNIFICATION AND CONTROL PRIMITIVES NEEDED TO EXECUTE
    THESE LANGUAGES ON THIS ARCHITECTURE ARE PRESENTED
DE- PARALLEL PROCESSING; LOGIC PROGRAMMING; PROLOG
ID- PARALLEL PROCESSING; CONCURRENT PROLOG; MACHINE ARCHITECTURE; DATA FLOW
    MODEL; LOGIC PROGRAMMING LANGUAGES; PARALLEL PROLOG; PARALLEL
    COMPUTATION; NONDETERMINISTIC CONTROL; PARALLEL UNIFICATION


TI- Cooperating rewrite processes for natural-language analysis
AU- Filgueiras, M.
CS- Centro de Inf., Porto Univ., Portugal
JN- J. Logic Program. (USA) vol.3, no.4 279-98
PY- Dec. 1986
CD- <US Copyright Clearance Center Code> 0743-1066/86/$03.50
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 17
AB- General methods for understanding a natural language based on the
    intensive use of rewrite rules and on the existence of several
    cooperating processes are put forward. The choice of Horn-clause logic
    as the underlying formalism for semantic representations, together with
    the employment of unification as pattern-matching procedure and
    depth-first search with backtracking were derived from
    logic-programming ideas, in particular from the use of PROLOG. Several
    examples are presented to illustrate how these methods work
DE- logic programming; natural languages; PROLOG
ID- rewrite processes; natural-language analysis; rewrite rules;
    cooperating processes; Horn-clause logic; semantic representations;
    pattern-matching procedure; logic-programming; PROLOG
 
TI- Cooperating rewrite processes for natural-language analysis
AU- Filgueiras, M.
CS- Centro de Inf., Porto Univ., Portugal
JN- J. Logic Program. (USA) vol.3, no.4 279-98
PY- Dec. 1986
CD- <US Copyright Clearance Center Code> 0743-1066/86/$03.50
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 17
AB- General methods for understanding a natural language based on the
    intensive use of rewrite rules and on the existence of several
    cooperating processes are put forward. The choice of Horn-clause logic
    as the underlying formalism for semantic representations, together with
    the employment of unification as pattern-matching procedure and
    depth-first search with backtracking were derived from
    logic-programming ideas, in particular from the use of PROLOG. Several
    examples are presented to illustrate how these methods work
DE- logic programming; natural languages; PROLOG
ID- rewrite processes; natural-language analysis; rewrite rules;
    cooperating processes; Horn-clause logic; semantic representations;
    pattern-matching procedure; logic-programming; PROLOG
 
TI- A technique for doing lazy evaluation in logic
AU- Narain, S.
CS- Dept. of Info. Sci., Rand Corp., Santa Monica, CA, USA
JN- J. Logic Program. (USA) vol.3, no.3 259-76
PY- Oct. 1986
CD- <US Copyright Clearance Center Code> 0743-1066/86/03.50
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 24
AB- The author develops a natural technique for defining functions in
    logic, i.e. PROLOG, which directly yields lazy evaluation. Its use does
    not require any change to the PROLOG interpreter. Function definitions
    run as PROLOG programs and so run very efficiently. It is possible to
    combine lazy evaluation with nondeterminism and simulate coroutining.
    It is also possible to handle infinite data structures and implement
    networks of communicating processes. The author analyzes this technique
    and develops a precise definition of lazy evaluation for lists. For
    further efficiency he shows how to preprocess programs and ensure,
    using logical variables, that values of expressions once generated are
    remembered for future access. Finally, he shows how to translate
    programs in a simple functional language into programs using this
    technique
DE- list processing; logic programming; PROLOG
ID- lazy evaluation; PROLOG; infinite data structures; lists; logical
    variables; functional language
 
TI- LOGIN: a logic programming language with built-in inheritance
AU- Ait-Kaci, H.; Nasr, R.
CS- Artificial Intelligence Program, Microelectron. & Comput. Technol.
    Corp., Austin, TX, USA
JN- J. Logic Program. (USA) vol.3, no.3 185-215
PY- Oct. 1986
CD- <US Copyright Clearance Center Code> 0743-1066/86/03.50
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 10
AB- An elaboration of the PROLOG language is described in which the notion
    of first-order term is replaced by a more general one. This extended
    form of terms allows the integration of inheritance-an IS-A
    taxonomy-directly into the unification process rather than indirectly
    through the resolution-based inference mechanism of PROLOG. This
    results in more efficient computations and enhanced language
    expressiveness. The language thus obtained, called LOGIN, subsumes
    PROLOG, in the sense that conventional PROLOG programs are equally well
    executed by LOGIN
DE- high level languages; logic programming; PROLOG
ID- LOGIN; logic programming language; built-in inheritance; PROLOG; I S- A
    taxonomy; language expressiveness
 
TI- Logic programming
AU- Kriz, J.; Sugaya, H.
CS- Brown Boveri, Baden, Switzerland
AU- <Editor> Guth, R.
JN- Computer Systems for Process Control. Proceedings of a Brown Boveri
    Symposium 305-41
PY- 1986
CL- Baden, Switzerland
CY- 2-3 Sept. 1985
PU- Plenum New York, USA
PG- xxvi+346
BN- 0 306 42386 3
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- GENERAL,REVIEW; PRACTICAL; 
RF- 28
AB- The concepts of logic programming have not yet been fully realized,
    because of the large requirements on memory and execution time of
    conventional computers. The programming language Prolog is based on
    logic programming, but employs various additional logical features in
    order to be a practical programming language. Recent advances in
    compilation and hardware design are continuously improving the
    feasibility of logic-based programming languages for industrial
    applications. At the BBC Research Center, the system Modula-Prolog is
    being used for fast prototyping and knowledge engineering.
    Modula-Prolog permits the arbitrary combination of Modula-2 and Prolog
    programs and hence utilizes the advantages of both procedural and logic
    programming. Modula-Prolog has been applied to the development of
    knowledge-based expert systems for the configuration and diagnosis of
    technical systems
DE- expert systems; logic programming; Modula; PROLOG
ID- logic programming; procedural programming; memory; execution time;
    Prolog; practical programming language; compilation; hardware design;
    industrial applications; BBC Research Center; Modula-Prolog; knowledge
    engineering; knowledge-based expert systems; diagnosis; technical
    systems
 
TI- Test sets generation from algebraic specifications using logic
    programming
AU- Bouge, L.; Choquet, N.; Fribourg, L.; Gaudel, M.-C.
CS- Paris Univ., France; 
JN- J. Syst. & Software (USA) vol.6, no.4 343-60
PY- Nov. 1986
CD- <US Copyright Clearance Center Code> 0164-1212/86/$3.50
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; THEORETICAL; 
RF- 47
AB- The authors present a method and a tool for generating test sets from
    algebraic data type specifications. They give formal definitions of the
    basic concepts required in their approach to functional testing. They
    discuss the problem of testing algebraic data types implementations.
    This allows the introduction of additional hypotheses and thus the
    description of a method for generating test sets. The implementation of
    the method is based on logic programming. Some limitations of PROLOG
    are discussed and two extensions are presented, METALOG and SLOG, which
    allow good implementations of the method
DE- data structures; logic programming; program testing; PROLOG
ID- algebraic specifications; logic programming; data type specifications;
    functional testing; PROLOG; METALOG; SLOG
 
TI- Negative knowledge toward a strategy for asking in logic programming
AU- Edmonds, E.
CS- Dept. of Comput. Studies, Loughborough Univ. of Technol., England
JN- Int. J. Man-Mach. Stud. (GB) vol.24, no.6 597-600
PY- June 1986
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- THEORETICAL; 
RF- 5
AB- Rule-based systems that ask the user and that also allow a not operator
    to be used in the rules have existed for some time. The paper briefly
    explores an idea of Edmonds (1984) for bringing together such recent
    development within logic programming in order to provide a logic-based
    system with an integral, automatic, strategy for asking. The discussion
    shows that a simple and natural interpretation of PROLOG can provide a
    step towards logic-based human-computer co-operation
DE- expert systems; interactive systems; logic programming; PROLOG
ID- rule-based systems; negative knowledge; NOT operator; asking; logic
    programming; logic-based system; PROLOG; human-computer co-operation
 
TI- Implementing parallel algorithms in Concurrent PROLOG: the MAXFLOW
    experience
AU- Hellerstein, L.; Shapiro, E.
CS- Weizmann Inst. of Sci., Rehovoth, Israel
JN- J. Logic Program. (USA) vol.3, no.2 157-84
PY- July 1986
CD- <US Copyright Clearance Center Code> 0743-1066/86/$03.50
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 11
AB- This paper reports on the experience of implementing Shiloach and
    Vishkin's parallel MAXFLOW algorithm (1982) in Concurrent PROLOG. The
    major difficulties in this endeavor were understanding the algorithm
    and adapting it to the computational model of Concurrent PROLOG. In
    spite of the difficulties, the authors were able to produce a
    Concurrent PROLOG program that implements the algorithm and achieves
    the expected complexity bounds. The lack of destructive assignment in
    the logic program's computation model prevents PROLOG from being an
    efficient implementation language for many sequential algorithms. The
    main conclusion is that, in concurrent algorithms, message passing is a
    powerful substitute for destructive assignment. It is therefore
    possible to write efficient Concurrent PROLOG implementations of
    concurrent algorithms
DE- logic programming; parallel algorithms; parallel programming; PROLOG
ID- logic programming; parallel algorithms; parallel MAXFLOW algorithm;
    Concurrent PROLOG; complexity bounds; sequential algorithms; concurrent
    algorithms; message passing
 
 
TI- Analysis of sequential PROLOG programs
AU- Onai, R.; Shimizu, H.; Masuda, K.; Oso, M.
CS- ICOT Res. Center, Inst. for New Generation Comput. Technol., Tokyo,
    Japan
JN- J. Logic Program. (USA) vol.3, no.2 119-41
PY- July 1986
CD- <US Copyright Clearance Center Code> 0743-1066/86/$03.50
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 20
AB- The authors consider the characteristics of sequential PROLOG programs
    using static and dynamic analyzers. They were developed to analyze
    ICOT-developed PROLOG programs and to collect various data items for
    studying program characteristics. Thirty-nine programs were
    statistically analyzed; two of these were also analyzed dynamically.
    The static analyzer is written in DEC-10 PROLOG. It simply reads a
    program from the beginning and outputs various types of information
    about the program. The dynamic analyzer is also written in DEC-10
    PROLOG. It executes a program that can be executed in parallel by
    providing a goal for the program. During the execution, it collects
    various data including those obtained in the static analysis
DE- logic programming; program testing; PROLOG
ID- logic programming; sequential PROLOG programs; static analyzer; DEC-10
    PROLOG; dynamic analyzer
 
TI- Experimenting with parallel programming in logic
AU- Waksman, A.
CS- Temple Univ., Philadelphia, PA, USA
CS- <Sponsor> US Army Res. Office
JN- Proceedings of the Workshop on Future Directions in Computer
    Architecture and Software 323-5
PY- 1986
CL- Charleston, SC, USA
CY- 5-7 May 1986
PU- US Army Res. Office Research Triangle Park, NC, USA
PG- v+414
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
AB- Presents an extension to the logic programming language Prolog, SISPRO
    (Super is Prolog). This extension is on a very small scale but is
    typical of other efforts in this area to extend the capability of
    purely logic programs to handle also functional constructs. The
    motivation for efforts in this direction is to remove obstacles in
    bringing about the further development of a very promising software
    tool
DE- logic programming; parallel programming; PROLOG
ID- parallel programming; logic; logic programming language; Prolog; SISPRO
    ; Super is Prolog; logic programs; functional constructs; software tool
    
 
TI- A procedural approach to search control in Prolog
AU- Devanbu, P.; Freeland, M.; Naqvi, S.
CS- AT&T Bell Labs., Murray Hill, NJ, USA
JN- ECAI '86. 7th European Conference on Artificial Intelligence.
    Proceedings 53-7 vol.2
PY- 1986
CL- Brighton, England
CY- 21-25 July 1986
PU- Conference Services London, England
PG- 2 vol. (597+xxxii+187)
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 6
AB- A nice feature of Prolog is its almost purely declarative nature, i.e.,
    a program is a description of the problem, and the inference engine
    executes this description. Yet this lack of procedural control
    manifests itself in many a woefully inefficient program. The authors
    present an approach to implementing explicit search control in Prolog
    that is simple, powerful and distinct from the declarative portion of
    the program, thus following R. Kowalski's maxim that
    'algorithm=logic+control'
DE- logic programming; PROLOG
ID- procedural approach; search control; Prolog; declarative nature;
    inference engine; inefficient program
 
TI- PROSELOG: a readability improvement for logic programming
AU- Hill, G.
CS- IBM Corp., Tucson, AZ, USA
CS- <Sponsor> IEEE; Arizona State Univ
JN- Fifth Annual International Phoenix Conference on Computers and
    Communications: PCCC'86. 1986 Conference Proceedings (Cat.
    No.86CH2371-3) 379-85
PY- 1986
CL- Scottsdale, AZ, USA
CY- 26-28 March 1986
PU- IEEE Comput. Soc. Press Washington, DC, USA
PG- xx+720
BN- 0 8186 0691 6
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 4
AB- PROLOG is a powerful logic programming language which has recursion,
    backtracking, unification and inference capabilities. However, an area
    which could be improved is the syntax of the language, because it is in
    prefix order, which makes reading sizable PROLOG programs difficult. In
    response to this problem, the PROSELOG language was developed. PROSELOG
    is a prose-like logic programming language which has the same powerful
    capabilities as PROLOG, but with a more user-friendly syntax which
    filters out 'noise' words, such as 'a', 'an' or 'the'. It allows
    prefix, infix and postfix orders, as well as any combination of them,
    as desired by the programmer who wishes to make logic programs resemble
    spoken language. A discussion is presented of the PROSELOG language,
    examples with associated output are given, and the compiler and
    interpreter which were developed for the language are described
DE- logic programming; program compilers; program interpreters; PROLOG
ID- improved program readability; infix order; postfix order; improved
    program comprehensibility; PROSELOG; PROLOG; logic programming language
    ; prefix order; user-friendly syntax; compiler; interpreter
 
TI- Propositional branching time temporal logic in PROLOG
AU- Papapanagiotakis, G.; Azema, P.; Pradin-Chezalviel, B.
CS- Lab. d'Autom. et d'Anal. des Syst., CNRS, Paris, France
CS- <Sponsor> IEEE; Arizona State Univ
JN- Fifth Annual International Phoenix Conference on Computers and
    Communications: PCCC'86. 1986 Conference Proceedings (Cat.
    No.86CH2371-3) 371-7
PY- 1986
CL- Scottsdale, AZ, USA
CY- 26-28 March 1986
PU- IEEE Comput. Soc. Press Washington, DC, USA
PG- xx+720
BN- 0 8186 0691 6
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; THEORETICAL; 
RF- 11
AB- An interpretation is presented of propositional branching-time temporal
    logic in terms of logic programming. The main target of this work is to
    find a method for formally verifying concurrent systems. PROLOG
    interpreted Petri nets and PROLOG interpreted propositional
    branching-time temporal logic are used to supply, respectively, a model
    and specifications. As an example, the model of a distributed mutual
    exclusion algorithm is built and some fundamental properties of this
    algorithm are verified
DE- directed graphs; distributed processing; formal logic; logic
    programming; program verification; PROLOG
ID- formal concurrent-systems verification; logic programming; PROLOG
    interpreted Petri nets; PROLOG interpreted propositional branching-time
    temporal logic; distributed mutual exclusion algorithm
 
TI- A PROLOG based graphical approach for knowledge expression
AU- Rueher, M.; Thomas, M.-C.; Gubert, A.; Ladret, D.
CS- Lab. d'Inf. de SophiaAntipolis, Nice Univ., France
JN- Microsoftware Eng. (GB) vol.2, no.4 249-54
PY- Oct. 1986
CD- <US Copyright Clearance Center Code> 0266-9463/86/020249-06$2.00
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 12
AB- To facilitate knowledge expression the authors propose a graphical
    representation for the Prolog logic programming language. This paper
    outlines the main features of their system and describes shortly the
    implementation on a Macintosh computer. A non trivial example shows the
    possibilities of the system
DE- Apple computers; knowledge engineering; logic programming; PROLOG
    listings; software tools; specification languages
ID- executable specifications; knowledge expression; graphical
    representation; Prolog logic programming language; Macintosh computer
 
TI- Logic programming: a tool for MS/OR?
AU- Bharath, R.
CS- Dept. of Comput. Inf. Syst., Northern Michigan Univ., Marquette, MI,
    USA
JN- Interfaces (USA) vol.16, no.5 80-91
PY- Sept.-Oct. 1986
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 21
AB- Japan's fifth generation computer systems for the 1990s and the
    associated subjects of logic programming, expert systems, and the
    programming language PROLOG have received much publicity lately. The
    background to these subjects is summarized, followed by a minitutorial
    in PROLOG, a language relevant and potentially useful for MS/OR
DE- fifth generation systems; logic programming; management science;
    operations research; PROLOG
ID- management science; operations research; MS/OR; fifth generation
    computer systems; logic programming; expert systems; programming
    language; PROLOG
 
TI- A note on implementing PROLOG in LISP
AU- Stojanovski, J.
CS- Dept. of Comput. Sci., Jozef Stefan Inst., Ljubljana, Yugoslavia
JN- Inf. Process. Lett. (Netherlands) vol.23, no.5 261-4
PY- 24 Nov. 1986
CD- <US Copyright Clearance Center Code> 0020-0190/86/$3.50
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; THEORETICAL; 
RF- 12
AB- The author discusses the implementation of the 'cut' primitive and the
    'last call optimisation' (also called tail recursion optimisation) of
    Prolog in Lisp
DE- LISP; logic programming; program interpreters; PROLOG
ID- last call optimisation; tail recursion optimisation; Prolog; Lisp
 
TI- The value of an array facility in Prolog
AU- Chen, G.; Williams, M.H.
CS- Dept. of Comput. Sci., Heriot-Watt Univ., Edinburgh, Scotland
JN- Inf. Process. Lett. (Netherlands) vol.23, no.5 247-51
PY- 24 Nov. 1986
CD- <US Copyright Clearance Center Code> 0020-0190/86/$3.50
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- EXPERIMENTAL; 
RF- 3
AB- It was decided to add a facility to handle arrays to the C-Prolog
    interpreter in order to assess its effect on the performance. As far as
    the user is concerned this entails the definition of three basic
    operations, viz. creation of an array, access to an array element, and
    update of an array element. The system described uses two different
    update operations and the applicative semantics of Prolog is preserved
    by performing a flow analysis of the Prolog program to determine which
    operations should be used at which points. It was expected that with
    the optimization of the use of destructive update operations, the
    performance of the resulting programs in general should be improved.
    However, the results were unexpectedly disappointing
DE- data structures; logic programming; PROLOG
ID- C-Prolog interpreter; update operations; applicative semantics; flow
    analysis; destructive update operations
 
TI- Prolog
AU- Wilkerson, R.W.
CS- Dept. of Comput. Sci., Missouri Univ., Rolla, MO, USA
JN- IEEE Potentials (USA) vol.5, no.3 22-5
PY- Oct. 1986
CD- <US Copyright Clearance Center Code> 0278-6648/86/1000-0022$01.00
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- APPLIC; GENERAL,REVIEW; 
AB- A description is given of Prolog, a contraction of PROgramming in
    LOGic, which uses the formalism of mathematical logic as its primary
    design principle. The structure of Prolog is examined, and a database
    program is described to illustrate its application. An application to
    an artificial intelligence problem, the Towers of Hanoi, is also given
DE- artificial intelligence; database management systems; logic programming
    ; PROLOG
ID- Prolog; PROgramming; LOGic; mathematical logic; database program;
    artificial intelligence problem; Towers of Hanoi
 
TI- Burstall-Darlington program transformation method applied to logic
    programming
AU- Azibi, N.; Costa, E.J.; Kodratoff, Y.
CS- LRI, Univ. de Paris-Sud, Orsay, France; 
JN- Artificial Intelligence and Advanced Computer Technology
    Conference/Exhibition. 2nd Presentation. Conference Proceedings 17 pp.
PY- 1986
CL- Rhein-Main-Halle, Wiesbaden, Germany
CY- 23-25 Sept. 1986
PU- TCM Expositions Liphook, Hants., England
PG- 504
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 12
AB- The article explains the different steps of the method which consists
    in automatically finding the predicate GEN (GENeralized), called
    EUREKA. This predicate is candidate for the Burstall-Darlington
    FOLDING/UNFOLDING mechanism. The goal of these manipulations is the
    transformation of recursive PROLOG programs into quasi-iterative
    programs
DE- logic programming; program interpreters; PROLOG
ID- Burstall-Darlington program transformation; logic programming;
    predicate; recursive PROLOG programs; quasi-iterative programs
 
TI- Objects in concurrent logic programming languages
AU- Kahn, K.; Tribble, E.D.; Miller, M.S.; Bobrow, D.G.
CS- Intelligent Syst. Lab., Xerox Palo Alto Res. Center, CA, USA
CS- <Sponsor> ACM
JN- SIGPLAN Not. (USA) vol.21, no.10 29-38
PY- Oct. 1986
CT- Object-Orientated Programming Workshop
CL- Yorktown Heights, NY, USA
CY- 9-13 June 1986
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 8
AB- Concurrent Prolog supports object-oriented programming with a clean
    semantics and additional programming constructs such as incomplete
    messages, unification, direct broadcasting, and concurrency
    synchronization. While it provides excellent computational support, the
    authors claim it does not provide good notation for expressing the
    abstractions of object-oriented programming. They describe a
    preprocessor that remedies this problem. The resulting language,
    Vulcan, is then used as a vehicle for exploring new variants of
    object-oriented programming which become possible in this framework
DE- data structures; high level languages; logic programming; parallel
    programming; program processors; PROLOG
ID- data abstraction; concurrent logic programming languages; Concurrent
    Prolog; object-oriented programming; Vulcan
 
TI- Logicon: an integration of Prolog into Icon
AU- Lapalme, G.; Chapleau, S.
CS- Dept. d'Informatique et de Recherche Operationnelle, Montreal Univ.,
    Que., Canada
JN- Software-Pract. & Exper. (GB) vol.16, no.10 925-44
PY- Oct. 1986
CD- <US Copyright Clearance Center Code> 0038-0644/86/100925-20$10.00
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 12
AB- This paper describes the coupling of logic programming with Icon, which
    is a programming language aimed at string processing. Icon and Prolog
    have many similarities and their integration is feasible and desirable
    because the weaknesses of one can be compensated for by the strengths
    of the other. In our case, a Prolog interpreter was written as an Icon
    procedure that can be linked and called by an Icon program. This
    interpreter deals with all Icon data types and can be called in the
    context of the goal-directed evaluation of Icon. The authors give an
    example showing the power of this symbiosis between these two languages
    where a Prolog call in Icon is a generator and an Icon call in a Prolog
    clause is a built-in predicate
DE- high level languages; logic programming; PROLOG
ID- language integration; Logicon; Prolog; Icon; logic programming;
    programming language; string processing; data types; goal-directed
    evaluation; built-in predicate
 
TI- A reduction model for parallel interpretation of logic programs
AU- Wang Lun
CS- Dept. of Comp. Sci. & Eng., Harbin Inst. of Technol., China.
CS- <Sponsor> SPIE
JN- Proc. SPIE Int. Soc. Opt. Eng. (USA) vol.657 120-1
PY- 1986
CT- Applications of Artificial Intelligence IV
CL- Innsbruck, Austria
CY- 15-16 April 1986
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- THEORETICAL; 
RF- 7
AB- Applicative models of computation based on applicative languages have,
    in recent years, received considerable attention as an attractive
    alternative to the Von Neumann model. Prolog is a high level
    applicative language. Its execution is conceptually an AND-OR tree
    search based on resolution proof procedure. The paper presents a
    reduction model for parallel interpretation of applicative languages
    such as Prolog and LISP. Reduction semantics of logic programs is
    analysed. A new classification of proposed models for parallel
    execution of logic programs is also given
DE- logic programming; parallel programming; PROLOG
ID- PROLOG; high level languages; reduction, semantics; reduction model;
    parallel interpretation; logic programs; applicative languages; AND-OR
    tree search; resolution proof procedure; LISP
 
TI- Uranus reference manual for V-11 (including Prolog/KR)
AU- Nakashima, H.
CS- Electrotech. Lab., Ibaraki, Japan
JN- Bull. Electrotech. Lab. (Japan) vol.50, no.8 829-910
PY- 1986
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
AB- This is a reference manual for a logic-based knowledge representation
    system Uranus (Universal Representation-Aimed Novel Uranus System).
    Uranus stems from Prolog/KR, which is a superset of Prolog. This manual
    is intended to be used both for Uranus and Prolog/KR. Uranus is an
    interactive logic programming system designed to support programs
    manipulating symbols and structures, especially artificial intelligence
    programs embedding knowledge. Uranus is equipped with some of the basic
    tools used in AI programs: pattern matching, backtracking, multiple
    world mechanism, etc. Manipulating structures in Uranus is much simpler
    than in Lisp. Manipulating modular knowledge in Uranus is much simpler
    than in Prolog. Thus, a programmer can start at a point closer to the
    solution. The main difference between Uranus and other logic
    programming languages is that Uranus consists of multiple worlds and
    the user has the control over those worlds (this is why the system is
    called Uranus after the name of the God of the universe). Uranus is
    available on Symbolics lisp-machines. Prolog/KR is available on Hitachi
    and Fujitsu M series, DEC-20 and VAX
DE- artificial intelligence; interactive systems; logic programming; PROLOG
    ; user manuals
ID- Uranus reference manual; logic-based knowledge representation system;
    Universal Representation-Aimed Novel Uranus System; superset of Prolog;
    Uranus; Prolog/KR; interactive logic programming system; programs
    manipulating symbols; artificial intelligence programs embedding
    knowledge; pattern matching; backtracking; multiple world mechanism
 
TI- A survey of control facilities in logic programming
AU- Vasak, T.
CS- Dept.of Comput. Sci., New South Wales Univ., Kensington, NSW, Australia
JN- Aust. Comput. J. (Australia) vol.18, no.3 136-45
PY- Aug. 1986
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- GENERAL,REVIEW; PRACTICAL; THEORETICAL; 
RF- 37
AB- One of the major problems in logic programming that needs to be
    overcome is the provision of control facilities more powerful than
    those currently available yet which preserve the declarative semantics
    of programs. The topic has been the subject of considerable research in
    recent years with many diverse approaches being taken. This survey
    provides a critical overview of these various attempts, highlighting
    their strengths and weaknesses
DE- logic programming; PROLOG
ID- PROLOG; control facilities; logic programming; declarative semantics
 
TI- Automated reasoning in geometry theorem proving with PROLOG
AU- Coelho, H.; Pereira, L.M.
CS- Lab. Nacional de Engenharia Civil, Lisboa, Portugal
JN- J. Autom. Reasoning (Netherlands) vol.2, no.4 329-90
PY- Dec. 1986
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- APPLIC; THEORETICAL; 
RF- 21
AB- Describes automated reasoning in a PROLOG Euclidean geometry
    theorem-prover. It brings into focus general topics in automated
    reasoning and the ability of PROLOG in coping with them
DE- geometry; logic programming; PROLOG; theorem proving
ID- GEOM; geometry theorem proving; PROLOG; Euclidean geometry; automated
    reasoning
 
TI- Programming in logic for power systems control
AU- Gann, J.O.; Irving, M.R.; Sterling, M.J.H.
CS- Durham Univ., England
JN- Second International Conference on Power System Monitoring and Control
    (Conf. Publ. No.266) 372-7
PY- 1986
CL- Durham, England
CY- 8-11 July 1986
PU- IEE London, England
PG- xii+405
BN- 0 85296 331 9
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 9
AB- The objective of the control of an electrical power system is to
    provide a secure supply, within physical constraints, at minimum cost.
    This optimisation requires the solution to a number of complex problems
    on time scales from a few seconds to several years. To achieve this
    objective requires an increasing use of computers throughout all layers
    of a power system. The authors describe how logic, in the form of the
    computer language PROLOG, may be applied in the field of computer
    assisted power systems control. Network topology and observability
    determination are used to show how the burden of computer programming
    in the problem solving process may be lessened, leading to a potential
    for a wider applicability in complex online control schemes
DE- logic programming; power system computer control; PROLOG
ID- logic programming; power systems control; optimisation; computer
    language PROLOG; computer assisted power systems control; observability
    ; online control
 
 
TI- Turbo PROLOG: another miracle?
AU- Swan, T.
JN- Program. J. (USA) vol.4, no.5 27-8, 30-1, 34
PY- Sept.-Oct. 1986
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; PRODUCT REVIEW; 
AB- A review of Borland's Turbo PROLOG is given. The author discusses
    whether it is in fact PROLOG and how it handles logic programming.
    Finally, he questions whether PROLOG will replace Pascal
DE- logic programming; program compilers; programming environments; PROLOG;
    software packages
ID- programming environments; software packages; Borland; compilers; Turbo
    PROLOG; logic programming
 
TI- Concurrent Prolog: a progress report
AU- Shapiro, E.
CS- Weizmann Inst. of Sci., Rehovot, Israel
JN- Computer (USA) vol.19, no.8 44-58
PY- Aug. 1986
CD- <US Copyright Clearance Center Code> 0018-9162/86/0800-0044$01.00
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 48
AB- Concurrent Prolog is a logic programming language designed for
    concurrent programming and parallel execution. A process-oriented
    language, it embodies dataflow synchronization and guarded-command
    indeterminancy as its basic control mechanisms. The basic concepts and
    definition of the language are outlined and the major programming
    techniques that emerged out of three years of its use are surveyed. The
    history of the language development, implementation, and applications
    are reviewed
DE- logic programming; parallel processing; PROLOG; synchronisation
ID- logic programming language; concurrent programming; parallel execution;
    process-oriented language; dataflow synchronization; guarded-command
    indeterminancy; control mechanisms; language development
 
TI- The lion and the unicorn meet PROLOG (automatic theorem-proving)
AU- Ramsey, B.D.
CS- Div. of Gen. Products, IBM Corp., Tucson, AZ, USA
JN- SIGPLAN Not. (USA) vol.21, no.8 62-70
PY- Aug. 1986
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 9
AB- A recent paper by H.J. Ohlbach and M. Schmidt-Schauss (see Journal of
    Automated Reasoning, no.1, p.327-32, 1985) described ways to apply
    automatic theorem-proving techniques to a logic puzzle. The PROLOG
    programming language pertains to automatic theorem-proving. The paper
    did not mention PROLOG, but in this paper the author uses PROLOG to
    solve the logic puzzle the other paper discussed. He compares his
    results with the results given in the paper
DE- logic programming; PROLOG; theorem proving
ID- logic programming; automatic theorem-proving; logic puzzle; PROLOG
 
TI- Analogical reasoning using transformations of rules
AU- Haraguchi, M.
CS- Res. Inst. of Fundamental Inf. Sci., Kyushu Univ. Fukuoka, Japan
JN- Bull. Inf. & Cybern. (Japan) vol.22, no.1-2 1-8
PY- March 1986
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- THEORETICAL; 
RF- 13
AB- A formalism of analogical reasoning is presented. The analogical
    reasoning can be considered as a deduction with a function of
    transforming logical rules. From this viewpoint, the reasoning is
    defined in terms of deduction, and is therefore realized in a logic
    programming system. The reasoning system is described as an extension
    of a Prolog interpreter
DE- artificial intelligence; formal logic; logic programming; program
    interpreters; programming theory; PROLOG
ID- logical rule transformations; analogical reasoning; deduction; logic
    programming system; Prolog interpreter
 
TI- Logic modelling
AU- Futo, I.; Gergely, T.; Deutsch, T.
AU- <Editor> Kerckhoffs, E.J.H.; Vansteenkiste, G.C.; Zeigler, B.P.
CS- <Sponsor> Belgium Nat. Sci. Res. Found; Minist. Educ.; Comm. Eur.
    Communities
JN- AI Applied to Simulation. Proceedings of the European Conference 117-29
PY- 1986
CL- Ghent, Belgium
CY- 25-28 Feb. 1985
PU- SCS San Diego, CA, USA
PG- xii+205
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 11
AB- The authors aim is to provide a modelling tool for analysis or/and
    synthesis of goal-oriented systems. In the paper they give a detailed
    description of the modelling as a cognitive process showing that in the
    different phase of modelling one uses different languages. They show
    how logic-more exactly a constructive part of logic-is appropriate for
    modelling and how System Theory can be used as a systematization
    principle for model construction. Finally a modelling and problem
    solving system called TS-PROLOG based on a restricted version of the
    first order predicate calculus is introduced and its use is shown on an
    insulin administration problem
DE- knowledge engineering; logic programming; modelling; PROLOG
ID- modelling tool; goal-oriented systems; cognitive process; System Theory
    ; systematization principle; model construction; problem solving system
    ; TS-PROLOG; insulin administration problem
 
TI- FProlog: a language to integrate logic and functional programming for
    automated assembly
AU- Hutchinson, S.A.; Kak, A.C.
CS- Sch. of Electr. Eng., Purdue Univ., W. Lafayette, IN, USA
CS- <Sponsor> IEEE
JN- Proceedings 1986 IEEE International Conference on Robotics and
    Automation (Cat. No.86CH2282-2) 904-9 vol.2
PY- 1986
CD- <US Copyright Clearance Center Code> CH2282-2/86/0000-0904$01.00
CL- San Francisco, CA, USA
CY- 7-10 April 1986
PU- IEEE Comput. Soc. Press Washington, DC, USA
PG- 3 vol. xxxvi+2051
BN- 0 8186 0695 9
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 15
AB- The authors present FProlog, a programming language designed to act as
    the top level in a robot assembly system. FProlog is a logic
    programming language, with the ability to interface with LISP. This
    allows the use of a logic programming environment to construct assembly
    plans, while using LISP programs to interface with vision systems,
    world modelling systems, robot manipulators, etc. FProlog differs from
    hybrid logic programming languages, such as LOGLISP, in that FProlog
    may invoke functional programs as goals, and the functional programs
    may invoke FProlog's inference engine. Also, FProlog differs from
    traditional robot assembly languages, such as AUTOPASS, in its
    generality, and therefore its ability to interface with many different
    subsystems. As a demonstration of the applicability of FProlog, the
    authors present an FProlog program which is used as the top level in a
    robot assembly system which performs a version of the block world
    experiment
DE- assembling; logic programming; PROLOG; robots
ID- FProlog; functional programming; automated assembly; robot assembly
    system; logic programming; LISP; block world experiment
 
TI- Pitfalls in Prolog programming
AU- Ng, K.W.; Ma, W.Y.
CS- Dept. of Comput. Sci., Chinese Univ. of Hong Kong, Shatin, Hong Kong
JN- SIGPLAN Not. (USA) vol.21, no.4 75-9
PY- April 1986
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 1
AB- A programming language is an intermediate medium between the human user
    and the machine. Ideally is should reduce the gap between human
    reasoning and the machine's processing mechanism to the minimum.
    Accordingly, none of the contemporary programming languages can be said
    to be ideal. Prolog is no exception. However, it is usually emphasized
    that programming in Prolog is very easy, even a beginner can handle it
    within a few hours of learning. The rationale behind this conception is
    that Prolog clauses are actually some logical statements, and logic is
    the basis of every rational subject. The problem arises in that Prolog
    programming is not equivalent to logic programming. Prolog still shares
    the effect of the influence of the fundamental Von Neumann computer
    architecture on conventional programming languages. If a user wants to
    write a Prolog program just according to his logical reasoning, he will
    probably fall into an unexpected trap of the language
DE- logic programming; PROLOG
ID- Prolog programming; programming language; Prolog clauses; logic
    programming
 
TI- Normalization of relations and Prolog
AU- Ceri, S.; Gottlob, G.
CS- Dipartimento di Elettronica, Politecnico de Milano, Italy
JN- Commun. ACM (USA) vol.29, no.6 504-44
PY- June 1986
CD- <US Copyright Clearance Center Code> 0001-0782/86/0600-0524$00.75
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 30
AB- A program for the normalization of relations that is written in Prolog
    has several advantages relative to programs written in conventional
    programming languages: notably, conciseness and clarity. The program
    presented by the authors implements several normalization algorithms
    and is suitable for the interactive design of small database
    applications and as a teaching aid
DE- database management systems; logic programming; PROLOG; PROLOG listings
ID- normalization algorithms; database applications; teaching aid
 
TI- A controllable PROLOG database system
AU- Minsky, N.; Rosenshtein, D.; Chomicki, J.
CS- Dept. of Comput. Sci., Rutgers Univ., New Brunswick, NJ, USA
CS- <Sponsor> IEEE
JN- International Conference on Data Engineering (Cat. No.86CH2261-6)
    618-28
PY- 1986
CD- <US Copyright Clearance Center Code> CH2261-6/86/0000-00618$01.00
CL- Los Angeles, CA, USA
CY- 5-7 Feb. 1986
PU- IEEE Comput. Soc. Press Washington, DC, USA
PG- xvii+732
BN- 0 8186 0655 X
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 24
AB- A model is presented which provides a single comprehensive mechanism to
    control the use, operation and evolution of database systems. This
    model unifies several concepts generally considered to be quite
    distinct. In particular, it minimizes the formal distinction between
    the users of the database, the programs embedded in it, and even the
    administrators and the programmers maintaining it. Under this model,
    the concepts of subschema and of program module are replaced with a
    single concept of frame, which serves as the locus of power and of
    activity in the system. The proposed control mechanism is closed, in
    the sense that the process of establishing controls is itself
    controllable by the same mechanism. This can be used to formalize and
    control managerial policies about the use and evolution of database
    systems
DE- database management systems; logic programming; PROLOG; software
    reliability
ID- database reliability; controllable PROLOG database; control mechanism
 
TI- Multiway merge with constant delay in Concurrent Prolog
AU- Shapiro, E.; Safra, S.
CS- Dept. of Comput. Sci., Weizmann Inst. of Sci., Rehovot, Israel
JN- New Generation Comput. (Japan) vol.4, no.2 211-16
PY- 1986
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 9
AB- Multiway dynamic mergers with constant delay are an essential component
    of a parallel logic programming language. Previous attempts to defined
    efficient mergers have required complex optimising compilers land
    run-time support. This paper proposes a simple technique to implement
    mergers efficiently. The technique requires an additional data type and
    the definition of an operation on it. The operation allows multiple
    processes to access a stream without incurring the cost of searching
    for the end of stream. It is specified in Concurrent Prolog and is used
    to define multiple assignment variables using a monitor. The technique
    forms the basis for stream merging in Logix, a practical programming
    environment written in Flat Concurrent Prolog
DE- logic programming; merging; multiprocessing programs; PROLOG
ID- constant delay; Concurrent Prolog; parallel logic programming language;
    data type; multiple processes; multiple assignment variables; stream
    merging; Logix; programming environment
 
 
TI- Specification and initialization of a logic computer system
AU- Kusalik, A.J.
CS- Dept. of Comput. Sci., British Columbia Univ., Vancouver, BC, Canada
JN- New Generation Comput. (Japan) vol.4, no.2 189-209
PY- 1986
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 43
AB- A logic computer system consists of an inference machine and a
    compatible logic operating system. This paper describes prospective
    models for a logic computer system, and its hardware and software
    components. The language Concurrent Prolog serves as the single
    implementation, specification, and machine language. The computer
    system is represented as a logic programming goal
    logic-computer-system. Specification of the system corresponds to
    resolution of this goal. Clauses used to solve the goal-and ensuing
    subgoals-progressively refine the machine, operating system, and
    computer system designs. In addition, the accumulation of all clauses
    describing the logic operating system constitute its implementation.
    Logic computer systems with vastly different fundamental
    characteristics can be concisely specified in this manner. Two
    contrasting examples are given and discussed. An important
    characteristic of both peripheral devices and the overall computer
    system, whether they are restartable or perpetual, is examined. A
    method for operational initialization of the logic computer system is
    presented. The same clauses which incrementally specify characteristics
    of the computer system also describe the manner in which this
    initialization takes place
DE- logic programming; multiprocessing programs; multiprocessing systems;
    operating systems (computers); PROLOG
ID- logic computer system; inference machine; compatible logic operating
    system; Concurrent Prolog
 
TI- Translating Pascal for execution on a Prolog-based system
AU- Williams, M.H.; Chen, G.
CS- Dept. of Comput. Sci., Heriot-Watt Univ., Edinburgh, Scotland
JN- Comput. J. (GB) vol.29, no.3 246-52
PY- June 1986
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 14
AB- One of the objectives of the Japanese Fifth Generation Computer Project
    is to develop computer systems whose kernel languages are based on
    logic programming rather than on the conventional imperative languages
    which have been in general use until now. This has led to conjecture
    about the problem of the large base of existing software which is
    implemented in imperative languages. To this end a study has been
    conducted into the possibility of translating programs written in
    Pascal-S into Prolog. Because of the radically different control and
    data structures in these two languages, the translation process is not
    straightforward. The problems associated with this process are
    discussed and its performance assessed
DE- logic programming; Pascal; PROLOG; software engineering
ID- Japanese Fifth Generation Computer Project; kernel languages; logic
    programming; imperative languages; Pascal-S; Prolog; data structures
 
TI- New directions in logic programming
AU- Bowen, K.A.
CS- Sch. of Comput. & Inf. Sci., Syracuse Univ., NY, USA
CS- <Sponsor> ACM
JN- 1986 ACM Fourteenth Annual Computer Science Conference: CSC '86
    Proceedings 19-27
PY- 1986
CD- <US Copyright Clearance Center Code> 0 89791 177 6/86/0002/0019$00.75
CL- Cincinnati, OH, USA
CY- 4-6 Feb. 1986
PU- ACM New York, USA
PG- xxxiii+531
BN- 0 89791 177 6
DT- CONFERENCE PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 18
AB- PROLOG has established itself as a highly successful example of the
    logic programming paradigm. Today there are a number of vigorous
    research streams exploring methods of extending the capabilities and
    capacities achieved by PROLOG. These include treatment of concurrency,
    inclusion of functional programming capabilities, and incorporation of
    metalevel reasoning techniques. The paper surveys the goals and current
    state of these explorations
DE- logic programming; PROLOG
ID- logic programming; PROLOG; concurrency; functional programming;
    metalevel reasoning techniques
 
TI- A constructive view of PROLOG
AU- Bojadziev, D.
CS- Dept. of Comput. Sci. & Inf., Ljubljana, Yugoslavia
JN- J. Logic Program. (USA) vol.3, no.1 69-74
PY- April 1986
CD- <US Copyright Clearance Center Code> 0743-1066/86/$03.50
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 13
AB- A constructive rationalization of PROLOG is presented, covering the
    logical form of definite clause programs and the role of negative
    (goal) clauses. This view is developed from the idea, taken from set
    theory, that a constructive theory can be obtained if classical
    reasoning is confined to a constructively limited basis. The syntax of
    definite clauses is seen as reflecting a constructive view of
    description in that it prevents the expression of incomplete and
    negative information; the purely negative clauses initiate a classical
    proof technique, operating on a definite axiomatic basis
DE- logic programming; PROLOG
ID- Horn clauses; logic programming; PROLOG; definite clause programs; set
    theory; constructive theory; classical reasoning; negative information;
    proof technique
 
TI- Negation as inconsistency. I
AU- Gabbay, D.M.; Sergot, M.J.
CS- Dept. of Comput., Imperial Coll. of Sci. & Technol., London, England
JN- J. Logic Program. (USA) vol.3, no.1 1-35
PY- April 1986
CD- <US Copyright Clearance Center Code> 0743-1066/86/$03.50
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 11
AB- The notion of the negation as inconsistency is motivated and introduced
    into PROLOG. This negation is fully compatible with classical negation
    and gives a version of PROLOG which is a stronger fragment of classical
    logic than ordinary PROLOG. It is intended that negation as
    inconsistency replace the notion of negation as failure. Negation as
    inconsistency can be generalized in a natural way and in its
    generalized form will include negation as failure as a special case
DE- logic programming; PROLOG
ID- logic programming; negation; inconsistency; PROLOG; classical logic
 
TI- BRIE: the Boca Raton inference engine (programming in LISP and PROLOG)
AU- Brown, R.J., III
JN- Dr. Dobb's J. (USA) vol.11, no.4 24-6, 28, 30-2, 34-5, 62, 66-70
PY- April 1986
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- GENERAL,REVIEW; PRACTICAL; 
RF- 13
AB- Introduces PROLOG programming, LISP programming, and the underlying
    mechanisms involved in a PROLOG interpreter. A working micro-PROLOG
    program demonstrates how logic programming can be used for database
    applications. A working muLISP program is used to explain the
    factoring, resolution, and paramodulation rules of inference. The
    author also describes a refinement of the resolution algorithm that
    could form the basis for a viable PROLOG interpreter. Finally, he
    explains the PROLOG deduction cycle and backtracking and the concept of
    a programming environment
DE- LISP; LISP listings; logic programming; PROLOG; PROLOG listings
ID- PROLOG listings; BRIE; Boca Raton inference engine; PROLOG programming;
    LISP programming; PROLOG interpreter; micro-PROLOG program; logic
    programming; database applications; muLISP program; paramodulation
    rules of inference; resolution algorithm; PROLOG deduction cycle;
    backtracking; programming environment
 
TI- Translating production rules into a forward reasoning PROLOG program
AU- Yamamoto, A.; Tanaka, H.
CS- Dept. of Comput. Sci., Tokyo Inst. of Technol., Japan
JN- New Generation Comput. (Japan) vol.4, no.1 97-105
PY- 1986
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 7
AB- Several attempts have been made to design a production system using
    PROLOG. To construct a forward reasoning system, the rule interpreter
    is often written in PROLOG, but its execution is slow. The authors
    propose a rule translation method where production rules are translated
    into a PROLOG program and forward reasoning is done by the translated
    program. To translate the rules, they adopt the technique developed in
    BUP, the bottom-up parsing system in PROLOG. Man-machine dialogue
    functions are added to the production system and show the potential of
    the method to be applied to expert systems
DE- expert systems; logic programming; PROLOG
ID- production rules; forward reasoning; PROLOG program; production system;
    rule interpreter; rule translation; bottom-up parsing system; expert
    systems
 
TI- MOLOG: a system that extends PROLOG with modal logic
AU- Farinas Del Cerro, L.
CS- Langages et Systems Inf., Univ. Paul Sabatier, Toulouse, France
JN- New Generation Comput. (Japan) vol.4, no.1 35-50
PY- 1986
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- THEORETICAL; 
RF- 15
AB- The author presents an extension of PROLOG using modal logic. A new
    deduction method is also given based on a rule closer to the classical
    inference rule of PROLOG
DE- formal logic; logic programming; PROLOG; theorem proving
ID- theorem proving; PROLOG extension; logic programming; Horn clauses;
    problem solving; MOLOG; modal logic; deduction method; classical
    inference rule
 
TI- micro-PROLOG
AU- Ennals, R.
CS- Dept. of Comput., Imperial Coll., London, England
JN- Comput. Educ. (GB) no.52 13-15
PY- Feb. 1986
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 8
AB- Since the first implementation of micro-PROLOG by Frank McCabe in 1980
    there have been many introductory papers, lectures and courses, and a
    number of books. Funded research projects have been established around
    the world, and through the availability of micro-PROLOG on the cheapest
    and most generally available microcomputers thousands of people have
    been introduced to ideas of logic programming. This paper sets out to
    introduce micro-PROLOG in the light of that experience, noting that the
    ways in which the language has been used in different contexts vary
    considerably. It is driven by some of the questions that the author has
    been asked over the last five years
DE- logic programming; microcomputer applications; PROLOG
ID- micro-PROLOG; microcomputers; logic programming
 
TI- Spelling verification in PROLOG
AU- Berghel, H.; Traudt, E.
CS- Dept. of Comput. Sci., Nebraska Univ., Lincoln, NE, USA
JN- SIGPLAN Not. (USA) vol.21, no.1 19-27
PY- Jan. 1986
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 11
AB- A spelling verification program written in PROLOG is presented. This
    program performs simple table lookup for each word in an input list. If
    the current word fails to match with the lexical entries, several
    procedures are invoked which will attempt to identify the type of
    spelling error and suggest alternative spellings
DE- logic programming; PROLOG; spelling aids
ID- logic programming; spelling verification program; PROLOG; table lookup;
    lexical entries; spelling error
 
TI- Programming in logic. II
AU- Covington, M.
CS- Adv. Comput. Methods Center, Georgia State Univ., Atlanta, GA, USA
JN- PC Tech J. (USA) vol.4, no.1 145-54
PY- Jan. 1986
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; PRODUCT REVIEW; 
AB- For pt.I see ibid., vol.3, no.12, p.82 (1985). The number of PROLOG
    interpreters available to the user proliferates as the popularity of
    this programming language continues to increase; 11 implementations are
    reviewed here
DE- logic programming; program interpreters; PROLOG
ID- logic programming; PROLOG interpreters; programming language
 
TI- Dewey indexing of PROLOG traces
AU- Foo, N.Y.
CS- Basser Dept. of Comput. Sci., Sydney Univ., NSW, Australia
JN- Comput. J. (GB) vol.29, no.1 17-19
PY- Feb. 1986
DT- JOURNAL PAPER; 
LA- ENGLISH
TC- PRACTICAL; 
RF- 4
AB- Dewey decimal indexing is introduced to label the nodes of a PROLOG
    proof tree. The indices are exploited to linearise the conventional
    preorder search sequence. The scheme is shown to be a very simple and
    convenient way to display traces, and is used to annotate and simulate
    backtracking and variable binding in PROLOG. Independent traces can
    also be merged easily
DE- indexing; logic programming; PROLOG
ID- logic programming; Dewey indexing; PROLOG traces; decimal indexing;
    proof tree; search sequence; backtracking; variable binding
