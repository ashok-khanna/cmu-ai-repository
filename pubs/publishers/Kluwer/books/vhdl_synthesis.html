
Circuit Synthesis with VHDL


by


Roland Airiau
Jean-Michel Berge
Vincent Olive
CNET, France Telecom, France

1.1. Why VHDL?	1
1.2. VHDL for Which Purpose?	2
1.3. Is VHDL a Good Language for Synthesis?	3
1.4. A Book, an Outline	4
1.5. Synthesis Domain	6
1.6. Interests of Synthesis	7
1.7. Architectural Synthesis Versus Logic Synthesis	8
1.7.1. Technologies of Logic and Architectural Synthesis	9
1.7.2. Implications on Design Methodology	10
1.8. Consistency Between Simulation and Synthesis	12
2. VHDL Concepts	13
2.1. Philosophy of the Language	13
2.1.1. Generality	13
2.1.2. Time	15
2.1.3. Modularity	15
2.1.4. Portability	17
2.2. Hardware Hierarchy	18
2.2.1. Entity/Architecture	18
2.2.2. Direct Instantiation of Entity	22
2.2.3. Notion of Component	22
2.2.4. Component Declaration	23
2.2.5. Component Instantiation	24
2.2.6. Component Configuration	25
2.2.7. Concurrent Procedure Call	27
2.3. Software Hierarchy	28
2.3.1. Writing Software	28
2.3.2. Packages	28
2.3.3. Subprograms	30
2.4. Objects of the Language	32
2.4.1. Constants	32
2.4.2. Variables	32
2.4.3. Signal	32
2.4.4. Files	34
2.5. Information Representation	35
2.5.1. Types of Objects	35
2.5.2. Scalar Types	35
2.5.3. Composite Types	36
2.5.4. Object Classes	37
2.6. Concurrency	37
2.6.1. Informal Definition	37
2.6.2. Signals and Ports	38
2.6.3. Resolution Function	39
2.6.4. Process	40
2.6.5.  Other Concurrent Statements	41
2.6.6. Guarded Blocks	43
2.7. Sequential Domain	43
2.8. Attached Characteristics	44
2.9. Predefined Environment	45
2.9.1. Predefined Environment of the Language Itself	45
2.9.2. Standard Environment	46
2.9.3. "Proprietary" Environment	47
3. mapping VHDL to Hardware	49
3.1. Synthesis Modeling Style	49
3.2. VHDL Types	49
3.2.1. Supported Type Declarations	50
3.2.2. Predefined Types	54
3.2.3. IEEE Strongly Recommended Types	54
3.2.4. Unsupported Types	58
3.2.5. Subtypes	59
3.3. VHDL Objects	59
3.3.1. Constants	59
3.3.2. Variables Versus Signals	61
3.3.3. Initial Values	63
3.3.4. Arithmetic Operators	63
3.4. Sequential Statements	69
3.4.1. Variable Assignment	69
3.4.2. Signal Assignment	70
3.4.3. Synchronization Statement	70
3.4.4. Conditional Statement	72
3.4.5. Iterative Statement	77
3.4.6. Subprogram Call	80
3.5. Concurrent Statements	80
3.5.1. Process and Synchronization Statement	80
3.5.2. Signal Assignment	86
3.5.3. Component Instantiation	88
3.5.4. Block Statement	89
3.5.5. Concurrent Procedure Call	91
3.5.6. Generate Statement	93
3.6. Using Generics	95
3.7. Conclusion	99
4. Mapping Hardware to VHDL	101
4.1. Combinational Circuits	101
4.1.1. Logic Gates	102
4.1.2. Comparators	105
4.1.3. Arithmetic Operations	108
4.1.4. Shift and Rotate Operations	115
4.1.5. Multiplexers	118
4.1.6. ALU	127
4.1.7. Three-State Logic	132
4.1.8. ROM	134
4.1.9. PLA	136
4.2. Synchronous Circuits	139
4.2.1. Latches	140
4.2.2. Registers	142
4.2.3. Synchronous Counters	146
4.2.4. Memories	154
4.2.5. Finite State Machines	159
5. Design Methodology	175
5.1. Synthesis Design Cycle	175
5.1.1. Design Cycle Steps	175
5.1.2.  Modeling for Synthesis	177
5.1.3.  Synthesis Process	177
5.1.4.  Final Validation	179
5.2. Synthesis Process Control	179
5.2.1. What Is Synthesis Process Control?	179
5.2.2. Design Constraints	180
5.2.3. Interface Formats	180
6. Synthesis Standard Environment	183
6.1. Principle	183
6.2. Package STD_LOGIC_1164	184
6.2.1. Logic Type Interpretation: Simulation Semantics	184
6.2.2. Description of Package STD_LOGIC_1164	185
6.3. Synthesis Working Group Results	187
6.3.1. Logic Type Interpretation: Synthesis Semantics	187
6.3.2. Arithmetic Packages	190
6.3.3. Special Identifications	192
7. Case Study	193
7.1. Traffic Light Controller: Once Again?	193
7.2. Specification of the Problem	193
7.3. Entity Declaration	195
7.4. Describing the Behavioral Architecture	196
7.5. Describing the Synthesizable Architecture	198
7.5.1. From Behavioral To Synthesizable Description	198
7.5.2. First Proposition of Synthesizable Architecture	199
7.5.3 Second Proposition of Synthetizable Architecture	203
7.6. Designer's Concerns	205
7.6.1. Tool Dependency	205
7.6.2. Constraint Checking	205
8. Appendix	207
8.1. Grammar Summary	208
8.2. Memo	212
8.2.1. Process: Is Inferred Hardware Combinational or Sequential?	212
8.2.2. Combinational Circuits: Logic Gates	213
8.2.3. Combinational Circuits: Multiplexers	214
8.2.4. Combinational Circuits: Three-State Operators	215
8.2.5. Sequential Circuits: Latch and Register	216
8.2.6. Sequential Circuits: Counter with Reset	217
8.2.7. Sequential Circuits: Finite State Machine	218
8.3 Index	219

LIST OF FIGURES

Figure 1.1.	Methodology for Synthesis Result Validation	3
Figure 1.2.	Synopsis of the Book	5
Figure 1.3.	Design Cycle	7
Figure 1.4.	Resource Sharing in Logic Synthesis	9
Figure 1.5.	Functional to Physical Level	11
Figure 2.1.	Different Levels of Description	14
Figure 2.2.	Compiling Source File into Design Units	16
Figure 2.3.	Five Kinds of Design Units	17
Figure 2.4.	Concept of Entity	19
Figure 2.5.	Circuit-Level Entity - RS Latch	19
Figure 2.6.	System Level Entity - Coder	20
Figure 2.7.	Structural Architecture at Gate-Level - Latch	21
Figure 2.8.	Behavioral Architecture at System-Level - Coder	21
Figure 2.9.	Direct Instantiation	22
Figure 2.10.	Notion of Component Instantiation	24
Figure 2.11.	Configuration of a Component Instantiation	26
Figure 2.12.	Flexibility Carried Out by the Configuration	27
Figure 2.13.	Duality Between Hardware/Software Hierarchies	29
Figure 2.14.	Subprogram Header and Subprogram Body	31
Figure 2.15.	Usual Representation of a Driver Signal	33
Figure 2.16.	Inertial and Transport Modes	34
Figure 2.17.	Latch - Two "Concurrent" Gates	37
Figure 2.18.	Simulator's View of the Latch	38
Figure 2.19.	Signals and Ports	39
Figure 3.1.	Sequential Hardware Inferred by Architecture A	56
Figure 3.2.	Architecture B, Value '0' Is Used as "Don't Care" Value	57
Figure 3.3.	Architecture C Using a "Don't Care" Character	58
Figure 3.4.	Synthesized Result for Architecture A of MEMO_ONE	62
Figure 3.5.	Synthesized Result for Architecture B of MEMO_ONE	63
Figure 3.6.	Predefined VHDL Operators	64
Figure 3.7.	Logical Operations on Signals and Their Schematic Results	64
Figure 3.8.	Parentheses and their Impact on the Inferred Hardware	66
Figure 3.9.	Synthesized Result of the Operator "&"	67
Figure 3.10.	Inferred Hardware Resulting from Unary Minus Operator	68
Figure 3.11. 	Resulting Hardware of Multiplexers	72
Figure 3.12. 	Basic Gates Translating an "if" Statement	73
Figure 3.13.	Resulting Hardware of Case Statement Using Integer	74
Figure 3.14.	Hardware of a Case Statement Using Enumerated Type	74
Figure 3.15.	Resulting Hardware Without Resource Sharing	76
Figure 3.16.	Hardware Possibilities After Adder Operator Sharing	77
Figure 3.17. 	Hardware Counterpart of Assignment in for Loop Statement	77
Figure 3.18.	Hardware of the for Loop Statement with Next Statement	78
Figure 3.19.	Synthesized Result of a Loop with Exit Statement	79
Figure 3.20. 	Hardware Counterpart of this Conditional Assigment	87
Figure 3.21.	Hardware Counterpart of these Selected Assignments	88
Figure 3.22.	Schematic of Three-state Buffer Inferred by Block Statement	91
Figure 3.23.	Generic N Inputs and Gate	95
Figure 3.24.	Resulting Hardware of Two Different Instantiations	98
Figure 4.1.	Parity Computation	105
Figure 4.2.	Inferred Hardware Minimization	107
Figure 4.3.	(Single) Shift Right Arithmetic Operation	116
Figure 4.4.	Synthesized Result of Combinatorial Multiplexer	119
Figure 4.5.	Usual Representation of a Multiplexer	119
Figure 4.6.	Resource Sharing, Adder	128
Figure 4.7.	Resource Sharing 1, Simple ALU	128
Figure 4.8.	Resource Sharing 2, Simple ALU	129
Figure 4.9.	Bidirectional Three-State Resource	132
Figure 4.10.	PLA Principle	136
Figure 4.11.	Equivalent Structures of Synchronous Circuits	139
Figure 4.12.	Multiplex in Synchronous Context	145
Figure 4.13.	Register with Synchronous Enable	145
Figure 4.14.	Logarithmic Conversion Function	149
Figure 4.15.	Multiphase Clock Generator	151
Figure 4.16.	Comparison Between Architectures A and B	154
Figure 4.17.	External View of the Register File	155
Figure 4.18.	External View of a LIFO	157
Figure 4.19.	Same Period P, Different Clock-Level Ratios H1 and H2	161
Figure 4.20.	Simple Cyclic FSM	167
Figure 5.1.	Design Cycle Flow Chart	176
Figure 6.1.	Resolution Function of type STD_LOGIC	185
Figure 6.2.	'X' Propagation Strategy, Example of the Addition	192
Figure 7.1.	Traffic Light State Diagram	194
Figure 7.2.	Schematic View of Synthesizable Architecture	200

Foreword
This book is an introduction to the use of VHDL synthesis tools in design.
Logic (RTL) synthesis and some aspects of architectural synthesis are developed
in it.

Modeling styles
The proposed modeling style does not target a specific market tool. Since there
is no standard modeling style, this book is a tradeoff between what the
designer could legitimately expect from the tools and what a synthesis tool
builder can reasonably implement. 
Therefore, some of the constructs presented in this book may not be
synthesizable on all synthesis tools. The following pages focus on constructs
universally recognized as synthesizable by synthesis tools. Nevertheless, in
some cases, the designer is warned that a given construct, even if conceptually
synthesizable, is not currently recognized by all synthesis tools. 
Of course, this classification is a snapshot of a moving situation. The
designers, as well as the authors, are expecting a convergence to a common set
of recognized constructs to occur soon.

VHDL'92
A new version of VHDL, commonly referenced as VHDL'92, was accepted in
September 1993 and is, at least theoretically, the only legal version of VHDL.
This version of the language is upward compatible with the old one, sometimes
referred to as VHDL'87. Indeed, the new version has no major consequences on
the modeling style for synthesis. Nevertheless, when certain new constructs
appear to be used in the synthesis domain, they may be illustrated, and
signaled as such, in this book. Since all synthesis tools are far from
accepting all new constructs, a VHDL'87 version of the same example is always
provided. For more details on VHDL'92, please refer to [BER92].1

Architectural Synthesis
This book mainly focuses on the logic synthesis process, which is the only one
really proposed by tool vendors. The difference between logic and architectural
synthesis mainly depends on the intelligence of the tools and not on the
descriptive capabilities of the language. This publication may offer the
designer the modeling capabilities of entering the architectural synthesis
process.

Combinational/Sequential and Synchronous/Asynchronous
Throughout this book, the words combinational, sequential, synchronous, and
asynchronous are used for VHDL descriptions. Without entering philosophical
considerations, the following simplified definitions are sufficient for a good
understanding of the book.

Combinational/sequential are hardware notions:
o	A VHDL description is said to be combinational if its inferred hardware does
not involve any memorization elements. 
o	A VHDL description, that is not combinational is said to be sequential. 

Synchronous/asynchronous are abstractions of system-level:
o	A VHDL description is said to be synchronous if a specific control signal
called a clock is present. If all synchronization points rely on this clock,
the design is purely synchronous. Since synchronous implies memorization,
synchronous designs, either purely or not, are sequential. 
o	The word asynchronous is used in this book to characterize parts of the VHDL
description that do not rely on a clock. Combinational circuits are therefore
asynchronous, but this does not necessary deny memorization (e.g., asynchronous
FIFO).


1. About Synthesis
1.1. Why VHDL?
A new era is opening up in electronics system design. By analogy with software
programmers who no longer have to deal with internal coding details of
computers, electronics designers are less and less concerned with circuit
layout and standard components, especially when programmable ones (FPGA, EPLD)
are targeted. New synthesis techniques are raising the level of abstraction of
electronic device descriptions. By using the latter, the designer can deal with
more complex applications with a complete mastery of the technologies.
Furthermore, such techniques allow him or her to remain apart from the explicit
description of the physical level. Abstraction means symbolic coding and
therefore language, while synthesis techniques owe their wide use to hardware
description languages.
Chronologically speaking, VHDL is not the first hardware description language.
Created to be a standard, it is now widely accepted and adopted. VHDL owes its
success both to its predecessors and to the maturity of its basic principles.
It is the result of numerous studies on logic simulation principles and
associated languages. Through this connection, it inherits from the electronic
world.
VHDL language designers have taken a sufficiently objective stance in order to
remain apart from the electronic domain. In this too narrow context of
electronics, the designed language could not skip a generation, which VHDL
does. Above all, a purely electronic language would have had little chance of
becoming a reference standard: competitors are numerous.
The combination of computing and electronics is the key to the success of VHDL.
In the software domain, languages have acquired a high degree of maturity. VHDL
represents the association of the most up-to-date concepts with the
specificities of hardware description languages.
The power and richness of the language do in fact overtake the original scope
of VHDL. VHDL is a general purpose simulation language, and electronics may be
seen as a given application domain. Other technologies (optics, pneumatics,
etc.) are potentially concerned. New domains such as industrial process
simulation, neuronics, or networks are also covered. The only real restriction
to the use of VHDL for a given application is that the algorithm of simulation
must be event-driven, which means that actions occur at discrete points in time
and may imply other actions at discrete points in time. In the future, its
extension to analog systems may deal with continuous systems: a standardization
process is in progress.
1.2. VHDL for Which Purpose?
Simulation (i.e., execution of a description in order to check its time
behavior) is not the only possible application of hardware description
languages. Other applications such as synthesis already exist:
o	formal proof, which is a technique allowing comparison of two descriptions of
different levels. This proof is performed according to specific criteria and
these techniques are promising. They potentially allow, at least in some cases,
the certification that a low-level description is consistent with a functional
description. No simulation will be performed for this, but the result will be a
real certification and not only a validation as provided by a conventional
simulation (i.e., only given a specific set of stimuli).
o	documentation that allows hardware description language to be used to
describe a system in an informational way: to explain the implementation
choices in a nonambiguous and standard manner. This description is potentially
a part of the design documentation and should offer enough abstraction to
allow, if necessary, another system design in another technology.
o	specification that consists in using a high-level language to state the
requirements in an unambiguous way. Such a modeling should not only describe
the desired system behavior but also its functional and timing constraints.

This book focuses on another important application domain of hardware
description languages: synthesis. Its goal is to propose to designers the bases
of a new methodology as well as to give them a thorough understanding of VHDL
for this specific purpose. On the other hand, the reader will only find here a
quick overview of the fundamental techniques of synthesis, just enough for a
good mastery of the results. Circuit Synthesis with VHDL is entirely devoted to
the modeling techniques for synthesis as well as to the setting up of the
underlying design methodology.
1.3. Is VHDL a Good Language for Synthesis?
The language VHDL was not originally designed for synthesis. All VHDL
constructs are not synthesizable: access types or files for instance have no
direct hardware correspondence. However, it is perfectly possible to design a
language in which all constructs are synthesizable. UDL/I, the Japanese
Standard23 proves this. Therefore, is VHDL unsuited to synthesis?
To negatively answer this question, it is first of all fundamental to really
understand that the VHDL modeling for synthesis of a system is usually
associated with its testbench. The testbench is the part of the description
that models the environment of the system and allows its testing. This
separation between system and testbench is important. Once the system is
synthesized, it is possible to reuse the same testbench to simulate the result
of the synthesis process and check its consistency. Figure 1.1 illustrates this
methodology.
#001#
.c.Figure 1.1.	Methodology for Synthesis Result Validation
Often seen as a simple collection of stimuli, the testbench description can be
complex, and multiple scenarios may be involved. A complexity of the same order
as that of the system is not exceptional. All the power of VHDL can be used
when describing the testbench: it will not be synthesized. 
Furthermore, synthesis techniques are in their early stages and should evolve
dramatically in the next few years. It is therefore essential that the language
widely adopted for synthesis will in no way block progress to new levels of
synthesis and increasing abstractions. The generality of VHDL allows it to deal
with any synthesis level whatever its abstraction. 
1.4. A Book, an Outline
How is this book made up? What path should one follow to achieve a good
understanding and use of synthesis techniques? Figure 1.2 summarizes this.
In this introductory chapter, synthesis is explained in order to extract its
clear definition, to show its inherent advantages, to determine the different
classes of synthesis as well as their domains and limits of use, to understand
the basic techniques, and finally to evaluate the consequences of such
techniques on the design cycle.
In the second chapter, VHDL is studied in a more global way. It is not an
academic in-depth course on the language, but a sufficiently detailed overview
to bring out and achieve a good understanding of the basic concepts and their
relationships with the synthesis domain. If VHDL is becoming THE hardware
description language of so many tool vendors (often used for input and
sometimes output of synthesis tools), it is mainly thanks to these concepts. Of
course, a designer skilled in VHDL might want to skip this chapter.
In the third chapter, all language constructs acceptable for synthesis purposes
are systematically detailed. The hardware meaning is associated with each of
them. Throughout this chapter, care is taken to provide a full and accurate
description of the synthesis syntax and semantics offered by the language. This
is not restricted to present-day accepted aspects; "avant-garde" language
constructs are also given and signaled.
As a complement to the previous one, the fourth chapter addresses the
modeling-for-synthesis problem in a bottom-up approach. This chapter goes
through the main target architectures commonly used. Modeling style advice is
given and each problem is illustrated with examples.
Chapter five discusses the necessary underlying methodology when modeling for
synthesis purposes. Which level of abstraction should one choose? 
#001#.c.Figure 1.2.	Synopsis of the Book
Which degree of detail is it necessary to achieve in the architectural choices?
What is realistic to expect from existing synthesis tools? Since the functional
aspects of synthesis have been solved in previous chapters, this chapter can
answer these fundamental questions. Furthermore, interaction between user and
synthesis tool, such as parameters for controling the synthesis process, are
also studied.
The sixth chapter presents the synthesis standard environment. This environment
is not part of the language but appears as separate standard packages that have
been (or will soon be) balloted. Some conventions and standard synthesis
semantics are also defined.
The seventh and last chapter puts into practice the different modeling
techniques on a real case of significant complexity. The goal of this chapter
is to match basic modeling techniques against the functional, topological, and
timing requirements of a real-life problem.
Finally, the appendix allows the designer to quickly access much useful
information on providing a synthesizable design style.
1.5. Synthesis Domain
What is synthesis? What is its use and final purpose? 
Synthesis is a process that allows translation from a behavioral description to
a structural description where each element represents (or can automatically
generate) a predefined electronic resource. The original functionality has to
be maintained, and timing and topological requirements have to be met.
Etymologically speaking, analysis or projection would be closer to the concept
than the word synthesis, which commonly deals with the idea of abstracting.
What is nowadays usually called electronics synthesis does exactly the
opposite: it starts from an abstract level and goes to an implementation level.
Within the design cycle, synthesis represents one of the last steps.4 It
follows the specification phase and architectural refinements. The design cycle
will be studied in section 1.7 along with other methodological considerations. 
Synthesis techniques aim to match the result of architectural choices against a
collection of basic elements. An element may be a clearly identified hardware
resource or some standard cell for integrated circuits. It can also be a
functional resource like a counter, an equality comparator, or a sequencer,
which itself is deemed to be implemented by lower-level hardware resources. 
#001#
.c.Figure 1.3.	Design Cycle
By the very nature of the targeted resources, two domains are particularly
noticeable: 
o	logic synthesis, whose element library has an explicit hardware equivalent
o	architectural synthesis, which is based upon a library of operational
resources that are described at a functional level and thus are more abstract

More details on the differences between these domains will be given in section
1.7.
1.6. Interests of Synthesis
>From the definition of synthesis given previously, one may infer that its
primary advantage is the higher abstraction level of hardware descriptions. The
application designer has less and less detailed descriptions to write. For
example, he or she is not expected to provide an accurate description of the
control signals of a counter explicitly used: only the counting functionality
and the constraints on the use of the resource must be indicated. The gain from
the abstraction is to reduce and condense descriptions at the start, and,
consequently, to ease their debugging.
The more abstract the level, the more functional the specification. Synthesis,
in this respect, helps to shorten the path leading from the idea to the
implementation. We must however be careful, for there is (still) a long way to
go between expressing the functionality and choosing the architecture that
optimally fits the constraints. Here is where the expertise and skill of the
designer come into play, and will continue to come into play so for some time
to come.
Automatically generating hardware implementation also means providing a
high-quality result. Since systems are becoming increasingly complex, it is no
longer possible to envisage their design "by-hand": the number of objects to be
handled is becoming astronomical. With synthesis, the amount of information
given by the designer decreases. The information mostly consists of behavioral
descriptions and corresponding constraints. Synthesis is undoubtedly leading to
more secure designs and should be seen as a quality label on a design cycle. 
Since synthesis reduces the size of descriptions, it also allows easier
updates, fast debugging, and a wider exploration of architectural choices. In
this context, the best tradeoff between cost and performance can more easily be
found by the designer.
The large number of lines of hardware descriptions together with the new
possibility of parametrization is leading to the creation of (reusable)
resource libraries in addition to a better productivity of electronic designs.
The lower average density of layout resulting from the use of synthesis tools
compared to hand design is a drawback of such methods. Nevertheless, the
evolution of technological processes is leading to a twofold increase in
complexity for a given area every two or three years, and therefore offers real
possibilities for synthesis.
The increasing complexity of systems to be designed, high-quality requirements,
and reduction on the average time to market are other concerns that imply the
use of synthesis techniques.
1.7. Architectural Synthesis Versus Logic Synthesis
The synthesis domain consists of two distinct levels: logic synthesis and
architectural synthesis. A presentation of these levels to analyze their places
in the design cycle, is therefore necessary.
1.7.1. Technologies of Logic and Architectural Synthesis
Logic synthesis (also called RTL synthesis), as well as architectural synthesis
(also called high-level synthesis), aims to match a behavioral description (the
input) with a collection of interconnected elements of a library. These
elements have a simple functionality and can be some memory elements (based on
latches and D flip-flops), logic operators (and, or, etc.), or arithmetic
operators such as adders or multipliers.
Nevertheless, only architectural synthesis accepts more complex operators such
as association of elementary operators, sophisticated memories, or ALUs. The
main steps allowing the transformation from a text source into a description
using these basic elements are the following:
o	Compilation. The text source is optimized during the analysis phase.
Redundancies are eliminated, constants are propagated, and nonaccessible parts
of the text source are ignored. These optimization techniques are common to
both logic and architectural synthesis and well-known in software compilation.
o	Sharing and allocation of resources. This is the important point of
divergence between logic synthesis and architectural synthesis. Logic synthesis
only deals with the sharing of functional resources used exclusively in time.
This concept needs further explanation. Typically, a description where the
output is the conditional result of two additions leads to a sharing of the
addition resource: the inputs of the adder are multiplexed (see figure 1.4).
Both logic synthesis and architectural synthesis proceed in the same way in
this case.
#001#
.c.Figure 1.4.	Resource Sharing in Logic Synthesis
		Architectural synthesis goes further: if the timing constraints are
respected, these techniques may allocate and reuse the same resource at
different temporal phases. The real difference with logic synthesis is not only
in the interconnection of elements, but also and mainly in the very control of
the resource. A significant increase in the abstraction level of the initial
behavioral description is induced by this last functionality.
		For designers, logic synthesis provides a way to avoid describing required
resources. Architectural synthesis will automatically infer not only the
resources, but also the control itself, once given the speed constraints as
well as timing constraints of the physical elements. The optimum degree of
parallelism will therefore be deduced in order to minimize the area or power
consumption of the result.
1.7.2. Implications on Design Methodology
1.7.2.1. New prospects
In the next few years, new synthesis techniques will have more and more impact
on system design methodology. The synthesis process by itself is not the source
of such a modification. Synthesis is only one of the potential targets of a
hardware description. 
Modeling ("modelware," that is the act to describe the behavior of a system as
a whole), is really changing design methods. The remarkable point is that a
single language, VHDL, is now able to cover the entire design cycle from
functional specification to low-level structural description. 
Methodological elements appear from the ability of VHDL to adapt to all aspects
of the problem at any stage of the design.
1.7.2.2. Functional specification phase
The goal here is to translate the requirements into a formal description. These
requirements may have multiple aspects: documents with texts mixed with
schemes, references to international standards (protocol), sets of equations,
algorithms, etc. Even the completeness of the specification itself is not
always ensured.
The need for a functional description as reference model is therefore obvious.
This model will be the essential starting point of the design cycle and will
allow, by comparison of simulation results (and perhaps in the future using
formal proof), validation of the following steps of the methodology. It is now
well-known that such a functional model allows the designer an in-depth
understanding of the problem to be solved. Fundamental questions, such as the
completeness of data transforms, arise during this phase.
#001#
.c.Figure 1.5.	Functional to Physical Level
1.7.2.3. Architectural choice phase
There is no universal tool for this phase. Experience and designer know-how are
the keys to success. All the potential targets must be taken into account.
Their number is quite large: from software to ASICs, from programmable devices
to standard circuits. 
Indeed, synthesizable description is also one of these targets. By its very
nature, it is fuzzy and abstract. The goal of this book is to help the designer
achieve a better understanding of it and therefore use it more efficiently.
chapters 3 and 4 study different ways of expressing hardware in VHDL.
Therefore, the designer will better understand the real capabilities of today's
synthesis tools.
As discussed in the previous section, the synthesis domain is vast. At the
highest level, it is possible to express a set of interdependent treatments
(data-flow graph) without any specific control. The only requirement is to
respect constraints, if any. This is the architectural synthesis domain. 
On the other hand, logic synthesis requires the complete description of the
control and use of resources in time. Thus, by itself it appears to be a
consistent continuation of the architectural synthesis process, once the
resource allocation has been performed. 
Beyond all doubt, these two synthesis levels (architectural and logic) will in
the future merge into one.
1.8. Consistency Between Simulation and Synthesis
One of the main objectives of all methodology is to make the transformation
between two steps as safe as possible. Checks can be provided for this.
Synthesis consists of the transformation of an initial description, as abstract
as possible, into a structural description using well-identified hardware
resources. Therefore, in terms of methodology, comparing both descriptions is
essential.
The power of description of VHDL is able, without any constraints, to support
the two levels of description. Indeed, there is no real problem at this stage,
but much more trouble is related to the transformation technology. In other
words, the way of interpreting VHDL text sources for synthesis purposes (the
semantics for synthesis) is fundamental and critical, and it determines the
quality of the result.
It is true that the design of VHDL has only been achieved in terms of
simulation semantics but this book wishes to proclaim loud and clear that an
unambiguous synthesis semantics, respecting the simulation semantics, may be
defined. It is time now to go into more detail.








-------------------------------------ORDER FORM------------------------------

Ref:  ftpser

Please send me: 
Circuit Synthesis with VHDL, by R. Airiau, J-M Berge, V. Olive
_____copy(ies) HB, ISBN: 0-7923-9429-1 US$ 89.95, Dfl 190.00, GBP 67.50

  Payment enclosed to the amount of ___________________________

* Please invoice me 

* Please charge my credit card 

  Name of Card Holder: ______________________________________  

  Card. no.: ________________________________________________

  Expiry Date:______________________________________________

     Am. Ex.*          Visa*           Diners Club*           Mastercard*

Delivery address: 

Name: ___________________________________________________________________

Address: ________________________________________________________________

         ________________________________________________________________

         ________________________________________________________________

         ________________________________________________________________


Date:________________     Signature:_______________________________

To be sent to:


Outside North America                         In USA and Canada

KLUWER ACADEMIC PUBLISHERS GROUP              KLUWER ACADEMIC PUBLISHERS 
Order Dept.                                   Order Dept
P.O. Box 322                                  101 Philip Drive
3300 AH Dordrecht, The Netherlands            Norwell, 02016 MA
Tel: +31-78-524400                            Tel: 617-871-6600
Fax +31-78-524474.                            Fax: 617-871-6528
email:  vanderlinden@wkap.nl                  email: kluwer@world.std.com

Orders from individuals accompanied by payment or authorization to
charge a credit card account will ensure prompt delivery. Postage and
handling charges will be absorbed by the Publisher on all such orders.
Payment will be accepted in any convertible currency. Please check the
rate of exchange at your bank. For sales within the Netherlands please
add 6% VAT (BTW). Prices are subject to change without notice.

* Delete those that do not apply.

