<!DOCTYPE HTML PUBLIC "-//W3O//DTD W3 HTML 2.0//EN">
<!Converted with LaTeX2HTML 0.6.5 (Tue Nov 15 1994) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds >

<!-- Mirrored from www.cs.cmu.edu/afs/cs/project/ai-repository/ai/util/html/cltl/clm/node191.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 22 Oct 2021 10:09:53 GMT -->
<HEAD>
<TITLE>22.1.4. Standard Dispatching Macro Character Syntax</TITLE>
</HEAD>
<BODY>
<meta name="description" value=" Standard Dispatching Macro Character Syntax">
<meta name="keywords" value="clm">
<meta name="resource-type" value="document">
<meta name="distribution" value="global">
<P>
<b>Common Lisp the Language, 2nd Edition</b>
 <BR> <HR><A NAME=tex2html3927 HREF="node192.html"><IMG ALIGN=BOTTOM ALT="next" SRC="icons/next_motif.gif"></A> <A NAME=tex2html3925 HREF="node187.html"><IMG ALIGN=BOTTOM ALT="up" SRC="icons/up_motif.gif"></A> <A NAME=tex2html3919 HREF="node190.html"><IMG ALIGN=BOTTOM ALT="previous" SRC="icons/previous_motif.gif"></A> <A NAME=tex2html3929 HREF="node1.html"><IMG ALIGN=BOTTOM ALT="contents" SRC="icons/contents_motif.gif"></A> <A NAME=tex2html3930 HREF="index-2.html"><IMG ALIGN=BOTTOM ALT="index" SRC="icons/index_motif.gif"></A> <BR>
<B> Next:</B> <A NAME=tex2html3928 HREF="node192.html"> The Readtable</A>
<B>Up:</B> <A NAME=tex2html3926 HREF="node187.html"> Printed Representation of </A>
<B> Previous:</B> <A NAME=tex2html3920 HREF="node190.html"> Macro Characters</A>
<HR> <P>
<H2><A NAME=SECTION002614000000000000000>22.1.4. Standard Dispatching Macro Character Syntax</A></H2>
<P>
<A NAME=SHARPSIGNMACROCHARACTERSECTION>The</A>
<A NAME=25511>standard</A>
syntax includes forms introduced by the <tt>#</tt> character.
These take the general form of a <tt>#</tt>,
a second character that identifies the syntax,
and following arguments in some form.
If the second character is a letter, then case is not important;
<tt>#O</tt> and <tt>#o</tt> are considered to be equivalent, for example.
<P>
Certain <tt>#</tt> forms allow an unsigned decimal number to appear
between the <tt>#</tt> and the second character; some other
forms even require it.  Those forms that do not explicitly permit
such a number to appear forbid it.
<A NAME=StandardSharpMacroDefinitionsTable>&#160;</A>
<pre>
----------------------------------------------------------------
Table 22-4: Standard # Macro Character Syntax

#!  <i>undefined</i> *                #&lt;backspace&gt;  <i>signals error</i> 
#"  <i>undefined</i>                  #&lt;tab&gt;        <i>signals error</i> 
##  <i>reference to #= label</i>      #&lt;newline&gt;    <i>signals error</i> 
#$  <i>undefined</i>                  #&lt;linefeed&gt;   <i>signals error</i> 
#%  <i>undefined</i>                  #&lt;page&gt;       <i>signals error</i> 
#&  <i>undefined</i>                  #&lt;return&gt;     <i>signals error</i> 
#'  <i>function abbreviation</i>      #&lt;space&gt;      <i>signals error</i> 
#(  <i>simple vector</i>              #+      <i>read-time conditional</i> 
#)  <i>signals error</i>              #-      <i>read-time conditional</i> 
#*  <i>bit-vector</i>                 #.      <i>read-time evaluation</i> 
#,  <i>load-time evaluation</i>       #/      <i>undefined</i> 
#0  <i>used for infix arguments</i>   #A, #a  <i>array</i> 
#1  <i>used for infix arguments</i>   #B, #b  <i>binary rational</i> 
#2  <i>used for infix arguments</i>   #C, #c  <i>complex number</i> 
#3  <i>used for infix arguments</i>   #D, #d  <i>undefined</i> 
#4  <i>used for infix arguments</i>   #E, #e  <i>undefined</i> 
#5  <i>used for infix arguments</i>   #F, #f  <i>undefined</i> 
#6  <i>used for infix arguments</i>   #G, #g  <i>undefined</i> 
#7  <i>used for infix arguments</i>   #H, #h  <i>undefined</i> 
#8  <i>used for infix arguments</i>   #I, #i  <i>undefined</i> 
#9  <i>used for infix arguments</i>   #J, #j  <i>undefined</i> 
#:  <i>uninterned symbol</i>          #K, #k  <i>undefined</i> 
#;  <i>undefined</i>                  #L, #l  <i>undefined</i> 
#<  <i>signals error</i>              #M, #m  <i>undefined</i> 
#=  <i>label following object</i>     #N, #n  <i>undefined</i> 
#>  <i>undefined</i>                  #O, #o  <i>octal rational</i> 
#?  <i>undefined</i> *                #P, #p  <i>pathname</i> 
#@  <i>undefined</i>                  #Q, #q  <i>undefined</i> 
#[  <i>undefined</i> *                #R, #r  <i>radix-n rational</i> 
#\  <i>character object</i>           #S, #s  <i>structure</i> 
#]  <i>undefined</i> *                #T, #t  <i>undefined</i> 
#^  <i>undefined</i>                  #U, #u  <i>undefined</i> 
#_  <i>undefined</i>                  #V, #v  <i>undefined</i> 
#`  <i>undefined</i>                  #W, #w  <i>undefined</i> 
#{  <i>undefined</i> *                #X, #x  <i>hexadecimal rational</i> 
#|  <i>balanced comment</i>           #Y, #y  <i>undefined</i> 
#}  <i>undefined</i> *                #Z, #z  <i>undefined</i>    
#~  <i>undefined</i>                  #&lt;rubout&gt; <i>undefined</i>

The combinations marked by an asterisk are explicitly reserved to the user
and will never be defined by Common Lisp.

<img align=bottom alt="change_begin" src="gif/change_begin.gif"><br>
X3J13 voted in June 1989 (PATHNAME-PRINT-READ) to
specify #P and #p (<i>undefined</i> in the first edition).
<br><img align=bottom alt="change_end" src="gif/change_end.gif">

----------------------------------------------------------------

</pre>
<P>
The currently defined <tt>#</tt> constructs are described below
and summarized in table <A HREF="node191.html#StandardSharpMacroDefinitionsTable">22-4</A>;
more are likely to be added in the future.  However, the constructs
<tt>#!</tt>, <tt>#?</tt>, <tt>#[</tt>, <tt>#]</tt>,
<tt>#{</tt>, and <tt>#}</tt>
are explicitly reserved for the user and will never be defined by the
Common Lisp standard.
<DL COMPACT><DT><tt>#\</tt>
<DD>
<tt>#\<i>x</i></tt> reads in as a character object that represents the
character <i>x</i>.  Also, <tt>#\<i>name</i></tt> reads in as the character object
whose name is <i>name</i>.
<A NAME=21358>&#160;</A>
Note that the backslash <tt> </tt> allows this
construct to be parsed easily by EMACS-like editors.
<P>
In the single-character case, the character <i>x</i> must be followed
by a non-constituent character, lest a <i>name</i> appear to follow the
<tt>#\</tt>.  A good model of what happens is that after <tt>#\</tt> is read,
the reader backs up over the <tt> </tt> and then reads an extended token,
treating the initial <tt> </tt> as an escape character (whether it really
is or not in the current readtable).
<P>
Uppercase and lowercase letters are distinguished after <tt>#\</tt>;
<tt>#\A</tt> and <tt>#\a</tt> denote different character objects.  Any
character works after <tt>#\</tt>, even those that are normally special to
<tt>read</tt>, such as parentheses.  Non-printing characters may be used
after <tt>#\</tt>, although for them names are generally preferred.
<P>
<tt>#\<i>name</i></tt> reads in as a character object whose name is <i>name</i>
(actually, whose name is <tt>(string-upcase <i>name</i>)</tt>;
therefore the syntax is case-insensitive).
The <i>name</i> should have the syntax of a symbol.
The following names are standard across all implementations:
<PRE>
newline         The character that represents the division between lines
space           The space or blank character
</PRE>
The following names are semi-standard; if an implementation supports
them, they should be used for the described characters and no others.
<PRE>
rubout          The rubout or delete character.
page            The form-feed or page-separator character
tab             The tabulate character
backspace       The backspace character
return          The carriage return character
linefeed        The line-feed character
</PRE>
In some implementations, one or more of these characters might be
a synonym for a standard character; the <tt>#\Linefeed</tt> character
might be the same as <tt>#\Newline</tt>, for example.
<P>
When the Lisp printer types out the name of a special character, it uses the
same table as the <tt>#\</tt> reader; therefore any character name you see typed out
is acceptable as input (in that implementation).  Standard names are always
preferred over non-standard names for printing.
<P>
The following convention is used in implementations that support
non-zero bits attributes for character objects.
If a name after <tt>#\</tt> is longer than one character and has a hyphen in it,
then it may be split into the two parts preceding
and following the first hyphen; the first part (actually, <tt>string-upcase</tt>
of the first part)
may then be interpreted as
the name or initial of a bit, and the second part as the name of the character
(which may in turn contain a hyphen and be subject to further splitting).
For example:
<P><pre>
#\Control-Space         #\Control-Meta-Tab 
#\C-M-Return            #\H-S-M-C-Rubout
</pre><P>
If the character name consists of a single character, then that character
is used.  Another <tt> </tt> may be necessary to quote the character.
<P><pre>
#\Control-%             #\Control-Meta-\&quot; 
#\Control-\a             #\Meta-&gt;
</pre><P>
<P>
</dL>
<img align=bottom alt="old_change_begin" src="gif/old_change_begin.gif">
<dl compact><dd>
If an unsigned decimal integer appears between the <tt>#</tt> and <tt> </tt>,
it is interpreted as a font number, to become the font attribute
of the character object (see <tt>char-font</tt>).
</dl>
<img align=bottom alt="old_change_end" src="gif/old_change_end.gif">
<p>
<img align=bottom alt="change_begin" src="gif/change_begin.gif"><br>
<dl compact><dd>
X3J13 voted in March 1989 (CHARACTER-PROPOSAL) <A NAME=21416>&#160;</A> 
to replace the notion of bits and font attributes with
that of implementation-defined attributes.  Presumably
this eliminates the portable use of this syntax for font information,
although the vote did not address this question directly.
</dl>
<img align=bottom alt="change_end" src="gif/change_end.gif">
<dl compact>
<DT><tt>#'</tt>
<DD>
<tt>#'<i>foo</i></tt> is an abbreviation for <tt>(function <i>foo</i>)</tt>.
<i>foo</i> may be the printed representation of any Lisp object.
This abbreviation may be remembered by analogy with the <tt>'</tt>
macro character, since the <tt>function</tt> and <tt>quote</tt> special forms are
similar in form.
<P>
<DT><tt>#(</tt>
<DD>
A series of representations of objects enclosed by <tt>#(</tt> and <tt>)</tt>
is read as a simple vector of those objects.  This is analogous to
the notation for lists.
<P>
If an unsigned decimal integer appears between the <tt>#</tt> and <tt>(</tt>,
it specifies explicitly the length of the vector.  In that case,
it is an error if too many objects are specified before the closing <tt>)</tt>,
and if too few are specified, the last object
(it is an error if there are none in this case)
is used to fill all
remaining elements of the vector.
For example,
<P><pre>
#(a b c c c c) #6(a b c c c c) #6(a b c) #6(a b c c)
</pre><P>
all mean the same thing: a vector of length 6 with elements <tt>a</tt>, <tt>b</tt>,
and four instances of <tt>c</tt>.  
The notation <tt>#()</tt> denotes an empty vector, as does <tt>#0()</tt>
(which is legitimate because it is not the case that too few elements
are specified).
<P>
<DT><tt>#*</tt>
<DD>
A series of binary digits (<tt>0</tt> and <tt>1</tt>) preceded by <tt>#*</tt> is
read as a simple bit-vector containing those bits, the leftmost bit
in the series being bit 0 of the bit-vector.
<P>
If an unsigned decimal integer appears between the <tt>#</tt> and <tt>*</tt>,
it specifies explicitly the length of the vector.  In that case,
it is an error if too many bits are specified,
and if too few are specified the last one
(it is an error if there are none in this case)
is used to fill all remaining elements of the bit-vector.
For example,
<P><pre>
#*101111     #6*101111     #6*101     #6*1011
</pre><P>
all mean the same thing: a vector of length 6 with elements <tt>1</tt>, <tt>0</tt>,
<tt>1</tt>, <tt>1</tt>, <tt>1</tt>, and <tt>1</tt>.
The notation <tt>#*</tt> denotes an empty bit-vector, as does <tt>#0*</tt>
(which is legitimate because it is not the case that too few elements
are specified).
</dl>
<img align=bottom alt="change_begin" src="gif/change_begin.gif">
<dl compact><dd>
Compare this to <tt>#B</tt>, used for expressing integers in binary notation.
</dl>
<img align=bottom alt="change_end" src="gif/change_end.gif">
<dl compact>
<DT><tt>#:</tt>
<DD>
<tt>#:<i>foo</i></tt> requires <i>foo</i> to have the syntax of an unqualified
symbol name (no embedded colons).  It denotes an <i>uninterned</i> symbol
whose name is <i>foo</i>.  Every time this syntax is encountered, a different
uninterned symbol is created.  If it is necessary to refer to the
same uninterned symbol more than once in the same expression,
the <tt>#=</tt> syntax may be useful.
<P>
<DT><tt>#.</tt>
<DD>
<tt>#.<i>foo</i></tt> is read as the object resulting from the evaluation
of the Lisp object represented by <i>foo</i>,
which may be the printed representation of any Lisp object.
The evaluation is done during the <tt>read</tt> process, when the <tt>#.</tt>
construct is encountered.
<P>
</dl>
<img align=bottom alt="change_begin" src="gif/change_begin.gif">
<dl compact><dd>
X3J13 voted in June 1989 (DATA-IO) <A NAME=21469>&#160;</A>  to add a new reader control variable,
<tt>*read-eval*</tt>.  If it is true,
the <tt>#.</tt> reader macro behaves as described above;
if it is false, the <tt>#.</tt> reader macro signals an error.
</dl>
<img align=bottom alt="change_end" src="gif/change_end.gif">
<dl compact>
<dd>
The <tt>#.</tt> syntax therefore performs a read-time evaluation of <i>foo</i>.
By contrast, <tt>#,</tt> (see below) performs a load-time evaluation.
<P>
Both <tt>#.</tt> and <tt>#,</tt> allow you to include, in an expression
being read, an object that does not have a convenient printed
representation; instead of writing a representation for the object,
you write an expression that will <i>compute</i> the object.
<P>
</DL>
<img align=bottom alt="old_change_begin" src="gif/old_change_begin.gif">
<DL COMPACT><DT><tt>#,</tt>
<DD>
<tt>#,<i>foo</i></tt> is read as the object resulting from the evaluation
of the Lisp object represented by <i>foo</i>,
which may be the printed representation of any Lisp object.
The evaluation is done during the <tt>read</tt> process,
unless the compiler is doing the reading, in which case it is arranged
that <i>foo</i> will be evaluated when the file of compiled code is loaded.
The <tt>#,</tt> syntax therefore performs a load-time evaluation of <i>foo</i>.
By contrast, <tt>#.</tt> (see above) performs a read-time evaluation.
In a sense, <tt>#,</tt> is like specifying <tt>(eval load)</tt> to
<tt>eval-when</tt>, whereas <tt>#.</tt> is more like specifying <tt>(eval compile)</tt>.
It makes no difference when loading interpreted code; when code
is to be compiled, however, <tt>#.</tt> specifies compile-time evaluation and
<tt>#,</tt> specifies load-time evaluation.
</DL>
<img align=bottom alt="old_change_end" src="gif/old_change_end.gif">
<P>
<img align=bottom alt="change_begin" src="gif/change_begin.gif"><br>
X3J13 voted in January 1989
(SHARP-COMMA-CONFUSION) <A NAME=21501>&#160;</A> 
to remove <tt>#,</tt> from the language.
X3J13 noted that the first edition failed to make it clear that <tt>#,</tt>
can be meaningful only within quoted forms.  All sorts of anomalies can arise,
including inconsistencies between the interpreter and compiler, if <tt>#,</tt>
is not properly restricted.  See <tt>load-time-eval</tt>.
<br><img align=bottom alt="change_end" src="gif/change_end.gif">
<P>
<DL COMPACT><DT><tt>#B</tt>
<DD>
<tt>#b<i>rational</i></tt> reads <i>rational</i> in binary (radix 2).
For example, <tt>#B1101</tt> == <tt>13</tt>, and <tt>#b101/11</tt> == <tt>5/3</tt>.
</dl>
<img align=bottom alt="change_begin" src="gif/change_begin.gif">
<dl compact><dd>
Compare this to <tt>#*</tt>, used for expressing bit-vectors in binary notation.
</dl>
<img align=bottom alt="change_end" src="gif/change_end.gif">
<dl compact>
<DT><tt>#O</tt>
<DD>
<tt>#o<i>rational</i></tt> reads <i>rational</i> in octal (radix 8).
For example, <tt>#o37/15</tt> == <tt>31/13</tt>, and <tt>#o777</tt> == <tt>511</tt>.
<P>
<DT><tt>#X</tt>
<DD>
<tt>#x<i>rational</i></tt> reads <i>rational</i> in hexadecimal (radix 16).
The digits above <tt>9</tt> are the letters <tt>A</tt> through <tt>F</tt> (the lowercase
letters <tt>a</tt> through <tt>f</tt> are also acceptable).  For example,
<tt>#xF00</tt> == <tt>3840</tt>.
<P>
<DT><tt>#<i>n</i>R</tt>
<DD>
<tt>#<i>radix</i>r<i>rational</i></tt> reads <i>rational</i> in radix <i>radix</i>.
<i>radix</i> must consist of only digits, and
it is read in decimal; its value must be between 2 and 36 (inclusive).
<P>

<P>
For example, <tt>#3r102</tt> is another way of writing <tt>11</tt>, and <tt>#11R32</tt>
is another way of writing <tt>35</tt>.  For radices larger than 10, letters of
the alphabet are used in order for the digits after <tt>9</tt>.
<P>
<DT><tt>#<i>n</i>A</tt>
<DD>
The syntax <tt>#<i>n</i>A<i>object</i></tt> constructs an <i>n</i>-dimensional array,
using <i>object</i> as the value of the <tt>:initial-contents</tt> argument
to <tt>make-array</tt>.
<P>
The value of <i>n</i> makes a difference:
<tt>#2A((0 1 5) (foo 2 (hot dog)))</tt>, for example, represents a 2-by-3 matrix:
<P><pre>
0       1       5 
foo     2       (hot dog)
</pre><P>
In contrast, <tt>#1A((0 1 5) (foo 2 (hot dog)))</tt> represents a length-2
array whose elements are lists:
<P><pre>
(0 1 5)    (foo 2 (hot dog))
</pre><P>
Furthermore, <tt>#0A((0 1 5) (foo 2 (hot dog)))</tt> represents a zero-dimensional
array whose sole element is a list:
<P><pre>
((0 1 5) (foo 2 (hot dog)))
</pre><P>
Similarly, <tt>#0Afoo</tt> (or, more readably, <tt>#0A foo</tt>) represents
a zero-dimensional array whose sole element is the symbol <tt>foo</tt>.
The expression <tt>#1Afoo</tt> would not be legal because <tt>foo</tt> is
not a sequence.
<P>
<DT><tt>#S</tt>
<DD>
The syntax <tt>#s(<i>name</i> <i>slot1</i> <i>value1</i> <i>slot2</i> <i>value2</i> ...)</tt>
denotes a structure.  This is legal only if <i>name</i> is the name
of a structure already defined by <tt>defstruct</tt> and if the
structure has a standard constructor macro, which it normally will.
Let <i>cm</i> stand for the name of this constructor macro;
then this syntax is equivalent to
<P><pre>
#.(<i>cm</i> <i>keyword1</i> '<i>value1</i> <i>keyword2</i> '<i>value2</i> ...)
</pre><P>
where each <i>keywordj</i> is the result of computing
<P><pre>
(intern (string <i>slotj</i>) 'keyword)
</pre><P>
(This computation is made so that one need not write a colon in
front of every slot name.)
The net effect is that the constructor macro is called
with the specified slots
having the specified values (note that one does not write quote marks
in the <tt>#S</tt> syntax).  Whatever object the constructor macro returns
is returned by the <tt>#S</tt> syntax.
</DL>
<img align=bottom alt="change_begin" src="gif/change_begin.gif"><br>
<DL COMPACT><DT><tt>#P</tt>
<DD>
X3J13 voted in June 1989 (PATHNAME-PRINT-READ) <A NAME=21594>&#160;</A> 
to define the reader syntax <tt>#p&quot;...&quot;</tt> to be equivalent to
<tt>#.(parse-namestring &quot;...&quot;)</tt>.  Presumably this was meant to
be taken descriptively and not literally.  I would think, for example,
that the committee did not wish to quibble over the package in which
the name <tt>parse-namestring</tt> was to be read.  Similarly, I would
presume that the <tt>#p</tt> syntax operates normally rather than signaling
an error when <tt>*read-eval*</tt> is false.  I interpret the intent
of the vote to be that <tt>#p</tt> reads a following form, which should be
a string, that is then converted to a pathname as if by application
of the standard function <tt>parse-namestring</tt>.
</DL>
<img align=bottom alt="change_end" src="gif/change_end.gif">
<DL COMPACT><DT><tt>#<i>n</i>=</tt>
<DD>
The syntax <tt>#<i>n</i>=<i>object</i></tt> reads as whatever Lisp object
has <i>object</i> as its printed representation.  However, that object
is labelled by <i>n</i>, a required unsigned decimal integer, for
possible reference by the syntax <tt>#<i>n</i>#</tt> (below).
The scope of the label is the expression being read by the outermost
call to <tt>read</tt>.  Within this expression
the same label may not appear twice.
<P>
<DT><tt>#<i>n</i>#</tt>
<DD>
The syntax <tt>#<i>n</i>#</tt>, where <i>n</i> is a required unsigned decimal integer,
serves as a reference to some object labelled by <tt>#<i>n</i>=</tt>;
that is, <tt>#<i>n</i>#</tt> represents a pointer to the same identical
(<tt>eq</tt>) object labelled by <tt>#<i>n</i>=</tt>.
This permits notation of structures with shared or circular substructure.
For example, a structure created in the variable <tt>y</tt> by this code:
<P><pre>
(setq x (list 'p 'q)) 
(setq y (list (list 'a 'b) x 'foo x)) 
(rplacd (last y) (cdr y))
</pre><P>
could be represented in this way:
<P><pre>
((a b) . #1=(#2=(p q) foo #2# . #1#))
</pre><P>
Without this notation, but with <tt>*print-length*</tt> set to <tt>10</tt>,
the structure would print in this way:
<P><pre>
((a b) (p q) foo (p q) (p q) foo (p q) (p q) foo (p q) ...)
</pre><P>
A reference <tt>#<i>n</i>#</tt> may occur only after a label <tt>#<i>n</i>=</tt>;
forward references are not permitted.  In addition, the reference
may not appear as the labelled object itself (that is,
one may not write <tt>#<i>n</i>= #<i>n</i>#</tt>), because the object
labelled by <tt>#<i>n</i>=</tt> is not well defined in this case.
<P>
<DT><tt>#+</tt>
<DD>
<A NAME=READTIMECONDITIONAL>&#160;</A>
The <tt>#+</tt> syntax provides a read-time conditionalization facility;
the syntax is
<P><pre>
#+<i>feature</i> <i>form</i>
</pre><P>
If <i>feature</i> is ``true,'' then this syntax represents a Lisp object
whose printed representation is <i>form</i>.  If <i>feature</i> is ``false,''
then this syntax is effectively whitespace; it is as if it did not appear.
<P>
The <i>feature</i> should be the printed representation of a symbol or list.
If <i>feature</i> is a symbol, then 
it is true if and only if it is a member of the list that is the value of
the global variable <tt>*features*</tt>.
<P>
</dl>
<hr>
<b>Compatibility note:</b> MacLisp uses the <tt>status</tt> special form for
this purpose, and Lisp Machine Lisp duplicates <tt>status</tt> essentially only
for the sake of <tt>(status features)</tt>.  The use of a variable allows
one to bind the features list, when compiling, for example.
<hr>
<dl compact><dd>
Otherwise,
<i>feature</i> should be a Boolean expression composed of <tt>and</tt>, <tt>or</tt>, and
<tt>not</tt> operators on (recursive) <i>feature</i> expressions.
<P>
For example, suppose that in implementation A the features <tt>spice</tt> and
<tt>perq</tt> are true, and in implementation B the feature <tt>lispm</tt> is true.
Then the expressions on the left below are read the same as those on the
right in implementation A:
<P><listing>
(cons #+spice "Spice" #+lispm "Lispm" x)      (cons "Spice" x) 
(setq a '(1 2 #+perq 43 #+(not perq) 27))     (setq a '(1 2 43)) 
(let ((a 3) #+(or spice lispm) (b 3))         (let ((a 3) (b 3)) 
  (foo a))                                      (foo a))
(cons a #+perq #-perq b c)                    (cons a c)
</listing>
In implementation B, however, they are read in this way:
<P><listing>
(cons #+spice "Spice" #+lispm "Lispm" x)      (cons "Lispm" x) 
(setq a '(1 2 #+perq 43 #+(not perq) 27))     (setq a '(1 2 27)) 
(let ((a 3) #+(or spice lispm) (b 3))         (let ((a 3) (b 3)) 
  (foo a))                                      (foo a))
(cons a #+perq #-perq b c)                    (cons a c)
</listing><P>
<P>
The <tt>#+</tt> construction must be used judiciously if unreadable code is
not to result.  The user should make a careful choice between read-time
conditionalization and run-time conditionalization.
</dl>
<img align=bottom alt="old_change_begin" src="gif/old_change_begin.gif">
<dl compact><dd>
The <tt>#+</tt> syntax operates by first reading the <i>feature</i> specification
and then skipping over the <i>form</i> if the <i>feature</i> is ``false.''
This skipping of a form is a bit tricky because of the possibility of
user-defined macro characters and side effects caused by the <tt>#.</tt> and 
<tt>#,</tt> constructions.  It is accomplished by binding the variable
<tt>*read-suppress*</tt> to a non-<tt>nil</tt> value and then calling the <tt>read</tt>
function.  See the description of <tt>*read-suppress*</tt> for the details
of this operation.
</dl>
<img align=bottom alt="old_change_end" src="gif/old_change_end.gif">
<p>
<img align=bottom alt="change_begin" src="gif/change_begin.gif">
<dl compact><dd>
X3J13 voted in January 1989
(SHARP-COMMA-CONFUSION) <A NAME=21678>&#160;</A> 
to remove <tt>#,</tt> from the language.
<P>
X3J13 voted in March 1988 (SHARPSIGN-PLUS-MINUS-PACKAGE) <A NAME=21682>&#160;</A> 
to specify that the <tt>keyword</tt> package is the default package during
the reading of a feature specification.  Thus <tt>#+spice</tt> means the
same thing as <tt>#+:spice</tt>, and
<tt>#+(or spice lispm)</tt> means the same thing as <tt>#+(or :spice :lispm)</tt>.
Symbols in other packages
may be used as feature names, but one must use an explicit package prefix
to cite one after <tt>#+</tt>.
</dl>
<img align=bottom alt="change_end" src="gif/change_end.gif">
<dl compact>
<DT><tt>#-</tt>
<DD>
<tt>#-<i>feature</i> <i>form</i></tt> is equivalent to <tt>#+(not <i>feature</i>) <i>form</i></tt>.
<P>
<DT><tt>#|</tt>
<DD>
<tt>#|...|#</tt> is treated as a comment by the reader, just as everything
from a semicolon to the next newline is treated as a comment.
Anything may appear in the comment, except that it must be balanced
with respect to other occurrences of <tt>#|</tt> and <tt>|#</tt>.
Except for this nesting rule, the comment may contain any characters
whatsoever.
<P>
The main purpose of this construct is to allow ``commenting out''
of blocks of code or data.  The balancing rule allows such blocks
to contain pieces already so commented out.  In this respect
the <tt>#|...|#</tt> syntax of Common Lisp differs from the <tt>/*...*/</tt> comment syntax
used by PL/I and C.
<P>
<DT><tt>#&lt;</tt>
<DD>
This is not legal reader syntax.
It is conventionally used in the printed representation of objects that cannot
be read back in.  Attempting to read a <tt>#&lt;</tt> will cause an error.
(More precisely, it <i>is</i> legal syntax, but the macro-character
function for <tt>#&lt;</tt> signals an error.)
</dl>
<img align=bottom alt="change_begin" src="gif/change_begin.gif">
<dl compact><dd>
The usual convention for printing unreadable data objects is to print some identifying
information (the internal machine address of the object, if nothing else)
preceded by <tt>#&lt;</tt> and followed by <tt>&gt;</tt>.
<P>
X3J13 voted in June 1989 (DATA-IO) <A NAME=21709>&#160;</A>  to add
<tt>print-unreadable-object</tt>, a macro that prints an object using <tt>#&lt;...&gt;</tt>
syntax and also takes care of checking the variable <tt>*print-readably*</tt>.
</dl>
<img align=bottom alt="change_end" src="gif/change_end.gif">
<dl compact>
<DT><tt>#</tt><b><</b>space<b>></b>, <tt> #</tt><b><</b>tab<b>></b>,
      <tt> #</tt><b><</b>newline<b>></b>,
      <tt> #</tt><b><</b>page<b>></b>, <tt> #</tt><b><</b>return<b>></b>
<DD>
A <tt>#</tt> followed by a whitespace character is not legal reader syntax.
This prevents abbreviated forms produced via <tt>*print-level*</tt> cutoff
from reading in again, as a safeguard against losing
information.
(More precisely, this <i>is</i> legal syntax, but the macro-character
function for it signals an error.)
<P>
<DT><tt>#)</tt>
<DD>
This is not legal reader syntax.
This prevents abbreviated forms produced via <tt>*print-level*</tt> cutoff
from reading in again, as a safeguard against losing information.
(More precisely, this <i>is</i> legal syntax, but the macro-character
function for it signals an error.)
<P>
 </DL>
<P>
<BR> <HR><A NAME=tex2html3927 HREF="node192.html"><IMG ALIGN=BOTTOM ALT="next" SRC="icons/next_motif.gif"></A> <A NAME=tex2html3925 HREF="node187.html"><IMG ALIGN=BOTTOM ALT="up" SRC="icons/up_motif.gif"></A> <A NAME=tex2html3919 HREF="node190.html"><IMG ALIGN=BOTTOM ALT="previous" SRC="icons/previous_motif.gif"></A> <A NAME=tex2html3929 HREF="node1.html"><IMG ALIGN=BOTTOM ALT="contents" SRC="icons/contents_motif.gif"></A> <A NAME=tex2html3930 HREF="index-2.html"><IMG ALIGN=BOTTOM ALT="index" SRC="icons/index_motif.gif"></A> <BR>
<B> Next:</B> <A NAME=tex2html3928 HREF="node192.html"> The Readtable</A>
<B>Up:</B> <A NAME=tex2html3926 HREF="node187.html"> Printed Representation of </A>
<B> Previous:</B> <A NAME=tex2html3920 HREF="node190.html"> Macro Characters</A>
<HR> <P>
<HR>
<P><ADDRESS>
AI.Repository@cs.cmu.edu
</ADDRESS>
</BODY>
