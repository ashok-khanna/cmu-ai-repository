<!DOCTYPE HTML PUBLIC "-//W3O//DTD W3 HTML 2.0//EN">
<!Converted with LaTeX2HTML 0.6.5 (Tue Nov 15 1994) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds >

<!-- Mirrored from www.cs.cmu.edu/afs/cs/project/ai-repository/ai/util/html/cltl/clm/node73.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 22 Oct 2021 00:31:38 GMT -->
<HEAD>
<TITLE>6.2.2. Specific Data Type Predicates</TITLE>
</HEAD>
<BODY>
<meta name="description" value=" Specific Data Type Predicates">
<meta name="keywords" value="clm">
<meta name="resource-type" value="document">
<meta name="distribution" value="global">
<P>
<b>Common Lisp the Language, 2nd Edition</b>
 <BR> <HR><A NAME=tex2html2422 HREF="node74.html"><IMG ALIGN=BOTTOM ALT="next" SRC="icons/next_motif.gif"></A> <A NAME=tex2html2420 HREF="node71.html"><IMG ALIGN=BOTTOM ALT="up" SRC="icons/up_motif.gif"></A> <A NAME=tex2html2416 HREF="node72.html"><IMG ALIGN=BOTTOM ALT="previous" SRC="icons/previous_motif.gif"></A> <A NAME=tex2html2424 HREF="node1.html"><IMG ALIGN=BOTTOM ALT="contents" SRC="icons/contents_motif.gif"></A> <A NAME=tex2html2425 HREF="index-2.html"><IMG ALIGN=BOTTOM ALT="index" SRC="icons/index_motif.gif"></A> <BR>
<B> Next:</B> <A NAME=tex2html2423 HREF="node74.html"> Equality Predicates</A>
<B>Up:</B> <A NAME=tex2html2421 HREF="node71.html"> Data Type Predicates</A>
<B> Previous:</B> <A NAME=tex2html2417 HREF="node72.html"> General Type Predicates</A>
<HR> <P>
<H2><A NAME=SECTION001022000000000000000>6.2.2. Specific Data Type Predicates</A></H2>
<P>
The following predicates test for individual data types.
<P>
<BR><b>[Function]</b><BR>
<tt>null</tt> <tt><i>object</i></tt><P>
<tt>null</tt> is true if its argument is <tt>()</tt>,
and otherwise is false.
This is the same operation performed by the function <tt>not</tt>;
however, <tt>not</tt> is normally used to invert a Boolean value,
whereas <tt>null</tt> is normally used to test for an empty list.  The programmer
can therefore express <i>intent</i> by the choice of function name.
<P><pre>
(null x) == (typep x 'null) == (eq x '<tt>()</tt>)
</pre><P>
<BR><b>[Function]</b><BR>
<tt>symbolp</tt> <tt><i>object</i></tt><P><tt>symbolp</tt> is true if its argument is a symbol,
and otherwise is false.
<P><pre>
(symbolp x) == (typep x 'symbol)
</pre><P>
<hr>
<b>Compatibility note:</b> The Interlisp equivalent of <tt>symbolp</tt> is
called <tt>litatom</tt>.
<hr>
<P>
<BR><b>[Function]</b><BR>
<tt>atom</tt> <tt><i>object</i></tt><P>The predicate <tt>atom</tt> is true if its argument is not a cons,
and otherwise is false.
Note that <tt>(atom '<tt>()</tt>)</tt> is true, because <tt>()</tt><IMG ALIGN=BOTTOM ALT="" SRC="_24769_tex2html_wrap40411.gif"><tt>nil</tt>.
<P><pre>
(atom x) == (typep x 'atom) == (not (typep x 'cons))
</pre><P>
<hr>
<b>Compatibility note:</b> In some Lisp dialects, notably Interlisp,
only symbols and numbers are considered to be atoms; arrays
and strings are considered to be neither atoms nor lists (conses).
<hr>
<P>
<BR><b>[Function]</b><BR>
<tt>consp</tt> <tt><i>object</i></tt><P>The predicate <tt>consp</tt> is true if its argument is a cons,
and otherwise is false.
Note that the empty list is not a cons, so
<tt>(consp '<tt>()</tt>)</tt> == <tt>(consp '<tt>nil</tt>)</tt> => <tt>nil</tt>.
<P><pre>
(consp x) == (typep x 'cons) == (not (typep x 'atom))
</pre><P>
<hr>
<b>Compatibility note:</b> Some Lisp implementations call this function
<tt>pairp</tt> or <tt>listp</tt>.  The name <tt>pairp</tt> was rejected for Common Lisp
because it emphasizes too strongly the dotted-pair notion rather than the
usual usage of conses in lists.  On the other hand, <tt>listp</tt> too strongly
implies that the cons is in fact part of a list, which after all it might
not be; moreover, <tt>()</tt> is a list, though not a cons.
The name <tt>consp</tt> seems to be the appropriate compromise.
<hr>
<P>
<BR><b>[Function]</b><BR>
<tt>listp</tt> <tt><i>object</i></tt><P><tt>listp</tt> is true if its argument is a cons or the empty list <tt>()</tt>,
and otherwise is false.  It does not check for whether the list
is a ``true list'' (one terminated by <tt>nil</tt>) or a ``dotted list''
(one terminated by a non-null atom).
<P><pre>
(listp x) == (typep x 'list) == (typep x '(or cons null))
</pre><P>
<BR><b>[Function]</b><BR>
<tt>numberp</tt> <tt><i>object</i></tt><P><tt>numberp</tt> is true if its argument is any kind of number,
and otherwise is false.
<P><pre>
(numberp x) == (typep x 'number)
</pre><P>
<BR><b>[Function]</b><BR>
<tt>integerp</tt> <tt><i>object</i></tt><P><tt>integerp</tt> is true if its argument is an integer, and otherwise
is false.
<P><pre>
(integerp x) == (typep x 'integer)
</pre><P>
<hr>
<b>Compatibility note:</b> In MacLisp this is called <tt>fixp</tt>.
Users have been confused as to whether this meant <tt>integerp</tt>
or <tt>fixnump</tt>, and so the name <tt>integerp</tt> has been adopted here.
<hr>
<P>
<BR><b>[Function]</b><BR>
<tt>rationalp</tt> <tt><i>object</i></tt><P><tt>rationalp</tt> is true if its argument is a rational number (a ratio or
an integer), and otherwise is false.
<P><pre>
(rationalp x) == (typep x 'rational)
</pre><P>
<BR><b>[Function]</b><BR>
<tt>floatp</tt> <tt><i>object</i></tt><P><tt>floatp</tt> is true if its argument is a floating-point number,
and otherwise is false.
<P><pre>
(floatp x) == (typep x 'float)
</pre><P>
<img align=bottom alt="change_begin" src="gif/change_begin.gif"><br>
<BR><b>[Function]</b><BR>
<tt>realp</tt> <tt><i>object</i></tt><P>X3J13 voted in March 1989 (REAL-NUMBER-TYPE) <A NAME=4196>&#160;</A>  to add the function <tt>realp</tt>.
<tt>realp</tt> is true if its argument is a real number,
and otherwise is false.
<P><pre>
(realp x) == (typep x 'real)
</pre><P>
<img align=bottom alt="change_end" src="gif/change_end.gif">
<P>
<BR><b>[Function]</b><BR>
<tt>complexp</tt> <tt><i>object</i></tt><P><tt>complexp</tt> is true if its argument is a complex number,
and otherwise is false.
<P><pre>
(complexp x) == (typep x 'complex)
</pre><P>
<BR><b>[Function]</b><BR>
<tt>characterp</tt> <tt><i>object</i></tt><P><tt>characterp</tt> is true if its argument is a character,
and otherwise is false.
<P><pre>
(characterp x) == (typep x 'character)
</pre><P>
<BR><b>[Function]</b><BR>
<tt>stringp</tt> <tt><i>object</i></tt><P><tt>stringp</tt> is true if its argument is a string,
and otherwise is false.
<P><pre>
(stringp x) == (typep x 'string)
</pre><P>
<BR><b>[Function]</b><BR>
<tt>bit-vector-p</tt> <tt><i>object</i></tt><P><tt>bit-vector-p</tt> is true if its argument is a bit-vector,
and otherwise is false.
<P><pre>
(bit-vector-p x) == (typep x 'bit-vector)
</pre><P>
<BR><b>[Function]</b><BR>
<tt>vectorp</tt> <tt><i>object</i></tt><P><tt>vectorp</tt> is true if its argument is a vector,
and otherwise is false.
<P><pre>
(vectorp x) == (typep x 'vector)
</pre><P>
<BR><b>[Function]</b><BR>
<tt>simple-vector-p</tt> <tt><i>object</i></tt><P><tt>vectorp</tt> is true if its argument is a simple general vector,
and otherwise is false.
<P><pre>
(simple-vector-p x) == (typep x 'simple-vector)
</pre><P>
<BR><b>[Function]</b><BR>
<tt>simple-string-p</tt> <tt><i>object</i></tt><P><tt>simple-string-p</tt> is true if its argument is a simple string,
and otherwise is false.
<P><pre>
(simple-string-p x) == (typep x 'simple-string)
</pre><P>
<BR><b>[Function]</b><BR>
<tt>simple-bit-vector-p</tt> <tt><i>object</i></tt><P><tt>simple-bit-vector-p</tt> is true if its argument is a simple bit-vector,
and otherwise is false.
<P><pre>
(simple-bit-vector-p x) == (typep x 'simple-bit-vector)
</pre>
<P>
<BR><b>[Function]</b><BR>
<tt>arrayp</tt> <tt><i>object</i></tt><P><tt>arrayp</tt> is true if its argument is an array,
and otherwise is false.
<P><pre>
(arrayp x) == (typep x 'array)
</pre><P>
<BR><b>[Function]</b><BR>
<tt>packagep</tt> <tt><i>object</i></tt><P><tt>packagep</tt> is true if its argument is a package,
and otherwise is false.
<P><pre>
(packagep x) == (typep x 'package)
</pre><P>
<BR><b>[Function]</b><BR>
<tt>functionp</tt> <tt><i>object</i></tt><P>
<img align=bottom alt="old_change_begin" src="gif/old_change_begin.gif"><br>
<tt>functionp</tt> is true if its argument is suitable for applying
to arguments, using for example the <tt>funcall</tt> or <tt>apply</tt> function.
Otherwise <tt>functionp</tt> is false.
<P>
<tt>functionp</tt> is always true of symbols, lists whose <i>car</i>
is the symbol <tt>lambda</tt>, any value returned by the <tt>function</tt>
special form, and any values returned by the function <tt>compile</tt>
when the first argument is <tt>nil</tt>.
<br><img align=bottom alt="old_change_end" src="gif/old_change_end.gif">
<P>
<img align=bottom alt="change_begin" src="gif/change_begin.gif"><br>
X3J13 voted in June 1988 (FUNCTION-TYPE) <A NAME=4267>&#160;</A> 
to define
<P><pre>
(functionp x) == (typep x 'function)
</pre><P>
Because the vote also specifies that types <tt>cons</tt> and <tt>symbol</tt> are disjoint
from the type <tt>function</tt>, this is an incompatible change;
now <tt>functionp</tt> is in fact always false of symbols and lists.
<br><img align=bottom alt="change_end" src="gif/change_end.gif">
<P>
<BR><b>[Function]</b><BR>
<tt>compiled-function-p</tt> <tt><i>object</i></tt><P><tt>compiled-function-p</tt> is true if its argument is any compiled code object,
and otherwise is false.
<P><pre>
(compiled-function-p x) == (typep x 'compiled-function)
</pre><P>
<P>
<img align=bottom alt="old_change_begin" src="gif/old_change_begin.gif">
<BR><b>[Function]</b><BR>
<tt>commonp</tt> <tt><i>object</i></tt><P><tt>commonp</tt> is true if its argument is any standard Common Lisp data type,
and otherwise is false.
<P><pre>
(commonp x) == (typep x 'common)
</pre><P>
<img align=bottom alt="old_change_end" src="gif/old_change_end.gif">
<P>
<img align=bottom alt="change_begin" src="gif/change_begin.gif"><br>
X3J13 voted in March 1989
(COMMON-TYPE) <A NAME=4289>&#160;</A> 
to remove the predicate <tt>commonp</tt> (and the type <tt>common</tt>) from the language.
<br><img align=bottom alt="change_end" src="gif/change_end.gif">
<P>
<P>See also <tt>standard-char-p</tt>, <tt>string-char-p</tt>,
<tt>streamp</tt>, <tt>random-state-p</tt>,
<tt>readtablep</tt>,
<tt>hash-table-p</tt>, and <tt>pathnamep</tt>.
<P>
<BR> <HR><A NAME=tex2html2422 HREF="node74.html"><IMG ALIGN=BOTTOM ALT="next" SRC="icons/next_motif.gif"></A> <A NAME=tex2html2420 HREF="node71.html"><IMG ALIGN=BOTTOM ALT="up" SRC="icons/up_motif.gif"></A> <A NAME=tex2html2416 HREF="node72.html"><IMG ALIGN=BOTTOM ALT="previous" SRC="icons/previous_motif.gif"></A> <A NAME=tex2html2424 HREF="node1.html"><IMG ALIGN=BOTTOM ALT="contents" SRC="icons/contents_motif.gif"></A> <A NAME=tex2html2425 HREF="index-2.html"><IMG ALIGN=BOTTOM ALT="index" SRC="icons/index_motif.gif"></A> <BR>
<B> Next:</B> <A NAME=tex2html2423 HREF="node74.html"> Equality Predicates</A>
<B>Up:</B> <A NAME=tex2html2421 HREF="node71.html"> Data Type Predicates</A>
<B> Previous:</B> <A NAME=tex2html2417 HREF="node72.html"> General Type Predicates</A>
<HR> <P>
<HR>
<P><ADDRESS>
AI.Repository@cs.cmu.edu
</ADDRESS>
</BODY>
