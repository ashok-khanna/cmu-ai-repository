
<!-- Mirrored from www.cs.cmu.edu/afs/cs/project/ai-repository/ai/util/html/faqs/lang/lisp/part1/faq-doc-2.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 22 Oct 2021 17:20:47 GMT -->
<HEAD>
<TITLE>FAQ: Lisp Frequently Asked Questions 1/7 [Monthly posting] - [1-1] What is the difference between Scheme and Common Lisp?</TITLE>
</HEAD>
<BODY>
<H1>[1-1] What is the difference between Scheme and Common Lisp?</H1>
<PRE>
Scheme is a dialect of Lisp that stresses conceptual elegance and
simplicity. It is specified in R4RS and IEEE standard P1178. (See
the Scheme FAQ for details on standards for Scheme.) Scheme is much
smaller than Common Lisp; the specification is about 50 pages,
compared to Common Lisp's 1300 page draft standard. (See question
[4-10] for details on standards for Common Lisp.) Advocates of Scheme
often find it amusing that the Scheme standard is shorter than the
index to CLtL2. 

Scheme is often used in computer science curricula and programming
language research, due to its ability to represent many programming
abstractions with its simple primitives. Common Lisp is often used for
real world programming because of its large library of utility
functions, a standard object-oriented programming facility (CLOS), and
a sophisticated condition handling system.

See the Scheme FAQ for information about object-oriented programming
in Scheme. 

In Common Lisp, a simple program would look something like the
following:

   (defun fact (n)
     (if (&#60; n 2)
         1
         (* n (fact (1- n)))))

In Scheme, the equivalent program would like like this:

   (define fact
     (lambda (n)
       (if (&#60; n 2)
           1
         (* n (fact (- n 1))))))

Experienced Lisp programmers might write this program as follows in order
to allow it to run in constant space:

   (defun fact (n)
     (labels ((tail-recursive-fact (counter accumulator)
                (if (&#62; counter n)
                    accumulator
                    (tail-recursive-fact (1+ counter)
                                         (* counter accumulator)))))
       (tail-recursive-fact 1 1)))

Whereas in Scheme the same computation could be written as follows:

   (define fact
     (lambda (n)
       (letrec ((tail-recursive-fact
                 (lambda (counter accumulator)
                   (if (&#62; counter n)
                       accumulator
                     (tail-recursive-fact (+ counter 1)
                                          (* counter accumulator))))))
               (tail-recursive-fact 1 1))))

or perhaps (using IEEE named LETs):

   (define fact
     (lambda (n)
       (let loop ((counter n)
                  (accumulator 1))
            (if (&#60; counter 2)
                accumulator
              (loop (- counter 1)
                    (* accumulator counter))))))

Some Schemes allow one to use the syntax (define (fact n) ...) instead
of (define fact (lambda (n) ...)).
</PRE>
<A NAME=up HREF="faq.html">Go Back Up</A><P>
<A NAME=up HREF="faq-doc-1.html">Go To Previous</A><P>
<A NAME=up HREF="faq-doc-3.html">Go To Next</A><P>
</BODY>
