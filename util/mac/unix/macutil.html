#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create:
#	macutil
# This archive created: Mon Apr 27 02:10:27 1992
export PATH; PATH=/bin:/usr/bin:$PATH
if test ! -d 'macutil'
then
	echo shar: "creating directory 'macutil'"
	mkdir 'macutil'
fi
echo shar: "entering directory 'macutil'"
cd 'macutil'
if test ! -d 'crc'
then
	echo shar: "creating directory 'crc'"
	mkdir 'crc'
fi
echo shar: "entering directory 'crc'"
cd 'crc'
echo shar: "extracting 'makecrc.c'" '(4416 characters)'
if test -f 'makecrc.c'
then
	echo shar: "will not over-write existing file 'makecrc.c'"
else
sed 's/^X//' << \SHAR_EOF > 'makecrc.c'
X/* This program will write six C routines for the calculation of
X * the following CRC's. */
X
X/* The CRC polynomial.
X * These 4 values define the crc-polynomial.
X * If you change them, you must change crctab[]'s initial value to what is
X * printed by initcrctab() [see 'compile with -DMAKETAB' above].
X */
X
X/* This tables assumes CCITT is MSB first.  Swapped means LSB first.   In that
X * case the polynomial is also swapped
X */
X
X/* 16 bit crc's */
X/* Value used by:			CCITT	KERMIT	ARC	BINHEX	*/
X/* the poly:				0x1021	0x8408	0xA001	0x1021	*/
X/* original:				0x1021	0x1021	0x8005	0x1021	*/
X/* init value:				-1	0	0	0	*/
X/* swapped:				no	yes	yes	no	*/
X/* bits in CRC:				16	16	16	16	*/
X/* ARC used by LHARC, ZOO, STUFFIT					*/
X/* BINHEX used by XMODEM, PACKIT					*/
X
X/* 32 bit crc's */
X/* Value used by:			CCITT32		ZIP		*/
X/* the poly:				0x04c11db7	0xedb88320	*/
X/* original:				0x04c11db7	0x04c11db7	*/
X/* init value:				-1		-1		*/
X/* swapped				no		yes		*/
X/* bits in CRC:				32		32		*/
X/* ZIP used by COMPACTOR						*/
X
X#include <stdio.h>
X
Xextern void exit();
Xextern char *strcat();
X
Xstatic void initcrctab();
X
Xmain()
X{
X    initcrctab("ccitt", 0x1021, 0xffff, 0, 16);
X    initcrctab("kermit", 0x8408, 0, 1, 16);
X    initcrctab("arc", 0xa001, 0, 1, 16);
X    initcrctab("binhex", 0x1021, 0, 0, 16);
X    initcrctab("ccitt32",0x04c11db7,0xffffffff,0,32);
X    initcrctab("zip",0xedb88320,0xffffffff,1,32);
X    exit(0);
X    /*NOTREACHED*/
X}
X
Xstatic void initcrctab(name, poly, init, swapped, bits)
Xchar *name;
Xint poly, init, swapped, bits;
X{
X    register  int b, i;
X    unsigned short v;
X    unsigned long vv;
X    FILE *fd;
X    char buf[20];
X    
X    buf[0] = 0;
X    (void)strcat(buf, name);
X    (void)strcat(buf, ".c");
X    if((fd = fopen(buf, "w")) == NULL) {
X	(void)fprintf(stderr, "Cannot open %s for writing\n", buf);
X	exit(1);
X    }
X    (void)fprintf(fd, "unsigned long %s_crcinit = %d;\n", name, init);
X    (void)fprintf(fd, "\n");
X    if(bits == 16) {
X	(void)fprintf(fd, "static unsigned short crctab[256] = {\n");
X    } else {
X	(void)fprintf(fd, "static unsigned long crctab[256] = {\n");
X    }
X    (void)fprintf(fd, "    ");
X    if(bits == 16) {
X	for(b = 0; b < 256; ++b) {
X	    if(swapped) {
X		for(v = b, i = 8; --i >= 0;)
X		    v = v & 1 ? (v>>1)^poly : v>>1;
X	    } else {
X		for(v = b<<8, i = 8; --i >= 0;)
X		    v = v & 0x8000 ? (v<<1)^poly : v<<1;
X	    }
X	    (void)fprintf(fd, "0x%.4x,", v & 0xffff);
X	    if((b&7) == 7) {
X		(void)fprintf(fd, "\n");
X		if(b != 255) (void)fprintf(fd, "    ");
X	    } else {
X		(void)fprintf(fd, " ");
X	    }
X	}
X    } else {
X	for(b = 0; b < 256; ++b) {
X	    if(swapped) {
X		for(vv = b, i = 8; --i >= 0;)
X		    vv = vv & 1 ? (vv>>1)^poly : vv>>1;
X	    } else {
X		for(vv = b<<24, i = 8; --i >= 0;)
X		    vv = vv & 0x80000000 ? (vv<<1)^poly : vv<<1;
X	    }
X	    (void)fprintf(fd, "0x%.8x,", vv & 0xffffffff);
X	    if((b&3) == 3) {
X		(void)fprintf(fd, "\n");
X		if(b != 255) (void)fprintf(fd, "    ");
X	    } else {
X		(void)fprintf(fd, " ");
X	    }
X	}
X    }
X    (void)fprintf(fd, "};\n");
X    (void)fprintf(fd, "\n");
X    (void)fprintf(fd, "unsigned long %s_updcrc(icrc, icp, icnt)\n", name);
X    (void)fprintf(fd, "    unsigned long icrc;\n");
X    (void)fprintf(fd, "    unsigned char *icp;\n");
X    (void)fprintf(fd, "    int icnt;\n");
X    (void)fprintf(fd, "{\n");
X    if(bits == 16) {
X	(void)fprintf(fd, "#define M1 0xff\n");
X	(void)fprintf(fd, "#define M2 0xff00\n");
X    } else {
X	(void)fprintf(fd, "#define M1 0xffffff\n");
X	(void)fprintf(fd, "#define M2 0xffffff00\n");
X    }
X    (void)fprintf(fd, "    register unsigned long crc = icrc;\n");
X    (void)fprintf(fd, "    register unsigned char *cp = icp;\n");
X    (void)fprintf(fd, "    register int cnt = icnt;\n");
X    (void)fprintf(fd, "\n");
X    (void)fprintf(fd, "    while(cnt--) {\n");
X    if(bits == 16) {
X	if (swapped) {
X	    (void)fprintf(fd,
X		    "\tcrc=((crc>>8)&M1)^crctab[(crc&0xff)^*cp++];\n");
X	} else {
X	    (void)fprintf(fd,
X		    "\tcrc=((crc<<8)&M2)^crctab[((crc>>8)&0xff)^*cp++];\n");
X	}
X    } else {
X	if(swapped) {
X	    (void)fprintf(fd,
X		    "\tcrc=((crc>>8)&M1)^crctab[(crc&0xff)^*cp++];\n");
X	} else {
X	    (void)fprintf(fd,
X		    "\tcrc=((crc<<8)&M2)^crctab[((crc>>24)&0xff)^*cp++];\n");
X	}
X    }
X    (void)fprintf(fd, "    }\n");
X    (void)fprintf(fd, "\n");
X    (void)fprintf(fd, "    return(crc);\n");
X    (void)fprintf(fd, "}\n");
X    (void)fprintf(fd, "\n");
X    (void)fclose(fd);
X}
X
SHAR_EOF
if test 4416 -ne "`wc -c < 'makecrc.c'`"
then
	echo shar: "error transmitting 'makecrc.c'" '(should have been 4416 characters)'
fi
fi
echo shar: "extracting 'makefile'" '(475 characters)'
if test -f 'makefile'
then
	echo shar: "will not over-write existing file 'makefile'"
else
sed 's/^X//' << \SHAR_EOF > 'makefile'
XCFLAGS =	-O $(CF)
XCRCC =	arc.c ccitt.c kermit.c binhex.c ccitt32.c zip.c
XCRCO =	arc.o ccitt.o kermit.o binhex.o ccitt32.o zip.o
X
Xlibcrc.a:	$(CRCO)
X	ar r libcrc.a $(CRCO)
X	if test -f /usr/bin/ranlib ;\
X	then \
X		ranlib libcrc.a ;\
X	fi
X
Xclean:
X	-rm -f $(CRCC) $(CRCO) libcrc.a makecrc makecrc.o
X
X$(CRCC):	makecrc
X	./makecrc
X
Xmakecrc:	makecrc.o
X	cc -O -o makecrc makecrc.o
X
Xarc.o:	arc.c
Xccitt.o:	ccitt.c
Xkermit.o:	kermit.c
Xbinhex.o:	binhex.c
Xccitt32.o:	ccitt32.c
Xzip.o:		zip.c
X
SHAR_EOF
if test 475 -ne "`wc -c < 'makefile'`"
then
	echo shar: "error transmitting 'makefile'" '(should have been 475 characters)'
fi
fi
echo shar: "done with directory 'crc'"
cd ..
if test ! -d 'fileio'
then
	echo shar: "creating directory 'fileio'"
	mkdir 'fileio'
fi
echo shar: "entering directory 'fileio'"
cd 'fileio'
echo shar: "extracting 'wrfile.h'" '(289 characters)'
if test -f 'wrfile.h'
then
	echo shar: "will not over-write existing file 'wrfile.h'"
else
sed 's/^X//' << \SHAR_EOF > 'wrfile.h'
Xextern char *out_buffer, *out_ptr;
X
Xextern void define_name();
Xextern void start_info();
Xextern void start_rsrc();
Xextern void start_data();
Xextern void end_file();
X#ifdef SCAN
Xextern void do_idf();
X#endif /* SCAN */
Xextern void do_mkdir();
Xextern void enddir();
Xextern char *get_mina();
X
SHAR_EOF
if test 289 -ne "`wc -c < 'wrfile.h'`"
then
	echo shar: "error transmitting 'wrfile.h'" '(should have been 289 characters)'
fi
fi
echo shar: "extracting 'wrfileopt.h'" '(145 characters)'
if test -f 'wrfileopt.h'
then
	echo shar: "will not over-write existing file 'wrfileopt.h'"
else
sed 's/^X//' << \SHAR_EOF > 'wrfileopt.h'
Xextern int wrfileopt();
Xextern void give_wrfileopt();
Xextern void set_wrfileopt();
Xextern void set_s_wrfileopt();
Xextern char *get_wrfileopt();
X
SHAR_EOF
if test 145 -ne "`wc -c < 'wrfileopt.h'`"
then
	echo shar: "error transmitting 'wrfileopt.h'" '(should have been 145 characters)'
fi
fi
echo shar: "extracting 'fileglob.h'" '(39 characters)'
if test -f 'fileglob.h'
then
	echo shar: "will not over-write existing file 'fileglob.h'"
else
sed 's/^X//' << \SHAR_EOF > 'fileglob.h'
Xextern int bytes_read, bytes_written;
X
SHAR_EOF
if test 39 -ne "`wc -c < 'fileglob.h'`"
then
	echo shar: "error transmitting 'fileglob.h'" '(should have been 39 characters)'
fi
fi
echo shar: "extracting 'makefile'" '(556 characters)'
if test -f 'makefile'
then
	echo shar: "will not over-write existing file 'makefile'"
else
sed 's/^X//' << \SHAR_EOF > 'makefile'
XCFLAGS=	-O $(CF)
X
Xall:	wrfile.o rdfile.o fileglob.o
X	touch all
X
Xwrfile.o:	wrfile.c
X
Xrdfile.o:	rdfile.c
X
Xclean:
X	-rm -f wrfile.o
X	-rm -f rdfile.o
X	-rm -f fileglob.o
X	-rm -f all
X
Xwrfile.o:	machdr.h
Xwrfile.o:	wrfile.h
Xwrfile.o:	wrfileopt.h
Xwrfile.o:	fileglob.h
Xwrfile.o:	aufs.h
Xwrfile.o:	appledouble.h
Xwrfile.o:	../util/util.h
Xwrfile.o:	../util/curtime.h
Xrdfile.o:	machdr.h
Xrdfile.o:	rdfile.h
Xrdfile.o:	rdfileopt.h
Xrdfile.o:	../util/util.h
Xrdfile.o:	../util/curtime.h
Xrdfile.o:	../util/masks.h
Xrdfile.o:	aufs.h
Xrdfile.o:	appledouble.h
Xfileglob.o:	fileglob.h
X
SHAR_EOF
if test 556 -ne "`wc -c < 'makefile'`"
then
	echo shar: "error transmitting 'makefile'" '(should have been 556 characters)'
fi
fi
echo shar: "extracting 'machdr.h'" '(432 characters)'
if test -f 'machdr.h'
then
	echo shar: "will not over-write existing file 'machdr.h'"
else
sed 's/^X//' << \SHAR_EOF > 'machdr.h'
X#define INFOBYTES 128
X
X/* The following are copied out of macput.c/macget.c */
X#define I_NAMEOFF 1
X/* 65 <-> 80 is the FInfo structure */
X#define I_TYPEOFF 65
X#define I_AUTHOFF 69
X#define I_FLAGOFF 73
X#define I_LOCKOFF 81
X#define I_DLENOFF 83
X#define I_RLENOFF 87
X#define I_CTIMOFF 91
X#define I_MTIMOFF 95
X
X#define F_NAMELEN 63
X#define I_NAMELEN 69    /* 63 + strlen(".info") + 1 */
X
X#define INITED_MASK	1
X#define PROTCT_MASK	0x40
X
SHAR_EOF
if test 432 -ne "`wc -c < 'machdr.h'`"
then
	echo shar: "error transmitting 'machdr.h'" '(should have been 432 characters)'
fi
fi
echo shar: "extracting 'wrfile.c'" '(19424 characters)'
if test -f 'wrfile.c'
then
	echo shar: "will not over-write existing file 'wrfile.c'"
else
sed 's/^X//' << \SHAR_EOF > 'wrfile.c'
X#ifdef TYPES_H
X#include <sys/types.h>
X#endif /* TYPES_H */
X#include <sys/stat.h>
X#include <ctype.h>
X#include <stdio.h>
X#include "machdr.h"
X#include "wrfile.h"
X#include "wrfileopt.h"
X#include "../util/util.h"
X#ifdef AUFSPLUS
X#include "../util/curtime.h"
X#define AUFS
X#endif /* AUFSPLUS */
X#ifdef AUFS
X#include "aufs.h"
X#define APPLESHARE
X#endif /* AUFS */
X#ifdef APPLEDOUBLE
X#include "appledouble.h"
X#include "../util/curtime.h"
X#define APPLESHARE
X#endif /* APPLEDOUBLE */
X
X#define TEXT 0
X#define DATA 1
X#define RSRC 2
X#define FULL 3
X#define MACB 4
X#define FORK 5
X#define APSH 6
X#define MACS 7
X#define UNIX 8
X#ifdef SCAN
X#define MACI 9
X#endif /* SCAN */
X
Xextern char *malloc();
Xextern char *realloc();
Xextern char *strcpy();
Xextern char *strncpy();
Xextern char *strcat();
Xextern void exit();
X
X#ifdef UNDEF /* Do not declare sprintf; not portable (but lint will complain) */
Xchar *sprintf();
X#endif /* UNDEF */
X
X#ifdef AUFS
Xstatic void check_aufs();
Xstatic void aufs_namings();
Xstatic void wr_aufs_info();
X#endif /* AUFS */
X#ifdef APPLEDOUBLE
Xstatic void check_appledouble();
Xstatic void appledouble_namings();
Xstatic void wr_appledouble_info();
X#endif /* APPLEDOUBLE */
X#ifdef APPLESHARE
Xstatic void mk_share_name();
X#endif /* APPLESHARE */
X
X#ifndef BSD
X/* all those stupid differences! */
X#define bcopy(src,dest,length)	memcpy((dest),(src),(length))
X#define bzero(block,length)	memset((block),0,(length))
X#endif /* BSD */
X
X#define INFO_FORK	1
X#define RSRC_FORK	2
X#define DATA_FORK	3
X
Xstatic char f_info[I_NAMELEN];
Xstatic char f_data[I_NAMELEN*3];
Xstatic char f_rsrc[I_NAMELEN];
Xstatic char f_text[I_NAMELEN];
Xstatic char f_unix[I_NAMELEN];
Xstatic char f_bin[I_NAMELEN];
Xstatic char f_folder[] = ".foldername";
Xstatic char share_name[256];
X#ifdef APPLESHARE
Xstatic char hex[] = "0123456789abcdef";
X#endif /* APPLESHARE */
X#ifdef AUFS
Xstatic char infodir[] = ".finderinfo";
Xstatic char rsrcdir[] = ".resource";
X#define INFOSZ	sizeof(infodir)
X#define RSRCSZ	sizeof(rsrcdir)
Xstatic char f_info_aufs[I_NAMELEN*3+INFOSZ];
Xstatic char f_rsrc_aufs[I_NAMELEN*3+RSRCSZ];
X#endif /* AUFS */
X#ifdef APPLEDOUBLE
Xstatic char infodir[] = ".AppleDouble";
X#define INFOSZ	sizeof(infodir)
Xstatic char f_info_appledouble[I_NAMELEN*3+INFOSZ];
X#endif /* APPLEDOUBLE */
X
Xstatic int mode = MACB;
Xstatic int mode_restricted = 0;
Xstatic int mode_s_restricted = 0;
Xchar *out_buffer, *out_ptr;
X
Xstatic char init_buffer[128];
Xstatic char *buffer = &(init_buffer[0]);
Xstatic char *rbuffer = NULL, *dbuffer = NULL;
Xstatic char *ptr;
Xstatic unsigned long rsz, dsz, totsize, maxsize;
X
Xvoid define_name(text)
Xchar *text;
X{
X    (void)sprintf(f_info, "%s.info", text);
X    (void)sprintf(f_rsrc, "%s.rsrc", text);
X    (void)sprintf(f_data, "%s.data", text);
X    (void)sprintf(f_text, "%s.text", text);
X    (void)sprintf(f_bin, "%s.bin", text);
X    (void)sprintf(f_unix, "%s", text);
X#ifdef APPLESHARE
X/* Do not do namestuffing here.  We want to base again on the information in
X   the info header, so this is delayed
X*/
X#endif /* APPLESHARE */
X}
X
Xvoid start_info(info, rsize, dsize)
Xchar *info;
Xunsigned long rsize, dsize;
X{
X    int rs, ds;
X
X    rsz = rsize;
X    dsz = dsize;
X    rs = (((rsz + 127) >> 7) << 7);
X    ds = (((dsz + 127) >> 7) << 7);
X    totsize = rs + ds + 128;
X    if(buffer == &(init_buffer[0])) {
X	buffer = (char *)malloc((unsigned)totsize);
X    } else if(maxsize < totsize) {
X	buffer = (char *)realloc(buffer, (unsigned)totsize);
X    }
X    maxsize = totsize;
X    if(buffer == NULL) {
X	(void)fprintf(stderr, "Insufficient memory, aborting\n");
X	exit(1);
X    }
X    dbuffer = buffer + 128;
X    rbuffer = dbuffer + ds;
X    (void)bzero(buffer, (int)totsize);
X    ptr = buffer;
X    (void)bcopy(info, ptr, 128);
X#ifdef AUFS
X/* Now we do filenaming etc. */
X    if(mode == APSH) {
X	aufs_namings();
X    }
X#endif /* AUFS */
X#ifdef APPLEDOUBLE
X/* Now we do filenaming etc. */
X    if(mode == APSH) {
X	appledouble_namings();
X    }
X#endif /* APPLEDOUBLE */
X}
X
Xvoid start_rsrc()
X{
X    out_buffer = out_ptr = rbuffer;
X}
X
Xvoid start_data()
X{
X    out_buffer = out_ptr = dbuffer;
X}
X
Xvoid end_file()
X{
X    FILE *fp;
X    int i, c;
X
X    buffer[I_FLAGOFF] &= (~INITED_MASK);
X    switch(mode) {
X    case FULL:
X    case FORK:
X	fp = fopen(f_info, "w");
X	if(fp == NULL) {
X	    perror(f_info);
X	    exit(1);
X	}
X	(void)fwrite(buffer, 1, 128, fp);
X	(void)fclose(fp);
X	if(rsz != 0 || mode == FULL) {
X	    fp = fopen(f_rsrc, "w");
X	    if(fp == NULL) {
X		perror(f_rsrc);
X		exit(1);
X	    }
X	    (void)fwrite(rbuffer, 1, (int)rsz, fp);
X	    (void)fclose(fp);
X	}
X	if(dsz != 0 || mode == FULL) {
X	    fp = fopen(f_data, "w");
X	    if(fp == NULL) {
X		perror(f_data);
X		exit(1);
X	    }
X	    (void)fwrite(dbuffer, 1, (int)dsz, fp);
X	    (void)fclose(fp);
X	}
X	break;
X    case RSRC:
X	fp = fopen(f_rsrc, "w");
X	if(fp == NULL) {
X	    perror(f_rsrc);
X	    exit(1);
X	}
X	(void)fwrite(rbuffer, 1, (int)rsz, fp);
X	(void)fclose(fp);
X	break;
X    case DATA:
X	fp = fopen(f_data, "w");
X	if(fp == NULL) {
X	    perror(f_data);
X	    exit(1);
X	}
X	(void)fwrite(dbuffer, 1, (int)dsz, fp);
X	(void)fclose(fp);
X	break;
X    case TEXT:
X	fp = fopen(f_text, "w");
X	if(fp == NULL) {
X	    perror(f_data);
X	    exit(1);
X	}
X	for(i = 0; i < dsz; i++) {
X	    c = dbuffer[i];
X	    if(c == '\012' || c == '\015') {
X		dbuffer[i] = '\027' -c;
X	    }
X	}
X	(void)fwrite(dbuffer, 1, (int)dsz, fp);
X	(void)fclose(fp);
X	break;
X    case UNIX:
X	fp = fopen(f_unix, "w");
X	if(fp == NULL) {
X	    perror(f_data);
X	    exit(1);
X	}
X	for(i = 0; i < dsz; i++) {
X	    c = dbuffer[i];
X	    if(c == '\012' || c == '\015') {
X		dbuffer[i] = '\027' -c;
X	    }
X	}
X	(void)fwrite(dbuffer, 1, (int)dsz, fp);
X	(void)fclose(fp);
X	break;
X    case MACB:
X	fp = fopen(f_bin, "w");
X	if(fp == NULL) {
X	    perror(f_bin);
X	    exit(1);
X	}
X	if(buffer[I_FLAGOFF + 1] & PROTCT_MASK) {
X	    buffer[I_LOCKOFF] = 1;
X	}
X	buffer[I_FLAGOFF + 1] = 0;
X	buffer[I_LOCKOFF + 1] = 0;
X	(void)fwrite(buffer, 1, (int)totsize, fp);
X	(void)fclose(fp);
X	break;
X    case MACS:
X#ifdef SCAN
X    case MACI:
X#endif /* SCAN */
X	if(buffer[I_FLAGOFF + 1] & PROTCT_MASK) {
X	    buffer[I_LOCKOFF] = 1;
X	}
X	buffer[I_FLAGOFF + 1] = 0;
X	buffer[I_LOCKOFF + 1] = 0;
X	(void)fwrite(buffer, 1, (int)totsize, stdout);
X	break;
X#ifdef AUFS
X    case APSH:
X	fp = fopen(f_info_aufs, "w");
X	if(fp == NULL) {
X	    perror(f_info_aufs);
X	    exit(1);
X	}
X	wr_aufs_info(fp);
X	(void) fclose(fp);
X	fp = fopen(f_rsrc_aufs, "w");
X	if(fp == NULL) {
X	    perror(f_rsrc_aufs);
X	    exit(1);
X	}
X	(void)fwrite(rbuffer, 1, (int)rsz, fp);
X	(void)fclose(fp);
X	fp = fopen(f_data, "w");
X	if(fp == NULL) {
X	    perror(f_data);
X	    exit(1);
X	}
X	(void)fwrite(dbuffer, 1, (int)dsz, fp);
X	(void)fclose(fp);
X	break;
X#endif /* AUFS */
X#ifdef APPLEDOUBLE
X    case APSH:
X	fp = fopen(f_info_appledouble, "w");
X	if(fp == NULL) {
X	    perror(f_info_appledouble);
X	    exit(1);
X	}
X	wr_appledouble_info(fp);
X	(void)fwrite(rbuffer, 1, (int)rsz, fp);
X	(void)fclose(fp);
X	fp = fopen(f_data, "w");
X	if(fp == NULL) {
X	    perror(f_data);
X	    exit(1);
X	}
X	(void)fwrite(dbuffer, 1, (int)dsz, fp);
X	(void)fclose(fp);
X	break;
X#endif /* APPLEDOUBLE */
X    }
X}
X
X#ifdef SCAN
Xvoid do_idf(name, kind)
Xchar *name;
Xint kind;
X{
X    int n;
X
X    if(mode != MACI) {
X	return;
X    }
X    n = strlen(name);
X    (void)bzero(buffer, INFOBYTES);
X    buffer[I_NAMEOFF + 1] = kind;
X    put4(buffer + I_DLENOFF, (unsigned long)n);
X    (void)fwrite(buffer, 1, INFOBYTES, stdout);
X    if(n != 0) {
X	(void)fwrite(name, 1, n, stdout);
X	n = (((n + 127) >> 7) << 7) - n;
X	while(n-- > 0) {
X	    (void)fputc(0, stdout);
X	}
X    }
X}
X#endif /* SCAN */
X
Xvoid do_mkdir(name, header)
Xchar *name, *header;
X{
Xstruct stat sbuf;
XFILE *fp;
X#ifdef NOMKDIR
Xchar command[21]; /* Systems without mkdir system call but more than 14
X		     char file names?  Ridiculous! */
Xint sysreturn;
X#endif /* MKDIR */
X#ifdef APPLESHARE
Xchar dirinfo[I_NAMELEN*3+INFOSZ+10];
X#endif /* APPLESHARE */
X
X#ifndef SCAN
X    if(mode == MACS) {
X#else /* SCAN */
X    if(mode == MACS || mode == MACI) {
X#endif /* SCAN */
X        header[I_NAMEOFF] |= 0x80;
X	(void)fwrite(header, 1, INFOBYTES, stdout);
X	header[I_NAMEOFF] &= 0x7f;
X	return;
X    }
X#ifdef APPLESHARE
X    if(mode == APSH) {
X	(void)bcopy(header, buffer, INFOBYTES);
X	mk_share_name();
X    } else {
X	(void)strcpy(share_name, name);
X    }
X#else /* APPLESHARE */
X    (void)strcpy(share_name, name);
X#endif /* APPLESHARE */
X    if(stat(share_name, &sbuf) == -1) {  /* directory doesn't exist */
X#ifndef NOMKDIR
X	if(mkdir(share_name, 0777) == -1) {
X	    (void)fprintf(stderr, "Can't create subdirectory %s\n", share_name);
X	    exit(1);
X	}
X#else /* NOMKDIR */
X	sprintf(command, "mkdir %s", share_name);
X	if((sysreturn = system(command)) != 0) {
X	    (void)fprintf(stderr, "Can't create subdirectory %s\n", share_name);
X	    exit(sysreturn);
X	}
X#endif /* NOMKDIR */
X    } else {		/* something exists with this name */
X	if((sbuf.st_mode & S_IFMT) != S_IFDIR) {
X	    (void)fprintf(stderr, "Directory name %s already in use\n",
X		share_name);
X	    exit(1);
X	}
X    }
X    (void)chdir(share_name);
X#ifdef APPLESHARE
X#ifdef AUFS
X    if(mode == APSH) {
X	if(stat(rsrcdir, &sbuf) == -1) {  /* directory doesn't exist */
X	    if(mkdir(rsrcdir, 0777) == -1) {
X	 	(void)fprintf(stderr, "Can't create subdirectory %s\n",
X			rsrcdir);
X	 	exit(1);
X	    }
X	} else {
X	    if((sbuf.st_mode & S_IFMT) != S_IFDIR) {
X		(void)fprintf(stderr, "Directory name %s already in use\n",
X			rsrcdir);
X		exit(1);
X	    }
X	}
X	if(stat(infodir, &sbuf) == -1) {  /* directory doesn't exist */
X	    if(mkdir(infodir, 0777) == -1) {
X	 	(void)fprintf(stderr, "Can't create subdirectory %s\n",
X			infodir);
X	 	exit(1);
X	    }
X	} else {
X	    if((sbuf.st_mode & S_IFMT) != S_IFDIR) {
X		(void)fprintf(stderr, "Directory name %s already in use\n",
X			infodir);
X		exit(1);
X	    }
X	}
X	dirinfo[0] = 0;
X	(void)strcat(dirinfo, "../");
X	(void)strcat(dirinfo, infodir);
X	(void)strcat(dirinfo, "/");
X	(void)strcat(dirinfo, share_name);
X	fp = fopen(dirinfo, "w");
X	if(fp == NULL) {
X	    perror(dirinfo);
X	    exit(1);
X	}
X	wr_aufs_info(fp);
X	(void)fclose(fp);
X    } else {
X	fp = fopen(f_folder, "w");
X	if(fp == NULL) {
X	    perror(f_folder);
X	    exit(1);
X	}
X        header[I_NAMEOFF] |= 0x80;
X	(void)fwrite(header, 1, INFOBYTES, fp);
X	header[I_NAMEOFF] &= 0x7f;
X	(void)fclose(fp);
X    }
X#endif /* AUFS */
X#ifdef APPLEDOUBLE
X    if(mode == APSH) {
X	if(stat(infodir, &sbuf) == -1) {  /* directory doesn't exist */
X	    if(mkdir(infodir, 0777) == -1) {
X	 	(void)fprintf(stderr, "Can't create subdirectory %s\n",
X			infodir);
X	 	exit(1);
X	    }
X	} else {
X	    if((sbuf.st_mode & S_IFMT) != S_IFDIR) {
X		(void)fprintf(stderr, "Directory name %s already in use\n",
X			infodir);
X		exit(1);
X	    }
X	}
X	dirinfo[0] = 0;
X	(void)strcat(dirinfo, infodir);
X	(void)strcat(dirinfo, "/.Parent");
X	fp = fopen(dirinfo, "w");
X	if(fp == NULL) {
X	    perror(dirinfo);
X	    exit(1);
X	}
X	rsz = 0;
X	wr_appledouble_info(fp);
X	(void)fclose(fp);
X    } else {
X	fp = fopen(f_folder, "w");
X	if(fp == NULL) {
X	    perror(f_folder);
X	    exit(1);
X	}
X	header[I_NAMEOFF] |= 0x80;
X	(void)fwrite(header, 1, INFOBYTES, fp);
X	header[I_NAMEOFF] &= 0x7f;
X	(void)fclose(fp);
X    }
X#endif /* APPLEDOUBLE */
X#else /* APPLESHARE */
X    fp = fopen(f_folder, "w");
X    if(fp == NULL) {
X	perror(f_folder);
X	exit(1);
X    }
X    header[I_NAMEOFF] |= 0x80;
X    (void)fwrite(header, 1, INFOBYTES, fp);
X    header[I_NAMEOFF] &= 0x7f;
X    (void)fclose(fp);
X#endif /* APPLESHARE */
X}
X
Xvoid enddir()
X{
Xchar header[INFOBYTES];
Xint i;
X
X#ifndef SCAN
X    if(mode == MACS) {
X#else /* SCAN */
X    if(mode == MACS || mode == MACI) {
X#endif /* SCAN */
X	for(i = 0; i < INFOBYTES; i++) {
X	    header[i] = 0;
X	}
X	header[I_NAMEOFF] = 0x80;
X	(void)fwrite(header, 1, INFOBYTES, stdout);
X    } else {
X	(void)chdir("..");
X    }
X}
X
X#ifdef APPLESHARE
X#ifdef AUFS
Xstatic void check_aufs()
X{
X    /* check for .resource/ and .finderinfo/ */
X    struct stat stbuf;
X    int error = 0;
X
X    if(stat(rsrcdir,&stbuf) < 0) {
X	error ++;
X    } else {
X	if((stbuf.st_mode & S_IFMT) != S_IFDIR) {
X		  error ++;
X	}
X    }
X    if(stat(infodir,&stbuf) < 0) {
X	error ++;
X    } else {
X	if((stbuf.st_mode & S_IFMT) != S_IFDIR) {
X		  error++;
X	}
X    }
X    if(error) {
X	(void)fprintf(stderr, "Not in an Aufs folder.\n");
X	exit(1);
X    }
X}
X
Xstatic void aufs_namings()
X{
X    mk_share_name();
X    (void)sprintf(f_info_aufs, "%s/%s", infodir, share_name);
X    (void)sprintf(f_rsrc_aufs, "%s/%s", rsrcdir, share_name);
X    (void)sprintf(f_data, "%s", share_name);
X}
X
Xstatic void wr_aufs_info(fp)
XFILE *fp;
X{
X    FileInfo theinfo;
X    int n;
X
X    bzero((char *) &theinfo, sizeof theinfo);
X    theinfo.fi_magic1 = FI_MAGIC1;
X    theinfo.fi_version = FI_VERSION;
X    theinfo.fi_magic = FI_MAGIC;
X    theinfo.fi_bitmap = FI_BM_MACINTOSHFILENAME;
X
X    /* AUFS stores Unix times. */
X#ifdef AUFSPLUS
X    theinfo.fi_datemagic = FI_MAGIC;
X    theinfo.fi_datevalid = FI_CDATE | FI_MDATE;
X    put4(theinfo.fi_ctime, get4(buffer + I_CTIMOFF) - TIMEDIFF);
X    put4(theinfo.fi_mtime, get4(buffer + I_MTIMOFF) - TIMEDIFF);
X    put4(theinfo.fi_utime, (unsigned long)time((time_t *)0));
X#endif /* AUFSPLUS */
X    bcopy(buffer + I_TYPEOFF, theinfo.fi_fndr, 4);
X    bcopy(buffer + I_AUTHOFF, theinfo.fi_fndr + 4, 4);
X    bcopy(buffer + I_FLAGOFF, theinfo.fi_fndr + 8, 2);
X    if((n = buffer[I_NAMEOFF] & 0xff) > F_NAMELEN) {
X	n = F_NAMELEN;
X    }
X    (void)strncpy((char *)theinfo.fi_macfilename, buffer + I_NAMEOFF + 1,n);
X    /* theinfo.fi_macfilename[n] = '\0'; */
X    (void)strcpy((char *)theinfo.fi_comnt,
X	"Converted by Unix utility to Aufs format");
X    theinfo.fi_comln = strlen((char *)theinfo.fi_comnt);
X    (void)fwrite((char *) &theinfo, 1, sizeof theinfo, fp);
X}
X#endif /* AUFS */
X
X#ifdef APPLEDOUBLE
Xstatic void check_appledouble()
X{
X    /* check for .AppleDouble/ */
X    struct stat stbuf;
X    int error = 0;
X
X    if(stat(infodir,&stbuf) < 0) {
X	error ++;
X    } else {
X	if((stbuf.st_mode & S_IFMT) != S_IFDIR) {
X		  error++;
X	}
X    }
X    if(error) {
X	(void)fprintf(stderr, "Not in an AppleDouble folder.\n");
X	exit(1);
X    }
X}
X
Xstatic void appledouble_namings()
X{
X    mk_share_name();
X    (void)sprintf(f_info_appledouble, "%s/%s", infodir, share_name);
X    (void)sprintf(f_data, "%s", share_name);
X}
X
Xstatic void wr_appledouble_info(fp)
XFILE *fp;
X{
X    FileInfo theinfo;
X    int n;
X
X    bzero((char *) &theinfo, sizeof theinfo);
X    put4(theinfo.fi_magic, (unsigned long)FI_MAGIC);
X    put2(theinfo.fi_version, (unsigned long)FI_VERSION);
X    put4(theinfo.fi_fill5, (unsigned long)FI_FILL5);
X    put4(theinfo.fi_fill6, (unsigned long)FI_FILL6);
X    put4(theinfo.fi_hlen, (unsigned long)FI_HLEN);
X    put4(theinfo.fi_fill7, (unsigned long)FI_FILL7);
X    put4(theinfo.fi_namptr, (unsigned long)FI_NAMPTR);
X    put4(theinfo.fi_fill9, (unsigned long)FI_FILL9);
X    put4(theinfo.fi_commptr, (unsigned long)FI_COMMPTR);
X    put4(theinfo.fi_fill12, (unsigned long)FI_FILL12);
X    put4(theinfo.fi_timeptr, (unsigned long)FI_TIMEPTR);
X    put4(theinfo.fi_timesize, (unsigned long)FI_TIMESIZE);
X    put4(theinfo.fi_fill15, (unsigned long)FI_FILL15);
X    put4(theinfo.fi_infoptr, (unsigned long)FI_INFOPTR);
X    put4(theinfo.fi_infosize, (unsigned long)FI_INFOSIZE);
X
X    bcopy(buffer + I_TYPEOFF, theinfo.fi_type, 4);
X    bcopy(buffer + I_AUTHOFF, theinfo.fi_auth, 4);
X    bcopy(buffer + I_FLAGOFF, theinfo.fi_finfo, 2);
X    /* AppleDouble stores Unix times. */
X    put4(theinfo.fi_ctime, get4(buffer + I_CTIMOFF) - TIMEDIFF);
X    put4(theinfo.fi_mtime, get4(buffer + I_MTIMOFF) - TIMEDIFF);
X    if((n = buffer[I_NAMEOFF] & 0xff) > F_NAMELEN) {
X	n = F_NAMELEN;
X    }
X    put4(theinfo.fi_namlen, (unsigned long)n);
X    (void)strncpy((char *)theinfo.fi_name, buffer + I_NAMEOFF + 1,n);
X    /* theinfo.fi_macfilename[n] = '\0'; */
X    (void)strcpy((char *)theinfo.fi_comment,
X	"Converted by Unix utility to AppleDouble format");
X    put4(theinfo.fi_commsize, (unsigned long)strlen(theinfo.fi_comment));
X    put4(theinfo.fi_rsrc, (unsigned long)rsz);
X    /*  Still TODO */
X    /*  char	fi_ctime[4];	/* Creation time (Unix time) */
X    /*  char	fi_mtime[4];	/* Modification time (Unix time) */
X    (void)fwrite((char *) &theinfo, 1, sizeof theinfo, fp);
X}
X#endif /* APPLEDOUBLE */
X
Xstatic void mk_share_name()
X{
X    int ch;
X    char *mp, *up;
X
X    mp = buffer + 2;
X    up = &(share_name[0]);
X    while(ch = *mp++) {
X	if(isascii(ch) && ! iscntrl(ch) && isprint(ch) && ch != '/') {
X	    *up++ = ch;
X	} else {
X	    *up++ = ':';
X	    *up++ = hex[(ch >> 4) & 0xf];
X	    *up++ = hex[ch & 0xf];
X	}
X    }
X    *up = 0;
X}
X#endif /* APPLESHARE */
X
Xint wrfileopt(c)
Xchar c;
X{
X    switch(c) {
X    case 'b':
X	mode = MACB;
X	break;
X    case 'r':
X	if(mode_restricted) {
X	    return 0;
X	}
X	mode = RSRC;
X	break;
X    case 'd':
X	if(mode_restricted) {
X	    return 0;
X	}
X	mode = DATA;
X	break;
X    case 'u':
X	if(mode_restricted) {
X	    return 0;
X	}
X	mode = TEXT;
X	break;
X    case 'U':
X	if(mode_restricted) {
X	    return 0;
X	}
X	mode = TEXT;
X	break;
X    case 'f':
X	mode = FORK;
X	break;
X    case '3':
X	mode = FULL;
X	break;
X    case 's':
X	if(mode_s_restricted) {
X	    return 0;
X	}
X	mode = MACS;
X	break;
X#ifdef SCAN
X    case 'S':
X	if(mode_s_restricted) {
X	    return 0;
X	}
X	mode = MACI;
X	break;
X#endif /* SCAN */
X    case 'a':
X#ifdef APPLESHARE
X#ifdef AUFS
X	check_aufs();
X	mode = APSH;
X	break;
X#endif /* AUFS */
X#ifdef APPLEDOUBLE
X	check_appledouble();
X	mode = APSH;
X	break;
X#endif /* APPLEDOUBLE */
X#else /* APPLESHARE */
X	(void)fprintf(stderr, "Sorry, Apple-Unix sharing is not supported.\n");
X	(void)fprintf(stderr, "Recompile or omit -a option.\n");
X	exit(1);
X#endif /* APPLESHARE */
X    default:
X	return 0;
X    }
X    return 1;
X}
X
Xvoid give_wrfileopt()
X{
X    (void)fprintf(stderr, "File output options:\n");
X    (void)fprintf(stderr, "-b:\tMacBinary (default)\n");
X    if(!mode_s_restricted) {
X	(void)fprintf(stderr, "-s:\tMacBinary stream to standard output\n");
X#ifdef SCAN
X	(void)fprintf(stderr,
X	    "-S:\tas -s but with indication of orignal Unix filename\n");
X#endif /* SCAN */
X    }
X    (void)fprintf(stderr, "-f:\tthree fork mode, skipping empty forks\n");
X    (void)fprintf(stderr, "-3:\tthe same, writing also empty forks\n");
X    if(!mode_restricted) {
X	(void)fprintf(stderr, "-r:\tresource forks only\n");
X	(void)fprintf(stderr, "-d:\tdata forks only\n");
X	(void)fprintf(stderr,
X	    "-u:\tdata forks only with Mac -> Unix text file translation\n");
X	(void)fprintf(stderr,
X	    "-U:\tas -u, but filename will not have an extension\n");
X    }
X#ifdef APPLESHARE
X#ifdef AUFS
X    (void)fprintf(stderr, "-a:\tAUFS format\n");
X#endif /* AUFS */
X#ifdef APPLEDOUBLE
X    (void)fprintf(stderr, "-a:\tAppleDouble format\n");
X#endif /* APPLEDOUBLE */
X#else /* APPLESHARE */
X    (void)fprintf(stderr, "-a:\tnot supported, needs recompilation\n");
X#endif /* APPLESHARE */
X}
X
Xvoid set_wrfileopt(restricted)
X{
X    mode_restricted = restricted;
X}
X
Xvoid set_s_wrfileopt(restricted)
X{
X    mode_s_restricted = restricted;
X}
X
Xchar *get_wrfileopt()
X{
X    static char options[20];
X
X    (void)strcpy(options, "b");
X    if(!mode_s_restricted) {
X	(void)strcat(options, "s");
X#ifdef SCAN
X	(void)strcat(options, "S");
X#endif /* SCAN */
X    }
X    (void)strcat(options, "f3");
X    if(!mode_restricted) {
X	(void)strcat(options, "rduU");
X    }
X    (void)strcat(options, "a");
X    return options;
X}
X
Xchar *get_mina()
X{
X#ifdef APPLESHARE
X#ifdef AUFS
X    return ", AUFS supported";
X#endif /* AUFS */
X#ifdef APPLEDOUBLE
X    return ", AppleDouble supported";
X#endif /* APPLEDOUBLE */
X#else /* APPLESHARE */
X    return ", no Apple-Unix sharing supported";
X#endif /* APPLESHARE */
X}
X
SHAR_EOF
if test 19424 -ne "`wc -c < 'wrfile.c'`"
then
	echo shar: "error transmitting 'wrfile.c'" '(should have been 19424 characters)'
fi
fi
echo shar: "extracting 'fileglob.c'" '(32 characters)'
if test -f 'fileglob.c'
then
	echo shar: "will not over-write existing file 'fileglob.c'"
else
sed 's/^X//' << \SHAR_EOF > 'fileglob.c'
Xint bytes_read, bytes_written;
X
SHAR_EOF
if test 32 -ne "`wc -c < 'fileglob.c'`"
then
	echo shar: "error transmitting 'fileglob.c'" '(should have been 32 characters)'
fi
fi
echo shar: "extracting 'aufs.h'" '(1370 characters)'
if test -f 'aufs.h'
then
	echo shar: "will not over-write existing file 'aufs.h'"
else
sed 's/^X//' << \SHAR_EOF > 'aufs.h'
X#define MAXCLEN 199		/* max size of a comment string */
X#define FINFOLEN 32		/* Finder info is 32 bytes */
X#define MAXMACFLEN 31		/* max Mac file name length */
X#define FI_MAGIC1 255
X#define FI_VERSION 0x10		/* version major 1, minor 0 */
X				/* if we have more than 8 versions wer're */
X				/* doiong something wrong anyway */
X#define FI_MAGIC 0xda
X#define FI_BM_SHORTFILENAME 0x1	/* is this included? */
X#define FI_BM_MACINTOSHFILENAME 0x2 /* is this included? */
X#define FI_MDATE 0x01		/* mtime & utime are valid */
X#define FI_CDATE 0x02		/* ctime is valid */
X
Xtypedef struct {
X    char	fi_fndr[FINFOLEN];	/* finder info */
X    short	fi_attr;		/* attributes */
X    char	fi_magic1;		/* addional magic word check */
X    char	fi_version;		/* version number */
X    char	fi_magic;		/* magic word check */
X    char	fi_bitmap;		/* bitmap of included info */
X    char	fi_shortfilename[12+1];	/* possible short file name */
X    char	fi_macfilename[32+1];	/* possible macintosh file name */
X    char	fi_comln;		/* comment length */
X    char	fi_comnt[MAXCLEN+1];	/* comment string */
X#ifdef AUFSPLUS
X    char	fi_datemagic;		/* sanity check */
X    char	fi_datevalid;		/* validity flags */
X    char	fi_ctime[4];		/* mac file create time */
X    char	fi_mtime[4];		/* mac file modify time */
X    char	fi_utime[4];		/* (real) time mtime was set */
X#endif /* AUFSPLUS */
X} FileInfo;
X
SHAR_EOF
if test 1370 -ne "`wc -c < 'aufs.h'`"
then
	echo shar: "error transmitting 'aufs.h'" '(should have been 1370 characters)'
fi
fi
echo shar: "extracting 'appledouble.h'" '(1856 characters)'
if test -f 'appledouble.h'
then
	echo shar: "will not over-write existing file 'appledouble.h'"
else
sed 's/^X//' << \SHAR_EOF > 'appledouble.h'
X#define	FI_MAGIC	333319
X#define	FI_VERSION	1
X#define	FI_FILL5	5
X#define	FI_FILL6	2
X#define	FI_HLEN		589
X#define	FI_FILL7	3
X#define	FI_NAMPTR	86
X#define	FI_FILL9	4
X#define	FI_COMMPTR	341
X#define	FI_FILL12	7
X#define	FI_TIMEPTR	541
X#define	FI_TIMESIZE	16
X#define	FI_FILL15	9
X#define	FI_INFOPTR	557
X#define	FI_INFOSIZE	32
X
X/* All as char[n] because of possible alignment problems.  But is this needed?
X   Is this stuff in host order or in client order?  Assuming client order for
X   the moment.  Will not be a problem on big-endian machines. */
Xtypedef struct {
X	char	fi_magic[4];	/* magic header */
X	char	fi_version[2];	/* version number */
X	char	fi_fill1[4];	/* = 0, ???? */
X	char	fi_fill2[4];	/* = 0, ???? */
X	char	fi_fill3[4];	/* = 0, ???? */
X	char	fi_fill4[4];	/* = 0, ???? */
X	char	fi_fill5[4];	/* = 5, ???? */
X	char	fi_fill6[4];	/* = 2, ???? */
X	char	fi_hlen[4];	/* = 589, header length */
X	char	fi_rsrc[4];	/* resource length */
X	char	fi_fill7[4];	/* = 3, ???? */
X	char	fi_namptr[4];	/* = 86, filename pointer */
X	char	fi_namlen[4];	/* Mac filename length */
X	char	fi_fill9[4];	/* = 4, ???? */
X	char	fi_commptr[4];	/* = 341, comment pointer */
X	char	fi_commsize[4];	/* = 0, comment size */
X	char	fi_fill12[4];	/* = 7, ???? */
X	char	fi_timeptr[4];	/* = 541, pointer to times */
X	char	fi_timesize[4];	/* = 16, size of times */
X	char	fi_fill15[4];	/* = 9, ???? */
X	char	fi_infoptr[4];	/* = 557, finder info pointer */
X	char	fi_infosize[4];	/* = 32, finder info size */
X	char	fi_name[255];	/* Macintosh filename */
X	char	fi_comment[200];/* = 0, Comment */
X	char	fi_ctime[4];	/* Creation time (Unix time) */
X	char	fi_mtime[4];	/* Modification time (Unix time) */
X	char	fi_fill19[4];	/* = 0, ???? */
X	char	fi_fill20[4];	/* = 0, ???? */
X	char	fi_type[4];	/* File type */
X	char	fi_auth[4];	/* File creator */
X	char	fi_finfo[24];	/* Finder info */
X} FileInfo;
X
SHAR_EOF
if test 1856 -ne "`wc -c < 'appledouble.h'`"
then
	echo shar: "error transmitting 'appledouble.h'" '(should have been 1856 characters)'
fi
fi
echo shar: "extracting 'rdfile.c'" '(25879 characters)'
if test -f 'rdfile.c'
then
	echo shar: "will not over-write existing file 'rdfile.c'"
else
sed 's/^X//' << \SHAR_EOF > 'rdfile.c'
X#include <stdio.h>
X#ifdef TYPES_H
X#include <sys/types.h>
X#endif /* TYPES_H */
X#include <sys/stat.h>
X#include "machdr.h"
X#include "rdfile.h"
X#include "rdfileopt.h"
X#ifndef DIRENT_H
X#include <sys/dir.h>
X#define dirstruct direct
X#else /* DIRENT_H */
X#include <dirent.h>
X#define dirstruct dirent
X#endif /* DIRENT_H */
X#include "../util/curtime.h"
X#include "../util/masks.h"
X#include "../util/util.h"
X
X#ifdef AUFSPLUS
X#define AUFS
X#endif /* AUFSPLUS */
X#ifdef AUFS
X#define APPLESHARE
X#endif /* AUFS */
X#ifdef APPLEDOUBLE
X#define APPLESHARE
X#endif /* APPLEDOUBLE */
X
X#define NOTFOUND	0
X#define ISFILE		1
X#define	INFOFILE	2
X#define INFOEXT		3
X#define	SKIPFILE	4
X#define	MACBINARY	5
X#define	DIRECTORY	6
X#ifdef APPLESHARE
X#define	SHAREFILE	7
X#endif /* APPLESHARE */
X
X#define DATA_FORMAT	1
X#define RSRC_FORMAT	2
X#define UNIX_FORMAT	3
X
Xextern char *malloc();
Xextern char *realloc();
Xextern char *strcpy();
Xextern char *strncpy();
Xextern char *strcat();
Xextern void exit();
X
Xstatic void check_files();
Xstatic void read_file();
Xstatic void enter_dir();
Xstatic void exit_dir();
Xstatic int get_stdin_file();
X
Xchar file_info[INFOBYTES];
Xchar *data_fork, *rsrc_fork;
Xint data_size, rsrc_size;
Xstatic int max_data_size, max_rsrc_size;
X
Xtypedef struct filelist {
X    int nfiles;
X    char **files;
X    int *kind;
X    struct filelist *previous;
X    int current;
X#ifdef APPLESHARE
X    int shared_dir;
X#endif /* APPLESHARE */
X} filelist;
X
Xstatic int data_only;
Xstatic int no_recurse;
Xstatic int read_stdin;
Xstatic filelist global_files;
Xstatic filelist *current_files;
Xstatic char f_name[] = ".foldername";
X#ifdef APPLESHARE
X#ifdef AUFS
X#include "aufs.h"
Xstatic char infodir[] = ".finderinfo";
Xstatic char rsrcdir[] = ".resource";
Xstatic void read_aufs_info();
X#endif /* AUFS */
X#ifdef APPLEDOUBLE
X#include "appledouble.h"
Xstatic char infodir[] = ".AppleDouble";
Xstatic void read_appledouble_info();
X#endif /* APPLEDOUBLE */
X#endif /* APPLESHARE */
Xstatic char filename[255];
Xstatic int filekind;
X
Xvoid setup(argc, argv)
Xint argc;
Xchar **argv;
X{
X    if(argc == 0) {
X	read_stdin = 1;
X    } else {
X	read_stdin = 0;
X	global_files.previous = NULL;
X	global_files.nfiles = argc;
X	global_files.files = argv;
X	global_files.current = 0;
X	current_files = &global_files;
X	check_files(1);
X    }
X}
X
Xstatic void check_files(initial)
Xint initial;
X{
X    struct stat stbuf;
X    int i, j, n;
X    char filename[255], filename1[255];
X
X    /* Check the method to read the file */
X    current_files->current = 0;
X    /* Set initially to NOTFOUND or DIRECTORY */
X    n = current_files->nfiles;
X    current_files->kind = (int *)malloc((unsigned)n * sizeof(int));
X    if(current_files->kind == NULL) {
X	(void)fprintf(stderr, "Insufficient memory\n");
X	exit(1);
X    }
X    for(i = 0; i < n; i++) {
X	current_files->kind[i] = NOTFOUND;
X	if(stat(current_files->files[i], &stbuf) >= 0) {
X	    if((stbuf.st_mode & S_IFMT) == S_IFDIR) {
X		/* We found a directory */
X		current_files->kind[i] = DIRECTORY;
X		continue;
X	    }
X	    current_files->kind[i] = ISFILE;
X	}
X    }
X    /* That is enough for data_only mode */
X    if(data_only) {
X	return;
X    }
X#ifdef APPLESHARE
X    /* First check whether we are in a folder on a shared volume */
X    i = 1;
X#ifdef AUFS
X    if(stat(rsrcdir,&stbuf) < 0) {
X	i = 0;
X    } else {
X	if((stbuf.st_mode & S_IFMT) != S_IFDIR) {
X	    i = 0;
X	}
X    }
X    if(stat(infodir,&stbuf) < 0) {
X	i = 0;
X    } else {
X	if((stbuf.st_mode & S_IFMT) != S_IFDIR) {
X	    i = 0;
X	}
X    }
X#endif /* AUFS */
X#ifdef APPLEDOUBLE
X    if(stat(infodir,&stbuf) < 0) {
X	i = 0;
X    } else {
X	if((stbuf.st_mode & S_IFMT) != S_IFDIR) {
X	    i = 0;
X	}
X    }
X#endif /* APPLEDOUBLE */
X    current_files->shared_dir = i;
X#endif /* APPLESHARE */
X    for(i = 0; i < n; i++) {
X	if(current_files->kind[i] == NOTFOUND) {
X	    j = 0;
X	} else if(current_files->kind[i] == ISFILE) {
X	    /* Check whether the file is special */
X#ifdef APPLESHARE
X	    if(!current_files->shared_dir &&
X	       !strcmp(current_files->files[i], f_name)) {
X		current_files->kind[i] = SKIPFILE;
X		continue;
X	    }
X#else /* APPLESHARE */
X	    if(!strcmp(current_files->files[i], f_name)) {
X		current_files->kind[i] = SKIPFILE;
X		continue;
X	    }
X#endif /* APPLESHARE */
X	    j = 1;
X	} else if(current_files->kind[i] == SKIPFILE) {
X	    continue;
X	} else if(!initial) { /* DIRECTORY */
X	    /* Check whether the directory is special */
X	    if(!strcmp(current_files->files[i], ".") ||
X	       !strcmp(current_files->files[i], "..")) {
X		current_files->kind[i] = SKIPFILE;
X	    }
X#ifdef APPLESHARE
X#ifdef AUFS
X	    if(current_files->shared_dir &&
X	       (!strcmp(current_files->files[i], infodir) ||
X		!strcmp(current_files->files[i], rsrcdir))) {
X		current_files->kind[i] = SKIPFILE;
X	    }
X#endif /* AUFS */
X#ifdef APPLEDOUBLE
X	    if(current_files->shared_dir &&
X	       !strcmp(current_files->files[i], infodir)) {
X		current_files->kind[i] = SKIPFILE;
X	    }
X#endif /* APPLEDOUBLE */
X#endif /* APPLESHARE */
X	    continue;
X	} else { /* Take all directories from command line! */
X	    continue;
X	}
X#ifdef APPLESHARE
X	/* Check whether file is in shared format */
X	if(j & current_files->shared_dir) {
X	    j = 0;
X	    filename[0] = 0;
X	    (void)strcat(filename, infodir);
X	    (void)strcat(filename, "/");
X	    (void)strcat(filename, current_files->files[i]);
X	    /* There ought to be an associated file in the info direcory */
X	    if(stat(filename, &stbuf) >= 0) {
X		current_files->kind[i] = SHAREFILE;
X		continue;
X	    }
X	}
X#endif /* APPLESHARE */
X	/* If file not found check for the same with .info extension */
X	if(!j) {
X	    filename[0] = 0;
X	    (void)strcat(filename, current_files->files[i]);
X	    (void)strcat(filename, ".info");
X	    /* Found a .info file, else no such file found */
X	    if(stat(filename, &stbuf) >= 0) {
X		current_files->kind[i] = INFOEXT;
X	    }
X	    continue;
X	}
X	/* Now we found the file.  Check first whether the name ends with
X	   .info */
X	j = strlen(current_files->files[i]) - 5;
X	if(!strncmp(current_files->files[i] + j, ".info", 5)) {
X	    /* This is a .info file.  Set as INFOFILE */
X	    current_files->kind[i] = INFOFILE;
X	    /* Now remove from list of files the same with .data or .rsrc
X	       extension */
X	    filename[0] = 0;
X	    (void)strcat(filename, current_files->files[i]);
X	    filename[j] = 0;
X	    (void)strcpy(filename1, filename);
X	    (void)strcat(filename, ".data");
X	    (void)strcat(filename1, ".rsrc");
X	    for(j = i + 1; j < n; j++) {
X		if(!strcmp(filename, current_files->files[j])) {
X		    /* Associated .data file */
X		    current_files->kind[j] = SKIPFILE;
X		    continue;
X		}
X		if(!strcmp(filename1, current_files->files[j])) {
X		    /* Associated .rsrc file */
X		    current_files->kind[j] = SKIPFILE;
X		}
X	    }
X	    continue;
X	}
X	if(!strncmp(current_files->files[i] + j, ".data", 5) ||
X	   !strncmp(current_files->files[i] + j, ".rsrc", 5)) {
X	    /* .data or .rsrc file found.  Check whether there is an
X	       associated .info file in the filelist */
X	    filename[0] = 0;
X	    (void)strcat(filename, current_files->files[i]);
X	    filename[j] = 0;
X	    (void)strcat(filename, ".info");
X	    for(j = i + 1; j < n; j++) {
X		if(!strcmp(filename, current_files->files[j])) {
X		    /* Found an associated .info file! */
X		    current_files->kind[i] = SKIPFILE;
X		    break;
X		}
X	    }
X	    if(j < n) {
X		continue;
X	    }
X	}
X	/* Finally nothing special */
X	current_files->kind[i] = MACBINARY;
X    }
X}
X
Xint nextfile()
X{
X    int i = current_files->current;
X
X    if(read_stdin) {
X	return get_stdin_file();
X    }
Xagain:
X    if(i == current_files->nfiles) {
X	if(current_files->previous == NULL) {
X	    return ISATEND;
X	} else {
X	    exit_dir();
X	    current_files->current++;
X	    return ENDDIR;
X	}
X    }
X    filename[0] = 0;
X    (void)strcat(filename, current_files->files[i]);
X    filekind = current_files->kind[i];
X    switch(filekind) {
X    case DIRECTORY:
X	if(no_recurse) {
X	    (void)fprintf(stderr, "Directory %s skipped.\n", filename);
X	    i++;
X	    current_files->current = i;
X	    goto again;
X	}
X	enter_dir();
X	return ISDIR;
X    case SKIPFILE:
X	i++;
X	current_files->current = i;
X	goto again;
X    case NOTFOUND:
X	(void)fprintf(stderr, "File %s not found.\n", filename);
X	exit(1);
X    default:
X	read_file();
X	current_files->current = i + 1;
X	return ISFILE;
X    }
X}
X
Xstatic void read_file()
X{
X    FILE *fd;
X    int c, j, lname, skip;
X    struct stat stbuf;
X#ifdef APPLESHARE
X    char filename1[255];
X#endif /* APPLESHARE */
X
X    switch(filekind) {
X    case ISFILE:
X	if(stat(filename, &stbuf) < 0) {
X	    (void)fprintf(stderr, "Cannot stat file %s\n", filename);
X	    exit(1);
X	}
X	for(j = 0; j < INFOBYTES; j++) {
X	    file_info[j] = 0;
X	}
X	(void)strcpy(file_info + I_NAMEOFF + 1, filename);
X	file_info[I_NAMEOFF] = strlen(filename);
X	put4(file_info + I_CTIMOFF, (unsigned long)stbuf.st_ctime + TIMEDIFF);
X	put4(file_info + I_MTIMOFF, (unsigned long)stbuf.st_mtime + TIMEDIFF);
X	if(data_only == RSRC_FORMAT) {
X	    rsrc_size = stbuf.st_size;
X	    data_size = 0;
X	    if(rsrc_size > max_rsrc_size) {
X		if(rsrc_fork == NULL) {
X		    rsrc_fork = malloc((unsigned)rsrc_size);
X		} else {
X		    rsrc_fork = realloc(rsrc_fork, (unsigned)rsrc_size);
X		}
X		max_rsrc_size = rsrc_size;
X	    }
X	    (void)strncpy(file_info + I_TYPEOFF, "RSRC", 4);
X	    (void)strncpy(file_info + I_AUTHOFF, "RSED", 4);
X	    put4(file_info + I_RLENOFF, (unsigned long)rsrc_size);
X	    if((fd = fopen(filename, "r")) == NULL) {
X		(void)fprintf(stderr, "Cannot open file %s\n", filename);
X		exit(1);
X	    }
X	    if(fread(rsrc_fork, 1, rsrc_size, fd) != rsrc_size) {
X		(void)fprintf(stderr, "Short file %s\n", filename);
X		exit(1);
X	    }
X	    (void)fclose(fd);
X	} else {
X	    data_size = stbuf.st_size;
X	    rsrc_size = 0;
X	    if(data_size > max_data_size) {
X		if(data_fork == NULL) {
X		    data_fork = malloc((unsigned)data_size);
X		} else {
X		    data_fork = realloc(data_fork, (unsigned)data_size);
X		}
X		max_data_size = data_size;
X	    }
X	    (void)strncpy(file_info + I_TYPEOFF, "TEXT", 4);
X	    (void)strncpy(file_info + I_AUTHOFF, "MACA", 4);
X	    put4(file_info + I_DLENOFF, (unsigned long)data_size);
X	    if((fd = fopen(filename, "r")) == NULL) {
X		(void)fprintf(stderr, "Cannot open file %s\n", filename);
X		exit(1);
X	    }
X	    if(fread(data_fork, 1, data_size, fd) != data_size) {
X		(void)fprintf(stderr, "Short file %s\n", filename);
X		exit(1);
X	    }
X	    (void)fclose(fd);
X	    if(data_only == UNIX_FORMAT) {
X		for(j = 0; j < data_size; j++) {
X		    c = data_fork[j];
X		    if(c == '\012' || c == '\015') {
X			data_fork[j] = '\027' -c;
X		    }
X		}
X	    }
X	}
X	break;
X    case INFOEXT:
X	(void)strcat(filename, ".info");
X    case INFOFILE:
X	lname = strlen(filename) - 5;
X	if((fd = fopen(filename, "r")) == NULL) {
X	    (void)fprintf(stderr, "Cannot open file %s\n", filename);
X	    exit(1);
X	}
X	if(fread(file_info, 1, INFOBYTES, fd) != INFOBYTES) {
X	    (void)fprintf(stderr, "Cannot read info header %s\n", filename);
X	}
X	(void)fclose(fd);
X	data_size = get4(file_info + I_DLENOFF);
X	rsrc_size = get4(file_info + I_RLENOFF);
X	if(data_size > max_data_size) {
X	    if(data_fork == NULL) {
X		data_fork = malloc((unsigned)data_size);
X	    } else {
X		data_fork = realloc(data_fork, (unsigned)data_size);
X	    }
X	    max_data_size = data_size;
X	}
X	if(rsrc_size > max_rsrc_size) {
X	    if(rsrc_fork == NULL) {
X		rsrc_fork = malloc((unsigned)rsrc_size);
X	    } else {
X		rsrc_fork = realloc(rsrc_fork, (unsigned)rsrc_size);
X	    }
X	    max_rsrc_size = rsrc_size;
X	}
X	if(data_size != 0) {
X	    filename[lname] = 0;
X	    (void)strcat(filename, ".data");
X	    if((fd = fopen(filename, "r")) == NULL) {
X		(void)fprintf(stderr, "Cannot open data fork %s\n", filename);
X		exit(1);
X	    }
X	    if(fread(data_fork, 1, data_size, fd) != data_size) {
X		(void)fprintf(stderr, "Premature EOF on %s\n", filename);
X	    }
X	    (void)fclose(fd);
X	}
X	if(rsrc_size != 0) {
X	    filename[lname] = 0;
X	    (void)strcat(filename, ".rsrc");
X	    if((fd = fopen(filename, "r")) == NULL) {
X		(void)fprintf(stderr, "Cannot open rsrc fork %s\n", filename);
X		exit(1);
X	    }
X	    if(fread(rsrc_fork, 1, rsrc_size, fd) != rsrc_size) {
X		(void)fprintf(stderr, "Premature EOF on %s\n", filename);
X	    }
X	    (void)fclose(fd);
X	}
X	break;
X    case MACBINARY:
X	if((fd = fopen(filename, "r")) == NULL) {
X	    (void)fprintf(stderr, "Cannot open file %s\n", filename);
X	    exit(1);
X	}
X	if(fread(file_info, 1, INFOBYTES, fd) != INFOBYTES) {
X	    (void)fprintf(stderr, "Short file %s\n", filename);
X	    exit(1);
X	}
X	if(file_info[0] != 0) {
X	    (void)fprintf(stderr, "File is not MacBinary: %s\n", filename);
X	    exit(1);
X	}
X	data_size = get4(file_info + I_DLENOFF);
X	rsrc_size = get4(file_info + I_RLENOFF);
X	if(file_info[I_LOCKOFF] & 1) {
X	    file_info[I_FLAGOFF + 1] = PROTCT_MASK;
X	    file_info[I_LOCKOFF] &= ~1;
X	}
X	if(data_size != 0) {
X	    if(data_size > max_data_size) {
X		if(data_fork == NULL) {
X		    data_fork = malloc((unsigned)data_size);
X		} else {
X		    data_fork = realloc(data_fork, (unsigned)data_size);
X		}
X		max_data_size = data_size;
X	    }
X	    if(fread(data_fork, 1, data_size, fd) != data_size) {
X		(void)fprintf(stderr, "Short file %s\n", filename);
X		exit(1);
X	    }
X	    skip = (((data_size + 127) >> 7) << 7) - data_size;
X	    for(j = 0; j < skip; j++) {
X		(void)fgetc(fd);
X	    }
X	}
X	if(rsrc_size != 0) {
X	    if(rsrc_size > max_rsrc_size) {
X		if(rsrc_fork == NULL) {
X		    rsrc_fork = malloc((unsigned)rsrc_size);
X		} else {
X		    rsrc_fork = realloc(rsrc_fork, (unsigned)rsrc_size);
X		}
X		max_rsrc_size = rsrc_size;
X	    }
X	    if(fread(rsrc_fork, 1, rsrc_size, fd) != rsrc_size) {
X		(void)fprintf(stderr, "Short file %s\n", filename);
X		exit(1);
X	    }
X	}
X	break;
X#ifdef APPLESHARE
X    case SHAREFILE:
X#ifdef AUFS
X	(void)strcpy(filename1, infodir);
X	(void)strcat(filename1, "/");
X	(void)strcat(filename1, filename);
X	if((fd = fopen(filename1, "r")) == NULL) {
X	    (void)fprintf(stderr, "Cannot open file %s\n", filename1);
X	}
X	read_aufs_info(fd);
X	(void)fclose(fd);
X	(void)strcpy(filename1, rsrcdir);
X	(void)strcat(filename1, "/");
X	(void)strcat(filename1, filename);
X	if(stat(filename1, &stbuf) >= 0) {
X	    rsrc_size = stbuf.st_size;
X	    put4(file_info + I_RLENOFF, (unsigned long)rsrc_size);
X	    if(rsrc_size > 0) {
X		if(rsrc_size > max_rsrc_size) {
X		    if(rsrc_fork == NULL) {
X			rsrc_fork = malloc((unsigned)rsrc_size);
X		    } else {
X			rsrc_fork = realloc(rsrc_fork, (unsigned)rsrc_size);
X		    }
X		    max_rsrc_size = rsrc_size;
X		}
X		if((fd = fopen(filename1, "r")) == NULL) {
X		    (void)fprintf(stderr, "Cannot open file %s\n", filename1);
X		    exit(1);
X		}
X		if(fread(rsrc_fork, 1, rsrc_size, fd) != rsrc_size) {
X		    (void)fprintf(stderr, "Short file %s\n", filename1);
X		    exit(1);
X		}
X		(void)fclose(fd);
X	    }
X	}
X	if(stat(filename, &stbuf) >= 0) {
X	    data_size = stbuf.st_size;
X	    put4(file_info + I_DLENOFF, (unsigned long)data_size);
X	    if(data_size > 0) {
X		if(data_size > max_data_size) {
X		    if(data_fork == NULL) {
X			data_fork = malloc((unsigned)data_size);
X		    } else {
X			data_fork = realloc(data_fork, (unsigned)data_size);
X		    }
X		    max_data_size = data_size;
X		}
X		if((fd = fopen(filename, "r")) == NULL) {
X		    (void)fprintf(stderr, "Cannot open file %s\n", filename);
X		    exit(1);
X		}
X		if(fread(data_fork, 1, data_size, fd) != data_size) {
X		    (void)fprintf(stderr, "Short file %s\n", filename1);
X		    exit(1);
X		}
X		(void)fclose(fd);
X	    }
X	}
X#endif /* AUFS */
X#ifdef APPLEDOUBLE
X	(void)strcpy(filename1, infodir);
X	(void)strcat(filename1, "/");
X	(void)strcat(filename1, filename);
X	if((fd = fopen(filename1, "r")) == NULL) {
X	    (void)fprintf(stderr, "Cannot open file %s\n", filename1);
X	}
X	read_appledouble_info(fd);
X	rsrc_size = get4(file_info + I_RLENOFF);
X	if(rsrc_size > 0) {
X	    if(rsrc_size > max_rsrc_size) {
X		if(rsrc_fork == NULL) {
X		    rsrc_fork = malloc((unsigned)rsrc_size);
X		} else {
X		    rsrc_fork = realloc(rsrc_fork, (unsigned)rsrc_size);
X		}
X		max_rsrc_size = rsrc_size;
X	    }
X	    if(fread(rsrc_fork, 1, rsrc_size, fd) != rsrc_size) {
X		(void)fprintf(stderr, "Short file %s\n", filename1);
X		exit(1);
X	    }
X	}
X	(void)fclose(fd);
X	if(stat(filename, &stbuf) >= 0) {
X	    data_size = stbuf.st_size;
X	    put4(file_info + I_DLENOFF, (unsigned long)data_size);
X	    if(data_size > 0) {
X		if(data_size > max_data_size) {
X		    if(data_fork == NULL) {
X			data_fork = malloc((unsigned)data_size);
X		    } else {
X			data_fork = realloc(data_fork, (unsigned)data_size);
X		    }
X		    max_data_size = data_size;
X		}
X		if((fd = fopen(filename, "r")) == NULL) {
X		    (void)fprintf(stderr, "Cannot open file %s\n", filename);
X		    exit(1);
X		}
X		if(fread(data_fork, 1, data_size, fd) != data_size) {
X		    (void)fprintf(stderr, "Short file %s\n", filename1);
X		    exit(1);
X		}
X		(void)fclose(fd);
X	    }
X	}
X#endif /* APPLEDOUBLE */
X	break;
X#endif /* APPLESHARE */
X    }
X}
X
Xstatic void enter_dir()
X{
X    DIR *directory;
X    struct dirstruct *curentry;
X    FILE *fd;
X    int n, j, namlen;
X    int listsize, cursize;
X    char *filetable;
X    filelist *new_files;
X#ifdef APPLESHARE
X    char filename1[255];
X#endif /* APPLESHARE */
X
X    for(j = 0; j < INFOBYTES; j++) {
X	file_info[j] = 0;
X    }
X    (void)strcpy(file_info + I_NAMEOFF + 1, filename);
X    file_info[I_NAMEOFF] = strlen(filename);
X    directory = opendir(filename);
X    if(directory == NULL) {
X	(void)fprintf(stderr, "Cannot read directory %s\n", filename);
X	exit(1);
X    }
X    listsize = 1024;
X    filetable = malloc((unsigned)listsize);
X    cursize = 0;
X    n = 0;
X    while((curentry = readdir(directory)) != NULL) {
X	namlen = strlen(curentry->d_name);
X	if(namlen + 1 > listsize - cursize) {
X	    listsize += 1024;
X	    filetable = realloc(filetable, (unsigned)listsize);
X	}
X	(void)strcpy(filetable + cursize, curentry->d_name);
X	cursize += (namlen + 1);
X	n++;
X    }
X    filetable = realloc(filetable, (unsigned)cursize);
X    (void)closedir(directory);
X    new_files = (filelist *)malloc(sizeof(filelist));
X    new_files->nfiles = n;
X    new_files->files = (char **)malloc((unsigned)n * sizeof(char **));
X    new_files->kind = (int *)malloc((unsigned)n * sizeof(int));
X    new_files->previous = current_files;
X    new_files->current = 0;
X    cursize = 0;
X    for(j = 0; j < n; j++) {
X	new_files->files[j] = filetable + cursize;
X	cursize += (strlen(filetable + cursize) + 1);
X    }
X    (void)chdir(filename);
X#ifdef APPLESHARE
X    if((fd = fopen(f_name, "r")) != NULL) {
X	if(fread(file_info, 1, INFOBYTES, fd) != INFOBYTES) {
X	    (void)fprintf(stderr, "File error on %s\n", f_name);
X	    exit(1);
X	}
X	file_info[I_NAMEOFF] |= 0x80;
X	(void)fclose(fd);
X    } else {
X#ifdef AUFS
X	(void)strcpy(filename1, "../");
X	(void)strcat(filename1, infodir);
X	(void)strcat(filename1, "/");
X	(void)strcat(filename1, filename);
X	if((fd = fopen(filename1, "r")) != NULL) {
X	    read_aufs_info(fd);
X	    (void)fclose(fd);
X	}
X#endif /* AUFS */
X#ifdef APPLEDOUBLE
X	(void)strcpy(filename1, infodir);
X	(void)strcat(filename1, "/.Parent");
X	if((fd = fopen(filename1, "r")) != NULL) {
X	    read_appledouble_info(fd);
X	    (void)fclose(fd);
X	}
X#endif /* APPLEDOUBLE */
X	file_info[I_NAMEOFF] |= 0x80;
X    }
X#else /* APPLESHARE */
X    if((fd = fopen(f_name, "r")) != NULL) {
X	if(fread(file_info, 1, INFOBYTES, fd) != INFOBYTES) {
X	    (void)fprintf(stderr, "File error on %s\n", f_name);
X	    exit(1);
X	}
X	file_info[I_NAMEOFF] |= 0x80;
X	(void)fclose(fd);
X    }
X#endif /* APPLESHARE */
X    current_files = new_files;
X    check_files(0);
X}
X
Xstatic void exit_dir()
X{
X    filelist *old_files;
X    int i;
X
X    for(i = 0; i < INFOBYTES; i++) {
X	file_info[i] = 0;
X    }
X    file_info[I_NAMEOFF] = 0x80;
X    old_files = current_files;
X    /* Do some garbage collection here! */
X    current_files = current_files->previous;
X    (void)free(old_files->files[0]);
X    (void)free((char *)old_files->files);
X    (void)free((char *)old_files->kind);
X    (void)free((char *)old_files);
X    (void)chdir("..");
X}
X
X#ifdef APPLESHARE
X#ifdef AUFS
Xstatic void read_aufs_info(fd)
XFILE *fd;
X{
X    FileInfo theinfo;
X    int i, n;
X    struct stat stbuf;
X
X    for(i = 0; i < INFOBYTES; i++) {
X	file_info[i] = 0;
X    }
X    bzero((char *) &theinfo, sizeof(theinfo));
X    if(fread((char *)&theinfo, 1, sizeof(theinfo), fd) != sizeof(theinfo)) {
X	(void)fprintf(stderr, "Short AUFS info header for %s\n", filename);
X	exit(1);
X    }
X    if(theinfo.fi_magic1 & BYTEMASK != FI_MAGIC1 ||
X       theinfo.fi_version & BYTEMASK != FI_VERSION ||
X       theinfo.fi_magic & BYTEMASK != FI_MAGIC) {
X	(void)fprintf(stderr, "Magic number mismatch on %s\n", filename);
X	exit(1);
X    }
X    bcopy(theinfo.fi_fndr, file_info + I_TYPEOFF, 4);
X    bcopy(theinfo.fi_fndr + 4, file_info + I_AUTHOFF, 4);
X    bcopy(theinfo.fi_fndr + 8, file_info + I_FLAGOFF, 2);
X    if(theinfo.fi_bitmap & FI_BM_MACINTOSHFILENAME) {
X	n = strlen(theinfo.fi_macfilename);
X	(void)strncpy(file_info + I_NAMEOFF + 1, (char *)theinfo.fi_macfilename,
X		n);
X    } else if(theinfo.fi_bitmap & FI_BM_SHORTFILENAME) {
X	n = strlen(theinfo.fi_shortfilename);
X	(void)strncpy(file_info + I_NAMEOFF + 1,
X		(char *)theinfo.fi_shortfilename, n);
X    } else {
X	n = strlen(filename);
X	(void)strncpy(file_info + I_NAMEOFF + 1, filename, n);
X    }
X    file_info[I_NAMEOFF] = n;
X#ifdef AUFSPLUS
X    if(theinfo.fi_datemagic == FI_MAGIC &&
X       (theinfo.fi_datevalid & (FI_CDATE | FI_MDATE)) ==
X		(FI_CDATE | FI_MDATE)) {
X	put4(file_info + I_CTIMOFF, get4(theinfo.fi_ctime) + TIMEDIFF);
X	put4(file_info + I_MTIMOFF, get4(theinfo.fi_mtime) + TIMEDIFF);
X    } else {
X	if(fstat(fileno(fd), &stbuf) >= 0) {
X	    put4(file_info + I_CTIMOFF,
X		(unsigned long)stbuf.st_ctime + TIMEDIFF);
X	    put4(file_info + I_MTIMOFF,
X		(unsigned long)stbuf.st_mtime + TIMEDIFF);
X	}
X    }
X#else /* AUFSPLUS */
X    if(fstat(fileno(fd), &stbuf) >= 0) {
X	put4(file_info + I_CTIMOFF, (unsigned long)stbuf.st_ctime + TIMEDIFF);
X	put4(file_info + I_MTIMOFF, (unsigned long)stbuf.st_mtime + TIMEDIFF);
X    }
X#endif /* AUFSPLUS */
X}
X#endif /* AUFS */
X
X#ifdef APPLEDOUBLE
X/* This version assumes that the AppleDouble info header is always the same
X   size and format.  I have not yet seen something that will lead me to
X   believe different.
X*/
Xstatic void read_appledouble_info(fd)
XFILE *fd;
X{
X    FileInfo theinfo;
X    int i, n;
X
X    for(i = 0; i < INFOBYTES; i++) {
X	file_info[i] = 0;
X    }
X    bzero((char *) &theinfo, sizeof(theinfo));
X    if(fread((char *)&theinfo, 1, sizeof(theinfo), fd) != sizeof(theinfo)) {
X	(void)fprintf(stderr, "Short AppleDouble info header for %s\n",
X		filename);
X	exit(1);
X    }
X    if(get4(theinfo.fi_magic) != FI_MAGIC ||
X       get2(theinfo.fi_version) != FI_VERSION) {
X	(void)fprintf(stderr, "Magic number mismatch on %s\n", filename);
X	exit(1);
X    }
X    bcopy(theinfo.fi_type, file_info + I_TYPEOFF, 4);
X    bcopy(theinfo.fi_auth, file_info + I_AUTHOFF, 4);
X    bcopy(theinfo.fi_finfo, file_info + I_FLAGOFF, 2);
X    n = get4(theinfo.fi_namlen);
X    (void)strncpy(file_info + I_NAMEOFF + 1, theinfo.fi_name, n);
X    file_info[I_NAMEOFF] = n;
X    put4(file_info + I_CTIMOFF, get4(theinfo.fi_ctime) + TIMEDIFF);
X    put4(file_info + I_MTIMOFF, get4(theinfo.fi_mtime) + TIMEDIFF);
X    rsrc_size = get4(theinfo.fi_rsrc);
X    put4(file_info + I_RLENOFF, (unsigned long)rsrc_size);
X}
X#endif /* APPLEDOUBLE */
X#endif /* APPLESHARE */
X
Xstatic int get_stdin_file()
X{
X    int i, skip;
X
X    i = fgetc(stdin);
X    if(i == EOF) {
X	return ISATEND;
X    }
X    (void)ungetc(i, stdin);
X    if(fread(file_info, 1, INFOBYTES, stdin) != INFOBYTES) {
X	(void)fprintf(stderr, "Short input\n");
X	exit(1);
X    }
X    if(file_info[0] != 0) {
X	(void)fprintf(stderr, "File is not MacBinary: %s\n", filename);
X	exit(1);
X    }
X    data_size = get4(file_info + I_DLENOFF);
X    rsrc_size = get4(file_info + I_RLENOFF);
X    if(file_info[I_LOCKOFF] & 1) {
X	file_info[I_FLAGOFF + 1] = PROTCT_MASK;
X	file_info[I_LOCKOFF] &= ~1;
X    }
X    if(data_size != 0) {
X	if(data_size > max_data_size) {
X	    if(data_fork == NULL) {
X		data_fork = malloc((unsigned)data_size);
X	    } else {
X		data_fork = realloc(data_fork, (unsigned)data_size);
X	    }
X	    max_data_size = data_size;
X	}
X	if(fread(data_fork, 1, data_size, stdin) != data_size) {
X	    (void)fprintf(stderr, "Short input\n");
X	    exit(1);
X	}
X	skip = (((data_size + 127) >> 7) << 7) - data_size;
X	for(i = 0; i < skip; i++) {
X	    (void)fgetc(stdin);
X	}
X    }
X    if(rsrc_size != 0) {
X	if(rsrc_size > max_rsrc_size) {
X	    if(rsrc_fork == NULL) {
X		rsrc_fork = malloc((unsigned)rsrc_size);
X	    } else {
X		rsrc_fork = realloc(rsrc_fork, (unsigned)rsrc_size);
X	    }
X	    max_rsrc_size = rsrc_size;
X	}
X	if(fread(rsrc_fork, 1, rsrc_size, stdin) != rsrc_size) {
X	    (void)fprintf(stderr, "Short input\n");
X	    exit(1);
X	}
X	skip = (((rsrc_size + 127) >> 7) << 7) - rsrc_size;
X	for(i = 0; i < skip; i++) {
X	    (void)fgetc(stdin);
X	}
X    }
X    if(file_info[I_NAMEOFF] & 0x80) {
X	if(file_info[I_NAMEOFF] == 0x80) {
X	    return ENDDIR;
X	}
X	return ISDIR;
X    }
X    return ISFILE;
X}
X
Xint rdfileopt(c)
Xchar c;
X{
X    switch(c) {
X    case 'd':
X	data_only = DATA_FORMAT;
X	break;
X    case 'u':
X    case 'U':
X	data_only = UNIX_FORMAT;
X	break;
X    case 'r':
X	data_only = RSRC_FORMAT;
X	break;
X    default:
X	return 0;
X    }
X    return 1;
X}
X
Xvoid give_rdfileopt()
X{
X    (void)fprintf(stderr, "File input options:\n");
X    (void)fprintf(stderr, "-r:\tread as resource files\n");
X    (void)fprintf(stderr, "-d:\tread as data files\n");
X    (void)fprintf(stderr,
X	"-u:\tread as data files with Unix -> Mac text file translation\n");
X    (void)fprintf(stderr, "-U:\ta synonym for -u\n");
X}
X
Xvoid set_norecurse()
X{
X    no_recurse = 1;
X}
X
Xchar *get_rdfileopt()
X{
X    static char options[] = "rduU";
X
X    return options;
X}
X
Xchar *get_minb()
X{
X#ifdef APPLESHARE
X#ifdef AUFS
X    return ", AUFS supported";
X#endif /* AUFS */
X#ifdef APPLEDOUBLE
X    return ", AppleDouble supported";
X#endif /* APPLEDOUBLE */
X#else /* APPLESHARE */
X    return ", no Apple-Unix sharing supported";
X#endif /* APPLESHARE */
X}
X
SHAR_EOF
if test 25879 -ne "`wc -c < 'rdfile.c'`"
then
	echo shar: "error transmitting 'rdfile.c'" '(should have been 25879 characters)'
fi
fi
echo shar: "extracting 'rdfile.h'" '(247 characters)'
if test -f 'rdfile.h'
then
	echo shar: "will not over-write existing file 'rdfile.h'"
else
sed 's/^X//' << \SHAR_EOF > 'rdfile.h'
X#define	ISATEND		0
X#define	ISFILE		1
X#define	ISDIR		2
X#define	ENDDIR		3
X
Xextern char file_info[INFOBYTES];
Xextern char *data_fork, *rsrc_fork;
Xextern int data_size, rsrc_size;
X
Xextern void setup();
Xextern int nextfile();
Xextern char *get_minb();
X
SHAR_EOF
if test 247 -ne "`wc -c < 'rdfile.h'`"
then
	echo shar: "error transmitting 'rdfile.h'" '(should have been 247 characters)'
fi
fi
echo shar: "extracting 'rdfileopt.h'" '(114 characters)'
if test -f 'rdfileopt.h'
then
	echo shar: "will not over-write existing file 'rdfileopt.h'"
else
sed 's/^X//' << \SHAR_EOF > 'rdfileopt.h'
Xextern int rdfileopt();
Xextern void give_rdfileopt();
Xextern void set_norecurse();
Xextern char *get_rdfileopt();
X
SHAR_EOF
if test 114 -ne "`wc -c < 'rdfileopt.h'`"
then
	echo shar: "error transmitting 'rdfileopt.h'" '(should have been 114 characters)'
fi
fi
echo shar: "extracting 'kind.h'" '(167 characters)'
if test -f 'kind.h'
then
	echo shar: "will not over-write existing file 'kind.h'"
else
sed 's/^X//' << \SHAR_EOF > 'kind.h'
X#ifdef SCAN
X#define UNIX_NAME	0
X#define PACK_NAME	1
X#define ARCH_NAME	2
X#define	UNKNOWN		16
X#define	PROTECTED	17
X#define	ERROR		32
X#define COPY		33
X#endif /* SCAN */
X
SHAR_EOF
if test 167 -ne "`wc -c < 'kind.h'`"
then
	echo shar: "error transmitting 'kind.h'" '(should have been 167 characters)'
fi
fi
echo shar: "done with directory 'fileio'"
cd ..
if test ! -d 'macunpack'
then
	echo shar: "creating directory 'macunpack'"
	mkdir 'macunpack'
fi
echo shar: "entering directory 'macunpack'"
cd 'macunpack'
echo shar: "extracting 'de_lzah.c'" '(6813 characters)'
if test -f 'de_lzah.c'
then
	echo shar: "will not over-write existing file 'de_lzah.c'"
else
sed 's/^X//' << \SHAR_EOF > 'de_lzah.c'
X#include "macunpack.h"
X#ifdef SIT
X#define DELZAH
X#endif /* SIT */
X#ifdef LZH
X#define DELZAH
X#endif /* LZH */
X#ifdef DELZAH
X#include "globals.h"
X#include "../util/masks.h"
X#include "../fileio/wrfile.h"
X
X/* Note: compare with LZSS decoding in lharc! */
X
X#define N	314
X#define T	(2*N-1)
X
X/*	Huffman table used for first 6 bits of offset:
X	#bits	codes
X	3	0x000
X	4	0x040-0x080
X	5	0x100-0x2c0
X	6	0x300-0x5c0
X	7	0x600-0xbc0
X	8	0xc00-0xfc0
X*/
X
Xstatic unsigned short HuffCode[] = {
X    0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,
X    0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,
X    0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,
X    0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,
X    0x040, 0x040, 0x040, 0x040, 0x040, 0x040, 0x040, 0x040,
X    0x040, 0x040, 0x040, 0x040, 0x040, 0x040, 0x040, 0x040,
X    0x080, 0x080, 0x080, 0x080, 0x080, 0x080, 0x080, 0x080,
X    0x080, 0x080, 0x080, 0x080, 0x080, 0x080, 0x080, 0x080,
X    0x0c0, 0x0c0, 0x0c0, 0x0c0, 0x0c0, 0x0c0, 0x0c0, 0x0c0,
X    0x0c0, 0x0c0, 0x0c0, 0x0c0, 0x0c0, 0x0c0, 0x0c0, 0x0c0,
X    0x100, 0x100, 0x100, 0x100, 0x100, 0x100, 0x100, 0x100,
X    0x140, 0x140, 0x140, 0x140, 0x140, 0x140, 0x140, 0x140,
X    0x180, 0x180, 0x180, 0x180, 0x180, 0x180, 0x180, 0x180,
X    0x1c0, 0x1c0, 0x1c0, 0x1c0, 0x1c0, 0x1c0, 0x1c0, 0x1c0,
X    0x200, 0x200, 0x200, 0x200, 0x200, 0x200, 0x200, 0x200,
X    0x240, 0x240, 0x240, 0x240, 0x240, 0x240, 0x240, 0x240,
X    0x280, 0x280, 0x280, 0x280, 0x280, 0x280, 0x280, 0x280,
X    0x2c0, 0x2c0, 0x2c0, 0x2c0, 0x2c0, 0x2c0, 0x2c0, 0x2c0,
X    0x300, 0x300, 0x300, 0x300, 0x340, 0x340, 0x340, 0x340,
X    0x380, 0x380, 0x380, 0x380, 0x3c0, 0x3c0, 0x3c0, 0x3c0,
X    0x400, 0x400, 0x400, 0x400, 0x440, 0x440, 0x440, 0x440,
X    0x480, 0x480, 0x480, 0x480, 0x4c0, 0x4c0, 0x4c0, 0x4c0,
X    0x500, 0x500, 0x500, 0x500, 0x540, 0x540, 0x540, 0x540,
X    0x580, 0x580, 0x580, 0x580, 0x5c0, 0x5c0, 0x5c0, 0x5c0,
X    0x600, 0x600, 0x640, 0x640, 0x680, 0x680, 0x6c0, 0x6c0,
X    0x700, 0x700, 0x740, 0x740, 0x780, 0x780, 0x7c0, 0x7c0,
X    0x800, 0x800, 0x840, 0x840, 0x880, 0x880, 0x8c0, 0x8c0,
X    0x900, 0x900, 0x940, 0x940, 0x980, 0x980, 0x9c0, 0x9c0,
X    0xa00, 0xa00, 0xa40, 0xa40, 0xa80, 0xa80, 0xac0, 0xac0,
X    0xb00, 0xb00, 0xb40, 0xb40, 0xb80, 0xb80, 0xbc0, 0xbc0,
X    0xc00, 0xc40, 0xc80, 0xcc0, 0xd00, 0xd40, 0xd80, 0xdc0,
X    0xe00, 0xe40, 0xe80, 0xec0, 0xf00, 0xf40, 0xf80, 0xfc0};
X
Xstatic short HuffLength[] = {
X    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
X    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
X    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
X    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
X    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
X    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
X    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
X    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
X    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
X    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
X    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
X    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
X    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
X    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
X    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
X    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8};
X
Xunsigned char (*lzah_getbyte)();
X
Xstatic void lzah_inithuf();
Xstatic void lzah_reorder();
Xstatic void lzah_move();
Xstatic void lzah_getbit();
Xstatic void lzah_outchar();
X
Xstatic char lzah_buf[4096];
Xstatic int lzah_bufptr;
Xstatic int lzah_bitsavail;
Xstatic int lzah_bits;
Xstatic int Frequ[1000];
Xstatic int ForwTree[1000];
Xstatic int BackTree[1000];
X
Xvoid de_lzah(obytes)
Xunsigned long obytes;
X{
X    int i, i1, j, ch, byte, offs, skip;
X
X    lzah_inithuf();
X    lzah_bitsavail = 0;
X    for(i = 0; i < 4036; i++) {
X	lzah_buf[i] = ' ';
X    }
X    lzah_bufptr = 4036;
X    while(obytes != 0) {
X	ch = ForwTree[T - 1];
X	while(ch < T) {
X	    lzah_getbit();
X	    if(lzah_bits & 0x80) {
X		ch = ch + 1;
X	    }
X	    ch = ForwTree[ch];
X	}
X	ch -= T;
X	if(Frequ[T - 1] >= 0x8000) {
X	    lzah_reorder();
X	}
X
X	i = BackTree[ch + T];
X	do {
X	    j = ++Frequ[i];
X	    i1 = i + 1;
X	    if(Frequ[i1] < j) {
X		while(Frequ[++i1] < j) ;
X		i1--;
X		Frequ[i] = Frequ[i1];
X		Frequ[i1] = j;
X
X		j = ForwTree[i];
X		BackTree[j] = i1;
X		if(j < T) {
X		    BackTree[j + 1] = i1;
X		}
X		ForwTree[i] = ForwTree[i1];
X		ForwTree[i1] = j;
X		j = ForwTree[i];
X		BackTree[j] = i;
X		if(j < T) {
X		    BackTree[j + 1] = i;
X		}
X		i = i1;
X	    }
X	    i = BackTree[i];
X	} while(i != 0);
X
X	if(ch < 256) {
X	    lzah_outchar((char)ch);
X	    obytes--;
X	} else {
X	    if(lzah_bitsavail != 0) {
X		byte = (lzah_bits << 1) & BYTEMASK;
X		lzah_bits = (*lzah_getbyte)() & BYTEMASK;
X		byte |= (lzah_bits >> lzah_bitsavail);
X		lzah_bits = lzah_bits << (7 - lzah_bitsavail);
X	    } else {
X		byte = (*lzah_getbyte)() & BYTEMASK;
X	    }
X	    offs = HuffCode[byte];
X	    skip = HuffLength[byte] - 2;
X	    while(skip-- != 0) {
X		byte = byte + byte;
X		lzah_getbit();
X		if(lzah_bits & 0x80) {
X		    byte++;
X		}
X	    }
X	    offs |= (byte & 0x3f);
X	    offs = ((lzah_bufptr - offs - 1) & 0xfff);
X	    ch = ch - 253;
X	    while(ch-- > 0) {
X		lzah_outchar(lzah_buf[offs++ & 0xfff]);
X		obytes--;
X		if(obytes == 0) {
X		    break;
X		}
X	    }
X	}
X    }
X}
X
Xstatic void lzah_inithuf()
X{
X    int i, j;
X
X    for(i = 0; i < N; i++) {
X	Frequ[i] = 1;
X	ForwTree[i] = i + T;
X	BackTree[i + T] = i;
X    }
X    for(i = 0, j = N; j < T; i += 2, j++) {
X	Frequ[j] = Frequ[i] + Frequ[i + 1];
X	ForwTree[j] = i;
X	BackTree[i] = j;
X	BackTree[i + 1] = j;
X    }
X    Frequ[T] = 0xffff;
X    BackTree[T - 1] = 0;
X}
X
Xstatic void lzah_reorder()
X{
X    int i, j, k, l;
X
X    j = 0;
X    for(i = 0; i < T; i++) {
X	if(ForwTree[i] >= T) {
X	    Frequ[j] = ((Frequ[i] + 1) >> 1);
X	    ForwTree[j] = ForwTree[i];
X	    j++;
X	}
X    }
X    for(i = 0, j = N; i < T; i += 2, j++) {
X	k = i + 1;
X	l = Frequ[i] + Frequ[k];
X	Frequ[j] = l;
X	k = j - 1;
X	while(l < Frequ[k]) {
X	    k--;
X	}
X	k = k + 1;
X	lzah_move(Frequ + k, Frequ + k + 1, j - k);
X	Frequ[k] = l;
X	lzah_move(ForwTree + k, ForwTree + k + 1, j - k);
X	ForwTree[k] = i;
X    }
X    for(i = 0; i < T; i++) {
X	k = ForwTree[i];
X	if(k >= T) {
X	    BackTree[k] = i;
X	} else {
X	    BackTree[k] = i;
X	    BackTree[k + 1] = i;
X	}
X    }
X}
X
Xstatic void lzah_move(p, q, n)
Xint *p, *q, n;
X{
X    if(p > q) {
X	while(n-- > 0) {
X	    *q++ = *p++;
X	}
X    } else {
X	p += n;
X	q += n;
X	while(n-- > 0) {
X	    *--q = *--p;
X	}
X    }
X}
X
Xstatic void lzah_getbit()
X{
X    if(lzah_bitsavail != 0) {
X	lzah_bits = lzah_bits + lzah_bits;
X	lzah_bitsavail--;
X    } else {
X	lzah_bits = (*lzah_getbyte)() & BYTEMASK;
X	lzah_bitsavail = 7;
X    }
X}
X
Xstatic void lzah_outchar(ch)
Xchar ch;
X{
X    *out_ptr++ = ch;
X    lzah_buf[lzah_bufptr++] = ch;
X    lzah_bufptr &= 0xfff;
X}
X#else /* DELZAH */
Xint delzah; /* keep lint and some compilers happy */
X#endif /* DELZAH */
X
SHAR_EOF
if test 6813 -ne "`wc -c < 'de_lzah.c'`"
then
	echo shar: "error transmitting 'de_lzah.c'" '(should have been 6813 characters)'
fi
fi
echo shar: "extracting 'pit.c'" '(6442 characters)'
if test -f 'pit.c'
then
	echo shar: "will not over-write existing file 'pit.c'"
else
sed 's/^X//' << \SHAR_EOF > 'pit.c'
X#include "macunpack.h"
X#ifdef PIT
X#include "../fileio/wrfile.h"
X#include "../fileio/fileglob.h"
X#include "../fileio/kind.h"
X#include "globals.h"
X#include "pit.h"
X#include "../fileio/machdr.h"
X#include "crc.h"
X#include "../util/masks.h"
X#include "../util/util.h"
X#include "huffman.h"
X
Xextern void read_tree();
Xextern void de_huffman();
Xextern void set_huffman();
X
Xstatic int pit_filehdr();
Xstatic void pit_wrfile();
Xstatic void pit_nocomp();
Xstatic void pit_huffman();
X
Xvoid pit()
X{
X    struct pit_header filehdr;
X    char pithdr[4];
X    int decode, synced, ch;
X    unsigned long data_crc, crc;
X
X    updcrc = binhex_updcrc;
X    crcinit = binhex_crcinit;
X    set_huffman(HUFF_BE);
X    synced = 0;
X    while(1) {
X	if(!synced) {
X	    if(fread(pithdr, 1, 4, infp) != 4) {
X		(void)fprintf(stderr, "Premature EOF\n");
X#ifdef SCAN
X		do_error("macunpack: Premature EOF");
X#endif /* SCAN */
X		exit(1);
X	    }
X	}
X	synced = 0;
X	if(strncmp(pithdr, "PEnd", 4) == 0) {
X	    break;
X	}
X	if(strncmp(pithdr, "PMa", 3) != 0) {
X	    (void)fprintf(stderr, "File contains non PackIt info %.4s\n",
X		    pithdr);
X#ifdef SCAN
X	    do_error("macunpack: File contains non PackIt info");
X#endif /* SCAN */
X	    exit(1);
X	}
X	switch(pithdr[3]) {
X	case 'g':
X	case '4':
X	    break;
X	case '5':
X	case '6':
X	    if(pithdr[3] == '6') {
X		(void)fprintf(stderr, "DES-");
X	    }
X	    (void)fprintf(stderr, "Encrypted file found, trying to sync");
X	    while(!synced) {
X		ch = getb(infp);
X		if(ch == 'P') {
X		    pithdr[0] = ch;
X		    pithdr[1] = ch = getb(infp);
X		    if(ch == 'M') {
X			pithdr[2] = ch = getb(infp);
X			if(ch == 'a') {
X			    pithdr[3] = ch = getb(infp);
X			    if((ch >= '4' && ch <= '6') || ch == 'g') {
X				synced = 1;
X			    }
X			}
X		    } else if(ch == 'E') {
X			pithdr[2] = ch = getb(infp);
X			if(ch == 'n') {
X			    pithdr[3] = ch = getb(infp);
X			    if(ch == 'd') {
X				synced = 1;
X			    }
X			}
X		    }
X		    if(!synced) {
X			(void)ungetc(ch, infp);
X		    }
X		}
X	    }
X	    (void)fprintf(stderr, ", done.\n");
X#ifdef SCAN
X	    do_idf("", PROTECTED);
X#endif /* SCAN */
X	    continue;
X	default:
X	    (void)fprintf(stderr, "File contains non PackIt info %.4s\n",
X		    pithdr);
X#ifdef SCAN
X	    do_error("macunpack: File contains non PackIt info");
X#endif /* SCAN */
X	    exit(1);
X	}
X	bytes_read = 0;
X	if(pithdr[3] == '4') {
X	    read_tree();
X	    decode = huffman;
X	} else {
X	    decode = nocomp;
X	}
X	if(pit_filehdr(&filehdr, decode) == -1) {
X	    (void)fprintf(stderr, "Can't read file header\n");
X#ifdef SCAN
X	    do_error("macunpack: Can't read file header");
X#endif /* SCAN */
X	    exit(1);
X	}
X	bytes_written = filehdr.rlen + filehdr.dlen;
X	start_info(info, filehdr.rlen, filehdr.dlen);
X	start_data();
X	pit_wrfile(filehdr.dlen, decode);
X	data_crc = (*updcrc)(INIT_CRC, out_buffer, filehdr.dlen);
X	start_rsrc();
X	pit_wrfile(filehdr.rlen, decode);
X	data_crc = (*updcrc)(data_crc, out_buffer, filehdr.rlen);
X	if(decode == nocomp) {
X	    crc = getb(infp);
X	    crc = (crc << 8) | getb(infp);
X	} else {
X	    crc = (getihuffbyte() & BYTEMASK) |
X		  ((getihuffbyte() & BYTEMASK) << 8);
X	}
X	if(crc != data_crc) {
X	    (void)fprintf(stderr,
X		    "CRC error in file: need 0x%04x, got 0x%04x\n",
X		    (int)crc, (int)data_crc);
X#ifdef SCAN
X	    do_error("macunpack: CRC error in file");
X#endif /* SCAN */
X	    exit(1);
X	}
X	if(verbose) {
X	    if(decode == nocomp) {
X		(void)fprintf(stderr, "\tNo compression");
X	    } else {
X		(void)fprintf(stderr, "\tHuffman compressed (%4.1f%%)",
X			100.0 * bytes_read / bytes_written);
X	    }
X	}
X	if(write_it) {
X	    end_file();
X	}
X	if(verbose) {
X	    (void)fprintf(stderr, ".\n");
X	}
X    }
X}
X
Xstatic int pit_filehdr(f, compr)
Xstruct pit_header *f;
Xint compr;
X{
X    register int i;
X    unsigned long crc;
X    int n;
X    char hdr[HDRBYTES];
X    char ftype[5], fauth[5];
X
X    for(i = 0; i < INFOBYTES; i++)
X	info[i] = '\0';
X
X    if(compr == huffman) {
X	for(i = 0; i < HDRBYTES; i++) {
X	    hdr[i] = getihuffbyte();
X	}
X    } else {
X	if(fread(hdr, 1, HDRBYTES, infp) != HDRBYTES) {
X	    return -1;
X	}
X    }
X    crc = INIT_CRC;
X    crc = (*updcrc)(crc, hdr, HDRBYTES - 2);
X
X    f->hdrCRC = get2(hdr + H_HDRCRC);
X    if(f->hdrCRC != crc) {
X	(void)fprintf(stderr,
X		"\tHeader CRC mismatch: got 0x%04x, need 0x%04x\n",
X		f->hdrCRC & WORDMASK, (int)crc);
X	return -1;
X    }
X
X    n = hdr[H_NLENOFF] & BYTEMASK;
X    if(n > H_NAMELEN) {
X	n = H_NAMELEN;
X    }
X    info[I_NAMEOFF] = n;
X    copy(info + I_NAMEOFF + 1, hdr + H_NAMEOFF, n);
X    transname(hdr + H_NAMEOFF, text, n);
X    text[n] = '\0';
X
X    f->rlen = get4(hdr + H_RLENOFF);
X    f->dlen = get4(hdr + H_DLENOFF);
X
X    write_it = 1;
X    if(list) {
X	transname(hdr + H_TYPEOFF, ftype, 4);
X	transname(hdr + H_AUTHOFF, fauth, 4);
X	do_indent(indent);
X	(void)fprintf(stderr,
X		"name=\"%s\", type=%4.4s, author=%4.4s, data=%ld, rsrc=%ld",
X		text, ftype, fauth, (long)f->dlen, (long)f->rlen);
X	if(info_only) {
X	    write_it = 0;
X	}
X	if(query) {
X	    write_it = do_query();
X	} else {
X	    (void)fputc('\n', stderr);
X	}
X    }
X
X
X    if(write_it) {
X	define_name(text);
X
X	copy(info + I_TYPEOFF, hdr + H_TYPEOFF, 4);
X	copy(info + I_AUTHOFF, hdr + H_AUTHOFF, 4);
X	copy(info + I_FLAGOFF, hdr + H_FLAGOFF, 2);
X	copy(info + I_LOCKOFF, hdr + H_LOCKOFF, 2);
X	copy(info + I_DLENOFF, hdr + H_DLENOFF, 4);
X	copy(info + I_RLENOFF, hdr + H_RLENOFF, 4);
X	copy(info + I_CTIMOFF, hdr + H_CTIMOFF, 4);
X	copy(info + I_MTIMOFF, hdr + H_MTIMOFF, 4);
X    }
X    return 1;
X}
X
Xstatic void pit_wrfile(bytes, type)
Xunsigned long bytes;
Xint type;
X{
X    if(bytes == 0) {
X	return;
X    }
X    switch(type) {
X    case nocomp:
X	pit_nocomp(bytes);
X	break;
X    case huffman:
X	pit_huffman(bytes);
X    }
X}
X
X/*---------------------------------------------------------------------------*/
X/*	No compression							     */
X/*---------------------------------------------------------------------------*/
Xstatic void pit_nocomp(ibytes)
Xunsigned long ibytes;
X{
X    int n;
X
X    n = fread(out_buffer, 1, (int)ibytes, infp);
X    if(n != ibytes) {
X	(void)fprintf(stderr, "Premature EOF\n");
X#ifdef SCAN
X	do_error("macunpack: Premature EOF");
X#endif /* SCAN */
X	exit(1);
X    }
X}
X
X/*---------------------------------------------------------------------------*/
X/*	Huffman compression						     */
X/*---------------------------------------------------------------------------*/
Xstatic void pit_huffman(obytes)
Xunsigned long obytes;
X{
X    de_huffman(obytes);
X}
X#else /* PIT */
Xint pit; /* keep lint and some compilers happy */
X#endif /* PIT */
X
SHAR_EOF
if test 6442 -ne "`wc -c < 'pit.c'`"
then
	echo shar: "error transmitting 'pit.c'" '(should have been 6442 characters)'
fi
fi
echo shar: "extracting 'sit.c'" '(19518 characters)'
if test -f 'sit.c'
then
	echo shar: "will not over-write existing file 'sit.c'"
else
sed 's/^X//' << \SHAR_EOF > 'sit.c'
X#include "macunpack.h"
X#ifdef SIT
X#include "globals.h"
X#include "sit.h"
X#include "crc.h"
X#include "../util/util.h"
X#include "../fileio/machdr.h"
X#include "../fileio/wrfile.h"
X#include "../fileio/kind.h"
X#include "../util/masks.h"
X#include "huffman.h"
X
Xextern void de_compress();
Xextern void core_compress();
Xextern void de_huffman();
Xextern void de_huffman_end();
Xextern void read_tree();
Xextern void set_huffman();
Xextern void de_lzah();
Xextern unsigned char (*lzah_getbyte)();
X
Xtypedef struct methodinfo {
X	char *name;
X	int number;
X};
X
Xstatic struct methodinfo methods[] = {
X    {"NoComp",  nocomp},
X    {"RLE",     rle},
X    {"LZC",     lzc},
X    {"Huffman", huffman},
X    {"LZAH",    lzah},
X    {"FixHuf",  fixhuf},
X    {"MW",      mw},
X};
Xstatic int sit_nodeptr;
X
Xstatic int readsithdr();
Xstatic int sit_filehdr();
Xstatic int sit_valid();
Xstatic int sit_checkm();
Xstatic char *sit_methname();
Xstatic void sit_folder();
Xstatic void sit_unstuff();
Xstatic void sit_wrfile();
Xstatic void sit_skip();
Xstatic void sit_nocomp();
Xstatic void sit_rle();
Xstatic void sit_lzc();
Xstatic void sit_huffman();
Xstatic void sit_lzah();
Xstatic unsigned char sit_getbyte();
Xstatic void sit_fixhuf();
Xstatic void sit_dosplit();
Xstatic void sit_mw();
Xstatic void sit_mw_out();
Xstatic int sit_mw_in();
X
Xstatic short code6[258] = {
X   1024,  512,  256,  256,  256,  256,  128,  128,
X    128,  128,  128,  128,  128,  128,  128,  128,
X    128,  128,   64,   64,   64,   64,   64,   64,
X     64,   64,   64,   64,   64,   64,   64,   64,
X     64,   64,   64,   64,   64,   64,   64,   64,
X     64,   64,   64,   64,   64,   64,   64,   64,
X     64,   64,   32,   32,   32,   32,   32,   32,
X     32,   32,   32,   32,   32,   32,   32,   32,
X     32,   32,   16,   16,   16,   16,   16,   16,
X     16,   16,   16,   16,   16,   16,   16,   16,
X     16,   16,   16,   16,   16,   16,   16,   16,
X     16,   16,   16,   16,   16,   16,   16,   16,
X     16,   16,   16,   16,   16,   16,   16,   16,
X     16,   16,   16,   16,   16,   16,   16,   16,
X     16,   16,   16,    8,    8,   16,   16,    8,
X      8,    8,    8,    8,    8,    8,    8,    8,
X      8,    8,    8,    8,    8,    8,    8,    8,
X      8,    8,    8,    8,    8,    8,    8,    8,
X      8,    8,    8,    8,    8,    8,    8,    8,
X      8,    8,    8,    8,    8,    8,    8,    4,
X      4,    4,    4,    4,    4,    4,    4,    4,
X      4,    4,    4,    4,    4,    4,    4,    4,
X      4,    4,    4,    4,    4,    4,    4,    4,
X      4,    4,    4,    4,    4,    4,    4,    4,
X      4,    4,    4,    4,    4,    4,    4,    4,
X      4,    4,    4,    4,    4,    4,    4,    4,
X      4,    4,    4,    4,    4,    4,    4,    4,
X      4,    4,    4,    4,    4,    4,    4,    4,
X      4,    4,    4,    4,    4,    4,    4,    4,
X      4,    4,    4,    4,    4,    4,    4,    4,
X      4,    4,    4,    4,    4,    4,    4,    4,
X      4,    4,    4,    4,    4,    4,    1,    1,
X      1,    1};
Xstatic char sit_buffer[32768];
Xstatic short sit_dict[16385];
Xstatic unsigned long sit_avail;
Xstatic int sit_bits_avail;
X
Xvoid sit()
X{
X    struct sitHdr sithdr;
X    struct fileHdr filehdr;
X    int i;
X
X    set_huffman(HUFF_BE);
X    core_compress((char *)NULL);
X    updcrc = arc_updcrc;
X    crcinit = arc_crcinit;
X    if(readsithdr(&sithdr) == 0) {
X	(void)fprintf(stderr, "Can't read file header\n");
X#ifdef SCAN
X	do_error("macunpack: Can't read file header");
X#endif /* SCAN */
X	exit(1);
X    }
X
X    for(i = 0; i < sithdr.numFiles; i++) {
X	if(sit_filehdr(&filehdr, 0) == -1) {
X	    (void)fprintf(stderr, "Can't read file header #%d\n", i+1);
X#ifdef SCAN
X	    do_error("macunpack: Can't read file header");
X#endif /* SCAN */
X	    exit(1);
X	}
X	if(!sit_valid(filehdr)) {
X	    continue;
X	}
X	if(filehdr.compRMethod == sfolder) {
X	    sit_folder(text);
X	} else {
X	    sit_unstuff(filehdr);
X	}
X    }
X}
X
Xstatic int readsithdr(s)
Xstruct sitHdr *s;
X{
X    char temp[SITHDRSIZE];
X
X    if(fread(temp, 1, SITHDRSIZE, infp) != SITHDRSIZE) {
X	return 0;
X    }
X
X    if(strncmp(temp + S_SIGNATURE,  "SIT!", 4) != 0 ||
X	strncmp(temp + S_SIGNATURE2, "rLau", 4) != 0) {
X	(void)fprintf(stderr, "Not a StuffIt file\n");
X	return 0;
X    }
X
X    s->numFiles = get2(temp + S_NUMFILES);
X    s->arcLength = get4(temp + S_ARCLENGTH);
X
X    return 1;
X}
X
Xstatic int sit_filehdr(f, skip)
Xstruct fileHdr *f;
Xint skip;
X{
X    register int i;
X    unsigned long crc;
X    int n;
X    char hdr[FILEHDRSIZE];
X    char ftype[5], fauth[5];
X
X    for(i = 0; i < INFOBYTES; i++) {
X	info[i] = '\0';
X    }
X    if(fread(hdr, 1, FILEHDRSIZE, infp) != FILEHDRSIZE) {
X	(void)fprintf(stderr, "Can't read file header\n");
X	return -1;
X    }
X    crc = INIT_CRC;
X    crc = (*updcrc)(crc, hdr, FILEHDRSIZE - 2);
X
X    f->hdrCRC = get2(hdr + F_HDRCRC);
X    if(f->hdrCRC != crc) {
X	(void)fprintf(stderr, "Header CRC mismatch: got 0x%04x, need 0x%04x\n",
X		f->hdrCRC & WORDMASK, (int)crc);
X	return -1;
X    }
X
X    n = hdr[F_FNAME] & BYTEMASK;
X    if(n > F_NAMELEN) {
X	n = F_NAMELEN;
X    }
X    info[I_NAMEOFF] = n;
X    copy(info + I_NAMEOFF + 1, hdr + F_FNAME + 1, n);
X    transname(hdr + F_FNAME + 1, text, n);
X
X    f->compRMethod = hdr[F_COMPRMETHOD];
X    f->compDMethod = hdr[F_COMPDMETHOD];
X    f->rsrcLength = get4(hdr + F_RSRCLENGTH);
X    f->dataLength = get4(hdr + F_DATALENGTH);
X    f->compRLength = get4(hdr + F_COMPRLENGTH);
X    f->compDLength = get4(hdr + F_COMPDLENGTH);
X    f->rsrcCRC = get2(hdr + F_RSRCCRC);
X    f->dataCRC = get2(hdr + F_DATACRC);
X
X    write_it = !skip;
X    if(list && !skip) {
X	if(f->compRMethod != efolder) {
X	    do_indent(indent);
X	}
X	if(f->compRMethod == sfolder) {
X	    (void)fprintf(stderr, "folder=\"%s\"", text);
X	} else if(f->compRMethod != efolder) {
X	    transname(hdr + F_FTYPE, ftype, 4);
X	    transname(hdr + F_CREATOR, fauth, 4);
X	    (void)fprintf(stderr,
X		    "name=\"%s\", type=%4.4s, author=%4.4s, data=%ld, rsrc=%ld",
X		    text, ftype, fauth,
X		    (long)f->dataLength, (long)f->rsrcLength);
X	}
X	if(info_only) {
X	    write_it = 0;
X	}
X	if(f->compRMethod != efolder) {
X	    if(query) {
X		write_it = do_query();
X	    } else {
X		(void)fputc('\n', stderr);
X	    }
X	}
X    }
X
X    if(write_it) {
X	define_name(text);
X
X	if(f->compRMethod != sfolder) {
X	    copy(info + I_TYPEOFF, hdr + F_FTYPE, 4);
X	    copy(info + I_AUTHOFF, hdr + F_CREATOR, 4);
X	    copy(info + I_FLAGOFF, hdr + F_FNDRFLAGS, 2);
X	    copy(info + I_DLENOFF, hdr + F_DATALENGTH, 4);
X	    copy(info + I_RLENOFF, hdr + F_RSRCLENGTH, 4);
X	    copy(info + I_CTIMOFF, hdr + F_CREATIONDATE, 4);
X	    copy(info + I_MTIMOFF, hdr + F_MODDATE, 4);
X	}
X    }
X    return 1;
X}
X
Xstatic int sit_valid(f)
Xstruct fileHdr f;
X{
X    int fr = f.compRMethod, fd = f.compDMethod;
X
X    if(fr == sfolder || fr == efolder) {
X	return 1;
X    }
X    if((fr & prot) || (fd & prot)) {
X	(void)fprintf(stderr, "\tFile is password protected");
X#ifdef SCAN
X	do_idf("", PROTECTED);
X#endif /* SCAN */
X    } else if(fr >= prot || fd >= prot) {
X	(void)fprintf(stderr, "\tUnknown stuffit flags: %x %x", fr, fd);
X#ifdef SCAN
X	do_idf("", UNKNOWN);
X#endif /* SCAN */
X    } else if(((1 << fr) & sknown) && ((1 << fd) & sknown)) {
X	if(sit_checkm(fr) && sit_checkm(fd)) {
X	    return 1;
X	}
X	if(!sit_checkm(fr)) {
X	    (void)fprintf(stderr, "\tMethod \"%s\" not implemented",
X		    sit_methname(fr));
X	} else {
X	    (void)fprintf(stderr, "\tMethod \"%s\" not implemented",
X		    sit_methname(fd));
X	}
X#ifdef SCAN
X	do_idf("", UNKNOWN);
X#endif /* SCAN */
X    } else {
X	(void)fprintf(stderr, "\tUnknown compression methods: %x %x", fr, fd);
X#ifdef SCAN
X	do_idf("", UNKNOWN);
X#endif /* SCAN */
X    }
X    (void)fprintf(stderr, ", skipping file.\n");
X    sit_skip(f.compRLength);
X    sit_skip(f.compDLength);
X    return 0;
X}
X
Xstatic int sit_checkm(f)
Xint f;
X{
X    switch(f) {
X    case nocomp:
X	return 1;
X    case rle:
X	return 1;
X    case lzc:
X	return 1;
X    case huffman:
X	return 1;
X    case lzah:
X	return 1;
X    case fixhuf:
X	return 1;
X    case mw:
X	return 1;
X    default:
X	return 0;
X    }
X    /* NOTREACHED */
X}
X
Xstatic char *sit_methname(n)
Xint n;
X{
Xint i, nmeths;
X    nmeths = sizeof(methods) / sizeof(struct methodinfo);
X    for(i = 0; i < nmeths; i++) {
X	if(methods[i].number == n) {
X	    return methods[i].name;
X	}
X    }
X    return NULL;
X}
X
Xstatic void sit_folder(name)
Xchar *name;
X{
X    int i, recurse;
X    char loc_name[64];
X    struct fileHdr filehdr;
X
X    for(i = 0; i < 64; i++) {
X	loc_name[i] = name[i];
X    }
X    if(write_it || info_only) {
X	if(write_it) {
X	    do_mkdir(text, info);
X	}
X	indent++;
X	while(1) {
X	    if(sit_filehdr(&filehdr, 0) == -1) {
X		(void)fprintf(stderr, "Can't read file header #%d\n", i+1);
X#ifdef SCAN
X		do_error("macunpack: Can't read file header");
X#endif /* SCAN */
X		exit(1);
X	    }
X	    if(!sit_valid(filehdr)) {
X		continue;
X	    }
X	    if(filehdr.compRMethod == sfolder) {
X		sit_folder(text);
X	    } else if(filehdr.compRMethod == efolder) {
X		break;
X	    } else {
X		sit_unstuff(filehdr);
X	    }
X	}
X	if(write_it) {
X	    enddir();
X	}
X	indent--;
X	if(list) {
X	    do_indent(indent);
X	    (void)fprintf(stderr, "leaving folder \"%s\"\n", loc_name);
X	}
X    } else {
X	recurse = 0;
X	while(1) {
X	    if(sit_filehdr(&filehdr, 1) == -1) {
X		(void)fprintf(stderr, "Can't read file header #%d\n", i+1);
X#ifdef SCAN
X		do_error("macunpack: Can't read file header");
X#endif /* SCAN */
X		exit(1);
X	    }
X	    if(filehdr.compRMethod == sfolder) {
X		recurse++;
X	    } else if(filehdr.compRMethod == efolder) {
X		recurse--;
X		if(recurse < 0) {
X		    break;
X		}
X	    } else {
X		sit_skip(filehdr.compRLength);
X		sit_skip(filehdr.compDLength);
X	    }
X	}
X    }
X}
X
Xstatic void sit_unstuff(filehdr)
Xstruct fileHdr filehdr;
X{
X    unsigned long crc;
X
X    if(write_it) {
X	start_info(info, filehdr.rsrcLength, filehdr.dataLength);
X    }
X    if(verbose) {
X	(void)fprintf(stderr, "\tRsrc: ");
X    }
X    if(write_it) {
X	start_rsrc();
X    }
X    sit_wrfile(filehdr.compRLength, filehdr.rsrcLength, filehdr.compRMethod);
X    if(write_it) {
X	crc = (*updcrc)(INIT_CRC, out_buffer, filehdr.rsrcLength);
X	if(filehdr.rsrcCRC != crc) {
X	    (void)fprintf(stderr,
X		"CRC error on resource fork: need 0x%04x, got 0x%04x\n",
X		filehdr.rsrcCRC, (int)crc);
X#ifdef SCAN
X	    do_error("macunpack: CRC error on resource fork");
X#endif /* SCAN */
X	    exit(1);
X	}
X    }
X    if(verbose) {
X	(void)fprintf(stderr, ", Data: ");
X    }
X    if(write_it) {
X	start_data();
X    }
X    sit_wrfile(filehdr.compDLength, filehdr.dataLength, filehdr.compDMethod);
X    if(write_it) {
X	crc = (*updcrc)(INIT_CRC, out_buffer, filehdr.dataLength);
X	if(filehdr.dataCRC != crc) {
X	    (void)fprintf(stderr,
X		"CRC error on data fork: need 0x%04x, got 0x%04x\n",
X		filehdr.dataCRC, (int)crc);
X#ifdef SCAN
X	    do_error("macunpack: CRC error on data fork");
X#endif /* SCAN */
X	    exit(1);
X	}
X	end_file();
X    }
X    if(verbose) {
X	(void)fprintf(stderr, ".\n");
X    }
X}
X
Xstatic void sit_wrfile(ibytes, obytes, type)
Xunsigned long ibytes, obytes;
Xunsigned char type;
X{
X    if(ibytes == 0) {
X	if(verbose) {
X	    (void)fprintf(stderr, "empty");
X	}
X	return;
X    }
X    switch(type) {
X    case nocomp:		/* no compression */
X	if(verbose) {
X	    (void)fprintf(stderr, "No compression");
X	}
X	if(write_it) {
X	    sit_nocomp(ibytes);
X	} else {
X	    sit_skip(ibytes);
X	}
X	break;
X    case rle:		/* run length encoding */
X	if(verbose) {
X	    (void)fprintf(stderr,
X		    "RLE compressed (%4.1f%%)", 100.0 * ibytes / obytes);
X	}
X	if(write_it) {
X	    sit_rle(ibytes);
X	} else {
X	    sit_skip(ibytes);
X	}
X	break;
X    case lzc:			/* LZC compression */
X	if(verbose) {
X	    (void)fprintf(stderr,
X		    "LZC compressed (%4.1f%%)", 100.0 * ibytes / obytes);
X	}
X	if(write_it) {
X	    sit_lzc(ibytes);
X	} else {
X	    sit_skip(ibytes);
X	}
X	break;
X    case huffman:		/* Huffman compression */
X	if(verbose) {
X	    (void)fprintf(stderr,
X		    "Huffman compressed (%4.1f%%)", 100.0 * ibytes / obytes);
X	}
X	if(write_it) {
X	    sit_huffman(obytes);
X	} else {
X	    sit_skip(ibytes);
X	}
X	break;
X    case lzah:			/* LZAH compression */
X	if(verbose) {
X	    (void)fprintf(stderr,
X		    "LZAH compressed (%4.1f%%)", 100.0 * ibytes / obytes);
X	}
X	if(write_it) {
X	    sit_lzah(obytes);
X	} else {
X	    sit_skip(ibytes);
X	}
X	break;
X    case fixhuf:		/* FixHuf compression */
X	if(verbose) {
X	    (void)fprintf(stderr,
X		    "FixHuf compressed (%4.1f%%)", 100.0 * ibytes / obytes);
X	}
X	if(write_it) {
X	    sit_fixhuf(ibytes);
X	} else {
X	    sit_skip(ibytes);
X	}
X	break;
X    case mw:			/* MW compression */
X	if(verbose) {
X	    (void)fprintf(stderr,
X		    "MW compressed (%4.1f%%)", 100.0 * ibytes / obytes);
X	}
X	if(write_it) {
X	    sit_mw(ibytes);
X	} else {
X	    sit_skip(ibytes);
X	}
X	break;
X    default:
X	(void)fprintf(stderr, "Unknown compression method %2x\n", type);
X#ifdef SCAN
X	do_idf("", UNKNOWN);
X#endif /* SCAN */
X	exit(1);
X    }
X}
X
X/* skip stuffit file */
Xstatic void sit_skip(ibytes)
Xunsigned long ibytes;
X{
X    while(ibytes != 0) {
X	if(getc(infp) == EOF) {
X	    (void)fprintf(stderr, "Premature EOF\n");
X#ifdef SCAN
X	    do_error("macunpack: Premature EOF");
X#endif /* SCAN */
X	    exit(1);
X	}
X	ibytes--;
X    }
X}
X
X/*---------------------------------------------------------------------------*/
X/*	Method 0: No compression					     */
X/*---------------------------------------------------------------------------*/
Xstatic void sit_nocomp(ibytes)
Xunsigned long ibytes;
X{
X    int n;
X
X    n = fread(out_buffer, 1, (int)ibytes, infp);
X    if(n != ibytes) {
X	(void)fprintf(stderr, "Premature EOF\n");
X#ifdef SCAN
X	do_error("macunpack: Premature EOF");
X#endif /* SCAN */
X	exit(1);
X    }
X}
X
X/*---------------------------------------------------------------------------*/
X/*	Method 1: Run length encoding					     */
X/*---------------------------------------------------------------------------*/
Xstatic void sit_rle(ibytes)
Xunsigned long ibytes;
X{
X    int ch, lastch, n, i;
X
X    while(ibytes != 0) {
X	ch = getb(infp) & BYTEMASK;
X	ibytes--;
X	if(ch == ESC) {
X	    n = (getb(infp) & BYTEMASK) - 1;
X	    ibytes--;
X	    if(n < 0) {
X		*out_ptr++ = ESC;
X		lastch = ESC;
X		n = 1;
X	    } else {
X		for(i = 0; i < n; i++) {
X		    *out_ptr++ = lastch;
X		}
X	    }
X	} else {
X	    *out_ptr++ = ch;
X	    lastch = ch;
X	}
X    }
X}
X
X/*---------------------------------------------------------------------------*/
X/*	Method 2: LZC compressed					     */
X/*---------------------------------------------------------------------------*/
Xstatic void sit_lzc(ibytes)
Xunsigned long ibytes;
X{
X    de_compress(ibytes, 14);
X}
X
X/*---------------------------------------------------------------------------*/
X/*	Method 3: Huffman compressed					     */
X/*---------------------------------------------------------------------------*/
Xstatic void sit_huffman(obytes)
Xunsigned long obytes;
X{
X    read_tree();
X    de_huffman(obytes);
X}
X
X/*---------------------------------------------------------------------------*/
X/*	Method 5: LZ compression plus adaptive Huffman encoding		     */
X/*---------------------------------------------------------------------------*/
Xstatic void sit_lzah(obytes)
Xunsigned long obytes;
X{
X    lzah_getbyte = sit_getbyte;
X    de_lzah(obytes);
X}
X
Xstatic unsigned char sit_getbyte()
X{
X    return getb(infp);
X}
X
X/*---------------------------------------------------------------------------*/
X/*	Method 6: Compression with a fixed Huffman encoding		     */
X/*---------------------------------------------------------------------------*/
Xstatic void sit_fixhuf(ibytes)
Xunsigned long ibytes;
X{
X    int i, sum, codes, sym, num;
X    char byte_int[4], byte_short[2];
X    long size;
X    int sign;
X    char *tmp_ptr, *ptr, *end_ptr;
X
X    sum = 0;
X    for(i = 0; i < 258; i++) {
X	sum += code6[i];
X	nodelist[i + 1].flag = 1;
X    }
X    sit_nodeptr = 258;
X    sit_dosplit(0, sum, 1, 258);
X    while(ibytes > 0) {
X	if(fread(byte_int, 1, 4, infp) != 4) {
X	    (void)fprintf(stderr, "Premature EOF\n");
X#ifdef SCAN
X	    do_error("Premature EOF");
X#endif /* SCAN */
X	    exit(1);
X	}
X	ibytes -= 4;
X	size = (long)get4(byte_int);
X	sign = 0;
X	if(size < 0) {
X	    size = - size;
X	    sign = 1;
X	}
X	size -= 4;
X	if(sign) {
X	    ibytes -= size;
X	    if(fread(sit_buffer, 1, (int)size, infp) != size) {
X		(void)fprintf(stderr, "Premature EOF\n");
X#ifdef SCAN
X		do_error("Premature EOF");
X#endif /* SCAN */
X		exit(1);
X	    }
X	} else {
X	    ibytes -= size;
X	    if(fread(byte_int, 1, 4, infp) != 4) {
X		(void)fprintf(stderr, "Premature EOF\n");
X#ifdef SCAN
X		do_error("Premature EOF");
X#endif /* SCAN */
X		exit(1);
X	    }
X	    size -= 4;
X	    if(fread(byte_short, 1, 2, infp) != 2) {
X		(void)fprintf(stderr, "Premature EOF\n");
X#ifdef SCAN
X		do_error("Premature EOF");
X#endif /* SCAN */
X		exit(1);
X	    }
X	    size -= 2;
X	    codes = get2(byte_short);
X	    for(i = 1; i <= codes; i++) {
X		nodelist[i].byte = getb(infp);
X	    }
X	    size -= codes;
X	    clrhuff();
X	    nodelist[257].byte = 0x100;
X	    nodelist[258].byte = 0x100;
X	    tmp_ptr = out_ptr;
X	    out_ptr = &(sit_buffer[0]);
X	    bytesread = 0;
X	    de_huffman_end(0x100);
X	    while(bytesread < size) {
X		(void)getb(infp);
X		bytesread++;
X	    }
X	    size = get4(byte_int);
X	    out_ptr = tmp_ptr;
X	}
X	ptr = sit_buffer;
X	end_ptr = ptr + size;
X	while(ptr < end_ptr) {
X	    num = *ptr++ & BYTEMASK;
X	    if(num < 0x80) {
X		while(num-- >= 0) {
X		    *out_ptr++ = *ptr++;
X		}
X	    } else if(num != 0x80) {
X		sym = *ptr++;
X		while(num++ <= 0x100) {
X		    *out_ptr++ = sym;
X		}
X	    }
X	}
X    }
X}
X
Xstatic void sit_dosplit(ptr, sum, low, upp)
Xint ptr, sum, low, upp;
X{
X    int i, locsum;
X
X    sum = sum / 2;
X    locsum = 0;
X    i = low;
X    while(locsum < sum) {
X	locsum += code6[i++ - 1];
X    }
X    if(low == i - 1) {
X	nodelist[ptr].zero = nodelist + low;
X    } else {
X	nodelist[ptr].zero = nodelist + ++sit_nodeptr;
X	sit_dosplit(sit_nodeptr, sum, low, i - 1);
X    }
X    if(upp == i) {
X	nodelist[ptr].one = nodelist + upp;
X    } else {
X	nodelist[ptr].one = nodelist + ++sit_nodeptr;
X	sit_dosplit(sit_nodeptr, sum, i, upp);
X    }
X}
X
X/*---------------------------------------------------------------------------*/
X/*	Method 8: Compression with a MW encoding			     */
X/*---------------------------------------------------------------------------*/
Xstatic void sit_mw(ibytes)
Xunsigned long ibytes;
X{
X    int ptr;
X    int max, max1, bits;
X    char *out_buf;
X
X    out_buf = out_buffer;
X    sit_bits_avail = 0;
X    sit_avail = 0;
Xstart_over:
X    max = 256;
X    max1 = max + max;
X    bits = 9;
X    ptr = sit_mw_in(bits, &ibytes);
X    if(ptr == max) {
X	goto start_over;
X    }
X    if(ptr > max || ptr < 0) {
X	out_buffer = out_buf;
X	return;
X    }
X    sit_dict[255] = ptr;
X    sit_mw_out(ptr);
X    while(1) {
X	ptr = sit_mw_in(bits, &ibytes);
X	if(ptr == max) {
X	    goto start_over;
X	}
X	if(ptr > max || ptr < 0) {
X	    out_buffer = out_buf;
X	    return;
X	}
X	sit_dict[max++] = ptr;
X	if(max == max1) {
X	    max1 <<= 1;
X	    bits++;
X	}
X	sit_mw_out(ptr);
X    }
X}
X
Xstatic void sit_mw_out(ptr)
Xint ptr;
X{
X    int stack_ptr;
X    int stack[16384];
X
X    stack_ptr = 1;
X    stack[0] = ptr;
X    while(stack_ptr) {
X	ptr = stack[--stack_ptr];
X	while(ptr >= 256) {
X	    stack[stack_ptr++] = sit_dict[ptr];
X	    ptr = sit_dict[ptr - 1];
X	}
X	*out_buffer++ = ptr;
X    }
X}
X
Xstatic int sit_mw_in(bits, ibytes)
Xint bits;
Xunsigned long *ibytes;
X{
X    int res, res1;
X
X    while(bits > sit_bits_avail) {
X	if(*ibytes == 0) {
X	    return -1;
X	}
X	(*ibytes)--;
X	sit_avail += (getb(infp) & BYTEMASK) << sit_bits_avail;
X	sit_bits_avail += 8;
X    }
X    res1 = sit_avail >> bits;
X    res = sit_avail ^ (res1 << bits);
X    sit_avail = res1;
X    sit_bits_avail -= bits;
X    return res;
X}
X
X#else /* SIT */
Xint sit; /* keep lint and some compilers happy */
X#endif /* SIT */
SHAR_EOF
if test 19518 -ne "`wc -c < 'sit.c'`"
then
	echo shar: "error transmitting 'sit.c'" '(should have been 19518 characters)'
fi
fi
echo shar: "extracting 'lzc.h'" '(599 characters)'
if test -f 'lzc.h'
then
	echo shar: "will not over-write existing file 'lzc.h'"
else
sed 's/^X//' << \SHAR_EOF > 'lzc.h'
X#define HEADERBYTES 48
X#define MAGIC1	"\253\315\000\060"
X#define MAGIC2	"\037\235"
X
X#define C_DLENOFF	4
X#define C_DLENOFFC	8
X#define C_RLENOFF	12
X#define C_RLENOFFC	16
X#define C_MTIMOFF	24
X#define C_CTIMOFF	28
X#define C_TYPEOFF	32
X#define C_AUTHOFF	36
X#define C_FLAGOFF	40
X
Xtypedef struct fileHdr {
X	unsigned long	magic1;
X	unsigned long	dataLength;
X	unsigned long	dataCLength;
X	unsigned long	rsrcLength;
X	unsigned long	rsrcCLength;
X	unsigned long	unknown1;
X	unsigned long	mtime;
X	unsigned long	ctime;
X	unsigned long	filetype;
X	unsigned long	fileauth;
X	unsigned long	flag1;
X	unsigned long	flag2;
X};
X
SHAR_EOF
if test 599 -ne "`wc -c < 'lzc.h'`"
then
	echo shar: "error transmitting 'lzc.h'" '(should have been 599 characters)'
fi
fi
echo shar: "extracting 'mcb.c'" '(2591 characters)'
if test -f 'mcb.c'
then
	echo shar: "will not over-write existing file 'mcb.c'"
else
sed 's/^X//' << \SHAR_EOF > 'mcb.c'
X#include "globals.h"
X#include "../fileio/machdr.h"
X#include "../fileio/wrfile.h"
X#include "../util/masks.h"
X#include "../util/util.h"
X
Xstatic int mcb_read;
X
Xstatic void mcb_wrfile();
X
Xvoid mcb(hdr, rsrcLength, dataLength, toread)
Xchar *hdr;
Xunsigned long rsrcLength, dataLength;
Xint toread;
X{
X    register int i;
X    int n;
X    char ftype[5], fauth[5];
X
X    mcb_read = toread;
X    for(i = 0; i < INFOBYTES; i++) {
X	info[i] = hdr[i];
X    }
X
X    n = hdr[I_NAMEOFF] & BYTEMASK;
X    if(n > F_NAMELEN) {
X	n = F_NAMELEN;
X    }
X    info[I_NAMEOFF] = n;
X    transname(hdr + I_NAMEOFF + 1, text, n);
X    if(hdr[I_LOCKOFF] & 1) {
X	hdr[I_FLAGOFF + 1] = PROTCT_MASK;
X	hdr[I_LOCKOFF] &= ~1;
X    }
X
X    write_it = 1;
X    if(list) {
X	transname(hdr + I_TYPEOFF, ftype, 4);
X	transname(hdr + I_AUTHOFF, fauth, 4);
X	do_indent(indent);
X	(void)fprintf(stderr,
X		"name=\"%s\", type=%4.4s, author=%4.4s, data=%ld, rsrc=%ld",
X		text, ftype, fauth, (long)dataLength, (long)rsrcLength);
X	if(info_only) {
X	    write_it = 0;
X	}
X	if(query) {
X	    write_it = do_query();
X	} else {
X	    (void)fputc('\n', stderr);
X	}
X    }
X
X    if(write_it) {
X	define_name(text);
X    }
X    if(write_it) {
X	start_info(info, rsrcLength, dataLength);
X    }
X    if(verbose) {
X	(void)fprintf(stderr, "\tData: ");
X    }
X    if(write_it) {
X	start_data();
X    }
X    mcb_wrfile(dataLength);
X    if(verbose) {
X	(void)fprintf(stderr, ", Rsrc: ");
X    }
X    if(write_it) {
X	start_rsrc();
X    }
X    mcb_wrfile(rsrcLength);
X    if(write_it) {
X	end_file();
X    }
X    if(verbose) {
X	(void)fprintf(stderr, ".\n");
X    }
X}
X
Xstatic void mcb_wrfile(ibytes)
Xunsigned long ibytes;
X{
X    int n;
X
X    if(ibytes == 0) {
X	if(verbose) {
X	    (void)fprintf(stderr, "empty");
X	}
X	return;
X    }
X    if(verbose) {
X	(void)fprintf(stderr, "No compression");
X    }
X    if(write_it) {
X	n = fread(out_buffer, 1, (int)ibytes, infp);
X	if(n != ibytes) {
X	    (void)fprintf(stderr, "Premature EOF\n");
X#ifdef SCAN
X	    do_error("macunpack: Premature EOF");
X#endif /* SCAN */
X	    exit(1);
X	}
X	mcb_read -= n;
X	n = ((n + 127) / 128) * 128 - n;
X	if(n > mcb_read) {
X	    n = mcb_read;
X	}
X	mcb_read -= n;
X	while(n-- > 0) {
X	    if(getc(infp) == EOF) {
X		(void)fprintf(stderr, "Premature EOF\n");
X#ifdef SCAN
X		do_error("macunpack: Premature EOF");
X#endif /* SCAN */
X		exit(1);
X	    }
X	}
X    } else {
X	n = ((ibytes + 127) / 128) * 128;
X	if(n > mcb_read) {
X	    n = mcb_read;
X	}
X	mcb_read -= n;
X	while(n-- > 0) {
X	    if(getc(infp) == EOF) {
X		(void)fprintf(stderr, "Premature EOF\n");
X#ifdef SCAN
X		do_error("macunpack: Premature EOF");
X#endif /* SCAN */
X		exit(1);
X	    }
X	}
X    }
X}
X
SHAR_EOF
if test 2591 -ne "`wc -c < 'mcb.c'`"
then
	echo shar: "error transmitting 'mcb.c'" '(should have been 2591 characters)'
fi
fi
echo shar: "extracting 'makefile'" '(4554 characters)'
if test -f 'makefile'
then
	echo shar: "will not over-write existing file 'makefile'"
else
sed 's/^X//' << \SHAR_EOF > 'makefile'
XCFLAGS = -O $(CF)
X
XSRCS =	macunpack.c \
X	globals.c \
X	macbinary.c \
X	dir.c \
X	mcb.c \
X	bin.c \
X	jdw.c \
X	stf.c \
X	lzc.c \
X	pit.c \
X	sit.c \
X	dia.c \
X	cpt.c \
X	zma.c \
X	lzh.c \
X	dd.c \
X	de_huffman.c \
X	de_compress.c \
X	de_lzah.c \
X	de_lzh.c \
X	crc.c \
X	bits_be.c
X
XOBJS =	macunpack.o \
X	globals.o \
X	macbinary.o \
X	dir.o \
X	mcb.o \
X	bin.o \
X	jdw.o \
X	stf.o \
X	lzc.o \
X	pit.o \
X	sit.o \
X	dia.o \
X	cpt.o \
X	zma.o \
X	lzh.o \
X	dd.o \
X	de_huffman.o \
X	de_compress.o \
X	de_lzah.o \
X	de_lzh.o \
X	crc.o \
X	bits_be.o
X
XLIB =	../crc/libcrc.a
XTNAME =	../util/transname
XUNAME =	../util/util
XONAME =	../fileio/wrfile
XGNAME =	../fileio/fileglob
XXOBJS =	$(TNAME).o $(UNAME).o $(ONAME).o $(GNAME).o
XXSRCS =	$(TNAME).c $(UNAME).c $(ONAME).c $(GNAME).c
XCRCS =	../crc/arc.c ../crc/binhex.c ../crc/zip.c
X
Xmacunpack:	$(OBJS) $(LIB) $(XOBJS)
X	$(CC) $(CFLAGS) -o macunpack $(OBJS) $(XOBJS) $(LIB)
X
X$(LIB):	../crc/makecrc.c
X	(cd ../crc; make CC=$(CC) CF="$(CF)" )
X
X$(TNAME).o:	$(TNAME).c
X	(cd ../util; make CC=$(CC) CF="$(CF)" )
X
X$(UNAME).o:	$(UNAME).c
X	(cd ../util; make CC=$(CC) CF="$(CF)" )
X
X$(ONAME).o:	$(ONAME).c
X	(cd ../fileio; make CC=$(CC) CF="$(CF)" )
X
X$(GNAME).o:	$(GNAME).c
X	(cd ../fileio; make CC=$(CC) CF="$(CF)" )
X
Xlint:
X	lint $(CF) $(LFLAGS) $(SRCS) $(XSRCS) $(CRCS)
X
Xclean:
X	-rm -f *.o
X
Xclobber:clean
X	-rm -f macunpack
X
Xmacunpack.o:	macunpack.h
Xmacunpack.o:	globals.h
Xmacunpack.o:	../util/patchlevel.h
Xmacunpack.o:	../fileio/wrfile.h
Xmacunpack.o:	../fileio/wrfileopt.h
Xmacunpack.o:	../fileio/kind.h
Xmacunpack.o:	../util/util.h
Xglobals.o:	globals.h
Xglobals.o:	../fileio/machdr.h
Xglobals.o:	../fileio/wrfile.h
Xglobals.o:	../fileio/kind.h
Xmacbinary.o:	macunpack.h
Xmacbinary.o:	globals.h
Xmacbinary.o:	zmahdr.h
Xmacbinary.o:	../fileio/machdr.h
Xmacbinary.o:	../fileio/wrfile.h
Xmacbinary.o:	../fileio/kind.h
Xmacbinary.o:	../util/util.h
Xdir.o:	globals.h
Xdir.o:	../fileio/machdr.h
Xdir.o:	../fileio/wrfile.h
Xdir.o:	../util/util.h
Xdir.o:	../util/masks.h
Xmcb.o:	globals.h
Xmcb.o:	../fileio/machdr.h
Xmcb.o:	../fileio/wrfile.h
Xmcb.o:	../util/masks.h
Xmcb.o:	../util/util.h
Xbin.o:	macunpack.h
Xbin.o:	globals.h
Xbin.o:	../fileio/machdr.h
Xbin.o:	../fileio/wrfile.h
Xbin.o:	../fileio/kind.h
Xbin.o:	../util/util.h
Xbin.o:	../util/masks.h
Xjdw.o:	macunpack.h
Xjdw.o:	jdw.h
Xjdw.o:	globals.h
Xjdw.o:	huffman.h
Xjdw.o:	../fileio/wrfile.h
Xjdw.o:	../fileio/machdr.h
Xjdw.o:	../util/util.h
Xjdw.o:	../util/masks.h
Xstf.o:	macunpack.h
Xstf.o:	stf.h
Xstf.o:	globals.h
Xstf.o:	huffman.h
Xstf.o:	../util/curtime.h
Xstf.o:	../fileio/wrfile.h
Xstf.o:	../fileio/machdr.h
Xstf.o:	../util/util.h
Xlzc.o:	macunpack.h
Xlzc.o:	globals.h
Xlzc.o:	lzc.h
Xlzc.o:	../util/util.h
Xlzc.o:	../fileio/machdr.h
Xlzc.o:	../fileio/wrfile.h
Xlzc.o:	../util/masks.h
Xpit.o:	macunpack.h
Xpit.o:	../fileio/fileglob.h
Xpit.o:	../fileio/wrfile.h
Xpit.o:	../fileio/kind.h
Xpit.o:	globals.h
Xpit.o:	pit.h
Xpit.o:	../fileio/machdr.h
Xpit.o:	crc.h
Xpit.o:	../util/masks.h
Xpit.o:	../util/util.h
Xpit.o:	huffman.h
Xsit.o:	macunpack.h
Xsit.o:	globals.h
Xsit.o:	sit.h
Xsit.o:	crc.h
Xsit.o:	../util/util.h
Xsit.o:	../fileio/machdr.h
Xsit.o:	../fileio/wrfile.h
Xsit.o:	../fileio/kind.h
Xsit.o:	../util/masks.h
Xsit.o:	huffman.h
Xdia.o:	macunpack.h
Xdia.o:	globals.h
Xdia.o:	dia.h
Xdia.o:	../util/curtime.h
Xdia.o:	../util/masks.h
Xdia.o:	../fileio/machdr.h
Xdia.o:	../fileio/wrfile.h
Xdia.o:	../fileio/kind.h
Xdia.o:	../util/util.h
Xcpt.o:	macunpack.h
Xcpt.o:	globals.h
Xcpt.o:	cpt.h
Xcpt.o:	crc.h
Xcpt.o:	../util/util.h
Xcpt.o:	../fileio/machdr.h
Xcpt.o:	../fileio/wrfile.h
Xcpt.o:	../fileio/kind.h
Xcpt.o:	../util/masks.h
Xcpt.o:	huffman.h
Xzma.o:	macunpack.h
Xzma.o:	globals.h
Xzma.o:	zma.h
Xzma.o:	crc.h
Xzma.o:	../fileio/machdr.h
Xzma.o:	../fileio/wrfile.h
Xzma.o:	../fileio/kind.h
Xzma.o:	../util/masks.h
Xzma.o:	../util/util.h
Xlzh.o:	macunpack.h
Xlzh.o:	globals.h
Xlzh.o:	lzh.h
Xlzh.o:	crc.h
Xlzh.o:	../fileio/wrfile.h
Xlzh.o:	../fileio/machdr.h
Xlzh.o:	../util/masks.h
Xlzh.o:	../util/util.h
Xlzh.o:	bits_be.h
Xdd.o:	macunpack.h
Xdd.o:	globals.h
Xdd.o:	dd.h
Xdd.o:	crc.h
Xdd.o:	../fileio/machdr.h
Xdd.o:	../fileio/wrfile.h
Xdd.o:	../fileio/fileglob.h
Xdd.o:	../util/masks.h
Xdd.o:	../util/util.h
Xde_huffman.o:	macunpack.h
Xde_huffman.o:	globals.h
Xde_huffman.o:	../util/masks.h
Xde_huffman.o:	huffman.h
Xde_huffman.o:	../fileio/wrfile.h
Xde_huffman.o:	../util/util.h
Xde_compress.o:	macunpack.h
Xde_compress.o:	globals.h
Xde_compress.o:	../fileio/wrfile.h
Xde_lzah.o:	macunpack.h
Xde_lzah.o:	globals.h
Xde_lzah.o:	../util/masks.h
Xde_lzah.o:	../fileio/wrfile.h
Xde_lzh.o:	macunpack.h
Xde_lzh.o:	globals.h
Xde_lzh.o:	../util/masks.h
Xde_lzh.o:	../fileio/wrfile.h
Xde_lzh.o:	bits_be.h
Xbits_be.o:	../util/masks.h
Xbits_be.o:	bits_be.h
X
SHAR_EOF
if test 4554 -ne "`wc -c < 'makefile'`"
then
	echo shar: "error transmitting 'makefile'" '(should have been 4554 characters)'
fi
fi
echo shar: "extracting 'cpt.c'" '(17640 characters)'
if test -f 'cpt.c'
then
	echo shar: "will not over-write existing file 'cpt.c'"
else
sed 's/^X//' << \SHAR_EOF > 'cpt.c'
X#include "macunpack.h"
X#ifdef DD
X#ifndef CPT
X#define CPT
X#endif /* CPT */
X#endif /* DD */
X#ifdef CPT
X#include "globals.h"
X#include "cpt.h"
X#include "crc.h"
X#include "../util/util.h"
X#include "../fileio/machdr.h"
X#include "../fileio/wrfile.h"
X#include "../fileio/kind.h"
X#include "../util/masks.h"
X#include "huffman.h"
X
X#define	ESC1		0x81
X#define	ESC2		0x82
X#define NONESEEN	0
X#define ESC1SEEN	1
X#define ESC2SEEN	2
X
Xextern char *malloc();
Xextern char *realloc();
Xextern int free();
X
Xstatic void cpt_uncompact();
Xstatic unsigned char *cpt_data;
Xstatic unsigned long cpt_datamax;
Xstatic unsigned long cpt_datasize;
Xstatic unsigned char cpt_LZbuff[CIRCSIZE];
Xstatic unsigned int cpt_LZptr;
Xstatic unsigned char *cpt_char;
Xstatic unsigned long cpt_crc;
Xstatic unsigned long cpt_inlength;
Xstatic unsigned long cpt_outlength;
Xstatic int cpt_outstat;
Xstatic unsigned char cpt_savechar;
Xstatic unsigned long cpt_newbits;
Xstatic int cpt_bitsavail;
Xstatic int cpt_blocksize;
X/* Lengths is twice the max number of entries, and include slack. */
X#define SLACK	6
Xstatic node cpt_Hufftree[512 + SLACK], cpt_LZlength[128 + SLACK],
X	    cpt_LZoffs[256 + SLACK];
X
Xstatic int readcpthdr();
Xstatic int cpt_filehdr();
Xstatic void cpt_folder();
Xstatic void cpt_uncompact();
Xstatic void cpt_wrfile();
Xvoid cpt_wrfile1();
Xstatic void cpt_outch();
Xstatic void cpt_rle();
Xstatic void cpt_rle_lzh();
Xstatic void cpt_readHuff();
Xstatic int cpt_get6bits();
Xstatic int cpt_getbit();
X
Xvoid cpt()
X{
X    struct cptHdr cpthdr;
X    struct fileHdr filehdr;
X    char *cptindex;
X    char *cptptr;
X    int i;
X
X    updcrc = zip_updcrc;
X    crcinit = zip_crcinit;
X    cpt_crc = INIT_CRC;
X    if(readcpthdr(&cpthdr) == 0) {
X	(void)fprintf(stderr, "Can't read archive header\n");
X#ifdef SCAN
X	do_error("macunpack: Can't read archive header");
X#endif /* SCAN */
X	exit(1);
X    }
X
X    cptindex = malloc((unsigned)(cpthdr.entries * FILEHDRSIZE));
X    if(cptindex == NULL) {
X	(void)fprintf(stderr, "Insufficient memory, aborting\n");
X	exit(1);
X    }
X    cptptr = cptindex;
X    if(fread(cptptr, 1, (int)cpthdr.commentsize, infp) != cpthdr.commentsize) {
X	(void)fprintf(stderr, "Can't read comment.\n");
X#ifdef SCAN
X	do_error("macunpack: Can't read comment");
X#endif /* SCAN */
X	exit(1);
X    }
X    cpt_crc = (*updcrc)(cpt_crc, cptptr, cpthdr.commentsize);
X
X    for(i = 0; i < cpthdr.entries; i++) {
X	*cptptr = getc(infp);
X	cpt_crc = (*updcrc)(cpt_crc, cptptr, 1);
X	if(*cptptr & 0x80) {
X	    cptptr[F_FOLDER] = 1;
X	    *cptptr &= 0x3f;
X	} else {
X	    cptptr[F_FOLDER] = 0;
X	}
X	if(fread(cptptr + 1, 1, *cptptr, infp) != *cptptr) {
X	    (void)fprintf(stderr, "Can't read file header #%d\n", i+1);
X#ifdef SCAN
X	    do_error("macunpack: Can't read file header");
X#endif /* SCAN */
X	    exit(1);
X	}
X	cpt_crc = (*updcrc)(cpt_crc, cptptr + 1, *cptptr);
X	if(cptptr[F_FOLDER]) {
X	    if(fread(cptptr + F_FOLDERSIZE, 1, 2, infp) != 2) {
X		(void)fprintf(stderr, "Can't read file header #%d\n", i+1);
X#ifdef SCAN
X		do_error("macunpack: Can't read file header");
X#endif /* SCAN */
X		exit(1);
X	    }
X	    cpt_crc = (*updcrc)(cpt_crc, cptptr + F_FOLDERSIZE, 2);
X	} else {
X	    if(fread(cptptr + F_VOLUME, 1, FILEHDRSIZE - F_VOLUME, infp) !=
X		FILEHDRSIZE - F_VOLUME) {
X		(void)fprintf(stderr, "Can't read file header #%d\n", i+1);
X#ifdef SCAN
X		do_error("macunpack: Can't read file header");
X#endif /* SCAN */
X		exit(1);
X	    }
X	    cpt_crc = (*updcrc)(cpt_crc, cptptr + F_VOLUME,
X				FILEHDRSIZE - F_VOLUME);
X	}
X	cptptr += FILEHDRSIZE;
X    }
X    if(cpt_crc != cpthdr.hdrcrc) {
X	(void)fprintf(stderr, "Header CRC mismatch: got 0x%08x, need 0x%08x\n",
X		(int)cpthdr.hdrcrc, (int)cpt_crc);
X#ifdef SCAN
X	do_error("macunpack: Header CRC mismatch");
X#endif /* SCAN */
X	exit(1);
X    }
X
X    cptptr = cptindex;
X    for(i = 0; i < cpthdr.entries; i++) {
X	if(cpt_filehdr(&filehdr, cptptr) == -1) {
X	    (void)fprintf(stderr, "Can't read file header #%d\n", i+1);
X#ifdef SCAN
X	    do_error("macunpack: Can't read file header");
X#endif /* SCAN */
X	    exit(1);
X	}
X	if(filehdr.folder) {
X	    cpt_folder(text, filehdr, cptptr);
X	    i += filehdr.foldersize;
X	    cptptr += filehdr.foldersize * FILEHDRSIZE;
X	} else {
X	    cpt_uncompact(filehdr);
X	}
X	cptptr += FILEHDRSIZE;
X    }
X    (void)free(cptindex);
X}
X
Xstatic int readcpthdr(s)
Xstruct cptHdr *s;
X{
X    char temp[CHDRSIZE];
X
X    if(fread(temp, 1, CPTHDRSIZE, infp) != CPTHDRSIZE) {
X	return 0;
X    }
X
X    if(temp[C_SIGNATURE] != 1) {
X	(void)fprintf(stderr, "Not a Compactor file\n");
X	return 0;
X    }
X
X    cpt_datasize = get4(temp + C_IOFFSET);
X    s->offset = cpt_datasize;
X    if(cpt_datasize > cpt_datamax) {
X	if(cpt_datamax == 0) {
X	    cpt_data = (unsigned char *)malloc((unsigned)cpt_datasize);
X	} else {
X	    cpt_data = (unsigned char *)realloc((char *)cpt_data,
X						(unsigned)cpt_datasize);
X	}
X	cpt_datamax = cpt_datasize;
X    }
X    if(cpt_data == NULL) {
X	(void)fprintf(stderr, "Insufficient memory, aborting\n");
X	exit(1);
X    }
X
X    if(fread((char *)(cpt_data + CPTHDRSIZE), 1,
X	(int)s->offset - CPTHDRSIZE, infp) != s->offset - CPTHDRSIZE) {
X	return 0;
X    }
X
X    if(fread(temp + CPTHDRSIZE, 1, CPTHDR2SIZE, infp) != CPTHDR2SIZE) {
X	return 0;
X    }
X
X    cpt_crc = (*updcrc)(cpt_crc, temp + CPTHDRSIZE + C_ENTRIES, 3);
X    s->hdrcrc = get4(temp + CPTHDRSIZE + C_HDRCRC);
X    s->entries = get2(temp + CPTHDRSIZE + C_ENTRIES);
X    s->commentsize = temp[CPTHDRSIZE + C_COMMENT];
X
X    return 1;
X}
X
Xstatic int cpt_filehdr(f, hdr)
Xstruct fileHdr *f;
Xchar *hdr;
X{
X    register int i;
X    int n;
X    char ftype[5], fauth[5];
X
X    for(i = 0; i < INFOBYTES; i++) {
X	info[i] = '\0';
X    }
X
X    n = hdr[F_FNAME] & BYTEMASK;
X    if(n > F_NAMELEN) {
X	n = F_NAMELEN;
X    }
X    info[I_NAMEOFF] = n;
X    copy(info + I_NAMEOFF + 1, hdr + F_FNAME + 1, n);
X    transname(hdr + F_FNAME + 1, text, n);
X
X    f->folder = hdr[F_FOLDER];
X    if(f->folder) {
X	f->foldersize = get2(hdr + F_FOLDERSIZE);
X    } else {
X	f->cptFlag = get2(hdr + F_CPTFLAG);
X	f->rsrcLength = get4(hdr + F_RSRCLENGTH);
X	f->dataLength = get4(hdr + F_DATALENGTH);
X	f->compRLength = get4(hdr + F_COMPRLENGTH);
X	f->compDLength = get4(hdr + F_COMPDLENGTH);
X	f->fileCRC = get4(hdr + F_FILECRC);
X	f->FndrFlags = get2(hdr + F_FNDRFLAGS);
X	f->filepos = get4(hdr + F_FILEPOS);
X	f->volume = hdr[F_VOLUME];
X    }
X
X    write_it = 1;
X    if(list) {
X	do_indent(indent);
X	if(f->folder) {
X	    (void)fprintf(stderr, "folder=\"%s\"", text);
X	} else {
X	    transname(hdr + F_FTYPE, ftype, 4);
X	    transname(hdr + F_CREATOR, fauth, 4);
X	    (void)fprintf(stderr,
X		    "name=\"%s\", type=%4.4s, author=%4.4s, data=%ld, rsrc=%ld",
X		    text, ftype, fauth,
X		    (long)f->dataLength, (long)f->rsrcLength);
X	}
X	if(info_only) {
X	    write_it = 0;
X	}
X	if(query) {
X	    write_it = do_query();
X	} else {
X	    (void)fputc('\n', stderr);
X	}
X    }
X
X
X    if(write_it) {
X	define_name(text);
X
X	if(!f->folder) {
X	    copy(info + I_TYPEOFF, hdr + F_FTYPE, 4);
X	    copy(info + I_AUTHOFF, hdr + F_CREATOR, 4);
X	    copy(info + I_FLAGOFF, hdr + F_FNDRFLAGS, 2);
X	    copy(info + I_DLENOFF, hdr + F_DATALENGTH, 4);
X	    copy(info + I_RLENOFF, hdr + F_RSRCLENGTH, 4);
X	    copy(info + I_CTIMOFF, hdr + F_CREATIONDATE, 4);
X	    copy(info + I_MTIMOFF, hdr + F_MODDATE, 4);
X	}
X    }
X    return 1;
X}
X
Xstatic void cpt_folder(name, fileh, cptptr)
Xchar *name;
Xstruct fileHdr fileh;
Xchar *cptptr;
X{
X    int i, nfiles;
X    char loc_name[64];
X    struct fileHdr filehdr;
X
X    for(i = 0; i < 64; i++) {
X	loc_name[i] = name[i];
X    }
X    if(write_it || info_only) {
X	cptptr += FILEHDRSIZE;
X	nfiles = fileh.foldersize;
X	if(write_it) {
X	    do_mkdir(text, info);
X	}
X	indent++;
X	for(i = 0; i < nfiles; i++) {
X	    if(cpt_filehdr(&filehdr, cptptr) == -1) {
X		(void)fprintf(stderr, "Can't read file header #%d\n", i+1);
X#ifdef SCAN
X		do_error("macunpack: Can't read file header");
X#endif /* SCAN */
X		exit(1);
X	    }
X	    if(filehdr.folder) {
X		cpt_folder(text, filehdr, cptptr);
X		i += filehdr.foldersize;
X		cptptr += filehdr.foldersize * FILEHDRSIZE;
X	    } else {
X		cpt_uncompact(filehdr);
X	    }
X	    cptptr += FILEHDRSIZE;
X	}
X	if(write_it) {
X	    enddir();
X	}
X	indent--;
X	if(list) {
X	    do_indent(indent);
X	    (void)fprintf(stderr, "leaving folder \"%s\"\n", loc_name);
X	}
X    }
X}
X
Xstatic void cpt_uncompact(filehdr)
Xstruct fileHdr filehdr;
X{
X    if(filehdr.cptFlag & 1) {
X	(void)fprintf(stderr, "\tFile is password protected, skipping file\n");
X#ifdef SCAN
X	do_idf("", PROTECTED);
X#endif /* SCAN */
X	return;
X    }
X    if(write_it) {
X	start_info(info, filehdr.rsrcLength, filehdr.dataLength);
X	cpt_crc = INIT_CRC;
X	cpt_char = cpt_data + filehdr.filepos;
X    }
X    if(verbose) {
X	(void)fprintf(stderr, "\tRsrc: ");
X	if(filehdr.compRLength == 0) {
X	    (void)fprintf(stderr, "empty");
X	} else if(filehdr.cptFlag & 2) {
X	    (void)fprintf(stderr, "RLE/LZH compressed (%4.1f%%)",
X		    100.0 * filehdr.compRLength / filehdr.rsrcLength);
X	} else {
X	    (void)fprintf(stderr, "RLE compressed (%4.1f%%)",
X		    100.0 * filehdr.compRLength / filehdr.rsrcLength);
X	}
X    }
X    if(write_it) {
X	start_rsrc();
X	cpt_wrfile(filehdr.compRLength, filehdr.rsrcLength,
X		   filehdr.cptFlag & 2);
X	cpt_char = cpt_data + filehdr.filepos + filehdr.compRLength;
X    }
X    if(verbose) {
X	(void)fprintf(stderr, ", Data: ");
X	if(filehdr.compDLength == 0) {
X	    (void)fprintf(stderr, "empty");
X	} else if(filehdr.cptFlag & 4) {
X	    (void)fprintf(stderr, "RLE/LZH compressed (%4.1f%%)",
X		    100.0 * filehdr.compDLength / filehdr.dataLength);
X	} else {
X	    (void)fprintf(stderr, "RLE compressed (%4.1f%%)",
X		    100.0 * filehdr.compDLength / filehdr.dataLength);
X	}
X    }
X    if(write_it) {
X	start_data();
X	cpt_wrfile(filehdr.compDLength, filehdr.dataLength,
X		   filehdr.cptFlag & 4);
X	if(filehdr.fileCRC != cpt_crc) {
X	    (void)fprintf(stderr,
X		"CRC error on file: need 0x%08lx, got 0x%08lx\n",
X		(long)filehdr.fileCRC, (long)cpt_crc);
X#ifdef SCAN
X	    do_error("macunpack: CRC error on file");
X#endif /* SCAN */
X	    exit(1);
X	}
X	end_file();
X    }
X    if(verbose) {
X	(void)fprintf(stderr, ".\n");
X    }
X}
X
Xstatic void cpt_wrfile(ibytes, obytes, type)
Xunsigned long ibytes, obytes;
Xunsigned short type;
X{
X    if(ibytes == 0) {
X	return;
X    }
X    cpt_outstat = NONESEEN;
X    cpt_inlength = ibytes;
X    cpt_outlength = obytes;
X    cpt_LZptr = 0;
X    cpt_blocksize = 0x1fff0;
X    if(type == 0) {
X	cpt_rle();
X    } else {
X	cpt_rle_lzh();
X    }
X    cpt_crc = (*updcrc)(cpt_crc, out_buffer, obytes);
X}
X
Xvoid cpt_wrfile1(in_char, ibytes, obytes, type, blocksize)
Xunsigned char *in_char;
Xunsigned long ibytes, obytes, blocksize;
Xint type;
X{
X    cpt_char = in_char;
X    if(ibytes == 0) {
X	return;
X    }
X    cpt_outstat = NONESEEN;
X    cpt_inlength = ibytes;
X    cpt_outlength = obytes;
X    cpt_LZptr = 0;
X    cpt_blocksize = blocksize;
X    if(type == 0) {
X	cpt_rle();
X    } else {
X	cpt_rle_lzh();
X    }
X}
X
Xstatic void cpt_outch(ch)
Xunsigned char ch;
X{
X    cpt_LZbuff[cpt_LZptr++ & (CIRCSIZE - 1)] = ch;
X    switch(cpt_outstat) {
X    case NONESEEN:
X	if(ch == ESC1 && cpt_outlength != 1) {
X	    cpt_outstat = ESC1SEEN;
X	} else {
X	    cpt_savechar = ch;
X	    *out_ptr++ = ch;
X	    cpt_outlength--;
X	}
X	break;
X    case ESC1SEEN:
X	if(ch == ESC2) {
X	    cpt_outstat = ESC2SEEN;
X	} else {
X	    cpt_savechar = ESC1;
X	    *out_ptr++ = ESC1;
X	    cpt_outlength--;
X	    if(cpt_outlength == 0) {
X		return;
X	    }
X	    if(ch == ESC1 && cpt_outlength != 1) {
X		return;
X	    }
X	    cpt_outstat = NONESEEN;
X	    cpt_savechar = ch;
X	    *out_ptr++ = ch;
X	    cpt_outlength--;
X	}
X	break;
X    case ESC2SEEN:
X	cpt_outstat = NONESEEN;
X	if(ch != 0) {
X	    while(--ch != 0) {
X		*out_ptr++ = cpt_savechar;
X		cpt_outlength--;
X		if(cpt_outlength == 0) {
X		    return;
X		}
X	    }
X	} else {
X	    *out_ptr++ = ESC1;
X	    cpt_outlength--;
X	    if(cpt_outlength == 0) {
X		return;
X	    }
X	    cpt_savechar = ESC2;
X	    *out_ptr++ = cpt_savechar;
X	    cpt_outlength--;
X	}
X    }
X}
X
X/*---------------------------------------------------------------------------*/
X/*	Run length encoding						     */
X/*---------------------------------------------------------------------------*/
Xstatic void cpt_rle()
X{
X    while(cpt_inlength-- > 0) {
X	cpt_outch(*cpt_char++);
X    }
X}
X
X/*---------------------------------------------------------------------------*/
X/*	Run length encoding plus LZ compression plus Huffman encoding	     */
X/*---------------------------------------------------------------------------*/
Xstatic void cpt_rle_lzh()
X{
X    int block_count;
X    unsigned int bptr;
X    int Huffchar, LZlength, LZoffs;
X
X    get_bit = cpt_getbit;
X    cpt_LZbuff[CIRCSIZE - 3] = 0;
X    cpt_LZbuff[CIRCSIZE - 2] = 0;
X    cpt_LZbuff[CIRCSIZE - 1] = 0;
X    cpt_LZptr = 0;
X    while(cpt_outlength != 0) {
X	cpt_readHuff(256, cpt_Hufftree);
X	cpt_readHuff(64, cpt_LZlength);
X	cpt_readHuff(128, cpt_LZoffs);
X	block_count = 0;
X	cpt_newbits = (*cpt_char++ << 8);
X	cpt_newbits = cpt_newbits | *cpt_char++;
X	cpt_newbits = cpt_newbits << 16;
X	cpt_bitsavail = 16;
X	while(block_count < cpt_blocksize && cpt_outlength != 0) {
X	    if(cpt_getbit()) {
X		Huffchar = gethuffbyte(cpt_Hufftree);
X		cpt_outch((unsigned char)Huffchar);
X		block_count += 2;
X	    } else {
X		LZlength = gethuffbyte(cpt_LZlength);
X		LZoffs = gethuffbyte(cpt_LZoffs);
X		LZoffs = (LZoffs << 6) | cpt_get6bits();
X		bptr = cpt_LZptr - LZoffs;
X		while(LZlength-- > 0) {
X		    cpt_outch(cpt_LZbuff[bptr++ & (CIRCSIZE - 1)]);
X		}
X		block_count += 3;
X	    }
X	}
X    }
X}
X
X/* Based on unimplod from unzip; difference are noted below. */
Xtypedef struct sf_entry {
X    int Value;
X    int BitLength;
X} sf_entry;
X
X/* See routine LoadTree.  The parameter tree (actually an array and
X   two integers) are only used locally in this version and hence locally
X   declared.  The parameter nodes has been renamed Hufftree.... */
Xstatic void cpt_readHuff(size, Hufftree)
Xint size;
Xstruct node *Hufftree;
X{
X    sf_entry tree_entry[256 + SLACK]; /* maximal number of elements */
X    int tree_entries;
X    int tree_MaxLength; /* finishes local declaration of tree */
X
X    int treeBytes, i, len;  /* declarations from ReadLengths */
X
X    /* declarations from SortLengths */
X    sf_entry *ejm1;
X    int j;
X    sf_entry *entry;
X/*  int i already above */
X    sf_entry tmp;
X    int entries;
X    unsigned a, b;
X
X    /* declarations from GenerateTrees */
X    int codelen, lvlstart, next, parents;
X/*  int i, j already above */
X
X    /* for Compactor */
X    int tree_count[32];
X    /* end declarations */
X
X    /* next paraphrased from ReadLengths with adaption for Compactor. */
X    treeBytes = *cpt_char++;
X    if(size < treeBytes * 2) { /* too many entries, something is wrong! */
X	(void)fprintf(stderr, "Bytes is: %d, expected: %d\n", treeBytes,
X		size / 2);
X#ifdef SCAN
X	do_error("macunpack: error in coding tree");
X#endif /* SCAN */
X	exit(1);
X    }
X    for(i = 0; i < 32; i++) {
X	tree_count[i] = 0;
X    }
X    i = 0;
X    tree_MaxLength = 0;
X    tree_entries = 0;
X    while(treeBytes-- > 0) { /* adaption for Compactor */
X	len = (*cpt_char) >> 4;
X	if(len != 0) { /* only if length unequal zero */
X	    if(len > tree_MaxLength) {
X		tree_MaxLength = len;
X	    }
X	    tree_count[len]++;
X	    tree_entry[tree_entries].Value = i;
X	    tree_entry[tree_entries++].BitLength = len;
X	}
X	i++;
X	len = *cpt_char++ & NIBBLEMASK;
X	if(len != 0) { /* only if length unequal zero */
X	    if(len > tree_MaxLength) {
X		tree_MaxLength = len;
X	    }
X	    tree_count[len]++;
X	    tree_entry[tree_entries].Value = i;
X	    tree_entry[tree_entries++].BitLength = len;
X	}
X	i++;
X    }
X
X    /* Compactor allows unused trailing codes in its Huffman tree! */
X    j = 0;
X    for(i = 0; i <= tree_MaxLength; i++) {
X	j = (j << 1) + tree_count[i];
X    }
X    j = (1 <<tree_MaxLength) - j;
X    /* Insert the unused entries for sorting purposes. */
X    for(i = 0; i < j; i++) {
X	tree_entry[tree_entries].Value = size;
X	tree_entry[tree_entries++].BitLength = tree_MaxLength;
X    }
X
X    /* adaption from SortLengths */
X    entry = &(tree_entry[0]);
X    entries = tree_entries;
X    for(i = 0; ++i < entries;) {
X	tmp = entry[i];
X	b = tmp.BitLength;
X	j = i;
X	while((j > 0) && ((a = (ejm1 = &(entry[j - 1]))->BitLength) >= b)) {
X	    if((a == b) && (ejm1->Value <= tmp.Value)) {
X		break;
X	    }
X	    *(ejm1 + 1) = *ejm1;
X	    --j;
X	}
X	entry[j] = tmp;
X    }
X
X    /* Adapted from GenerateTrees */
X    i = tree_entries - 1;
X    /* starting at the upper end (and reversing loop) because of Compactor */
X    lvlstart = next = size * 2 + SLACK - 1;
X    /* slight adaption because of different node format used */
X    for(codelen = tree_MaxLength; codelen >= 1; --codelen) {
X	while((i >= 0) && (tree_entry[i].BitLength == codelen)) {
X	    Hufftree[next].byte = tree_entry[i].Value;
X	    Hufftree[next].flag = 1;
X	    next--;
X	    i--;
X	}
X	parents = next;
X	if(codelen > 1) {
X	    /* reversed loop */
X	    for(j = lvlstart; j > parents + 1; j-= 2) {
X		Hufftree[next].one = &(Hufftree[j]);
X		Hufftree[next].zero = &(Hufftree[j - 1]);
X		Hufftree[next].flag = 0;
X		next--;
X	    }
X	}
X	lvlstart = parents;
X    }
X    Hufftree[0].one = &(Hufftree[next + 2]);
X    Hufftree[0].zero = &(Hufftree[next + 1]);
X    Hufftree[0].flag = 0;
X}
X
Xstatic int cpt_get6bits()
X{
Xint b = 0, cn;
X
X    b = (cpt_newbits >> 26) & 0x3f;
X    cpt_bitsavail -= 6;
X    cpt_newbits <<= 6;
X    if(cpt_bitsavail < 16) {
X	cn = (*cpt_char++ << 8);
X	cn |= *cpt_char++;
X	cpt_newbits |= (cn << (16 - cpt_bitsavail));
X	cpt_bitsavail += 16;
X    }
X    return b;
X}
X
Xstatic int cpt_getbit()
X{
Xint b;
X
X    b = (cpt_newbits >> 31) & 1;
X    cpt_bitsavail--;
X    if(cpt_bitsavail < 16) {
X	cpt_newbits |= (*cpt_char++ << 8);
X	cpt_newbits |= *cpt_char++;
X	cpt_bitsavail += 16;
X    }
X    cpt_newbits <<= 1;
X    return b;
X}
X#else /* CPT */
Xint cpt; /* keep lint and some compilers happy */
X#endif /* CPT */
X
SHAR_EOF
if test 17640 -ne "`wc -c < 'cpt.c'`"
then
	echo shar: "error transmitting 'cpt.c'" '(should have been 17640 characters)'
fi
fi
echo shar: "extracting 'zma.c'" '(9528 characters)'
if test -f 'zma.c'
then
	echo shar: "will not over-write existing file 'zma.c'"
else
sed 's/^X//' << \SHAR_EOF > 'zma.c'
X#include "macunpack.h"
X#ifdef ZMA
X#include "globals.h"
X#include "zma.h"
X#include "crc.h"
X#include "../fileio/machdr.h"
X#include "../fileio/wrfile.h"
X#include "../fileio/kind.h"
X#include "../util/masks.h"
X#include "../util/util.h"
X
Xextern char *malloc();
Xextern char *realloc();
Xextern void de_lzh();
X
X/* We do allow for possible backpointing, so we allocate the archive in core */
Xstatic char *zma_archive;
Xstatic char *zma_current;
Xstatic char *zma_filestart;
Xstatic unsigned long zma_length;
Xstatic long zma_archlength;
X
Xstatic int zma_filehdr();
Xstatic void zma_folder();
Xstatic void zma_mooz();
Xstatic void zma_wrfile();
Xstatic void zma_nocomp();
Xstatic void zma_lzh();
X
Xvoid zma(start, length)
X    char *start;
X    unsigned long length;
X{
X    struct fileHdr filehdr;
X    int i, toread;
X
X    if(length != 0) {
X	if(zma_archlength < length) {
X	    if(zma_archlength == 0) {
X		zma_archive = malloc((unsigned)length);
X	    } else {
X		zma_archive = realloc(zma_archive, (unsigned)length);
X	    }
X	    zma_archlength = length;
X	    if(zma_archive == NULL) {
X		(void)fprintf(stderr, "Insufficient memory, aborting\n");
X		exit(1);
X	    }
X	}
X	if(fread(zma_archive, 1, (int)length, infp) != length) {
X	    (void)fprintf(stderr, "Can't read archive.\n");
X#ifdef SCAN
X	    do_error("macunpack: Can't read archive");
X#endif /* SCAN */
X	    exit(1);
X	}
X	zma_length = get4(zma_archive + ZMAHDRS + 1);
X	if(zma_length != length) {
X	    (void)fprintf(stderr, "Archive length mismatch.\n");
X#ifdef SCAN
X	    do_error("macunpack: Archive length mismatch");
X#endif /* SCAN */
X	    exit(1);
X	}
X    } else {
X	zma_length =  get4(start + ZMAHDRS + 1);
X	if(zma_archlength < zma_length) {
X	    if(zma_archlength == 0) {
X		zma_archive = malloc((unsigned)zma_length);
X	    } else {
X		zma_archive = realloc(zma_archive, (unsigned)zma_length);
X	    }
X	    zma_archlength = zma_length;
X	    if(zma_archive == NULL) {
X		(void)fprintf(stderr, "Insufficient memory, aborting\n");
X		exit(1);
X	    }
X	}
X	if(zma_archive == NULL) {
X	    (void)fprintf(stderr, "Insufficient memory, aborting\n");
X	    exit(1);
X	}
X	for(i = 0; i <= ZMAHDRS2; i++) {
X	    zma_archive[i] = start[i];
X	}
X	toread = zma_length - ZMAHDRS2 - 1;
X	if(fread(zma_archive + ZMAHDRS2 + 1, 1, toread, infp) != toread) {
X	    (void)fprintf(stderr, "Can't read archive.\n");
X#ifdef SCAN
X	    do_error("macunpack: Can't read archive");
X#endif /* SCAN */
X	    exit(1);
X	}
X    }
X    /* Consistency checks */
X    if(zma_archive[0] != 0) {
X	(void)fprintf(stderr, "Not a \"Zoom\" archive after all, aborting\n");
X	exit(1);
X    }
X    if(strncmp(zma_archive + 1, ZMAHDR, ZMAHDRS)) {
X	(void)fprintf(stderr, "Not a \"Zoom\" archive after all, aborting\n");
X	exit(1);
X    }
X    zma_current = zma_archive + 8;
X    updcrc = arc_updcrc;
X    crcinit = arc_crcinit;
X    while(zma_current != zma_archive) {
X	if(zma_filehdr(&filehdr, 0) == -1) {
X	    (void)fprintf(stderr, "Can't find file header./n");
X#ifdef SCAN
X	    do_error("macunpack: Can't find file header");
X#endif /* SCAN */
X	    exit(1);
X	}
X	zma_filestart = zma_current + filehdr.hlen;
X	if(filehdr.what == z_dir) {
X	    zma_folder(filehdr);
X	} else {
X	    zma_mooz(filehdr);
X	}
X	zma_current = zma_archive + filehdr.next;
X    }
X}
X
Xstatic int zma_filehdr(f, skip)
Xstruct fileHdr *f;
Xint skip;
X{
X    register int i;
X    int n;
X    char ftype[5], fauth[5];
X
X    if(zma_current - zma_archive + Z_HDRSIZE > zma_length) {
X	return -1;
X    }
X    for(i = 0; i < INFOBYTES; i++) {
X	info[i] = '\0';
X    }
X
X    n = zma_current[Z_FNAME] & BYTEMASK;
X    if(n > F_NAMELEN) {
X	n = F_NAMELEN;
X    }
X    info[I_NAMEOFF] = n;
X    copy(info + I_NAMEOFF + 1, zma_current + Z_FNAME + 1, n);
X    transname(zma_current + Z_FNAME + 1, text, n);
X
X    f->what = zma_current[Z_WHAT];
X    f->rsrcLength = get4(zma_current + Z_URLEN);
X    f->dataLength = get4(zma_current + Z_UDLEN);
X    f->compRLength = get4(zma_current + Z_CRLEN);
X    f->compDLength = get4(zma_current + Z_CDLEN);
X    f->rsrcCRC = get2(zma_current + Z_RCRC);
X    f->dataCRC = get2(zma_current + Z_DCRC);
X    f->hlen = zma_current[Z_HLEN];
X    f->next = get4(zma_current + Z_NEXT);
X    if(f->what == z_dir) { /* A hack */
X	f->conts = get4(zma_current + Z_AUTH);
X    }
X    /* Set rsrc fork sizes correctly */
X    f->rsrcLength -= f->dataLength;
X    f->compRLength -= f->compDLength;
X
X    write_it = !skip;
X    if(f->what & 0x80) {
X	write_it = 0;
X	f->what = -f->what;
X	f->deleted = 1;
X	return 0;
X    }
X    f->deleted = 0;
X    if(list && !skip) {
X	do_indent(indent);
X	if(f->what == z_dir) {
X	    (void)fprintf(stderr, "folder=\"%s\"", text);
X	} else {
X	    transname(zma_current + Z_TYPE, ftype, 4);
X	    transname(zma_current + Z_AUTH, fauth, 4);
X	    (void)fprintf(stderr,
X		    "name=\"%s\", type=%4.4s, author=%4.4s, data=%ld, rsrc=%ld",
X		    text, ftype, fauth,
X		    (long)f->dataLength, (long)f->rsrcLength);
X	}
X	switch(f->what) {
X	case z_plug:
X	    (void)fputc('\n', stderr);
X	    (void)fprintf(stderr,
X		    "\tFile uses custom processing, cannot handle.\n");
X	    write_it = 0;
X	    return 0;
X	case z_dir:
X	case z_file:
X	case z_plain:
X	    break;
X	default:
X	    (void)fputc('\n', stderr);
X	    (void)fprintf(stderr,
X		    "\tEh, do not understand this (%d); skipped.\n", f->what);
X	    write_it = 0;
X	    return 0;
X	}
X
X	if(info_only) {
X	    write_it = 0;
X	}
X	if(query) {
X	    write_it = do_query();
X	} else {
X	    (void)fputc('\n', stderr);
X	}
X    }
X
X
X    if(write_it) {
X	define_name(text);
X
X	if(f->what != z_dir) {
X	    copy(info + I_TYPEOFF, zma_current + Z_TYPE, 4);
X	    copy(info + I_AUTHOFF, zma_current + Z_AUTH, 4);
X	    copy(info + I_FLAGOFF, zma_current + Z_FLAGS, 2);
X	    copy(info + I_DLENOFF, zma_current + Z_UDLEN, 4);
X	    put4(zma_current + Z_URLEN, f->rsrcLength);
X	    copy(info + I_RLENOFF, zma_current + Z_URLEN, 4);
X	    copy(info + I_CTIMOFF, zma_current + Z_MDATE, 4);
X	    copy(info + I_MTIMOFF, zma_current + Z_MDATE, 4);
X	}
X    }
X    return 1;
X}
X
Xstatic void zma_folder(fhdr)
Xstruct fileHdr fhdr;
X{
X    int i;
X    char loc_name[64];
X    struct fileHdr filehdr;
X
X    for(i = 0; i < 64; i++) {
X	loc_name[i] = text[i];
X    }
X    zma_current = zma_archive + fhdr.conts;
X    if(write_it || info_only) {
X	if(write_it) {
X	    do_mkdir(text, info);
X	}
X	indent++;
X	while(zma_current != zma_archive) {
X	    if(zma_filehdr(&filehdr, 0) == -1) {
X		(void)fprintf(stderr, "Can't find file header.\n");
X#ifdef SCAN
X		do_error("macunpack: Can't find file header");
X#endif /* SCAN */
X		exit(1);
X	    }
X	    zma_filestart = zma_current + filehdr.hlen;
X	    if(filehdr.what == z_dir) {
X		zma_folder(filehdr);
X	    } else {
X		zma_mooz(filehdr);
X	    }
X	    zma_current = zma_archive + filehdr.next;
X	}
X	if(write_it) {
X	    enddir();
X	}
X	indent--;
X	if(list) {
X	    do_indent(indent);
X	    (void)fprintf(stderr, "leaving folder \"%s\"\n", loc_name);
X	}
X    }
X}
X
Xstatic void zma_mooz(filehdr)
Xstruct fileHdr filehdr;
X{
X    unsigned long crc;
X
X    if(write_it) {
X	start_info(info, filehdr.rsrcLength, filehdr.dataLength);
X    }
X    if(verbose) {
X	(void)fprintf(stderr, "\tData: ");
X    }
X    if(write_it) {
X	start_data();
X    }
X    zma_wrfile(filehdr.compDLength, filehdr.dataLength, filehdr.what);
X    if(write_it) {
X	crc = (*updcrc)(INIT_CRC, out_buffer, filehdr.dataLength);
X	if(filehdr.dataCRC != crc) {
X	    (void)fprintf(stderr,
X		"CRC error on data fork: need 0x%04x, got 0x%04x\n",
X		(int)filehdr.dataCRC, (int)crc);
X#ifdef SCAN
X	    do_error("macunpack: CRC error on data fork");
X#endif /* SCAN */
X	    exit(1);
X	}
X    }
X    if(verbose) {
X	(void)fprintf(stderr, ", Rsrc: ");
X    }
X    if(write_it) {
X	start_rsrc();
X    }
X    zma_wrfile(filehdr.compRLength, filehdr.rsrcLength, filehdr.what);
X    if(write_it) {
X	crc = (*updcrc)(INIT_CRC, out_buffer, filehdr.rsrcLength);
X	if(filehdr.rsrcCRC != crc) {
X	    (void)fprintf(stderr,
X		"CRC error on resource fork: need 0x%04x, got 0x%04x\n",
X		(int)filehdr.rsrcCRC, (int)crc);
X#ifdef SCAN
X	    do_error("macunpack: CRC error on resource fork");
X#endif /* SCAN */
X	    exit(1);
X	}
X	end_file();
X    }
X    if(verbose) {
X	(void)fprintf(stderr, ".\n");
X    }
X}
X
Xstatic void zma_wrfile(ibytes, obytes, type)
Xunsigned long ibytes, obytes;
Xchar type;
X{
X    if(ibytes == 0) {
X	if(verbose) {
X	    (void)fprintf(stderr, "empty");
X	}
X	return;
X    }
X    switch(type) {
X    case z_plain:		/* no compression */
X	if(verbose) {
X	    (void)fprintf(stderr, "No compression");
X	}
X	if(write_it) {
X	    zma_nocomp(ibytes);
X	}
X	break;
X    case z_file:		/* lzh compression */
X	if(verbose) {
X	    (void)fprintf(stderr,
X		    "LZH compressed (%4.1f%%)", 100.0 * ibytes / obytes);
X	}
X	if(write_it) {
X	    zma_lzh(ibytes);
X	}
X	break;
X    default:
X	(void)fprintf(stderr, "Unknown compression method %2x\n", type);
X#ifdef SCAN
X	do_idf("", UNKNOWN);
X#endif /* SCAN */
X	exit(1);
X    }
X}
X
X/*---------------------------------------------------------------------------*/
X/*	No compression							     */
X/*---------------------------------------------------------------------------*/
Xstatic void zma_nocomp(ibytes)
Xunsigned long ibytes;
X{
X    int n = ibytes;
X    char *ptr = out_buffer;
X
X    while(n-- > 0) {
X	*ptr++ = *zma_filestart++;
X    }
X}
X
X/*---------------------------------------------------------------------------*/
X/*	LZ compression plus Huffman encoding				     */
X/*---------------------------------------------------------------------------*/
Xstatic void zma_lzh(ibytes)
Xunsigned long ibytes;
X{
X    /* Controlled by ibutes only */
X    de_lzh((long)ibytes, (long)(-1), &zma_filestart, 13);
X}
X#else /* ZMA */
Xint zma; /* keep lint and some compilers happy */
X#endif /* ZMA */
X
SHAR_EOF
if test 9528 -ne "`wc -c < 'zma.c'`"
then
	echo shar: "error transmitting 'zma.c'" '(should have been 9528 characters)'
fi
fi
echo shar: "extracting 'lzh.c'" '(18707 characters)'
if test -f 'lzh.c'
then
	echo shar: "will not over-write existing file 'lzh.c'"
else
sed 's/^X//' << \SHAR_EOF > 'lzh.c'
X#include "macunpack.h"
X#ifdef LZH
X#include "globals.h"
X#include "lzh.h"
X#include "crc.h"
X#include "../fileio/wrfile.h"
X#include "../fileio/machdr.h"
X#include "../util/masks.h"
X#include "../util/util.h"
X#include "bits_be.h"
X
X#define LZ5LOOKAHEAD    18    /* look ahead buffer size for LArc */
X#define LZ5BUFFSIZE	8192
X#define LZ5MASK		8191
X#define LZSLOOKAHEAD	17
X#define LZSBUFFSIZE	4096
X#define LZSMASK		4095
X#define LZBUFFSIZE	8192	/* Max of above buffsizes */
X
Xextern char *malloc();
Xextern char *realloc();
Xextern void de_lzah();
Xextern unsigned char (*lzah_getbyte)();
Xextern void de_lzh();
X
Xtypedef struct methodinfo {
X	char *name;
X	int number;
X};
X
Xstatic struct methodinfo methods[] = {
X    {"-lh0-", lh0},
X    {"-lh1-", lh1},
X    {"-lh2-", lh2},
X    {"-lh3-", lh3},
X    {"-lh4-", lh4},
X    {"-lh5-", lh5},
X    {"-lz4-", lz4},
X    {"-lz5-", lz5},
X    {"-lzs-", lzs}
X};
Xstatic char *lzh_archive;
Xstatic char *lzh_pointer;
Xstatic char *lzh_data;
Xstatic char *lzh_finfo;
Xstatic int lzh_fsize;
Xstatic int lzh_kind;
Xstatic int oldsize;
Xstatic char *lzh_file;
Xstatic int lzh_filesize;
Xstatic char *lzh_current;
Xstatic char *tmp_out_ptr;
Xstatic char lzh_lzbuf[LZBUFFSIZE];
X
Xstatic int lzh_filehdr();
Xstatic int lzh_checkm();
Xstatic char *lzh_methname();
Xstatic void lzh_wrfile();
Xstatic void lzh_skip();
Xstatic void lzh_nocomp();
X#ifdef UNTESTED
Xstatic void lzh_lzss1();
Xstatic void lzh_lzss2();
X#endif /* UNTESTED */
Xstatic void lzh_lzah();
Xstatic unsigned char lzh_getbyte();
X#ifdef UNDEF
Xstatic void lzh_lh2();
Xstatic void lzh_lh3();
X#endif /* UNDEF */
X#ifdef UNTESTED
Xstatic void lzh_lzh12();
X#endif /* UNTESTED */
Xstatic void lzh_lzh13();
X
Xvoid lzh(kind)
Xint kind;
X{
X    struct fileHdr filehdr;
X    int m, i, j;
X    char loc_name[64];
X    char dirinfo[INFOBYTES];
X
X    updcrc = arc_updcrc;
X    crcinit = arc_crcinit;
X    write_it = 1;
X    lzh_fsize = 0;
X    lzh_kind = kind;
X    if(lzh_archive == NULL) {
X	lzh_archive = malloc((unsigned)in_data_size);
X	oldsize = in_data_size;
X    } else if(in_data_size > oldsize) {
X	lzh_archive = realloc(lzh_archive, (unsigned)in_data_size);
X	oldsize = in_data_size;
X    }
X    if(lzh_archive == NULL) {
X	(void)fprintf(stderr, "Insufficient memory for archive.\n");
X	exit(1);
X    }
X    if(fread(lzh_archive, 1, in_data_size, infp) != in_data_size) {
X	(void)fprintf(stderr, "Can't read archive.\n");
X#ifdef SCAN
X	do_error("macunpack: Can't read archive");
X#endif /* SCAN */
X	exit(1);
X    }
X    lzh_pointer = lzh_archive;
X    while(1) {
X	if(in_data_size == 0) {
X	    break;
X	}
X	if(lzh_filehdr(&filehdr) == 0) {
X	    break;
X	}
X	m = lzh_checkm(&filehdr);
X	if(m < 0) {
X	    (void)fprintf(stderr,
X		    "Skipping file: \"%s\"; unknown method: %.5s.\n",
X		    text, filehdr.method);
X	    lzh_skip(&filehdr);
X	    continue;
X	}
X	if(!write_it) {
X	    /*  We are skipping a folder.  Skip the file if lzh_finfo is a
X		prefix of or identical to the folder info in the file. */
X	    if(lzh_fsize <= filehdr.extendsize &&
X	       !strncmp(lzh_finfo, filehdr.extend, lzh_fsize)) {
X		/* It was true, so we skip. */
X		lzh_skip(&filehdr);
X		continue;
X	    }
X	    /*  We have left the folder we were skipping. */
X	}
X	/*  Now we must leave folders until lzh_finfo is a proper prefix or
X	    identical to the folder info in the file. */
X	while(lzh_fsize > filehdr.extendsize ||
X	      strncmp(lzh_finfo, filehdr.extend, lzh_fsize)) {
X	    /*  Not a proper prefix, leave folder.  First determine which! */
X	    i = lzh_fsize - 1;
X	    while(--i >= 0 && lzh_finfo[i] != ':');
X	    i = i + 1;
X	    transname(lzh_finfo + i, loc_name, lzh_fsize - i - 1);
X	    lzh_fsize = i;
X	    if(write_it) {
X		indent--;
X		if(!info_only) {
X		    enddir();
X		}
X		if(list) {
X		    do_indent(indent);
X		    (void)fprintf(stderr, "leaving folder \"%s\"\n", loc_name);
X		}
X	    }
X	    write_it = 1;
X	}
X	write_it = 1;
X	/*  lzh_finfo is a proper prefix or identical, just show so. */
X	lzh_finfo = filehdr.extend;
X	/*  Now enter directories while lzh_finfo is smaller than extend. */
X	while(lzh_fsize < filehdr.extendsize) {
X	    i = lzh_fsize;
X	    while(lzh_finfo[++i] != ':');
X	    transname(lzh_finfo + lzh_fsize, loc_name, i - lzh_fsize);
X	    for(j = 0; j < INFOBYTES; j++) {
X		dirinfo[j] = 0;
X	    }
X	    dirinfo[I_NAMEOFF] = i - lzh_fsize;
X	    copy(dirinfo + I_NAMEOFF + 1, lzh_finfo + lzh_fsize, i - lzh_fsize);
X	    lzh_fsize = i + 1;
X	    if(list) {
X		do_indent(indent);
X		(void)fprintf(stderr, "folder=\"%s\"", loc_name);
X		if(query) {
X		    write_it = do_query();
X		} else {
X		    (void)fputc('\n', stderr);
X		}
X		if(write_it) {
X		    indent++;
X		}
X	    }
X	    if(write_it && !info_only) {
X		do_mkdir(loc_name, dirinfo);
X	    }
X	    if(!write_it) {
X		break;
X	    }
X	}
X	if(!write_it) {
X	    lzh_skip(&filehdr);
X	} else {
X	    lzh_wrfile(&filehdr, m);
X	}
X    }
X    /*  Leaving some more directories! */
X    while(lzh_fsize != 0) {
X	i = lzh_fsize - 1;
X	while(--i >= 0 && lzh_finfo[i] != ':');
X	i = i + 1;
X	transname(lzh_finfo + i, loc_name, lzh_fsize - i - 1);
X	lzh_fsize = i;
X	if(write_it) {
X	}
X	if(write_it) {
X	    indent--;
X	    if(!info_only) {
X		enddir();
X	    }
X	    if(list) {
X		do_indent(indent);
X		(void)fprintf(stderr, "leaving folder \"%s\"\n", loc_name);
X	    }
X	}
X    }
X}
X
Xstatic int lzh_filehdr(f)
Xstruct fileHdr *f;
X{
X    register int i;
X    char *hdr;
X    int c;
X    int ext_ptr;
X    int chk_sum = 0;
X    char *ptr;
X
X    if(in_data_size <= 0) {
X	return 0;
X    }
X    for(i = 0; i < INFOBYTES; i++) {
X	info[i] = '\0';
X    }
X    hdr = lzh_pointer;
X    in_data_size -= 2;
X    lzh_pointer += 2;
X    if(in_data_size < 0) {
X	in_data_size++;
X    }
X    f->hsize = (unsigned char)hdr[L_HSIZE];
X    if(f->hsize == 0) {
X	return 0;
X    }
X    f->hcrc = (unsigned char)hdr[L_HCRC];
X    ptr = hdr + L_METHOD;
X    in_data_size -= f->hsize;
X    lzh_pointer += f->hsize;
X    copy(&(f->method[0]), hdr + L_METHOD, 5);
X    f->psize = get4i(hdr + L_PSIZE);
X    f->upsize = get4i(hdr + L_UPSIZE);
X    f->lastmod = get4i(hdr + L_LASTMOD);
X    f->attribute = hdr[L_ATTRIBUTE + 1];
X    if(f->attribute < 2) {
X	for(i = 0; i < f->hsize; i++) {
X	    chk_sum += *ptr++;
X	}
X	chk_sum &= BYTEMASK;
X	if(chk_sum != f->hcrc) {
X	    (void)fprintf(stderr,
X		    "Header checksum error; got %.2x, must be %.2x.\n",
X		    chk_sum, f->hcrc);
X#ifdef SCAN
X	    do_error("macunpack: Header checksum error");
X#endif /* SCAN */
X	    exit(1);
X	}
X	f->nlength = (unsigned char)hdr[L_NLENGTH];
X	info[I_NAMEOFF] = f->nlength;
X	copy(info + I_NAMEOFF + 1, hdr + L_NAME, (int)f->nlength);
X	transname(hdr + L_NAME, text, (int)f->nlength);
X	ext_ptr = L_NLENGTH + f->nlength + 1;
X	f->crc = get2i(hdr + ext_ptr + L_CRC);
X	if(f->attribute == 1) {
X	    f->etype = hdr[ext_ptr + L_ETYPE];
X	    f->extendsize = hdr[ext_ptr + L_EXTENDSZ];
X	    f->extend = hdr + ext_ptr + L_EXTEND;
X	} else {
X	    f->extend = NULL;
X	    f->extendsize = 0;
X	}
X    } else if(f->attribute == 2) {
X	in_data_size += 2;
X	lzh_pointer -= 2;
X	f->nlength = hdr[L_2EXTENDSZ] - 3;
X	info[I_NAMEOFF] = f->nlength;
X	copy(info + I_NAMEOFF + 1, hdr + L_2EXTEND + 2, (int)f->nlength);
X	transname(hdr + L_2EXTEND + 2, text, (int)f->nlength);
X	ext_ptr = 
X	f->crc = get2i(hdr + L_2CRC);
X	f->etype = hdr[L_2ETYPE];
X	ext_ptr = L_2EXTEND + 2 + f->nlength;
X	f->extendsize = hdr[ext_ptr + L_EEXTENDSZ];
X	f->extend = hdr + ext_ptr + L_EEXTEND;
X    } else {
X	(void)fprintf(stderr, "Unknown file header format (%d).\n",
X		(int)f->attribute);
X#ifdef SCAN
X	do_error("macunpack: Unknown file header format");
X#endif /* SCAN */
X	exit(1);
X    }
X    if(f->extend != NULL) {
X	if(f->extendsize > 5) {
X	    f->extend += 2;
X	    hdr = f->extend;
X	    f->extendsize -= 3;
X	    for(i = 0; i < f->extendsize; i++) {
X		c = *hdr++;
X		if((c & BYTEMASK) == BYTEMASK) {
X		    hdr[-1] = ':';
X		    c = ':';
X		}
X	    }
X	    c = *hdr++;
X	    if(c == 5) {
X		  hdr += 5;
X	    }
X	} else {
X	     if(f->extendsize == 5) {
X		hdr = f->extend;
X		f->extend = NULL;
X		f->extendsize = 0;
X		hdr += 5;
X	    } else {
X		hdr = f->extend;
X		f->extend = NULL;
X		f->extendsize = 0;
X	    }
X	}
X    } else {
X	hdr = hdr + ext_ptr;
X    }
X    lzh_data = hdr;
X    if(f->attribute != 0) {
X	lzh_data++;
X    }
X    return 1;
X}
X
Xstatic int lzh_checkm(f)
Xstruct fileHdr *f;
X{
X    int i, nummeth;
X    char *meth;
X
X    meth = f->method;
X    nummeth = sizeof(methods) / sizeof(struct methodinfo);
X    for(i = 0; i < nummeth; i++) {
X	if(!strncmp(methods[i].name, meth, 5)) {
X	    return methods[i].number;
X	}
X    }
X    return -1;
X}
X
Xstatic char *lzh_methname(n)
Xint n;
X{
X    if(n > sizeof(methods) / sizeof(struct methodinfo)) {
X	return NULL;
X    }
X    return methods[n].name;
X}
X
Xstatic void lzh_wrfile(filehdr, method)
Xstruct fileHdr *filehdr;
Xint method;
X{
X    char ftype[5], fauth[5];
X    int rsrcLength, dataLength;
X    int doit;
X    char *mname;
X    unsigned long crc;
X
X    if(filehdr->upsize > lzh_filesize) {
X	if(lzh_filesize == 0) {
X	    lzh_file = malloc((unsigned)filehdr->upsize);
X	} else {
X	    lzh_file = realloc(lzh_file, (unsigned)filehdr->upsize);
X	}
X	if(lzh_file == NULL) {
X	    (void)fprintf(stderr, "Insufficient memory to unpack file.\n");
X	    exit(1);
X	}
X    }
X    switch(method) {
X    case lz4:
X	lzh_nocomp((unsigned long)128);
X	break;
X#ifdef UNTESTED
X    case lz5:
X	lzh_lzss1((unsigned long)128);
X	break;
X    case lzs:
X	lzh_lzss2((unsigned long)128);
X	break;
X#endif /* UNTESTED */
X    case lh0:
X	lzh_nocomp((unsigned long)128);
X	break;
X    case lh1:
X	lzh_lzah((unsigned long)128);
X	break;
X#ifdef UNDEF
X    case lh2:
X	lzh_lh2((unsigned long)128);
X	break;
X    case lh3:
X	lzh_lh3((unsigned long)128);
X	break;
X#endif /* UNDEF */
X#ifdef UNTESTED
X    case lh4:
X	lzh_lzh12((unsigned long)128);
X	break;
X#endif /* UNTESTED */
X    case lh5:
X	lzh_lzh13((unsigned long)128);
X	break;
X    default:
X	mname = lzh_methname(method);
X	if(mname != NULL) {
X	    do_indent(indent);
X	    (void)fprintf(stderr,
X		    "\tSorry, packing method not yet implemented.\n");
X	    do_indent(indent);
X	    (void)fprintf(stderr, "File = \"%s\"; ", text);
X	    (void)fprintf(stderr, "method = %s, skipping file.\n", mname);
X	    lzh_skip(filehdr);
X	    return;
X	}
X	(void)fprintf(stderr,
X		"There is something very wrong with this program!\n");
X#ifdef SCAN
X	do_error("macunpack: program error");
X#endif /* SCAN */
X	exit(1);
X    }
X    /* Checks whether everything is packed as MacBinary. */
X    if(*lzh_file != 0 /* More checks possible here. */) {
X	do_indent(indent);
X	(void)fprintf(stderr, "File = \"%s\" ", text);
X	(void)fprintf(stderr, "not packed in MacBinary, skipping file.\n");
X#ifdef SCAN
X	do_error("macunpack: not MacBinary");
X#endif /* SCAN */
X	lzh_skip(filehdr);
X	return;
X    }
X    copy(info, lzh_file, 128);
X    rsrcLength = get4(info + I_RLENOFF);
X    dataLength = get4(info + I_DLENOFF);
X    transname(info + I_TYPEOFF, ftype, 4);
X    transname(info + I_AUTHOFF, fauth, 4);
X    if(list) {
X	do_indent(indent);
X	(void)fprintf(stderr,
X		"name=\"%s\", type=%4.4s, author=%4.4s, data=%ld, rsrc=%ld",
X		text, ftype, fauth, (long)dataLength, (long)rsrcLength);
X    }
X    if(info_only) {
X	doit = 0;
X    } else {
X	doit = 1;
X    }
X    if(query) {
X	doit = do_query();
X    } else if(list) {
X	(void)fputc('\n', stderr);
X    }
X    if(doit) {
X	define_name(text);
X	start_info(info, (unsigned long)rsrcLength, (unsigned long)dataLength);
X    }
X    switch(method) {
X    case lz4:
X	if(verbose) {
X	    (void)fprintf(stderr, "\tNo Compression (%.5s)", filehdr->method);
X	}
X	if(doit) {
X	    lzh_nocomp(filehdr->upsize);
X	}
X	break;
X#ifdef UNTESTED
X    case lz5:
X	if(verbose) {
X	    (void)fprintf(stderr, "\tLZSS (%.5s) compressed (%4.1f%%)",
X		    filehdr->method, 100.0 * filehdr->psize / filehdr->upsize);
X	}
X	if(doit) {
X	    lzh_lzss1(filehdr->upsize);
X	}
X	break;
X    case lzs:
X	if(verbose) {
X	    (void)fprintf(stderr, "\tLZSS (%.5s) compressed (%4.1f%%)",
X		    filehdr->method, 100.0 * filehdr->psize / filehdr->upsize);
X	}
X	if(doit) {
X	    lzh_lzss2(filehdr->upsize);
X	}
X	break;
X#endif /* UNTESTED */
X    case lh0:
X	if(verbose) {
X	    (void)fprintf(stderr, "\tNo Compression (%.5s)", filehdr->method);
X	}
X	if(doit) {
X	    lzh_nocomp(filehdr->upsize);
X	}
X	break;
X    case lh1:
X	if(verbose) {
X	    (void)fprintf(stderr, "\tLZAH (%.5s) compressed (%4.1f%%)",
X		    filehdr->method, 100.0 * filehdr->psize / filehdr->upsize);
X	}
X	if(doit) {
X	    lzh_lzah(filehdr->upsize);
X	}
X	break;
X#ifdef UNDEF
X    case lh2:
X	if(verbose) {
X	    (void)fprintf(stderr, "\tLZAH (%.5s) compressed (%4.1f%%)",
X		    filehdr->method, 100.0 * filehdr->psize / filehdr->upsize);
X	}
X	if(doit) {
X	    lzh_lh2(filehdr->upsize);
X	}
X	break;
X    case lh3:
X	if(verbose) {
X	    (void)fprintf(stderr, "\tLZH (%.5s) compressed (%4.1f%%)",
X		    filehdr->method, 100.0 * filehdr->psize / filehdr->upsize);
X	}
X	if(doit) {
X	    lzh_lzh3(filehdr->upsize);
X	}
X	break;
X#endif /* UNDEF */
X#ifdef UNTESTED
X    case lh4:
X	if(verbose) {
X	    (void)fprintf(stderr, "\tLZH (%.5s) compressed (%4.1f%%)",
X		    filehdr->method, 100.0 * filehdr->psize / filehdr->upsize);
X	}
X	if(doit) {
X	    lzh_lzh12(filehdr->upsize);
X	}
X	break;
X#endif /* UNTESTED */
X    case lh5:
X	if(verbose) {
X	    (void)fprintf(stderr, "\tLZH (%.5s) compressed (%4.1f%%)",
X		    filehdr->method, 100.0 * filehdr->psize / filehdr->upsize);
X	}
X	if(doit) {
X	    lzh_lzh13(filehdr->upsize);
X	}
X    }
X    if(doit) {
X	crc = (*updcrc)(INIT_CRC, lzh_file, filehdr->upsize);
X	if(filehdr->crc != crc) {
X	    (void)fprintf(stderr,
X		    "CRC error on file: need 0x%04x, got 0x%04x\n",
X		    filehdr->crc, (int)crc);
X#ifdef SCAN
X	    do_error("macunpack: CRC error on file");
X#endif /* SCAN */
X	    exit(1);
X	}
X	start_data();
X	copy(out_ptr, lzh_file + 128, (int)(filehdr->upsize - 128));
X    }
X    if(verbose) {
X	(void)fprintf(stderr, ".\n");
X    }
X    if(doit) {
X	end_file();
X    }
X    lzh_skip(filehdr);
X}
X
Xstatic void lzh_skip(filehdr)
Xstruct fileHdr *filehdr;
X{
X    lzh_pointer += filehdr->psize;
X    in_data_size -= filehdr->psize;
X}
X
X/*---------------------------------------------------------------------------*/
X/*	-lz4- and -lh0: No compression					     */
X/*---------------------------------------------------------------------------*/
Xstatic void lzh_nocomp(obytes)
Xunsigned long obytes;
X{
X    copy(lzh_file, lzh_data, (int)obytes);
X}
X
X#ifdef UNTESTED
X/*---------------------------------------------------------------------------*/
X/*	-lz5-: LZSS compression, variant 1				     */
X/*---------------------------------------------------------------------------*/
Xstatic void lzh_lzss1(obytes)
Xunsigned long obytes;
X{
X    int mask, ch, lzcnt, lzptr, ptr, count;
X    char *p = lzh_lzbuf;
X    int i, j;
X
X    for(i = 0; i < 256; i++) {
X	for(j = 0; j < 13; j++) {
X	    *p++ = i;
X	}
X    }
X    for(i = 0; i < 256; i++) {
X	*p++ = i;
X    }
X    for(i = 0; i < 256; i++) {
X	*p++ = 255 - i;
X    }
X    for(i = 0; i < 128; i++) {
X	*p++ = 0;
X    }
X    for(i = 0; i < 128; i++) {
X	*p++ = ' ';
X    }
X
X    tmp_out_ptr = out_ptr;
X    out_ptr = lzh_file;
X    ptr = LZ5BUFFSIZE - LZ5LOOKAHEAD;
X    count = 0;
X    lzh_current = lzh_data;
X    while(obytes != 0) {
X	if(count == 0) {
X	    mask = *lzh_current++ & BYTEMASK;
X	    count = 8;
X	}
X	count--;
X	ch = *lzh_current++ & BYTEMASK;
X	if ((mask & 1) != 0) {
X	    *out_ptr++ = ch;
X	    lzh_lzbuf[ptr++] = ch;
X	    ptr &= LZ5MASK;
X	    obytes--;
X	} else {
X	    lzcnt = *lzh_current++;
X	    lzptr = (ch & 0x00ff) | ((lzcnt << 4) & 0x0f00);
X	    lzcnt = (lzcnt & 0x000f) + 3;
X	    obytes -= lzcnt;
X	    do {
X		ch = lzh_lzbuf[lzptr++];
X		lzh_lzbuf[ptr++] = ch;
X		*out_ptr++ = ch;
X		lzptr &= LZ5MASK;
X		ptr &= LZ5MASK;
X	    } while (--lzcnt != 0) ;
X	}
X	mask >>= 1;
X    }
X    out_ptr = tmp_out_ptr;
X}
X
X/*---------------------------------------------------------------------------*/
X/*	-lzs-: LZSS compression, variant 2				     */
X/*---------------------------------------------------------------------------*/
Xstatic void lzh_lzss2(obytes)
Xunsigned long obytes;
X{
X    int ch, lzcnt, lzptr, ptr, i;
X
X    tmp_out_ptr = out_ptr;
X    out_ptr = lzh_file;
X    ptr = LZSBUFFSIZE - LZSLOOKAHEAD;
X    for(i = 0; i < ptr; i++) {
X	lzh_lzbuf[i] = ' ';
X    }
X    for(i = ptr; i < LZSBUFFSIZE; i++) {
X	lzh_lzbuf[i] = 0;
X    }
X    bit_be_init_getbits();
X    bit_be_filestart = lzh_data;
X    bit_be_inbytes = -1;
X    while(obytes != 0) {
X	if(bit_be_getbits(1) == 0) {
X	    ch = bit_be_getbits(8);
X	    *out_ptr++ = ch;
X	    lzh_lzbuf[ptr++] = ch;
X	    ptr &= LZSMASK;
X	    obytes--;
X	} else {
X	    lzptr = bit_be_getbits(11);
X	    lzcnt = bit_be_getbits(4) + 3;
X	    obytes -= lzcnt;
X	    do {
X		ch = lzh_lzbuf[lzptr++];
X		lzh_lzbuf[ptr++] = ch;
X		*out_ptr++ = ch;
X		lzptr &= LZSMASK;
X		ptr &= LZSMASK;
X	    } while (--lzcnt != 0) ;
X	}
X    }
X    out_ptr = tmp_out_ptr;
X}
X#endif /* UNTESTED */
X
X/*---------------------------------------------------------------------------*/
X/*	-lh1-: LZ compression plus adaptive Huffman encoding		     */
X/*---------------------------------------------------------------------------*/
Xstatic void lzh_lzah(obytes)
Xunsigned long obytes;
X{
X    lzh_current = lzh_data + 2; /* SKIPPING BLOCKSIZE! */
X    tmp_out_ptr = out_ptr;
X    out_ptr = lzh_file;
X    lzah_getbyte = lzh_getbyte;
X    de_lzah(obytes);
X    out_ptr = tmp_out_ptr;
X}
X
Xstatic unsigned char lzh_getbyte()
X{
X    return *lzh_current++;
X}
X
X#ifdef UNDEF
X/*---------------------------------------------------------------------------*/
X/*	-lh2-: LZ** compression						     */
X/*---------------------------------------------------------------------------*/
Xstatic void lzh_lh2(obytes)
Xunsigned long obytes;
X{
X}
X
X/*---------------------------------------------------------------------------*/
X/*	-lh3-: LZ** compression						     */
X/*---------------------------------------------------------------------------*/
Xstatic void lzh_lh3(obytes)
Xunsigned long obytes;
X{
X}
X#endif /* UNDEF */
X
X#ifdef UNTESTED
X/*---------------------------------------------------------------------------*/
X/*	-lh4-: LZ(12) compression plus Huffman encoding			     */
X/*---------------------------------------------------------------------------*/
Xstatic void lzh_lzh12(obytes)
Xunsigned long obytes;
X{
X    lzh_current = lzh_data;
X    tmp_out_ptr = out_ptr;
X    out_ptr = lzh_file;
X    /* Controlled by obytes only */
X    de_lzh((long)(-1), (long)obytes, &lzh_current, 12);
X    out_ptr = tmp_out_ptr;
X}
X#endif /* UNTESTED */
X
X/*---------------------------------------------------------------------------*/
X/*	-lh5-: LZ(13) compression plus Huffman encoding			     */
X/*---------------------------------------------------------------------------*/
Xstatic void lzh_lzh13(obytes)
Xunsigned long obytes;
X{
X    lzh_current = lzh_data;
X    tmp_out_ptr = out_ptr;
X    out_ptr = lzh_file;
X    /* Controlled by obytes only */
X    de_lzh((long)(-1), (long)obytes, &lzh_current, 13);
X    out_ptr = tmp_out_ptr;
X}
X#else /* LZH */
Xint lzh; /* keep lint and some compilers happy */
X#endif /* LZH */
X
SHAR_EOF
if test 18707 -ne "`wc -c < 'lzh.c'`"
then
	echo shar: "error transmitting 'lzh.c'" '(should have been 18707 characters)'
fi
fi
echo shar: "extracting 'lzc.c'" '(4405 characters)'
if test -f 'lzc.c'
then
	echo shar: "will not over-write existing file 'lzc.c'"
else
sed 's/^X//' << \SHAR_EOF > 'lzc.c'
X#include "macunpack.h"
X#ifdef LZC
X#include "globals.h"
X#include "lzc.h"
X#include "../util/util.h"
X#include "../fileio/machdr.h"
X#include "../fileio/wrfile.h"
X#include "../util/masks.h"
X
Xextern void de_compress();
Xextern void core_compress();
Xextern void mcb();
X
Xstatic void lzc_zivm();
Xstatic void lzc_wrfile();
Xstatic void lzc_zivu();
X
Xvoid lzc(ohdr)
Xchar *ohdr;
X{
X    core_compress((char *)NULL);
X    if(!strncmp(ohdr + I_TYPEOFF, "ZIVM", 4)) {
X	lzc_zivm(ohdr);
X    } else {
X	lzc_zivu(ohdr);
X    }
X}
X
Xstatic void lzc_zivm(ohdr)
Xchar *ohdr;
X{
X    char hdr[HEADERBYTES];
X    unsigned long dataLength, rsrcLength, dataCLength, rsrcCLength;
X    char ftype[5], fauth[5];
X
X    if(fread(hdr, 1, HEADERBYTES, infp) != HEADERBYTES) {
X	(void)fprintf(stderr, "Can't read file header\n");
X#ifdef SCAN
X	do_error("macunpack: Can't read file header");
X#endif /* SCAN */
X	exit(1);
X    }
X    if(strncmp(hdr, MAGIC1, 4)) {
X	(void)fprintf(stderr, "Magic header mismatch\n");
X#ifdef SCAN
X	do_error("macunpack: Magic header mismatch");
X#endif /* SCAN */
X	exit(1);
X    }
X    dataLength = get4(hdr + C_DLENOFF);
X    dataCLength = get4(hdr + C_DLENOFFC);
X    rsrcLength = get4(hdr + C_RLENOFF);
X    rsrcCLength = get4(hdr + C_RLENOFFC);
X
X    write_it = 1;
X    if(list) {
X	copy(info, ohdr, INFOBYTES);
X	copy(info + I_TYPEOFF, hdr + C_TYPEOFF, 4);
X	copy(info + I_AUTHOFF, hdr + C_AUTHOFF, 4);
X	copy(info + I_DLENOFF, hdr + C_DLENOFF, 4);
X	copy(info + I_RLENOFF, hdr + C_RLENOFF, 4);
X	copy(info + I_CTIMOFF, hdr + C_CTIMOFF, 4);
X	copy(info + I_MTIMOFF, hdr + C_MTIMOFF, 4);
X	copy(info + I_FLAGOFF, hdr + C_FLAGOFF, 8);
X
X	transname(ohdr + I_NAMEOFF + 1, text, (int)ohdr[I_NAMEOFF]);
X	transname(hdr + C_TYPEOFF, ftype, 4);
X	transname(hdr + C_AUTHOFF, fauth, 4);
X	do_indent(indent);
X	(void)fprintf(stderr,
X		"name=\"%s\", type=%4.4s, author=%4.4s, data=%ld, rsrc=%ld",
X		text, ftype, fauth, (long)dataLength, (long)rsrcLength);
X	if(info_only) {
X	    write_it = 0;
X	}
X	if(query) {
X	    write_it = do_query();
X	} else {
X	    (void)fputc('\n', stderr);
X	}
X    }
X
X    if(write_it) {
X	define_name(text);
X    }
X    if(write_it) {
X	start_info(info, rsrcLength, dataLength);
X    }
X    if(verbose) {
X	(void)fprintf(stderr, "\tData: ");
X    }
X    if(write_it) {
X	start_data();
X    }
X    lzc_wrfile(dataLength, dataCLength);
X    if(verbose) {
X	(void)fprintf(stderr, ", Rsrc: ");
X    }
X    if(write_it) {
X	start_rsrc();
X    }
X    lzc_wrfile(rsrcLength, rsrcCLength);
X    if(write_it) {
X	end_file();
X    }
X    if(verbose) {
X	(void)fprintf(stderr, ".\n");
X    }
X}
X
Xstatic void lzc_wrfile(obytes, ibytes)
Xunsigned long obytes, ibytes;
X{
X    int n, nbits;
X    char subheader[3];
X
X    if(ibytes == 0) {
X	if(verbose) {
X	    (void)fprintf(stderr, "empty");
X	}
X	return;
X    }
X    if(ibytes == obytes) {
X	if(verbose) {
X	    (void)fprintf(stderr, "No compression");
X	}
X	if(write_it) {
X	    n = fread(out_buffer, 1, (int)ibytes, infp);
X	    if(n != ibytes) {
X		(void)fprintf(stderr, "Premature EOF\n");
X#ifdef SCAN
X		do_error("macunpack: Premature EOF");
X#endif /* SCAN */
X		exit(1);
X	    }
X	} else {
X	    n = ibytes;
X	    while(n-- > 0) {
X		if(getc(infp) == EOF) {
X		    (void)fprintf(stderr, "Premature EOF\n");
X#ifdef SCAN
X		    do_error("macunpack: Premature EOF");
X#endif /* SCAN */
X		    exit(1);
X		}
X	    }
X	}
X    } else {
X	if(fread(subheader, 1, 3, infp) != 3) {
X	    (void)fprintf(stderr, "Premature EOF\n");
X#ifdef SCAN
X	    do_error("macunpack: Premature EOF");
X#endif /* SCAN */
X	    exit(1);
X	}
X	if(strncmp(subheader, MAGIC2, 2)) {
X	    (void)fprintf(stderr, "Magic subheader mismatch\n");
X#ifdef SCAN
X	    do_error("macunpack: Magic subheader mismatch");
X#endif /* SCAN */
X	    exit(1);
X	}
X	nbits = subheader[2] & 0x7f;
X	if(verbose) {
X	    (void)fprintf(stderr, "LZC(%d) compressed (%4.1f%%)",
X		    nbits, 100.0 * ibytes / obytes);
X	}
X	if(write_it) {
X	    de_compress(ibytes - 3, nbits);
X	} else {
X	    n = ibytes - 3;
X	    while(n-- > 0) {
X		if(getc(infp) == EOF) {
X		    (void)fprintf(stderr, "Premature EOF\n");
X#ifdef SCAN
X		    do_error("macunpack: Premature EOF");
X#endif /* SCAN */
X		    exit(1);
X		}
X	    }
X	}
X    }
X}
X
Xstatic void lzc_zivu(ohdr)
Xchar *ohdr;
X{
X    (void)fprintf(stderr,
X	    "\tMacCompress(Unix) not yet implemented, copied as MacBinary\n");
X    mcb(ohdr, (unsigned long)in_rsrc_size, (unsigned long)in_data_size,
X	in_ds + in_rs);
X}
X#else /* LZC */
Xint lzc; /* keep lint and some compilers happy */
X#endif /* LZC */
X
SHAR_EOF
if test 4405 -ne "`wc -c < 'lzc.c'`"
then
	echo shar: "error transmitting 'lzc.c'" '(should have been 4405 characters)'
fi
fi
echo shar: "extracting 'macbinary.c'" '(13547 characters)'
if test -f 'macbinary.c'
then
	echo shar: "will not over-write existing file 'macbinary.c'"
else
sed 's/^X//' << \SHAR_EOF > 'macbinary.c'
X#include "macunpack.h"
X#include "globals.h"
X#include "../fileio/machdr.h"
X#include "../fileio/wrfile.h"
X#include "../fileio/kind.h"
X#include "zmahdr.h"
X#include "../util/util.h"
X
Xextern void dir();
Xextern void mcb();
X#ifdef BIN
Xextern void bin();
X#endif /* BIN */
X#ifdef JDW
Xextern void jdw();
X#endif /* JDW */
X#ifdef STF
Xextern void stf();
X#endif /* STF */
X#ifdef LZC
Xextern void lzc();
X#endif /* LZC */
X#ifdef ASQ
Xextern void asq();
X#endif /* ASQ */
X#ifdef ARC
Xextern void arc();
X#endif /* ARC */
X#ifdef PIT
Xextern void pit();
X#endif /* PIT */
X#ifdef SIT
Xextern void sit();
X#endif /* SIT */
X#ifdef DIA
Xextern void dia();
X#endif /* DIA */
X#ifdef CPT
Xextern void cpt();
X#endif /* CPT */
X#ifdef ZMA
Xextern void zma();
X#endif /* ZMA */
X#ifdef LZH
Xextern void lzh();
X#endif /* LZH */
X#ifdef DD
Xextern void dd_file();
Xextern void dd_arch();
X#endif /* DD */
X
Xstatic void skip_file();
X#ifdef SCAN
Xstatic void get_idf();
X#endif /* SCAN */
X
X#define Z	(ZMAHDRS2 + 1)
X
Xstatic int info_given;
X
Xvoid macbinary()
X{
X    char header[INFOBYTES];
X    int c;
X
X    while(1) {
X	if((c = fgetc(infp)) == EOF) {
X	    break;
X	}
X	(void)ungetc(c, infp);
X	if(fread(header, 1, Z, infp) != Z) {
X	    (void)fprintf(stderr, "Can't read MacBinary header.\n");
X#ifdef SCAN
X	    do_error("macunpack: Can't read MacBinary header");
X#endif /* SCAN */
X	    exit(1);
X	}
X#ifdef ZMA
X	if(!strncmp(header + 1, ZMAHDR, ZMAHDRS2)) {
X	    /* Can distinguish zoom data forks only this way from macbinary */
X	    if(verbose) {
X		(void)fprintf(stderr, "This is a \"Zoom\" archive.\n");
X	    }
X	    zma(header, (unsigned long)0);
X	    exit(0);
X	}
X#endif /* ZMA */
X	if(fread(header + Z, 1, INFOBYTES - Z, infp) != INFOBYTES - Z) {
X	    (void)fprintf(stderr, "Can't read MacBinary header.\n");
X#ifdef SCAN
X	    do_error("macunpack: Can't read MacBinary header");
X#endif /* SCAN */
X	    exit(1);
X	}
X	if(verbose && !info_given) {
X	    do_indent(indent);
X	    (void)fprintf(stderr, "This is \"MacBinary\" input.\n");
X	    info_given = 1;
X	}
X	if(header[I_NAMEOFF] & 0x80) {
X	    dir(header);
X	    continue;
X	}
X	in_data_size = get4(header + I_DLENOFF);
X	in_rsrc_size = get4(header + I_RLENOFF);
X	in_ds = (((in_data_size + 127) >> 7) << 7);
X	in_rs = (((in_rsrc_size + 127) >> 7) << 7);
X	ds_skip = in_ds - in_data_size;
X	rs_skip = in_rs - in_rsrc_size;
X	if(dir_skip != 0) {
X	    skip_file(in_ds + in_rs);
X	    continue;
X	}
X#ifdef SCAN
X	if(header[I_NAMEOFF] == 0) {
X	    get_idf((int)header[I_NAMEOFF + 1]);
X	    skip_file(ds_skip + in_rs);
X	    continue;
X	}
X#endif /* SCAN */
X	header[I_NAMEOFF + 1 + header[I_NAMEOFF]] = 0;
X#ifdef BIN
X	if(!strncmp(header + I_TYPEOFF, "TEXT", 4) &&
X	   !strncmp(header + I_AUTHOFF, "BnHq", 4)) {
X	    if(verbose) {
X		do_indent(indent);
X		(void)fprintf(stderr,
X			"This is a \"BinHex 5.0\" packed file.\n");
X	    }
X#ifdef SCAN
X	    do_idf(header + I_NAMEOFF + 1, PACK_NAME);
X#endif /* SCAN */
X	    bin(header, in_data_size, 0);
X	    skip_file(ds_skip + in_rs);
X	    continue;
X	}
X	if(!strncmp(header + I_TYPEOFF, "TEXT", 4) &&
X	   !strncmp(header + I_AUTHOFF, "GJBU", 4)) {
X	    if(verbose) {
X		do_indent(indent);
X		(void)fprintf(stderr,
X			"This is a \"MacBinary 1.0\" packed file.\n");
X	    }
X#ifdef SCAN
X	    do_idf(header + I_NAMEOFF + 1, PACK_NAME);
X#endif /* SCAN */
X	    bin(header, in_data_size, 0);
X	    skip_file(ds_skip + in_rs);
X	    continue;
X	}
X	/* Recognize only if creator is UMcp.  UMCP uses ttxt as default. */
X	if(!strncmp(header + I_TYPEOFF, "TEXT", 4) &&
X	   !strncmp(header + I_AUTHOFF, "UMcp", 4)) {
X	    if(verbose) {
X		do_indent(indent);
X		(void)fprintf(stderr, "This is a \"UMCP\" packed file.\n");
X	    }
X#ifdef SCAN
X	    do_idf(header + I_NAMEOFF + 1, PACK_NAME);
X#endif /* SCAN */
X	    bin(header, in_data_size, 1);
X	    skip_file(ds_skip + in_rs);
X	    continue;
X	}
X#endif /* BIN */
X#ifdef JDW
X	if(!strncmp(header + I_TYPEOFF, "Smal", 4) &&
X	   !strncmp(header + I_AUTHOFF, "Jdw ", 4)) {
X	    if(verbose) {
X		do_indent(indent);
X		(void)fprintf(stderr,
X			"This is a \"Compress It\" compressed file.\n");
X	    }
X#ifdef SCAN
X	    do_idf(header + I_NAMEOFF + 1, PACK_NAME);
X#endif /* SCAN */
X	    jdw((unsigned long)in_data_size);
X	    skip_file(ds_skip + in_rs);
X	    continue;
X	}
X#endif /* JDW */
X#ifdef STF
X	if(!strncmp(header + I_TYPEOFF, "COMP", 4) &&
X	   !strncmp(header + I_AUTHOFF, "STF ", 4)) {
X	    if(verbose) {
X		do_indent(indent);
X		(void)fprintf(stderr,
X			"This is a \"ShrinkToFit\" compressed file.\n");
X	    }
X#ifdef SCAN
X	    do_idf(header + I_NAMEOFF + 1, PACK_NAME);
X#endif /* SCAN */
X	    stf((unsigned long)in_data_size);
X	    skip_file(ds_skip + in_rs);
X	    continue;
X	}
X#endif /* STF */
X#ifdef LZC
X	if(!strncmp(header + I_TYPEOFF, "ZIVM", 4) &&
X	   !strncmp(header + I_AUTHOFF, "LZIV", 4)) {
X	    if(verbose) {
X		do_indent(indent);
X		(void)fprintf(stderr,
X			"This is a \"MacCompress(M)\" compressed file.\n");
X	    }
X#ifdef SCAN
X	    do_idf(header + I_NAMEOFF + 1, PACK_NAME);
X#endif /* SCAN */
X	    lzc(header);
X	    skip_file(ds_skip + in_rs);
X	    continue;
X	}
X	if(!strncmp(header + I_TYPEOFF, "ZIVU", 4) &&
X	   !strncmp(header + I_AUTHOFF, "LZIV", 4)) {
X	    if(verbose) {
X		do_indent(indent);
X		(void)fprintf(stderr,
X			"This is a \"MacCompress(U)\" compressed file.\n");
X	    }
X#ifdef SCAN
X	    do_idf(header + I_NAMEOFF + 1, PACK_NAME);
X#endif /* SCAN */
X	    lzc(header);
X	    continue;
X	}
X#endif /* LZC */
X#ifdef ASQ
X	if(!strncmp(header + I_TYPEOFF, "ArCv", 4) &&
X	   !strncmp(header + I_AUTHOFF, "TrAS", 4)) {
X	    if(verbose) {
X		do_indent(indent);
X		(void)fprintf(stderr,
X			"This is a \"AutoSqueeze\" compressed file.\n");
X	    }
X#ifdef SCAN
X	    do_idf(header + I_NAMEOFF + 1, PACK_NAME);
X#endif /* SCAN */
X	    lzh(0);
X	    skip_file(ds_skip + in_rs);
X	    continue;
X	}
X#endif /* ASQ */
X#ifdef ARC
X	if(!strncmp(header + I_TYPEOFF, "mArc", 4) &&
X	   !strncmp(header + I_AUTHOFF, "arc*", 4)) {
X	    if(verbose) {
X		do_indent(indent);
X		(void)fprintf(stderr, "This is a \"ArcMac\" archive.\n");
X	    }
X#ifdef SCAN
X	    do_idf(header + I_NAMEOFF + 1, ARCH_NAME);
X#endif /* SCAN */
X	    arc();
X	    skip_file(ds_skip + in_rs);
X	    continue;
X	}
X	if(!strncmp(header + I_TYPEOFF, "APPL", 4) &&
X	   !strncmp(header + I_AUTHOFF, "arc@", 4)) {
X	    if(verbose) {
X		do_indent(indent);
X		(void)fprintf(stderr,
X			"This is a \"ArcMac\" self extracting archive.\n");
X	    }
X#ifdef SCAN
X	    do_idf(header + I_NAMEOFF + 1, ARCH_NAME);
X#endif /* SCAN */
X	    arc();
X	    skip_file(ds_skip + in_rs);
X	    continue;
X	}
X#endif /* ARC */
X#ifdef PIT
X	if(!strncmp(header + I_TYPEOFF, "PIT ", 4) &&
X	   !strncmp(header + I_AUTHOFF, "PIT ", 4)) {
X	    if(verbose) {
X		do_indent(indent);
X		(void)fprintf(stderr, "This is a \"PackIt\" archive.\n");
X	    }
X#ifdef SCAN
X	    do_idf(header + I_NAMEOFF + 1, ARCH_NAME);
X#endif /* SCAN */
X	    pit();
X	    skip_file(ds_skip + in_rs);
X	    continue;
X	}
X#endif /* PIT */
X#ifdef SIT
X	if(!strncmp(header + I_TYPEOFF, "SIT!", 4) &&
X	   !strncmp(header + I_AUTHOFF, "SIT!", 4)) {
X	    if(verbose) {
X		do_indent(indent);
X		(void)fprintf(stderr, "This is a \"StuffIt\" archive.\n");
X	    }
X#ifdef SCAN
X	    do_idf(header + I_NAMEOFF + 1, ARCH_NAME);
X#endif /* SCAN */
X	    sit();
X	    skip_file(ds_skip + in_rs);
X	    continue;
X	}
X	if(!strncmp(header + I_TYPEOFF, "SITD", 4) &&
X	   !strncmp(header + I_AUTHOFF, "SIT!", 4)) {
X	    if(verbose) {
X		do_indent(indent);
X		(void)fprintf(stderr,
X			"This is a \"StuffIt Deluxe\" archive.\n");
X	    }
X#ifdef SCAN
X	    do_idf(header + I_NAMEOFF + 1, ARCH_NAME);
X#endif /* SCAN */
X	    sit();
X	    skip_file(ds_skip + in_rs);
X	    continue;
X	}
X	if(!strncmp(header + I_TYPEOFF, "APPL", 4) &&
X	   !strncmp(header + I_AUTHOFF, "aust", 4)) {
X	    if(verbose) {
X		do_indent(indent);
X		(void)fprintf(stderr,
X			"This is a \"StuffIt\" self extracting archive.\n");
X	    }
X#ifdef SCAN
X	    do_idf(header + I_NAMEOFF + 1, ARCH_NAME);
X#endif /* SCAN */
X	    sit();
X	    skip_file(ds_skip + in_rs);
X	    continue;
X	}
X#endif /* SIT */
X#ifdef DIA
X	if(!strncmp(header + I_TYPEOFF, "Pack", 4) &&
X	   !strncmp(header + I_AUTHOFF, "Pack", 4)) {
X	    if(verbose) {
X		do_indent(indent);
X		(void)fprintf(stderr, "This is a \"Diamond\" archive.\n");
X	    }
X#ifdef SCAN
X	    do_idf(header + I_NAMEOFF + 1, ARCH_NAME);
X#endif /* SCAN */
X	    dia((unsigned char *)header);
X	    skip_file(ds_skip + in_rs);
X	    continue;
X	}
X	if(!strncmp(header + I_TYPEOFF, "APPL", 4) &&
X	   !strncmp(header + I_AUTHOFF, "Pack", 4) &&
X	   in_data_size != 0) {
X	    if(verbose) {
X		do_indent(indent);
X		(void)fprintf(stderr,
X			"This is a \"Diamond\" self extracting archive.\n");
X	    }
X#ifdef SCAN
X	    do_idf(header + I_NAMEOFF + 1, ARCH_NAME);
X#endif /* SCAN */
X	    dia((unsigned char *)header);
X	    skip_file(ds_skip + in_rs);
X	    continue;
X	}
X#endif /* DIA */
X#ifdef CPT
X	if(!strncmp(header + I_TYPEOFF, "PACT", 4) &&
X	   !strncmp(header + I_AUTHOFF, "CPCT", 4)) {
X	    if(verbose) {
X		do_indent(indent);
X		(void)fprintf(stderr, "This is a \"Compactor\" archive.\n");
X	    }
X#ifdef SCAN
X	    do_idf(header + I_NAMEOFF + 1, ARCH_NAME);
X#endif /* SCAN */
X	    cpt();
X	    skip_file(ds_skip + in_rs);
X	    continue;
X	}
X	if(!strncmp(header + I_TYPEOFF, "APPL", 4) &&
X	   !strncmp(header + I_AUTHOFF, "EXTR", 4)) {
X	    if(verbose) {
X		do_indent(indent);
X		(void)fprintf(stderr,
X			"This is a \"Compactor\" self extracting archive.\n");
X	    }
X#ifdef SCAN
X	    do_idf(header + I_NAMEOFF + 1, ARCH_NAME);
X#endif /* SCAN */
X	    cpt();
X	    skip_file(ds_skip + in_rs);
X	    continue;
X	}
X#endif /* CPT */
X#ifdef ZMA
X	if(!strncmp(header + I_TYPEOFF, "zooM", 4) &&
X	   !strncmp(header + I_AUTHOFF, "zooM", 4)) {
X	    if(verbose) {
X		do_indent(indent);
X		(void)fprintf(stderr, "This is a \"Zoom\" archive.\n");
X	    }
X#ifdef SCAN
X	    do_idf(header + I_NAMEOFF + 1, ARCH_NAME);
X#endif /* SCAN */
X	    zma((char *)NULL, (unsigned long)in_data_size);
X	    skip_file(ds_skip + in_rs);
X	    continue;
X	}
X	if(!strncmp(header + I_TYPEOFF, "APPL", 4) &&
X	   !strncmp(header + I_AUTHOFF, "Mooz", 4)) {
X	    if(verbose) {
X		do_indent(indent);
X		(void)fprintf(stderr,
X			"This is a \"Zoom\" self extracting archive.\n");
X	    }
X#ifdef SCAN
X	    do_idf(header + I_NAMEOFF + 1, ARCH_NAME);
X#endif /* SCAN */
X	    zma((char *)NULL, (unsigned long)in_data_size);
X	    skip_file(ds_skip + in_rs);
X	    continue;
X	}
X#endif /* ZMA */
X#ifdef LZH
X	if(!strncmp(header + I_TYPEOFF, "LARC", 4) &&
X	   !strncmp(header + I_AUTHOFF, "LARC", 4)) {
X	    if(verbose) {
X		do_indent(indent);
X		(void)fprintf(stderr,
X			"This is a \"MacLHa (LHARC)\" archive.\n");
X	    }
X#ifdef SCAN
X	    do_idf(header + I_NAMEOFF + 1, ARCH_NAME);
X#endif /* SCAN */
X	    lzh(0);
X	    skip_file(ds_skip + in_rs);
X	    continue;
X	}
X	if(!strncmp(header + I_TYPEOFF, "LHA ", 4) &&
X	   !strncmp(header + I_AUTHOFF, "LARC", 4)) {
X	    if(verbose) {
X		do_indent(indent);
X		(void)fprintf(stderr,
X			"This is a \"MacLHa (LHA)\" archive.\n");
X	    }
X#ifdef SCAN
X	    do_idf(header + I_NAMEOFF + 1, ARCH_NAME);
X#endif /* SCAN */
X	    lzh(1);
X	    skip_file(ds_skip + in_rs);
X	    continue;
X	}
X#endif /* LZH */
X#ifdef DD
X	if((!strncmp(header + I_TYPEOFF, "DD01", 4) ||
X	    !strncmp(header + I_TYPEOFF, "DDF?", 3) ||
X	    !strncmp(header + I_TYPEOFF, "DDf?", 3)) &&
X	   !strncmp(header + I_AUTHOFF, "DDAP", 4)) {
X	    if(verbose) {
X		do_indent(indent);
X		(void)fprintf(stderr,
X			"This is a \"DiskDoubler\" compressed file.\n");
X	    }
X#ifdef SCAN
X	    do_idf(header + I_NAMEOFF + 1, PACK_NAME);
X#endif /* SCAN */
X	    dd_file((unsigned char *)header);
X	    skip_file(ds_skip + in_rs);
X	    continue;
X	}
X	if(!strncmp(header + I_TYPEOFF, "DDAR", 4) &&
X	   !strncmp(header + I_AUTHOFF, "DDAP", 4)) {
X	    if(verbose) {
X		do_indent(indent);
X		(void)fprintf(stderr, "This is a \"DiskDoubler\" archive.\n");
X	    }
X#ifdef SCAN
X	    do_idf(header + I_NAMEOFF + 1, ARCH_NAME);
X#endif /* SCAN */
X	    dd_arch((unsigned char *)header);
X	    skip_file(ds_skip + in_rs);
X	    continue;
X	}
X	if(!strncmp(header + I_TYPEOFF, "APPL", 4) &&
X	   !strncmp(header + I_AUTHOFF, "DSEA", 4)) {
X	    if(verbose) {
X		do_indent(indent);
X	    }
X	    c = getc(infp);
X	    (void)ungetc(c, infp);
X	    if(c == 'D') {
X		if(verbose) {
X		    (void)fprintf(stderr,
X			"This is a \"DiskDoubler\" self extracting archive.\n");
X#ifdef SCAN
X		    do_idf(header + I_NAMEOFF + 1, ARCH_NAME);
X#endif /* SCAN */
X		}
X		dd_arch((unsigned char *)header);
X	    } else {
X		if(verbose) {
X		    (void)fprintf(stderr,
X			"This is a \"DiskDoubler\" self decompressing file.\n");
X#ifdef SCAN
X		    do_idf(header + I_NAMEOFF + 1, PACK_NAME);
X#endif /* SCAN */
X		}
X		dd_file((unsigned char *)header);
X	    }
X	    skip_file(ds_skip + in_rs);
X	    continue;
X	}
X#endif /* DD */
X	if(header[0] == 0 /* MORE CHECKS HERE! */) {
X	    mcb(header, (unsigned long)in_rsrc_size,
X			(unsigned long)in_data_size, in_ds + in_rs);
X	    continue;
X	} else {
X	    (void)fprintf(stderr, "Unrecognized archive type.\n");
X	    exit(1);
X	}
X    }
X}
X
Xstatic void skip_file(skip)
Xint skip;
X{
X    char buff[1024];
X    int n;
X
X    while(skip > 0) {
X	n = (skip < 1024 ? skip : 1024);
X	if(fread(buff, 1, n, infp) != n) {
X	    (void)fprintf(stderr, "Incomplete file.\n");
X#ifdef SCAN
X	    do_error("macunpack: Incomplete file");
X#endif /* SCAN */
X	    exit(1);
X	}
X	skip -= n;
X    }
X}
X
X#ifdef SCAN
Xstatic void get_idf(kind)
Xint kind;
X{
X    char filename[255];
X
X    if(fread(filename, 1, in_data_size, infp) != in_data_size) {
X	(void)fprintf(stderr, "Incomplete file.\n");
X#ifdef SCAN
X	    do_error("macunpack: Incomplete file");
X#endif /* SCAN */
X	exit(1);
X    }
X    filename[in_data_size] = 0;
X    do_idf(filename, kind);
X}
X#endif /* SCAN */
X
SHAR_EOF
if test 13547 -ne "`wc -c < 'macbinary.c'`"
then
	echo shar: "error transmitting 'macbinary.c'" '(should have been 13547 characters)'
fi
fi
echo shar: "extracting 'globals.c'" '(422 characters)'
if test -f 'globals.c'
then
	echo shar: "will not over-write existing file 'globals.c'"
else
sed 's/^X//' << \SHAR_EOF > 'globals.c'
X#include "globals.h"
X#include "../fileio/machdr.h"
X#include "../fileio/wrfile.h"
X#include "../fileio/kind.h"
X
Xchar info[INFOBYTES];
Xchar text[F_NAMELEN+1];
X
Xint list, verbose, info_only, query, write_it, indent, dir_skip, no_dd;
XFILE *infp;
Xint in_data_size = -1;
Xint in_rsrc_size = -1;
Xint in_ds, in_rs, ds_skip, rs_skip;
X
X#ifdef SCAN
Xvoid do_error(string)
Xchar *string;
X{
X    do_idf(string, ERROR);
X}
X#endif /* SCAN */
X
SHAR_EOF
if test 422 -ne "`wc -c < 'globals.c'`"
then
	echo shar: "error transmitting 'globals.c'" '(should have been 422 characters)'
fi
fi
echo shar: "extracting 'crc.c'" '(52 characters)'
if test -f 'crc.c'
then
	echo shar: "will not over-write existing file 'crc.c'"
else
sed 's/^X//' << \SHAR_EOF > 'crc.c'
Xunsigned long crcinit;
X
Xunsigned long (*updcrc)();
X
SHAR_EOF
if test 52 -ne "`wc -c < 'crc.c'`"
then
	echo shar: "error transmitting 'crc.c'" '(should have been 52 characters)'
fi
fi
echo shar: "extracting 'dir.c'" '(1357 characters)'
if test -f 'dir.c'
then
	echo shar: "will not over-write existing file 'dir.c'"
else
sed 's/^X//' << \SHAR_EOF > 'dir.c'
X#include "globals.h"
X#include "../fileio/machdr.h"
X#include "../fileio/wrfile.h"
X#include "../util/util.h"
X#include "../util/masks.h"
X
Xextern char *malloc();
Xextern char *realloc();
X
Xstatic char *dir_stack;
Xstatic int dir_ptr = -64;
Xstatic int dir_max;
X
Xvoid dir(hdr)
Xchar *hdr;
X{
Xint doit;
X
X    if((hdr[I_NAMEOFF] & BYTEMASK) == 0x80) {
X	if(dir_skip) {
X	    dir_skip--;
X	    return;
X	}
X	indent--;
X	if(list) {
X	    do_indent(indent);
X	    (void)fprintf(stderr, "leaving folder \"%s\"\n",
X		    dir_stack + dir_ptr);
X	}
X	if(!info_only) {
X	    enddir();
X	}
X	dir_ptr -= 64;
X	return;
X    }
X    if(dir_skip) {
X	dir_skip++;
X	return;
X    }
X    dir_ptr += 64;
X    if(dir_ptr == dir_max) {
X	if(dir_max == 0) {
X	    dir_stack = malloc(64);
X	} else {
X	    dir_stack = realloc(dir_stack, (unsigned)dir_max + 64);
X	}
X	dir_max += 64;
X	if(dir_stack == NULL) {
X	    (void)fprintf(stderr, "Insufficient memory\n");
X	    exit(1);
X	}
X    }
X    transname(hdr + I_NAMEOFF + 1, dir_stack + dir_ptr,
X	      (int)(hdr[I_NAMEOFF] & 0x7f));
X    doit = 1;
X    if(list) {
X	do_indent(indent);
X	(void)fprintf(stderr, "folder=\"%s\"", dir_stack + dir_ptr);
X	if(query) {
X	    doit = do_query();
X	} else {
X	    (void)fputc('\n', stderr);
X	}
X    }
X    if(!doit) {
X	dir_ptr -= 64;
X	dir_skip = 1;
X	return;
X    }
X    if(!info_only) {
X	do_mkdir(dir_stack + dir_ptr, hdr);
X    }
X    indent++;
X}
X
SHAR_EOF
if test 1357 -ne "`wc -c < 'dir.c'`"
then
	echo shar: "error transmitting 'dir.c'" '(should have been 1357 characters)'
fi
fi
echo shar: "extracting 'bin.c'" '(1784 characters)'
if test -f 'bin.c'
then
	echo shar: "will not over-write existing file 'bin.c'"
else
sed 's/^X//' << \SHAR_EOF > 'bin.c'
X#include "macunpack.h"
X#ifdef BIN
X#include "globals.h"
X#include "../fileio/machdr.h"
X#include "../fileio/wrfile.h"
X#include "../fileio/kind.h"
X#include "../util/util.h"
X#include "../util/masks.h"
X
Xextern void mcb();
X
Xvoid bin(header, data_size, UMcp)
Xchar *header;
Xint data_size, UMcp;
X{
X    char hdr[INFOBYTES];
X    unsigned long rsrcLength, dataLength;
X
X    hdr[0] = getb(infp);
X    (void)ungetc(hdr[0], infp);
X    if(hdr[0] != 0) {
X	if(!strncmp(header + I_AUTHOFF, "BnHq", 4) && hdr[0] == '(') {
X	    do_indent(indent);
X	    (void)fprintf(stderr, "Sorry, this is a fake BinHex 5.0 file.  ");
X	    (void)fprintf(stderr, "Debinhex with hexbin first.\n");
X#ifdef SCAN
X	    do_error("macunpack: fake BinHex 5.0");
X#endif /* SCAN */
X	} else {
X	    do_indent(indent);
X	    (void)fprintf(stderr, "Sorry, contents not recognized.\n");
X#ifdef SCAN
X	    do_error("macunpack: contents not recognized");
X#endif /* SCAN */
X	}
X	do_indent(indent);
X	(void)fprintf(stderr, "Copying as a plain file.\n");
X#ifdef SCAN
X	do_idf("", COPY);
X#endif /* SCAN */
X	mcb(header, (unsigned long)in_data_size, (unsigned long)in_rsrc_size,
X	    in_ds + in_rs);
X	ds_skip = 0;
X	rs_skip = 0;
X	in_ds = 0;
X	in_rs = 0;
X	return;
X    }
X    if(fread(hdr, 1, INFOBYTES - 1, infp) != INFOBYTES) {
X	(void)fprintf(stderr, "Can't read file header\n");
X#ifdef SCAN
X	do_error("macunpack: Can't read file header");
X#endif /* SCAN */
X	exit(1);
X    }
X    rsrcLength = get4(hdr + I_RLENOFF);
X    dataLength = get4(hdr + I_DLENOFF);
X    if(UMcp) {
X	/* Why this?  Moreover, we are losing the bundle bit! */
X	put4(hdr + I_RLENOFF, ++rsrcLength);
X	put4(hdr + I_DLENOFF, ++dataLength);
X    }
X    mcb(hdr, rsrcLength, dataLength, data_size - INFOBYTES);
X}
X#else /* BIN */
Xint bin; /* keep lint and some compilers happy */
X#endif /* BIN */
X
SHAR_EOF
if test 1784 -ne "`wc -c < 'bin.c'`"
then
	echo shar: "error transmitting 'bin.c'" '(should have been 1784 characters)'
fi
fi
echo shar: "extracting 'crc.h'" '(306 characters)'
if test -f 'crc.h'
then
	echo shar: "will not over-write existing file 'crc.h'"
else
sed 's/^X//' << \SHAR_EOF > 'crc.h'
X#define INIT_CRC crcinit
X
Xextern unsigned long arc_crcinit;
Xextern unsigned long binhex_crcinit;
Xextern unsigned long zip_crcinit;
X
Xextern unsigned long arc_updcrc();
Xextern unsigned long binhex_updcrc();
Xextern unsigned long zip_updcrc();
X
Xextern unsigned long crcinit;
Xextern unsigned long (*updcrc)();
X
SHAR_EOF
if test 306 -ne "`wc -c < 'crc.h'`"
then
	echo shar: "error transmitting 'crc.h'" '(should have been 306 characters)'
fi
fi
echo shar: "extracting 'globals.h'" '(302 characters)'
if test -f 'globals.h'
then
	echo shar: "will not over-write existing file 'globals.h'"
else
sed 's/^X//' << \SHAR_EOF > 'globals.h'
X#include <stdio.h>
X
Xextern void exit();
Xextern void transname();
Xextern void do_error();
X
Xextern char info[];
Xextern char text[];
X
Xextern int list, verbose, info_only, query, write_it, indent, dir_skip, no_dd;
Xextern FILE *infp;
X
Xextern int in_data_size, in_rsrc_size, in_ds, in_rs, ds_skip, rs_skip;
X
SHAR_EOF
if test 302 -ne "`wc -c < 'globals.h'`"
then
	echo shar: "error transmitting 'globals.h'" '(should have been 302 characters)'
fi
fi
echo shar: "extracting 'pit.h'" '(870 characters)'
if test -f 'pit.h'
then
	echo shar: "will not over-write existing file 'pit.h'"
else
sed 's/^X//' << \SHAR_EOF > 'pit.h'
X#define H_NAMELEN 63
X
X#define H_NLENOFF 0
X#define H_NAMEOFF 1
X#define H_TYPEOFF 64
X#define H_AUTHOFF 68
X#define H_FLAGOFF 72
X#define	H_LOCKOFF 74
X#define H_DLENOFF 76
X#define H_RLENOFF 80
X#define H_CTIMOFF 84
X#define H_MTIMOFF 88
X#define H_HDRCRC  92
X#define HDRBYTES  94
X
Xstruct pit_header {		/* Packit file header (92 bytes) */
X	unsigned char nlen;	/* number of characters in packed file name */
X	char name[63];		/* name of packed file */
X	char type[4];		/* file type */
X	char auth[4];		/* file creator */
X	unsigned short flags;	/* file flags (?) */
X	unsigned short lock;	/* unknown */
X	unsigned long dlen;	/* number of bytes in data fork */
X	unsigned long rlen;	/* number of bytes in resource fork */
X	unsigned long ctim;	/* file creation time */
X	unsigned long mtim;	/* file modified time */
X	unsigned short hdrCRC;	/* CRC */
X};
X
X#define nocomp	0
X#define huffman	1
X
SHAR_EOF
if test 870 -ne "`wc -c < 'pit.h'`"
then
	echo shar: "error transmitting 'pit.h'" '(should have been 870 characters)'
fi
fi
echo shar: "extracting 'sit.h'" '(2682 characters)'
if test -f 'sit.h'
then
	echo shar: "will not over-write existing file 'sit.h'"
else
sed 's/^X//' << \SHAR_EOF > 'sit.h'
X#define S_SIGNATURE    0
X#define S_NUMFILES     4
X#define S_ARCLENGTH    6
X#define S_SIGNATURE2  10
X#define	S_VERSION     14
X#define SITHDRSIZE    22
X
X#define F_COMPRMETHOD    0
X#define F_COMPDMETHOD    1
X#define F_FNAME          2
X#define F_FTYPE         66
X#define F_CREATOR       70
X#define F_FNDRFLAGS     74
X#define F_CREATIONDATE  76
X#define F_MODDATE       80
X#define F_RSRCLENGTH    84
X#define F_DATALENGTH    88
X#define F_COMPRLENGTH   92
X#define F_COMPDLENGTH   96
X#define F_RSRCCRC      100
X#define F_DATACRC      102
X#define F_HDRCRC       110
X#define FILEHDRSIZE    112
X
Xtypedef long OSType;
X
Xtypedef struct sitHdr {			/* 22 bytes */
X	OSType	signature;		/* = 'SIT!' -- for verification */
X	unsigned short	numFiles;	/* number of files in archive */
X	unsigned long	arcLength;	/* length of entire archive incl.
X						hdr. -- for verification */
X	OSType	signature2;		/* = 'rLau' -- for verification */
X	unsigned char	version;	/* version number */
X	char reserved[7];
X};
X
Xtypedef struct fileHdr {		/* 112 bytes */
X	unsigned char	compRMethod;	/* rsrc fork compression method */
X	unsigned char	compDMethod;	/* data fork compression method */
X	unsigned char	fName[64];	/* a STR63 */
X	OSType	fType;			/* file type */
X	OSType	fCreator;		/* er... */
X	unsigned short FndrFlags;	/* copy of Finder flags.  For our
X						purposes, we can clear:
X						busy,onDesk */
X	unsigned long	creationDate;
X	unsigned long	modDate;	/* !restored-compat w/backup prgms */
X	unsigned long	rsrcLength;	/* decompressed lengths */
X	unsigned long	dataLength;
X	unsigned long	compRLength;	/* compressed lengths */
X	unsigned long	compDLength;
X	unsigned short rsrcCRC;		/* crc of rsrc fork */
X	unsigned short dataCRC;		/* crc of data fork */
X	char reserved[6];
X	unsigned short hdrCRC;		/* crc of file header */
X};
X
X
X/* file format is:
X	sitArchiveHdr
X		file1Hdr
X			file1RsrcFork
X			file1DataFork
X		file2Hdr
X			file2RsrcFork
X			file2DataFork
X		.
X		.
X		.
X		fileNHdr
X			fileNRsrcFork
X			fileNDataFork
X*/
X
X
X
X/* compression methods */
X#define nocomp	0	/* just read each byte and write it to archive */
X#define rle	1	/* RLE compression */
X#define lzc	2	/* LZC compression */
X#define huffman	3	/* Huffman compression */
X#define lzah	5	/* LZ with adaptive Huffman */
X#define fixhuf	6	/* Fixed Huffman table */
X#define mw	8	/* Miller-Wegman encoding */
X/* this bit says whether the file is protected or not */
X#define prot	16	/* password protected bit */
X/* rsrc & data compress are identical here: */
X#define sfolder	32	/* start of folder */
X#define efolder	33	/* end of folder */
X#define sknown	0x16f	/* known compression methods */
X
X/* all other numbers are reserved */
X
X#define	ESC	0x90	/* repeat packing escape */
X
SHAR_EOF
if test 2682 -ne "`wc -c < 'sit.h'`"
then
	echo shar: "error transmitting 'sit.h'" '(should have been 2682 characters)'
fi
fi
echo shar: "extracting 'huffman.h'" '(222 characters)'
if test -f 'huffman.h'
then
	echo shar: "will not over-write existing file 'huffman.h'"
else
sed 's/^X//' << \SHAR_EOF > 'huffman.h'
X#define	HUFF_BE		0
X#define	HUFF_LE		1
X
Xtypedef struct node {
X    int flag, byte;
X    struct node *one, *zero;
X} node;
X
Xextern int (*get_bit)();
Xextern void clrhuff();
X
Xextern struct node nodelist[];
Xextern int bytesread;
X
SHAR_EOF
if test 222 -ne "`wc -c < 'huffman.h'`"
then
	echo shar: "error transmitting 'huffman.h'" '(should have been 222 characters)'
fi
fi
echo shar: "extracting 'cpt.h'" '(2461 characters)'
if test -f 'cpt.h'
then
	echo shar: "will not over-write existing file 'cpt.h'"
else
sed 's/^X//' << \SHAR_EOF > 'cpt.h'
X#define C_SIGNATURE    0
X#define C_VOLUME       1
X#define C_XMAGIC       2
X#define C_IOFFSET      4
X#define CPTHDRSIZE     8
X
X#define C_HDRCRC       0
X#define C_ENTRIES      4
X#define C_COMMENT      6
X#define CPTHDR2SIZE    7
X
X#define CHDRSIZE       (CPTHDRSIZE+CPTHDR2SIZE)
X
X#define F_FNAME          0
X#define F_FOLDER        32
X#define F_FOLDERSIZE	33
X#define F_VOLUME        35
X#define F_FILEPOS       36
X#define F_FTYPE         40
X#define F_CREATOR       44
X#define F_CREATIONDATE  48
X#define F_MODDATE       52
X#define F_FNDRFLAGS     56
X#define F_FILECRC       58
X#define F_CPTFLAG       62
X#define F_RSRCLENGTH    64
X#define F_DATALENGTH    68
X#define F_COMPRLENGTH   72
X#define F_COMPDLENGTH   76
X#define FILEHDRSIZE     80
X
Xtypedef long	OSType;
X
Xtypedef struct cptHdr {			/* 8 bytes */
X	unsigned char	signature;	/* = 1 -- for verification */
X	unsigned char	volume;		/* for multi-file archives */
X	unsigned short	xmagic;		/* verification multi-file consistency*/
X	unsigned long	offset;		/* index offset */
X/* The following are really in header2 at offset */
X	unsigned long	hdrcrc;		/* header crc */
X	unsigned short	entries;	/* number of index entries */
X	unsigned char	commentsize;	/* number of bytes comment that follow*/
X};
X
Xtypedef struct fileHdr {		/* 78 bytes */
X	unsigned char	fName[32];	/* a STR32 */
X	unsigned char	folder;		/* set to 1 if a folder */
X	unsigned short	foldersize;	/* number of entries in folder */
X	unsigned char	volume;		/* for multi-file archives */
X	unsigned long	filepos;	/* position of data in file */
X	OSType	fType;			/* file type */
X	OSType	fCreator;		/* er... */
X	unsigned long	creationDate;
X	unsigned long	modDate;	/* !restored-compat w/backup prgms */
X	unsigned short FndrFlags;	/* copy of Finder flags.  For our
X						purposes, we can clear:
X						busy,onDesk */
X	unsigned long	fileCRC;	/* crc on file */
X	unsigned short	cptFlag;	/* cpt flags */
X	unsigned long	rsrcLength;	/* decompressed lengths */
X	unsigned long	dataLength;
X	unsigned long	compRLength;	/* compressed lengths */
X	unsigned long	compDLength;
X};
X
X
X/* file format is:
X	cptArchiveHdr
X		file1data
X			file1RsrcFork
X			file1DataFork
X		file2data
X			file2RsrcFork
X			file2DataFork
X		.
X		.
X		.
X		fileNdata
X			fileNRsrcFork
X			fileNDataFork
X	cptIndex
X*/
X
X
X
X/* cpt flags */
X#define encryp	1	/* file is encrypted */
X#define crsrc	2	/* resource fork is compressed */
X#define cdata	4	/* data fork is compressed */
X/*      ????	8	/* unknown */
X
X#define CIRCSIZE	8192
X
SHAR_EOF
if test 2461 -ne "`wc -c < 'cpt.h'`"
then
	echo shar: "error transmitting 'cpt.h'" '(should have been 2461 characters)'
fi
fi
echo shar: "extracting 'stf.c'" '(4993 characters)'
if test -f 'stf.c'
then
	echo shar: "will not over-write existing file 'stf.c'"
else
sed 's/^X//' << \SHAR_EOF > 'stf.c'
X#include "macunpack.h"
X#ifdef STF
X#include "stf.h"
X#include "globals.h"
X#include "huffman.h"
X#include "../util/curtime.h"
X#include "../fileio/wrfile.h"
X#include "../fileio/machdr.h"
X#include "../util/util.h"
X
Xextern void de_huffman();
Xextern void set_huffman();
X
Xtypedef struct{
X    int num;
X    int next;
X} table_struct;
X
Xstatic table_struct table[511];
Xstatic char length[256];
X
Xstatic void stf_wrfile();
Xstatic void stf_wrfork();
Xstatic void stf_construct();
X
Xvoid stf(ibytes)
Xunsigned long ibytes;
X{
X    char magic[3], fauth[5], ftype[5];
X    int filel, i;
X    unsigned int rsrcLength, dataLength;
X    unsigned long curtime;
X
X    set_huffman(HUFF_LE);
X    for(i = 0; i < 3; i++) {
X	magic[i] = getb(infp);
X    }
X    if(strncmp(magic, MAGIC, 3)) {
X	(void)fprintf(stderr, "Error in magic header.\n");
X#ifdef SCAN
X	do_error("macunpack: Error in magic header");
X#endif /* SCAN */
X	exit(1);
X    }
X    for(i = 0; i < INFOBYTES; i++) {
X	info[i] = 0;
X    }
X    filel = getb(infp);
X    info[I_NAMEOFF] = filel;
X    i = filel;
X    for(i = 1; i <= filel; i++) {
X	info[I_NAMEOFF + i] = getb(infp);
X    }
X    for(i = 0; i < 4; i++) {
X	info[I_TYPEOFF + i] = getb(infp);
X    }
X    for(i = 0; i < 4; i++) {
X	info[I_AUTHOFF + i] = getb(infp);
X    }
X    curtime = (unsigned long)time((time_t *)0) + TIMEDIFF;
X    put4(info + I_CTIMOFF, curtime);
X    put4(info + I_MTIMOFF, curtime);
X    rsrcLength = 0;
X    for(i = 0; i < 4; i++) {
X	rsrcLength = (rsrcLength << 8) + getb(infp);
X    }
X    put4(info + I_RLENOFF, (unsigned long)rsrcLength);
X    dataLength = 0;
X    for(i = 0; i < 4; i++) {
X	dataLength = (dataLength << 8) + getb(infp);
X    }
X    put4(info + I_DLENOFF, (unsigned long)dataLength);
X    ibytes -= filel + 20;
X    write_it = 1;
X    if(list) {
X	transname(info + I_NAMEOFF + 1, text, (int)info[I_NAMEOFF]);
X	transname(info + I_TYPEOFF, ftype, 4);
X	transname(info + I_AUTHOFF, fauth, 4);
X	do_indent(indent);
X	(void)fprintf(stderr,
X		"name=\"%s\", type=%4.4s, author=%4.4s, data=%25ld%2c.html rsrc=%ld",
X		text, ftype, fauth, (long)dataLength, (long)rsrcLength);
X	if(info_only) {
X	    write_it = 0;
X	}
X	if(query) {
X	    write_it = do_query();
X	} else {
X	    (void)fputc('\n', stderr);
X	}
X    }
X    stf_wrfile((unsigned long)rsrcLength, (unsigned long)dataLength, ibytes);
X}
X
Xstatic void stf_wrfile(rsrcLength, dataLength, ibytes)
Xunsigned long rsrcLength, dataLength, ibytes;
X{
X    unsigned long num = 0;
X
X    if(write_it) {
X	define_name(text);
X	start_info(info, rsrcLength, dataLength);
X	start_rsrc();
X	stf_wrfork(&num, rsrcLength, 0);
X	start_data();
X	stf_wrfork(&num, rsrcLength + dataLength, (int)(rsrcLength & 0xfff));
X	end_file();
X    } else {
X	for(num = 0; num < ibytes; num++) {
X	    (void)getb(infp);
X	}
X    }
X    if(verbose) {
X	(void)fprintf(stderr, "\tHuffman compressed (%4.1f%%).\n",
X		100.0 * ibytes / (rsrcLength + dataLength));
X    }
X}
X
Xstatic void stf_wrfork(num, towrite, offs)
Xunsigned long *num, towrite;
Xint offs;
X{
X    int c, k, max, i, i1;
X    char *tmp_out_ptr;
X
X    while(*num < towrite) {
X	if((*num & 0xfff) == 0) {
X	    clrhuff();
X	    c = getb(infp) & 0xff;
X	    k = c;
X	    max = 0;
X	    for(i = 0; i < k; i++) {
X		c = getb(infp) & 0xff;
X		nodelist[i + 1].flag = 1;
X		nodelist[i + 1].byte = i + 1;
X		table[i + 1].num = c;
X		table[i + 1].next = 0;
X		if(c > max) {
X		    max = c;
X		}
X	    }
X	    for(i = k; i < 32; i++) {
X		nodelist[i + 1].flag = 1;
X		nodelist[i + 1].byte = i + 1;
X		table[i + 1].num = 0;
X		table[i + 1].next = 0;
X	    }
X	    k = 0;
X	    for(i = 0; i <= max; i++) {
X		for(i1 = 1; i1 < 33; i1++) {
X		    if(table[i1].num == i) {
X			table[k].next = i1;
X			k = i1;
X		    }
X		}
X	    }
X	    stf_construct(32);
X	    tmp_out_ptr = out_ptr;
X	    out_ptr = length;
X	    de_huffman((unsigned long)256);
X	    out_ptr = tmp_out_ptr;
X	    for(i = 1; i < 257; i++) {
X		table[i].num = 0x40000000 >> length[i - 1];
X		nodelist[i].flag = 1;
X		nodelist[i].byte = i - 1;
X		table[i].next = 0;
X	    }
X	    k = 0;
X	    for(i = 1; i < 0x40000000; i <<= 1) {
X		for(i1 = 1; i1 < 257; i1++) {
X		    if(table[i1].num == i) {
X			table[k].next = i1;
X			k = i1;
X		    }
X		}
X	    }
X	    stf_construct(256);
X	}
X	i = 0x1000 - offs;
X	offs = 0;
X	if(i > towrite - *num) {
X	    i = towrite - *num;
X	}
X	de_huffman((unsigned long)i);
X	*num += i;
X    }
X}
X
Xstatic void stf_construct(n)
Xint n;
X{
X    int i, i1, i2, j1, k;
X
X    j1 = n + 1;
X    i = table[0].next;
X    i1 = table[i].next;
X    while(table[i1].next != 0) {
X	k = table[i].num + table[i1].num;
X	table[j1].num = k;
X	nodelist[j1].flag = 0;
X	nodelist[j1].zero = nodelist + i;
X	nodelist[j1].one = nodelist + i1;
X	i2 = i1;
X	i = table[i2].next;
X	while(i != 0 && table[i].num <= k) {
X	    i2 = i;
X	    i = table[i].next;
X	}
X	table[j1].next = i;
X	table[i2].next = j1;
X	i = table[i1].next;
X	i1 = table[i].next;
X	j1++;
X    }
X    table[0].num = table[i].num + table[i1].num;
X    nodelist[0].flag = 0;
X    nodelist[0].zero = nodelist + i;
X    nodelist[0].one = nodelist + i1;
X}
X#else /* STF */
Xint stf; /* keep lint and some compilers happy */
X#endif /* STF */
X
SHAR_EOF
if test 4993 -ne "`wc -c < 'stf.c'`"
then
	echo shar: "error transmitting 'stf.c'" '(should have been 4993 characters)'
fi
fi
echo shar: "extracting 'zma.h'" '(2074 characters)'
if test -f 'zma.h'
then
	echo shar: "will not over-write existing file 'zma.h'"
else
sed 's/^X//' << \SHAR_EOF > 'zma.h'
X#include "zmahdr.h"
X
X#define	Z_HDRSIZE	78
X
X#define	Z_WHAT		0	/* What kind of data? */
X#define	Z_HLEN		1	/* Header length */
X#define	Z_BFLAGS	2	/* Boolean flags */
X#define	Z_NEXT		4	/* Pointer to next entry */
X#define	Z_CRLEN		8	/* Length compressed resource */
X#define	Z_CDLEN		12	/* Length compressed data */
X#define	Z_URLEN		16	/* Length uncompressed resource */
X#define	Z_UDLEN		20	/* Length uncompressed data */
X#define	Z_TYPE		24	/* File type */
X#define	Z_AUTH		28	/* File creator */
X#define Z_CONTS		28	/* Directory contents pointer; overlayed */
X#define	Z_MDATE		32	/* Date */
X#define	Z_COMMENT	36	/* Comment offset, currently unused */
X#define	Z_FLAGS		40	/* Finder flags */
X#define	Z_DCRC		42	/* Data crc */
X#define	Z_RCRC		44	/* Resource crc */
X#define	Z_FNAME		46	/* File name length and name */
X
Xtypedef struct fileHdr {		/* 78 bytes */
X	char		deleted;	/* Not in original, split off from: */
X	char		what;		/* What kind?  Negative if deleted */
X	unsigned char	hlen ;		/* Header length */
X	unsigned short	boolFlags;	/* Boolean flags */
X	unsigned long	next;		/* Next entry */
X	unsigned long	compRLength;	/* The compressed lengths. */
X	unsigned long	compDLength;	/* For dirs, the second is # entries */
X	unsigned long	rsrcLength;	/* The uncompressed lengths. */
X	unsigned long	dataLength;
X	unsigned long	fType;		/* file type */
X	unsigned long	fCreator;	/* er... */
X	unsigned long	modDate;	/* !restored-compat w/backup prgms */
X	unsigned long	comment;	/* Comment offset */
X	unsigned short	FndrFlags;	/* copy of Finder flags.  For our
X						purposes, we can clear:
X						busy,onDesk */
X	unsigned short	dataCRC;	/* Data fork crc */
X	unsigned short	rsrcCRC;	/* Resource fork crc */
X	unsigned char	fName[32];	/* a STR32 */
X	/* The following are overlayed in the original structure */
X	unsigned long	conts;		/* Pointer to directory contents */
X};
X
X/* zma types (see what) */
X#define	z_noth	0	/* ??? */
X#define z_file	1	/* file is compressed */
X#define z_plain	2	/* file is uncompressed */
X#define	z_dir	3	/* directory */
X#define	z_plug	4	/* for plug in, not supported */
X
SHAR_EOF
if test 2074 -ne "`wc -c < 'zma.h'`"
then
	echo shar: "error transmitting 'zma.h'" '(should have been 2074 characters)'
fi
fi
echo shar: "extracting 'stf.h'" '(300 characters)'
if test -f 'stf.h'
then
	echo shar: "will not over-write existing file 'stf.h'"
else
sed 's/^X//' << \SHAR_EOF > 'stf.h'
X#define MAGIC	"RTH"
X
X#define	S_MAGIC		0
X#define	S_FLENGTH	3
X#define	S_RSRCLNGTH	3	/* + NAMELENGTH */
X#define	S_DATALNGTH	7	/* + NAMELENGTH */
X
Xtypedef struct fileHdr {
X	char		magic[3];
X	char		flength;
X	char		fname[32];	/* actually flength */
X	unsigned long	rsrcLength;
X	unsigned long	dataLength;
X};
X
SHAR_EOF
if test 300 -ne "`wc -c < 'stf.h'`"
then
	echo shar: "error transmitting 'stf.h'" '(should have been 300 characters)'
fi
fi
echo shar: "extracting 'bits_be.h'" '(220 characters)'
if test -f 'bits_be.h'
then
	echo shar: "will not over-write existing file 'bits_be.h'"
else
sed 's/^X//' << \SHAR_EOF > 'bits_be.h'
X#define	BITBUFSIZ	16
X
Xextern unsigned int bit_be_bitbuf;
Xextern char *bit_be_filestart;
Xextern int bit_be_inbytes;
X
Xextern void bit_be_fillbuf();
Xextern unsigned int bit_be_getbits();
Xextern void bit_be_init_getbits();
X
SHAR_EOF
if test 220 -ne "`wc -c < 'bits_be.h'`"
then
	echo shar: "error transmitting 'bits_be.h'" '(should have been 220 characters)'
fi
fi
echo shar: "extracting 'bits_be.c'" '(947 characters)'
if test -f 'bits_be.c'
then
	echo shar: "will not over-write existing file 'bits_be.c'"
else
sed 's/^X//' << \SHAR_EOF > 'bits_be.c'
X#include "../util/masks.h"
X#include "bits_be.h"
X
Xunsigned int bit_be_bitbuf;
Xchar *bit_be_filestart;
Xint bit_be_inbytes;
X
Xstatic unsigned int bit_be_subbitbuf;
Xstatic int bit_be_bitcount;
X
Xvoid bit_be_fillbuf(n)  /* Shift bit_be_bitbuf n bits left, read n bits */
Xint n;
X{
X    bit_be_bitbuf <<= n;
X    while (n > bit_be_bitcount) {
X	bit_be_bitbuf |= bit_be_subbitbuf << (n -= bit_be_bitcount);
X	if(bit_be_inbytes == 0) {
X	    bit_be_subbitbuf = 0;
X	} else {
X	    bit_be_subbitbuf = *bit_be_filestart++ & BYTEMASK;
X	    bit_be_inbytes--;
X	}
X	bit_be_bitcount = 8;
X    }
X    bit_be_bitbuf |= bit_be_subbitbuf >> (bit_be_bitcount -= n);
X    bit_be_bitbuf &= WORDMASK;
X}
X
Xunsigned int bit_be_getbits(n)
Xint n;
X{
X    unsigned int x;
X
X    x = bit_be_bitbuf >> (BITBUFSIZ - n);
X    bit_be_fillbuf(n);
X    return x;
X}
X
Xvoid bit_be_init_getbits()
X{
X    bit_be_bitbuf = 0;
X    bit_be_subbitbuf = 0;
X    bit_be_bitcount = 0;
X    bit_be_fillbuf(BITBUFSIZ);
X}
X
SHAR_EOF
if test 947 -ne "`wc -c < 'bits_be.c'`"
then
	echo shar: "error transmitting 'bits_be.c'" '(should have been 947 characters)'
fi
fi
echo shar: "extracting 'zmahdr.h'" '(68 characters)'
if test -f 'zmahdr.h'
then
	echo shar: "will not over-write existing file 'zmahdr.h'"
else
sed 's/^X//' << \SHAR_EOF > 'zmahdr.h'
X#define ZMAHDR	"\005\237\032"
X#define ZMAHDRS	3
X#define ZMAHDRS2	7
X
SHAR_EOF
if test 68 -ne "`wc -c < 'zmahdr.h'`"
then
	echo shar: "error transmitting 'zmahdr.h'" '(should have been 68 characters)'
fi
fi
echo shar: "extracting 'macunpack.c'" '(4173 characters)'
if test -f 'macunpack.c'
then
	echo shar: "will not over-write existing file 'macunpack.c'"
else
sed 's/^X//' << \SHAR_EOF > 'macunpack.c'
X#include "macunpack.h"
X#include "globals.h"
X#include "../util/patchlevel.h"
X#include "../fileio/wrfile.h"
X#include "../fileio/wrfileopt.h"
X#include "../fileio/kind.h"
X#include "../util/util.h"
X
X#define LOCALOPT	"ilvqVH"
X
Xextern char *strcat();
X#ifdef STF
Xextern void stf();
X#endif /* STF */
X#ifdef PIT
Xextern void pit();
X#endif /* PIT */
X#ifdef SIT
Xextern void sit();
X#endif /* SIT */
X#ifdef CPT
Xextern void cpt();
X#endif /* CPT */
Xvoid macbinary();
X
Xstatic void usage();
X
Xstatic char options[128];
X
Xint main(argc, argv)
Xint argc;
Xchar *argv[];
X{
X    int c;
X    extern int optind;
X    extern char *optarg;
X    int errflg;
X
X    set_wrfileopt(0);
X    (void)strcat(options, get_wrfileopt());
X    (void)strcat(options, LOCALOPT);
X    errflg = 0;
X
X    while((c = getopt(argc, argv, options)) != EOF) {
X#ifdef SCAN
X	if(c == 'S') {
X	    no_dd++;
X	}
X#endif /* SCAN */
X	if(!wrfileopt((char)c)) {
X	    switch(c) {
X	    case 'l':
X		list++;
X		break;
X	    case 'q':
X		query++;
X		break;
X	    case 'v':
X		verbose++;
X		break;
X	    case 'i':
X		info_only++;
X		break;
X	    case '?':
X		errflg++;
X		break;
X	    case 'H':
X		give_wrfileopt();
X		(void)fprintf(stderr, "Macunpack specific options:\n");
X		(void)fprintf(stderr,
X			"-i:\tgive information only, do not unpack\n");
X		(void)fprintf(stderr, "-l:\tgive listing\n");
X		(void)fprintf(stderr, "-v:\tgive verbose listing\n");
X		(void)fprintf(stderr,
X			"-q:\tquery for every file/folder before unpacking\n");
X		(void)fprintf(stderr,
X			"-V:\tgive information about this version\n");
X		(void)fprintf(stderr, "-H:\tthis message\n");
X		(void)fprintf(stderr, "Default is silent unpacking\n");
X		exit(0);
X	    case 'V':
X		(void)fprintf(stderr, "Version %s, ", VERSION);
X		(void)fprintf(stderr, "patchlevel %d", PATCHLEVEL);
X		(void)fprintf(stderr, "%s.\n", get_mina());
X		(void)fprintf(stderr, "Archive/file types recognized:\n");
X#ifdef BIN
X		(void)fprintf(stderr,
X			"\tBinHex 5.0, MacBinary 1.0 and UMCP (with caveat)\n");
X#endif /* BIN */
X#ifdef JDW
X		(void)fprintf(stderr, "\tCompress It\n");
X#endif /* JDW */
X#ifdef STF
X		(void)fprintf(stderr, "\tShrinkToFit\n");
X#endif /* STF */
X#ifdef LZC
X		(void)fprintf(stderr, "\tMacCompress\n");
X#endif /* LZC */
X#ifdef ASQ
X		(void)fprintf(stderr, "\tAutoSqueeze\n");
X#endif /* ASQ */
X#ifdef ARC
X		(void)fprintf(stderr, "\tArcMac\n");
X#endif /* ARC */
X#ifdef PIT
X		(void)fprintf(stderr, "\tPackIt\n");
X#endif /* PIT */
X#ifdef SIT
X		(void)fprintf(stderr, "\tStuffIt and StuffIt Deluxe\n");
X#endif /* SIT */
X#ifdef DIA
X		(void)fprintf(stderr, "\tDiamond\n");
X#endif /* DIA */
X#ifdef CPT
X		(void)fprintf(stderr, "\tCompactor\n");
X#endif /* CPT */
X#ifdef ZMA
X		(void)fprintf(stderr, "\tZoom\n");
X#endif /* ZMA */
X#ifdef LZH
X		(void)fprintf(stderr, "\tMacLHa\n");
X#endif /* LZH */
X#ifdef DD
X		(void)fprintf(stderr, "\tDiskDoubler\n");
X#endif /* DD */
X		exit(0);
X	    }
X	}
X    }
X    if(errflg) {
X	usage();
X	exit(1);
X    }
X
X    if(optind == argc) {
X	infp = stdin;
X    } else {
X	if((infp = fopen(argv[optind], "r")) == NULL) {
X	    (void)fprintf(stderr,"Can't open input file \"%s\"\n",argv[optind]);
X	    exit(1);
X	}
X#ifdef SCAN
X	do_idf(argv[optind], UNIX_NAME);
X#endif /* SCAN */
X    }
X
X    if(info_only || verbose || query) {
X	list++;
X    }
X    c = getc(infp);
X    (void)ungetc(c, infp);
X    switch(c) {
X    case 0:
X	macbinary();
X	break;
X#ifdef STF
X    case 'R':
X	if(verbose) {
X	    (void)fprintf(stderr, "This is a \"ShrinkToFit\" packed file.\n");
X	}
X	stf(~(unsigned long)1);
X	break;
X#endif /* STF */
X#ifdef PIT
X    case 'P':
X	if(verbose) {
X	    (void)fprintf(stderr, "This is a \"PackIt\" archive.\n");
X	}
X	pit();
X	break;
X#endif /* PIT */
X#ifdef SIT
X    case 'S':
X	if(verbose) {
X	    (void)fprintf(stderr, "This is a \"StuffIt\" archive.\n");
X	}
X	sit();
X	break;
X#endif /* SIT */
X#ifdef CPT
X    case 1:
X	if(verbose) {
X	    (void)fprintf(stderr, "This is a \"Compactor\" archive.\n");
X	}
X	cpt();
X	break;
X#endif /* CPT */
X    default:
X	(void)fprintf(stderr, "Unrecognized archive type\n");
X	exit(1);
X    }
X    exit(0);
X    /* NOTREACHED */
X}
X
Xstatic void usage()
X{
X    (void)fprintf(stderr, "Usage: macunpack [-%s] [filename]\n", options);
X    (void)fprintf(stderr, "Use \"macunpack -H\" for help.\n");
X}
X
SHAR_EOF
if test 4173 -ne "`wc -c < 'macunpack.c'`"
then
	echo shar: "error transmitting 'macunpack.c'" '(should have been 4173 characters)'
fi
fi
echo shar: "extracting 'macunpack.h'" '(571 characters)'
if test -f 'macunpack.h'
then
	echo shar: "will not over-write existing file 'macunpack.h'"
else
sed 's/^X//' << \SHAR_EOF > 'macunpack.h'
X#define	UNTESTED	/* Know about the untested algorithms */
X#define	BIN		/* Know about BinHex 5.0 etc. */
X#define	JDW		/* Know about Compress It */
X#define	STF		/* Know about ShrinkToFit */
X#define	LZC		/* Know about MacCompress */
X#undef	ASQ		/* Know about AutoSqueeze */
X#undef	ARC		/* Know about ArcMac */
X#define	PIT		/* Know about PackIt */
X#define	SIT		/* Know about StuffIt */
X#define	DIA		/* Know about Diamond */
X#define	CPT		/* Know about Compactor */
X#define	ZMA		/* Know about Zoom */
X#define	LZH		/* Know about LHa */
X#define	DD		/* Know about DiskDoubler */
X
SHAR_EOF
if test 571 -ne "`wc -c < 'macunpack.h'`"
then
	echo shar: "error transmitting 'macunpack.h'" '(should have been 571 characters)'
fi
fi
echo shar: "extracting 'lzh.h'" '(1339 characters)'
if test -f 'lzh.h'
then
	echo shar: "will not over-write existing file 'lzh.h'"
else
sed 's/^X//' << \SHAR_EOF > 'lzh.h'
X#define FILEHDRSIZE	22
X#define TOTALSIZE	64
X#define L_HSIZE		0
X#define L_HCRC		1
X#define L_METHOD	2
X#define L_PSIZE		7
X#define L_UPSIZE	11
X#define L_LASTMOD	15
X#define L_ATTRIBUTE	19
X
X/* Level 0 and level 1 headers */
X#define L_NLENGTH	21
X#define L_NAME		22
X/* Offset after name */
X#define L_CRC		0
X#define L_ETYPE		2
X#define L_EXTENDSZ	3
X#define L_EXTEND	4
X
X/* Level 2 header */
X#define L_2CRC		21
X#define L_2ETYPE	23
X#define L_2EXTENDSZ	24
X#define L_2EXTEND	25
X
X/* Extension definition, EXTEND defines the size of the extension. */
X#define L_KIND		0	/* After EXTEND */
X#define L_ENAME		2	/* Extension name, EXTEND-3 bytes long */
X/* Offset after name */
X#define L_EEXTENDSZ	0
X#define L_EEXTEND	1
X
Xtypedef struct fileHdr { /* 58 bytes */
X	unsigned char	hsize;
X	unsigned char	hcrc;
X	char		method[5];
X	unsigned long	psize;
X	unsigned long	upsize;
X	unsigned long	lastmod;
X	unsigned short	attribute;
X	unsigned char	nlength;
X	char		name[32];
X	unsigned short	crc;
X	unsigned char	etype;
X	unsigned char	extendsize;
X	char		*extend;
X	char		*data;
X};
X
X/* Currently known methods: */
X#define	lh0	0
X#define	lh1	1
X#define lh2	2
X#define lh3	3
X#define lh4	4
X#define	lh5	5
X#define lz4	6
X#define	lz5	7
X#define	lzs	8
X
Xextern char *lzh_pointer;
Xextern char *lzh_data;
Xextern char *lzh_finfo;
Xextern int lzh_fsize;
Xextern int lzh_kind;
Xextern char *lzh_file;
X
SHAR_EOF
if test 1339 -ne "`wc -c < 'lzh.h'`"
then
	echo shar: "error transmitting 'lzh.h'" '(should have been 1339 characters)'
fi
fi
echo shar: "extracting 'dia.c'" '(13018 characters)'
if test -f 'dia.c'
then
	echo shar: "will not over-write existing file 'dia.c'"
else
sed 's/^X//' << \SHAR_EOF > 'dia.c'
X#include "macunpack.h"
X#ifdef DIA
X#include "globals.h"
X#include "dia.h"
X#include "../util/curtime.h"
X#include "../util/masks.h"
X#include "../fileio/machdr.h"
X#include "../fileio/wrfile.h"
X#include "../fileio/kind.h"
X#include "../util/util.h"
X
Xextern char *malloc();
Xextern char *realloc();
X
Xstatic unsigned char *dia_archive;
Xstatic int dia_archive_size;
Xstatic int dia_max_archive_size;
Xstatic int dia_finfo;
Xstatic int dia_method;
Xstatic unsigned char *dia_archive_ptr;
Xstatic unsigned char *dia_header_ptr;
Xstatic unsigned char *dia_header_last;
Xstatic int dia_forklength;
Xstatic int dia_cforklength;
Xstatic unsigned char dia_bitbuf[BCHUNKSIZE];
Xstatic int dia_LZtab[BCHUNKSIZE];
Xstatic unsigned char *dia_bit_base;
Xstatic int dia_imask;
X
Xstatic void dia_folder();
Xstatic void dia_file();
Xstatic void dia_getlength();
Xstatic void dia_skipfork();
Xstatic void dia_getfork();
Xstatic void dia_getblock();
Xstatic int dia_decode();
Xstatic int dia_prevbit();
X
Xvoid dia(bin_hdr)
Xunsigned char *bin_hdr;
X{
X    int i, folder, nlength;
X    unsigned char hdr;
X    unsigned char *header;
X
X    dir_skip = 0;
X    for(i = 0; i < INFOBYTES; i++) {
X	info[i] = 0;
X    }
X    if(in_data_size > dia_max_archive_size) {
X	if(dia_archive == NULL) {
X	    dia_archive = (unsigned char *)malloc((unsigned)in_data_size);
X	} else {
X	    dia_archive = (unsigned char *)realloc((char *)dia_archive,
X						   (unsigned)in_data_size);
X	}
X	if(dia_archive == 0) {
X	    (void)fprintf(stderr, "Insufficient memory.\n");
X	    exit(1);
X	}
X	dia_max_archive_size = in_data_size;
X    }
X    dia_archive_size = in_data_size;
X    if(fread((char *)dia_archive, 1, in_data_size, infp) != in_data_size) {
X	(void)fprintf(stderr, "Can't read archive.\n");
X#ifdef SCAN
X	do_error("macunpack: Can't read archive");
X#endif /* SCAN */
X	exit(1);
X    }
X    nlength = bin_hdr[I_NAMEOFF] & BYTEMASK;
X    if(!strncmp((char *)bin_hdr + I_NAMEOFF + nlength - 1, " \272", 2)) {
X	nlength -= 2;
X    }
X    info[I_NAMEOFF] = nlength;
X    for(i = 1; i <= nlength; i++) {
X	info[I_NAMEOFF + i] = bin_hdr[I_NAMEOFF + i];
X    }
X    hdr = *dia_archive;
X    folder = hdr & IS_FOLDER;
X    dia_finfo = hdr & F_INFO;
X    if(hdr & VOLUME) {
X	(void)fprintf(stderr, "Multi-segment archives not implemented.\n");
X#ifdef SCAN
X	do_error("macunpack: Multi-segment archive");
X#endif /* SCAN */
X	exit(1);
X    }
X    if(hdr & CRYPTED) {
X	(void)fprintf(stderr, "Encrypted archives not implemented.\n");
X#ifdef SCAN
X	do_idf("", PROTECTED);
X#endif /* SCAN */
X	exit(1);
X    }
X    i = (hdr & N_BLOCKS) + 1;
X    header = (unsigned char *)malloc((unsigned)(i * CHUNKSIZE));
X    dia_archive_ptr = dia_archive + 1;
X    dia_header_last = header;
X    dia_method = 0;
X    while(i-- > 0) {
X	dia_getblock(&dia_archive_ptr, &dia_header_last);
X    }
X    dia_header_ptr = header;
X    if(folder) {
X	dia_folder((unsigned char *)NULL);
X    } else {
X	dia_file(*dia_header_ptr++, (unsigned char *)NULL);
X    }
X    free((char *)header);
X}
X
Xstatic void dia_folder(name)
Xunsigned char *name;
X{
X    unsigned char lname[32];
X    int i, length, doit;
X    unsigned char indicator, *old_ptr;
X
X    if(name != NULL) {
X	for(i = 0; i < INFOBYTES; i++) {
X	    info[i] = 0;
X	}
X	length = *name++ & REMAINS;
X	info[I_NAMEOFF] = length;
X	for(i = 1; i <= length; i++) {
X	    info[I_NAMEOFF + i] = *name++;
X	}
X    } else {
X	length = info[I_NAMEOFF];
X    }
X    if(dia_finfo) {
X	dia_header_ptr += 20;
X    }
X    if(!dir_skip) {
X	doit = 1;
X	if(list) {
X	    transname(info + I_NAMEOFF + 1, (char *)lname, length);
X	    do_indent(indent);
X	    (void)fprintf(stderr, "folder=\"%s\"", lname);
X	    if(query) {
X		doit = do_query();
X	    } else {
X		(void)fputc('\n', stderr);
X	    }
X	    if(doit) {
X		indent++;
X	    } else {
X		dir_skip = 1;
X	    }
X	}
X	if(doit && !info_only) {
X	    do_mkdir((char *)lname, info);
X	}
X    } else {
X	dir_skip++;
X    }
X    while(dia_header_ptr < dia_header_last) {
X	indicator = *dia_header_ptr;
X	if(indicator & LEAVE_FOLDER) {
X	    *dia_header_ptr = indicator & ~LEAVE_FOLDER;
X	    break;
X	} else if(indicator & ONLY_FOLDER) {
X	    if(indicator == ONLY_FOLDER) {
X		dia_header_ptr++;
X	    } else {
X		*dia_header_ptr -= 1;
X	    }
X	    break;
X	} else if(indicator & FOLDER) {
X	    old_ptr = dia_header_ptr;
X	    dia_header_ptr += (indicator & REMAINS) + 1;
X	    dia_folder(old_ptr);
X	} else {
X	    dia_header_ptr++;
X	    old_ptr = dia_header_ptr;
X	    dia_header_ptr += (*old_ptr & REMAINS) + 1;
X	    dia_file(indicator, old_ptr);
X	}
X    }
X    if(!dir_skip) {
X	if(doit) {
X	    indent--;
X	    if(!info_only) {
X		enddir();
X	    }
X	    do_indent(indent);
X	    (void)fprintf(stderr, "leaving folder \"%s\"\n", lname);
X	}
X    } else {
X	dir_skip--;
X    }
X}
X
Xstatic void dia_file(indicator, name)
Xunsigned char indicator, *name;
X{
X    unsigned char lname[32];
X    int i, length, doit;
X    int n_data, n_rsrc;
X    unsigned char *old_archive_ptr;
X    char ftype[5], fauth[5];
X    int dataLength, rsrcLength;
X    int cdataLength, crsrcLength;
X    int dataMethod, rsrcMethod;
X    unsigned long curtime;
X
X    if(name != NULL) {
X	for(i = 0; i < INFOBYTES; i++) {
X	    info[i] = 0;
X	}
X	length = *name++ & REMAINS;
X	info[I_NAMEOFF] = length;
X	for(i = 1; i <= length; i++) {
X	    info[I_NAMEOFF + i] = *name++;
X	}
X    } else {
X	length = info[I_NAMEOFF];
X    }
X    for(i = 0; i < 4; i++) {
X	info[I_TYPEOFF + i] = *dia_header_ptr++;
X    }
X    for(i = 0; i < 4; i++) {
X	info[I_AUTHOFF + i] = *dia_header_ptr++;
X    }
X    if(indicator & DATE_PRESENT) {
X	for(i = 0; i < 4; i++) {
X	    info[I_CTIMOFF + i] = *dia_header_ptr++;
X	}
X	for(i = 0; i < 4; i++) {
X	    info[I_MTIMOFF + i] = *dia_header_ptr++;
X	}
X    } else {
X	curtime = (unsigned long)time((time_t *)0) + TIMEDIFF;
X	put4(info + I_CTIMOFF, curtime);
X	put4(info + I_MTIMOFF, curtime);
X    }
X    if(dia_finfo) {
X	for(i = 0; i < 6; i++) {
X	    info[I_FLAGOFF + i] = *dia_header_ptr++;
X	}
X    }
X    n_data = 0;
X    if(indicator & HAS_DATA) {
X	if(indicator & SHORT_DATA) {
X	    n_data = 1;
X	} else {
X	    n_data = *dia_header_ptr++ + 1;
X	}
X    }
X    n_rsrc = 0;
X    if(indicator & HAS_RSRC) {
X	if(indicator & SHORT_RSRC) {
X	    n_rsrc = 1;
X	} else {
X	    n_rsrc = *dia_header_ptr++ + 1;
X	}
X    }
X    if(!dir_skip) {
X	old_archive_ptr = dia_archive_ptr;
X	dia_getlength(n_data);
X	dataLength = dia_forklength;
X	cdataLength = dia_cforklength;
X	dataMethod = dia_method;
X	dia_getlength(n_rsrc);
X	rsrcLength = dia_forklength;
X	crsrcLength = dia_cforklength;
X	rsrcMethod = dia_method;
X	dia_archive_ptr = old_archive_ptr;
X	put4(info + I_DLENOFF, (unsigned long)dataLength);
X	put4(info + I_RLENOFF, (unsigned long)rsrcLength);
X	if(list) {
X	    transname(info + I_NAMEOFF + 1, (char *)lname, length);
X	    do_indent(indent);
X	    transname(info + I_TYPEOFF, ftype, 4);
X	    transname(info + I_AUTHOFF, fauth, 4);
X	    (void)fprintf(stderr,
X		    "name=\"%s\", type=%4.4s, author=%4.4s, data=%25ld%2c.html rsrc=%ld",
X		    lname, ftype, fauth, (long)dataLength, (long)rsrcLength);
X	    if(info_only) {
X		doit = 0;
X	    } else {
X		doit = 1;
X	    }
X	    if(query) {
X		doit = do_query();
X	    } else {
X		(void)fputc('\n', stderr);
X	    }
X	} else {
X	    doit = 1;
X	}
X    } else {
X	dia_skipfork(n_data);
X	dia_skipfork(n_rsrc);
X	return;
X    }
X    if(doit) {
X	define_name((char *)lname);
X	start_info(info, (unsigned long)rsrcLength, (unsigned long)dataLength);
X    }
X    if(verbose) {
X	(void)fprintf(stderr, "\tData: ");
X	if(dataLength == 0) {
X	    (void)fprintf(stderr, "empty");
X	} else if(dataMethod == NOCOMP) {
X	    (void)fprintf(stderr, "No compression");
X	} else {
X	    if(dataMethod != COMP) {
X		(void)fprintf(stderr, "Partial ");
X	    }
X	    (void)fprintf(stderr, "LZFK compressed (%4.1f%%)",
X		100.0 * cdataLength / dataLength);
X	}
X    }
X    if(doit) {
X	start_data();
X	dia_getfork(n_data);
X    } else {
X	dia_skipfork(n_data);
X    }
X    if(verbose) {
X	(void)fprintf(stderr, ", Rsrc: ");
X	if(rsrcLength == 0) {
X	    (void)fprintf(stderr, "empty");
X	} else if(rsrcMethod == NOCOMP) {
X	    (void)fprintf(stderr, "No compression");
X	} else {
X	    if(rsrcMethod != COMP) {
X		(void)fprintf(stderr, "Partial ");
X	    }
X	    (void)fprintf(stderr, "LZFK compressed (%4.1f%%)",
X		100.0 * crsrcLength / rsrcLength);
X	}
X    }
X    if(doit) {
X	start_rsrc();
X	dia_getfork(n_rsrc);
X    } else {
X	dia_skipfork(n_rsrc);
X    }
X    if(verbose) {
X	(void)fprintf(stderr, ".\n");
X    }
X    if(doit) {
X	end_file();
X    }
X}
X
Xstatic void dia_getlength(nblocks)
Xint nblocks;
X{
X    int length;
X    unsigned char *arch_ptr, *block_ptr;
X    unsigned char block[CHUNKSIZE];
X
X    dia_method = 0;
X    dia_forklength = 0;
X    dia_cforklength = 0;
X    while(nblocks > 1) {
X	nblocks--;
X	length = get2((char *)dia_archive_ptr);
X	if(length >= 0x8000) {
X	    length = 0x10000 - length;
X	    dia_method |= NOCOMP;
X	} else {
X	    dia_method |= COMP;
X	}
X	dia_forklength += CHUNKSIZE;
X	dia_cforklength += length + 2;
X	dia_archive_ptr += length + 2;
X    }
X    if(nblocks == 1) {
X	arch_ptr = dia_archive_ptr;
X	block_ptr = block;
X	dia_getblock(&arch_ptr, &block_ptr);
X	dia_forklength += block_ptr - block;
X	dia_cforklength += arch_ptr - dia_archive_ptr;
X	dia_archive_ptr = arch_ptr;
X    }
X}
X
Xstatic void dia_skipfork(nblocks)
Xint nblocks;
X{
X    int length;
X
X    while(nblocks-- > 0) {
X	length = get2((char *)dia_archive_ptr);
X	if(length >= 0x8000) {
X	    length = 0x10000 - length;
X	}
X	dia_archive_ptr += length + 2;
X    }
X}
X
Xstatic void dia_getfork(nblocks)
Xint nblocks;
X{
X    while(nblocks-- > 0) {
X	dia_getblock(&dia_archive_ptr, (unsigned char **)&out_ptr);
X    }
X}
X
Xstatic void dia_getblock(archive_ptr, block_ptr)
Xunsigned char **archive_ptr, **block_ptr;
X{
X    int length, i;
X    unsigned char *arch_ptr, *bl_ptr;
X
X    arch_ptr = *archive_ptr;
X    bl_ptr = *block_ptr;
X    length = get2((char *)arch_ptr);
X    arch_ptr += 2;
X    if(length >= 0x8000) {
X	length = 0x10000 - length;
X	for(i = 0; i < length; i++) {
X	    *bl_ptr++ = *arch_ptr++;
X	}
X	*block_ptr += length;
X	dia_method |= NOCOMP;
X    } else {
X	*block_ptr += dia_decode(arch_ptr, bl_ptr, length);
X	dia_method |= COMP;
X    }
X    *archive_ptr += length + 2;
X}
X
Xstatic int dia_decode(ibuff, obuff, in_length)
Xunsigned char *ibuff, *obuff; int in_length;
X{
X    int nbits, set_zero, i, j;
X    unsigned char *bitbuf_ptr;
X    int count[4];
X    int *LZtab_ptr;
X    unsigned char *out_ptr, *buf_ptr, *in_ptr;
X    int omask;
X    int LZcount;
X    int *length_ptr, *nchars_ptr;
X    int *offsn_ptr, length, nchars, offset;
X    int *offs_ptr[4];
X    int nwords;
X
X    in_ptr = ibuff + in_length;
X    nbits = *--in_ptr;
X    nbits |= (*--in_ptr << 8);
X    if(nbits == WORDMASK) {
X	nbits = *--in_ptr;
X	nbits |= (*--in_ptr << 8);
X	nbits = nbits + WORDMASK;
X    }
X    bitbuf_ptr = dia_bitbuf + BCHUNKSIZE;
X    *--bitbuf_ptr = *--in_ptr;
X    set_zero = 0;
X    dia_bit_base = bitbuf_ptr;
X    dia_imask = 1 << (7 - (nbits & 7));
X    if(dia_prevbit()) {
X	set_zero = 1;
X    }
X    for(i = 0; i < nbits; i++) {
X	if(set_zero) {
X	    *--bitbuf_ptr = 0;
X	} else {
X	    *--bitbuf_ptr = *--in_ptr;
X	}
X	if(dia_prevbit()) {
X	    set_zero = !set_zero;
X	}
X    }
X    /* Now we have the bits in longitudal order; reorder them */
X    nwords = ((dia_bit_base - bitbuf_ptr) >> 1);
X    for(i = 0; i < nwords; i++) {
X	dia_LZtab[i] = 0;
X    }
X    omask = 1;
X    for(i = 0; i < 16; i++) {
X	j = nwords;
X	LZtab_ptr = dia_LZtab + nwords;
X	while(j-- > 0) {
X	    LZtab_ptr--;
X	    if(dia_prevbit()) {
X		*LZtab_ptr |= omask;
X	    }
X	}
X	omask <<= 1;
X    }
X    LZcount = nwords / 3;
X    /*  At this point we have in LZtab LZcount triples.  Each triple consists
X	of the following parts:
X		nchars:	the number of characters to take from input
X		length:	the number of characters - 1 to copy from output
X		offset:	the offset in the output buffer
X	The ordering is as follows:
X	1.	lengths
X	2.	nchars
X	3.	offsets for length 0
X	4.	offsets for length 1
X	5.	offsets for length 2
X	6.	offsets for length 3
X	7.	offsets for other lengths
X    */
X    /*	Now first count the occurences of lengths 0 to 3 */
X    count[0] = 0;
X    count[1] = 0;
X    count[2] = 0;
X    count[3] = 0;
X    for(i = 0; i < LZcount; i++) {
X	if((j = dia_LZtab[i]) < 4) {
X	    count[j]++;
X	}
X    }
X    length_ptr = dia_LZtab;
X    nchars_ptr = dia_LZtab + LZcount;
X    offs_ptr[0] = nchars_ptr + LZcount;
X    offs_ptr[1] = offs_ptr[0] + count[0];
X    offs_ptr[2] = offs_ptr[1] + count[1];
X    offs_ptr[3] = offs_ptr[2] + count[2];
X    offsn_ptr = offs_ptr[3] + count[3];
X    out_ptr = obuff;
X    for(i = 0; i < LZcount; i++) {
X	length = *length_ptr++;
X	nchars = *nchars_ptr++;
X	if(length < 4) {
X	    offset = *offs_ptr[length]++;
X	} else {
X	    offset = *offsn_ptr++;
X	}
X	while(nchars-- > 0) {
X	    *out_ptr++ = *ibuff++;
X	}
X	buf_ptr = out_ptr - length - offset - 1;
X	while(length-- >= 0) {
X	    *out_ptr++ = *buf_ptr++;
X	}
X    }
X    i = in_ptr - ibuff;
X    while(i-- > 0) {
X	*out_ptr++ = *ibuff++;
X    }
X    return out_ptr - obuff;
X}
X
Xstatic int dia_prevbit()
X{
X    int c;
X
X    if(dia_imask == 0x100) {
X	dia_bit_base--;
X	dia_imask = 1;
X    }
X    c = *dia_bit_base & dia_imask;
X    dia_imask <<= 1;
X    return c;
X}
X#else /* DIA */
Xint dia; /* keep lint and some compilers happy */
X#endif /* DIA */
X
SHAR_EOF
if test 13018 -ne "`wc -c < 'dia.c'`"
then
	echo shar: "error transmitting 'dia.c'" '(should have been 13018 characters)'
fi
fi
echo shar: "extracting 'de_huffman.c'" '(2547 characters)'
if test -f 'de_huffman.c'
then
	echo shar: "will not over-write existing file 'de_huffman.c'"
else
sed 's/^X//' << \SHAR_EOF > 'de_huffman.c'
X#include "macunpack.h"
X#ifdef JDW
X#define DEHUFFMAN
X#endif /* JDW */
X#ifdef STF
X#define DEHUFFMAN
X#endif /* STF */
X#ifdef PIT
X#define DEHUFFMAN
X#endif /* PIT */
X#ifdef SIT
X#define DEHUFFMAN
X#endif /* SIT */
X#ifdef CPT
X#define DEHUFFMAN
X#endif /* CPT */
X#ifdef DEHUFFMAN
X#include "globals.h"
X#include "../util/masks.h"
X#include "../fileio/wrfile.h"
X#include "huffman.h"
X#include "../util/util.h"
X
Xint (*get_bit)();
Xint bytesread;
X/* 515 because StuffIt Classic needs more than the needed 511 */
Xstruct node nodelist[515];
Xstatic int getbit_be();
Xstatic int getbit_le();
Xstatic int getdecodebyte();
X
Xstatic node *nodeptr, *read_sub_tree();
X
Xstatic int bit;
X
Xvoid de_huffman(obytes)
Xunsigned long obytes;
X{
X    while(obytes != 0) {
X	*out_ptr++ = gethuffbyte(nodelist);
X	obytes--;
X    }
X    return;
X}
X
Xvoid de_huffman_end(term)
Xunsigned int term;
X{
X    int c;
X
X    while((c = gethuffbyte(nodelist)) != term) {
X	*out_ptr++ = c;
X    }
X}
X
Xvoid set_huffman(endian)
Xint endian;
X{
X    if(endian == HUFF_LE) {
X	get_bit = getbit_le;
X    } else if(endian == HUFF_BE) {
X	get_bit = getbit_be;
X    }
X}
X
Xvoid read_tree()
X{
X    nodeptr = nodelist;
X    bit = 0;		/* put us on a boundary */
X    (void)read_sub_tree();
X}
X
X/* This routine recursively reads the Huffman encoding table and builds
X   a decoding tree. */
Xstatic node *read_sub_tree()
X{
X    node *np;
X
X    np = nodeptr++;
X    if((*get_bit)() == 1) {
X	np->flag = 1;
X	np->byte = getdecodebyte();
X    } else {
X	np->flag = 0;
X	np->zero = read_sub_tree();
X	np->one  = read_sub_tree();
X    }
X    return np;
X}
X
X/* This routine returns the next bit in the input stream (MSB first) */
Xstatic int getbit_be()
X{
X    static int b;
X
X    if(bit == 0) {
X	b = getb(infp) & BYTEMASK;
X	bit = 8;
X	bytesread++;
X    }
X    bit--;
X    return (b >> bit) & 1;
X}
X
X/* This routine returns the next bit in the input stream (LSB first) */
Xstatic int getbit_le()
X{
X    static int b;
X
X    if(bit == 0) {
X	b = getb(infp) & BYTEMASK;
X	bit = 8;
X	bytesread++;
X    }
X    bit--;
X    return (b >> (7 - bit)) & 1;
X}
X
Xvoid clrhuff()
X{
X    bit = 0;
X}
X
Xint gethuffbyte(l_nodelist)
Xnode *l_nodelist;
X{
X    register node *np;
X
X    np = l_nodelist;
X    while(np->flag == 0) {
X	np = (*get_bit)() ? np->one : np->zero;
X    }
X    return np->byte;
X}
X
Xint getihuffbyte()
X{
X    return gethuffbyte(nodelist);
X}
X
Xstatic int getdecodebyte()
X{
X    register int i, b;
X
X    b = 0;
X    for(i = 8; i > 0; i--) {
X	b = (b << 1) + (*get_bit)();
X    }
X    return b;
X}
X#else /* DEHUFFMAN */
Xint dehuffman; /* keep lint and some compilers happy */
X#endif /* DEHUFFMAN */
X
SHAR_EOF
if test 2547 -ne "`wc -c < 'de_huffman.c'`"
then
	echo shar: "error transmitting 'de_huffman.c'" '(should have been 2547 characters)'
fi
fi
echo shar: "extracting 'de_compress.c'" '(5169 characters)'
if test -f 'de_compress.c'
then
	echo shar: "will not over-write existing file 'de_compress.c'"
else
sed 's/^X//' << \SHAR_EOF > 'de_compress.c'
X#include "macunpack.h"
X#ifdef SIT
X#define DECOMPRESS
X#endif /* SIT */
X#ifdef LZC
X#define DECOMPRESS
X#endif /* LZC */
X#ifdef DECOMPRESS
X#include "globals.h"
X#include "../fileio/wrfile.h"
X
X/* Written to allow for bits to be upto 16, MacCompress can use 16 bits */
X
X#define	BITS	16
X#define HSIZE	69001		/* 95% occupancy */
X
X#define INIT_BITS 9			/* initial number of bits/code */
X
Xstatic int n_bits;				/* number of bits/code */
Xstatic int maxbits;			/* user settable max # bits/code */
Xstatic long maxcode;			/* maximum code, given n_bits */
Xstatic long maxmaxcode;			/* should NEVER generate this code */
X# define MAXCODE(n_bits)	((1 << (n_bits)) - 1)
X
Xstatic long htab [HSIZE];
Xstatic unsigned short codetab [HSIZE];
X
X#define tab_prefixof(i) codetab[i]
X#define tab_suffixof(i)	((unsigned char *)(htab))[i]
X#define de_stack	((unsigned char *)&tab_suffixof(1<<BITS))
X
Xstatic long free_ent = 0;			/* first unused entry */
X
Xstatic long getcode();
X
Xstatic int clear_flg = 0;
X
X/*
X * the next two codes should not be changed lightly, as they must not
X * lie within the contiguous general code space.
X */
X#define FIRST	257	/* first free entry */
X#define	CLEAR	256	/* table clear output code */
X
Xstatic int toread;
X
Xvoid de_compress(ibytes, mb)
Xunsigned long ibytes;
Xint mb;
X{
X    register unsigned char *stackp;
X    register int finchar;
X    register long code, oldcode, incode;
X
X    toread = ibytes;
X    maxbits = mb;
X    maxmaxcode = 1 << maxbits;
X    maxcode = MAXCODE(n_bits = INIT_BITS);
X    for(code = 255; code >= 0; code--) {
X	tab_prefixof(code) = 0;
X	tab_suffixof(code) = (unsigned char)code;
X    }
X    free_ent = FIRST;
X    finchar = oldcode = getcode();
X    if(oldcode == -1) {	/* EOF already? */
X	return;			/* Get out of here */
X    }
X    /* first code must be 8 bits = char */
X    *out_ptr++ = (char)finchar;
X    stackp = de_stack;
X    while((code = getcode()) > -1) {
X	if(code == CLEAR) {
X	    for(code = 255; code >= 0; code--) {
X		tab_prefixof(code) = 0;
X	    }
X	    clear_flg = 1;
X	    free_ent = FIRST - 1;
X	    if((code = getcode()) == -1) {	/* O, untimely death! */
X		break;
X	    }
X	}
X	incode = code;
X	/*
X	 * Special case for KwKwK string.
X	 */
X	if(code >= free_ent) {
X	    *stackp++ = finchar;
X	    code = oldcode;
X	}
X	/*
X	 * Generate output characters in reverse order
X	 */
X	while(code >= 256) {
X	    *stackp++ = tab_suffixof(code);
X	    code = tab_prefixof(code);
X	}
X	*stackp++ = finchar = tab_suffixof(code);
X	/*
X	 * And put them out in forward order
X	 */
X	do {
X	    *out_ptr++ = (char)*--stackp;
X	} while(stackp > de_stack);
X	/*
X	 * Generate the new entry.
X	 */
X	if((code=free_ent) < maxmaxcode) {
X	    tab_prefixof(code) = (unsigned short)oldcode;
X	    tab_suffixof(code) = finchar;
X	    free_ent = code+1;
X	}
X	/*
X	 * Remember previous code.
X	 */
X	oldcode = incode;
X    }
X    return;
X}
X
Xstatic unsigned char rmask[9] =
X    {0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff};
X
Xstatic int get_core_bytes;
Xstatic char *core_ptr;
Xstatic int file_bytes();
Xstatic int core_bytes();
X
Xstatic long getcode()
X{
X    register long code;
X    static int offset = 0, size = 0;
X    static unsigned char buf[BITS];
X    register int r_off, bits;
X    register unsigned char *bp = buf;
X
X    if(clear_flg > 0 || offset >= size || free_ent > maxcode) {
X	/*
X	 * If the next entry will be too big for the current code
X	 * size, then we must increase the size.  This implies reading
X	 * a new buffer full, too.
X	 */
X	if(free_ent > maxcode) {
X	    n_bits++;
X	    if(n_bits == maxbits) {
X		maxcode = maxmaxcode;	/* won't get any bigger now */
X	    } else {
X		maxcode = MAXCODE(n_bits);
X	    }
X	}
X	if(clear_flg > 0) {
X	    maxcode = MAXCODE (n_bits = INIT_BITS);
X	    clear_flg = 0;
X	}
X	if(toread == 0) {
X	    return -1;
X	}
X	if(get_core_bytes) {
X	    size = core_bytes((char *)buf, (n_bits < toread ? n_bits : toread));
X	} else {
X	    size = file_bytes((char *)buf, (n_bits < toread ? n_bits : toread));
X	}
X	toread -= size;
X	if(size <= 0) {
X	    (void)fprintf(stderr, "Premature EOF\n");
X#ifdef SCAN
X	    do_error("macunpack: Premature EOF");
X#endif /* SCAN */
X	    exit(1);
X	}
X	offset = 0;
X	/* Round size down to integral number of codes */
X	size = (size << 3) - (n_bits - 1);
X    }
X    r_off = offset;
X    bits = n_bits;
X    /*
X     * Get to the first byte.
X     */
X    bp += (r_off >> 3);
X    r_off &= 7;
X    /* Get first part (low order bits) */
X    code = (*bp++ >> r_off);
X    bits -= (8 - r_off);
X    r_off = 8 - r_off;		/* now, offset into code word */
X    /* Get any 8 bit parts in the middle (<=1 for up to 16 bits). */
X    if(bits >= 8) {
X	code |= *bp++ << r_off;
X	r_off += 8;
X	bits -= 8;
X    }
X    /* high order bits. */
X    code |= (*bp & rmask[bits]) << r_off;
X    offset += n_bits;
X    return code;
X}
X
Xstatic int file_bytes(buf, length)
Xchar *buf;
Xint length;
X{
X    return fread(buf, 1, length, infp);
X}
X
Xstatic int core_bytes(buf, length)
Xchar *buf;
Xint length;
X{
X    int i;
X
X    for(i = 0; i < length; i++) {
X	*buf++ = *core_ptr++;
X    }
X    return length;
X}
X
Xvoid core_compress(ptr)
Xchar *ptr;
X{
X    core_ptr = ptr;
X    get_core_bytes = ptr != NULL;
X}
X#else /* DECOMPRESS */
Xint decompress; /* keep lint and some compilers happy */
X#endif /* DECOMPRESS */
X
SHAR_EOF
if test 5169 -ne "`wc -c < 'de_compress.c'`"
then
	echo shar: "error transmitting 'de_compress.c'" '(should have been 5169 characters)'
fi
fi
echo shar: "extracting 'dia.h'" '(423 characters)'
if test -f 'dia.h'
then
	echo shar: "will not over-write existing file 'dia.h'"
else
sed 's/^X//' << \SHAR_EOF > 'dia.h'
X#define	IS_FOLDER	0x80
X#define	F_INFO		0x40
X#define VOLUME		0x30
X#define	CRYPTED		0x08
X#define N_BLOCKS	0x07
X
X#define	LEAVE_FOLDER	0x80
X#define	ONLY_FOLDER	0x40
X#define	FOLDER		0x20
X#define	DATE_PRESENT	0x10
X#define	HAS_DATA	0x08
X#define	HAS_RSRC	0x04
X#define	SHORT_DATA	0x02
X#define	SHORT_RSRC	0x01
X#define	REMAINS		0x1f
X
X#define CHUNKSIZE	32767
X#define BCHUNKSIZE	(CHUNKSIZE * 16 / 7)
X
X#define	NOCOMP		1
X#define COMP		2
X
SHAR_EOF
if test 423 -ne "`wc -c < 'dia.h'`"
then
	echo shar: "error transmitting 'dia.h'" '(should have been 423 characters)'
fi
fi
echo shar: "extracting 'arc.h'" '(1196 characters)'
if test -f 'arc.h'
then
	echo shar: "will not over-write existing file 'arc.h'"
else
sed 's/^X//' << \SHAR_EOF > 'arc.h'
X#define	MAGIC1		0	/* Should be 0x1b, marks Mac extension */
X#define	KIND		1	/* KIND == 0 marks end of archive */
X#define	FNAME		2
X#define	FILLER		33
X#define	FTYPE		34
X#define	FAUTH		38
X#define	FINFO		42
X#define	FDATA		50
X#define	FRSRC		54
X#define	FILLER		58
X#define	MAGIC2		59	/* Should be 0x1a, true Arc header start */
X#define	KIND2		60	/* Should be identical to KIND */
X#define	FNAME2		61	/* A PC-ified version of the filename */
X#define	SIZE		74
X#define	DATE		78
X#define	TIME		80
X#define	CRC		82
X#define	SIZE2		84	/* Not present if KIND == 1 */
X#define	HEADERBYTES	88
X
Xtypedef struct fileHdr { /* 84 or 88 bytes */
X	char		magic1;
X	char		kind;
X	char		fname[31];
X	char		filler;		/* ??? */
X	char		ftype[4];
X	char		fauth[4];
X	char		finfo[8];
X	unsigned long	dataLength;
X	unsigned long	rsrcLength;
X	char		filler;
X	char		magic2;
X	char		kind2;
X	char		fname2[13];
X	unsigned long	size;
X	unsigned short	date;
X	unsigned short	time;
X	unsigend short	crc;
X	unsigned long	size2;	/* Identical to size; this is wrong for Arc! */
X};
X
X#define	smallstored	1
X#define	stored		2
X#define	packed		3
X#define	squeezed	4
X#define	crunched1	5
X#define	crunched2	6
X#define	crunched3	7
X#define	crunched4	8
X#define	squashed	9
X
SHAR_EOF
if test 1196 -ne "`wc -c < 'arc.h'`"
then
	echo shar: "error transmitting 'arc.h'" '(should have been 1196 characters)'
fi
fi
echo shar: "extracting 'jdw.c'" '(3552 characters)'
if test -f 'jdw.c'
then
	echo shar: "will not over-write existing file 'jdw.c'"
else
sed 's/^X//' << \SHAR_EOF > 'jdw.c'
X#include "macunpack.h"
X#ifdef JDW
X#include "jdw.h"
X#include "globals.h"
X#include "huffman.h"
X#include "../fileio/wrfile.h"
X#include "../fileio/machdr.h"
X#include "../util/util.h"
X#include "../util/masks.h"
X
Xextern void de_huffman();
Xextern void set_huffman();
Xextern void read_tree();
Xextern void clrhuff();
X
Xstatic void jdw_wrfile();
Xstatic void jdw_wrfork();
Xstatic void jdw_block();
X
Xvoid jdw(ibytes)
Xunsigned long ibytes;
X{
X    char fauth[5], ftype[5];
X    int filel, i;
X    unsigned int rsrcLength, dataLength;
X
X    set_huffman(HUFF_BE);
X    for(i = 0; i < 6; i++) (void)getb(infp);
X    for(i = 0; i < INFOBYTES; i++) {
X	info[i] = 0;
X    }
X    for(i = 0; i < 4; i++) {
X	info[I_TYPEOFF + i] = getb(infp);
X    }
X    for(i = 0; i < 4; i++) {
X	info[I_AUTHOFF + i] = getb(infp);
X    }
X    for(i = 0; i < 8; i++) {
X	info[I_FLAGOFF + i] = getb(infp);
X    }
X    for(i = 0; i < 4; i++) {
X	info[I_DLENOFF + i] = getb(infp);
X    }
X    for(i = 0; i < 4; i++) {
X	info[I_RLENOFF + i] = getb(infp);
X    }
X    for(i = 0; i < 4; i++) {
X	info[I_CTIMOFF + i] = getb(infp);
X    }
X    for(i = 0; i < 4; i++) {
X	info[I_MTIMOFF + i] = getb(infp);
X    }
X    filel = getb(infp);
X    info[I_NAMEOFF] = filel;
X    i = filel;
X    for(i = 1; i <= filel; i++) {
X	info[I_NAMEOFF + i] = getb(infp);
X    }
X    (void)getb(infp);
X    rsrcLength = get4(info + I_RLENOFF);
X    dataLength = get4(info + I_DLENOFF);
X    ibytes -= filel + 40;
X    write_it = 1;
X    if(list) {
X	transname(info + I_NAMEOFF + 1, text, (int)info[I_NAMEOFF]);
X	transname(info + I_TYPEOFF, ftype, 4);
X	transname(info + I_AUTHOFF, fauth, 4);
X	do_indent(indent);
X	(void)fprintf(stderr,
X		"name=\"%s\", type=%4.4s, author=%4.4s, data=%25ld%2c.html rsrc=%ld",
X		text, ftype, fauth, (long)dataLength, (long)rsrcLength);
X	if(info_only) {
X	    write_it = 0;
X	}
X	if(query) {
X	    write_it = do_query();
X	} else {
X	    (void)fputc('\n', stderr);
X	}
X    }
X    jdw_wrfile((unsigned long)rsrcLength, (unsigned long)dataLength);
X}
X
Xstatic void jdw_wrfile(rsrcLength, dataLength)
Xunsigned long rsrcLength, dataLength;
X{
X    if(write_it) {
X	define_name(text);
X	start_info(info, rsrcLength, dataLength);
X	start_data();
X    }
X    if(verbose) {
X	(void)fprintf(stderr, "\tData: ");
X    }
X    jdw_wrfork(dataLength);
X    if(write_it) {
X	start_rsrc();
X    }
X    if(verbose) {
X	(void)fprintf(stderr, ", Rsrc: ");
X    }
X    jdw_wrfork(rsrcLength);
X    if(write_it) {
X	end_file();
X    }
X    if(verbose) {
X	(void)fprintf(stderr, ".\n");
X    }
X}
X
Xstatic void jdw_wrfork(length)
Xunsigned long length;
X{
X    int olength, ilength, i;
X    unsigned long origlength, comprlength;
X
X    if(length == 0) {
X	(void)fprintf(stderr, "empty");
X	return;
X    }
X    (void)fprintf(stderr, "Huffman compressed ");
X    comprlength = 0;
X    origlength = length;
X    while(length > 0) {
X	olength = getb(infp) & BYTEMASK;
X	olength = (olength << 8) | (getb(infp) & BYTEMASK);
X	ilength = getb(infp) & BYTEMASK;
X	ilength = (ilength << 8) | (getb(infp) & BYTEMASK);
X	if(write_it) {
X	    jdw_block(olength);
X	} else {
X	    for(i = 0; i < ilength; i++) {
X		(void)getb(infp);
X	    }
X	}
X	comprlength += ilength + 4;
X	length -= olength;
X    }
X    if(verbose) {
X	(void)fprintf(stderr, "(%4.1f%%)", 100.0 * comprlength / origlength);
X    }
X}
X
Xstatic void jdw_block(olength)
Xint olength;
X{
X    bytesread = 0;
X    read_tree();
X    /* Put reading back at a word boundary! */
X    while(bytesread & 3) {
X	(void)getb(infp);
X	bytesread++;
X    }
X    clrhuff();
X    de_huffman((unsigned long)olength);
X}
X#else /* JDW */
Xint jdw; /* keep lint and some compilers happy */
X#endif /* JDW */
X
SHAR_EOF
if test 3552 -ne "`wc -c < 'jdw.c'`"
then
	echo shar: "error transmitting 'jdw.c'" '(should have been 3552 characters)'
fi
fi
echo shar: "extracting 'jdw.h'" '(446 characters)'
if test -f 'jdw.h'
then
	echo shar: "will not over-write existing file 'jdw.h'"
else
sed 's/^X//' << \SHAR_EOF > 'jdw.h'
X#define	J_MAGIC		0
X#define J_TYPE		6
X#define J_AUTH		10
X#define	J_FINFO		14
X#define	J_DATALENGTH	22
X#define J_RSRCLENGTH	26
X#define	J_CTIME		30
X#define	J_MTIME		34
X#define	J_FLENGTH	38
X
Xtypedef struct fileHdr {
X	char		magic[6];
X	unsigned long	type;
X	unsigned long	auth;
X	char		finfo[8];
X	unsigned long	dataLength;
X	unsigned long	rsrcLength;
X	unsigned long	ctime;
X	unsigned long	mtime;
X	char		flength;
X	char		fname[32];	/* actually flength */
X};
X
SHAR_EOF
if test 446 -ne "`wc -c < 'jdw.h'`"
then
	echo shar: "error transmitting 'jdw.h'" '(should have been 446 characters)'
fi
fi
echo shar: "extracting 'de_lzh.c'" '(6147 characters)'
if test -f 'de_lzh.c'
then
	echo shar: "will not over-write existing file 'de_lzh.c'"
else
sed 's/^X//' << \SHAR_EOF > 'de_lzh.c'
X#include "macunpack.h"
X#ifdef ZMA
X#define DELZH
X#endif /* ZMA */
X#ifdef LZH
X#define DELZH
X#endif /* LZH */
X#ifdef DELZH
X#include "globals.h"
X#include "../util/masks.h"
X#include "../fileio/wrfile.h"
X#include "bits_be.h"
X
X/* This code is valid for bitsused upto 15. */
X#define DICBIT    13    /* 12(-lh4-) or 13(-lh5-) */
X#define UCHAR_MAX    255
X#define THRESHOLD    3
X
Xstatic int decoded;
Xstatic int bitsused;
Xstatic unsigned int blocksize;
Xstatic unsigned int decode_c();
Xstatic unsigned int decode_p();
Xstatic void make_table();
X
X/* lzh compression */
Xvoid de_lzh(ibytes, obytes, data, bits)
Xlong ibytes;
Xlong obytes;
Xchar **data;
Xint bits;
X{
X    unsigned int i, r, c;
X    int remains;
X
X    bit_be_inbytes = ibytes;
X    bit_be_filestart = *data;
X    bitsused = bits;
X    bit_be_init_getbits();
X    blocksize = 0;
X    decoded = 0;
X    r = 0;
X    for(;;) {
X	c = decode_c();
X	if(decoded) {
X	    *data = bit_be_filestart;
X	    return;
X	}
X	if(c <= UCHAR_MAX) {
X	    out_ptr[r++] = c;
X	    obytes--;
X	    if(obytes == 0) {
X		*data = bit_be_filestart;
X		return;
X	    }
X	} else {
X	    remains = c - (UCHAR_MAX + 1 - THRESHOLD);
X	    i = (r - decode_p() - 1);
X	    while(--remains >= 0) {
X		out_ptr[r++] = out_ptr[i++];
X		obytes--;
X		if(obytes == 0) {
X		    *data = bit_be_filestart;
X		    return;
X		}
X	    }
X	}
X    }
X}
X
X#define MAXMATCH 256
X#define NC (UCHAR_MAX + MAXMATCH + 2 - THRESHOLD)
X#define CBIT 9
X#define CODE_BIT 16
X#define NP (DICBIT + 1)
X#define NT (CODE_BIT + 3)
X#define PBIT 4  /* smallest integer such that (1U << PBIT) > NP */
X#define TBIT 5  /* smallest integer such that (1U << TBIT) > NT */
X#if NT > NP
X# define NPT NT
X#else
X# define NPT NP
X#endif
X
Xstatic unsigned int left[2 * NC - 1], right[2 * NC - 1];
Xstatic unsigned char c_len[NC], pt_len[NPT];
Xstatic unsigned int c_table[4096], pt_table[256];
X
Xstatic void read_pt_len(nn, nbit, i_special)
Xint nn;
Xint nbit;
Xint i_special;
X{
X    int i, c, n;
X    unsigned int mask;
X
X    n = bit_be_getbits(nbit);
X    if (n == 0) {
X	c = bit_be_getbits(nbit);
X	for (i = 0; i < nn; i++) {
X	    pt_len[i] = 0;
X	}
X	for (i = 0; i < 256; i++) {
X	    pt_table[i] = c;
X	}
X    } else {
X	i = 0;
X	while (i < n) {
X	    c = bit_be_bitbuf >> (BITBUFSIZ - 3);
X	    if (c == 7) {
X		mask = (unsigned) 1 << (BITBUFSIZ - 1 - 3);
X		while (mask & bit_be_bitbuf) {
X		    mask >>= 1;
X		    c++;
X		}
X	    }
X	    bit_be_fillbuf((c < 7) ? 3 : c - 3);
X	    pt_len[i++] = c;
X	    if (i == i_special) {
X		c = bit_be_getbits(2);
X		while (--c >= 0) {
X		    pt_len[i++] = 0;
X		}
X	    }
X	}
X	while (i < nn) {
X	    pt_len[i++] = 0;
X	}
X	make_table(nn, pt_len, 8, pt_table);
X    }
X}
X
Xstatic void read_c_len()
X{
X    int i, c, n;
X    unsigned int mask;
X
X    n = bit_be_getbits(CBIT);
X    if (n == 0) {
X	c = bit_be_getbits(CBIT);
X	for (i = 0; i < NC; i++) {
X	    c_len[i] = 0;
X	}
X	for (i = 0; i < 4096; i++) {
X	    c_table[i] = c;
X	}
X    } else {
X	i = 0;
X	while (i < n) {
X	    c = pt_table[bit_be_bitbuf >> (BITBUFSIZ - 8)];
X	    if (c >= NT) {
X		mask = (unsigned) 1 << (BITBUFSIZ - 1 - 8);
X		do {
X		    if (bit_be_bitbuf & mask) {
X			c = right[c];
X		    } else {
X			c = left [c];
X		    }
X		    mask >>= 1;
X		} while (c >= NT);
X	    }
X	    bit_be_fillbuf((int)pt_len[c]);
X	    if (c <= 2) {
X		if (c == 0) {
X		    c = 1;
X		} else if (c == 1) {
X		    c = bit_be_getbits(4) + 3;
X		} else {
X		    c = bit_be_getbits(CBIT) + 20;
X		}
X		while (--c >= 0) {
X		    c_len[i++] = 0;
X		}
X	    } else {
X		c_len[i++] = c - 2;
X	    }
X	}
X	while (i < NC) {
X	    c_len[i++] = 0;
X	}
X	make_table(NC, c_len, 12, c_table);
X    }
X}
X
Xstatic unsigned int decode_c()
X{
X    unsigned int j, mask;
X
X    if (blocksize == 0) {
X	blocksize = bit_be_getbits(16);
X	if (blocksize == 0) {
X	    decoded = 1;
X	    return 0;
X	}
X	read_pt_len(NT, TBIT, 3);
X	read_c_len();
X	read_pt_len(bitsused + 1, PBIT, -1);
X    }
X    blocksize--;
X    j = c_table[bit_be_bitbuf >> (BITBUFSIZ - 12)];
X    if (j >= NC) {
X	mask = (unsigned) 1 << (BITBUFSIZ - 1 - 12);
X	do {
X	    if (bit_be_bitbuf & mask) {
X		j = right[j];
X	    } else {
X		j = left [j];
X	    }
X	    mask >>= 1;
X	} while (j >= NC);
X    }
X    bit_be_fillbuf((int)c_len[j]);
X    return j;
X}
X
Xstatic unsigned int decode_p()
X{
X    unsigned int j, mask;
X
X    j = pt_table[bit_be_bitbuf >> (BITBUFSIZ - 8)];
X    if (j > bitsused) {
X	mask = (unsigned) 1 << (BITBUFSIZ - 1 - 8);
X	do {
X	    if (bit_be_bitbuf & mask) {
X		j = right[j];
X	    } else {
X		j = left [j];
X	    }
X	    mask >>= 1;
X	} while (j > bitsused);
X    }
X    bit_be_fillbuf((int)pt_len[j]);
X    if (j != 0) {
X	j = ((unsigned) 1 << (j - 1)) + bit_be_getbits((int) (j - 1));
X    }
X    return j;
X}
X
Xstatic void make_table(nchar, bitlen, tablebits, table)
Xint nchar;
Xunsigned char bitlen[];
Xint tablebits;
Xunsigned int table[];
X{
X    unsigned int count[17], weight[17], start[18], *p;
X    unsigned int i, k, len, ch, jutbits, avail, nextcode, mask;
X
X    for (i = 1; i <= 16; i++) {
X	count[i] = 0;
X    }
X    for (i = 0; i < nchar; i++) {
X	count[bitlen[i]]++;
X    }
X
X    start[1] = 0;
X    for (i = 1; i <= 16; i++) {
X	start[i + 1] = start[i] + (count[i] << (16 - i));
X    }
X
X    jutbits = 16 - tablebits;
X    for (i = 1; i <= tablebits; i++) {
X	start[i] >>= jutbits;
X	weight[i] = (unsigned) 1 << (tablebits - i);
X    }
X    while (i <= 16) {
X       weight[i] = (unsigned) 1 << (16 - i);
X       i++;
X    }
X
X    i = start[tablebits + 1] >> jutbits;
X    if (i != (unsigned int)((unsigned) 1 << 16)) {
X	k = 1 << tablebits;
X	while (i != k) {
X	    table[i++] = 0;
X	}
X    }
X
X    avail = nchar;
X    mask = (unsigned) 1 << (15 - tablebits);
X    for (ch = 0; ch < nchar; ch++) {
X	if ((len = bitlen[ch]) == 0) {
X	    continue;
X	}
X	nextcode = start[len] + weight[len];
X	if (len <= tablebits) {
X	    for (i = start[len]; i < nextcode; i++) {
X		table[i] = ch;
X	    }
X	} else {
X	    k = start[len];
X	    p = &table[k >> jutbits];
X	    i = len - tablebits;
X	    while (i != 0) {
X		if (*p == 0) {
X		    right[avail] = left[avail] = 0;
X		    *p = avail++;
X		}
X		if (k & mask) {
X		    p = &right[*p];
X		} else {
X		    p = &left[*p];
X		}
X		k <<= 1;
X		i--;
X	    }
X	    *p = ch;
X	}
X	start[len] = nextcode;
X    }
X}
X#else /* DELZH */
Xint delzh; /* keep lint and some compilers happy */
X#endif /* DELZH */
X
SHAR_EOF
if test 6147 -ne "`wc -c < 'de_lzh.c'`"
then
	echo shar: "error transmitting 'de_lzh.c'" '(should have been 6147 characters)'
fi
fi
echo shar: "extracting 'dd.h'" '(3113 characters)'
if test -f 'dd.h'
then
	echo shar: "will not over-write existing file 'dd.h'"
else
sed 's/^X//' << \SHAR_EOF > 'dd.h'
X#define	MAGIC1		"DDAR"
X#define	MAGIC2		"\253\315\000\124"
X
X/* Initial header */
X#define ARCHHDRCRC	 76
X#define ARCHHDRSIZE	 78
X
X/* File headers */
X#define D_MAGIC		  0
X#define D_FILL1		  4
X#define D_FNAME		  8
X#define D_ISDIR		 72
X#define D_ENDDIR	 73
X#define D_DATALENGTH	 74
X#define D_RSRCLENGTH	 78
X#define D_CTIME		 82
X#define D_MTIME		 86
X#define D_FTYPE		 90
X#define D_CREATOR	 94
X#define D_FNDRFLAGS	 98
X#define D_FILL2		100
X#define D_DATACRC	118
X#define D_RSRCCRC	120
X#define D_HDRCRC	122
X#define FILEHDRSIZE	124
X
X/* Compressed file header */
X#define	C_MAGIC		 0
X#define	C_DATALENGTH	 4
X#define	C_DATACLENGTH	 8
X#define	C_RSRCLENGTH	12
X#define	C_RSRCCLENGTH	16
X#define	C_DATAMETHOD	20
X#define	C_RSRCMETHOD	21
X#define	C_INFO1		22
X#define	C_MTIME		24
X#define	C_CTIME		28
X#define	C_FTYPE		32
X#define	C_CREATOR	36
X#define	C_FNDRFLAGS	40
X#define	C_FILL1		42
X#define	C_DATACRC	48
X#define	C_RSRCCRC	50
X#define	C_INFO2		52
X#define	C_DATAINFO	54
X#define	C_RSRCINFO	56
X#define	C_FILL2		58
X#define C_DATACRC2	78
X#define C_RSRCCRC2	80
X#define	C_HDRCRC	82
X#define	CFILEHDRSIZE	84
X
Xtypedef long OSType;
X
Xtypedef struct fileHdr {		/* 124 bytes */
X	unsigned char	magic[4];	/* "DDAR" */
X	unsigned char	fill1[4];	/* ??? */
X	unsigned char	fName[64];	/* a STR63 */
X	unsigned char	isdir;		/* starts a directory? */
X	unsigned char	enddir;		/* terminates a directory? */
X	unsigned long	dataLength;	/* lengths */
X	unsigned long	rsrcLength;
X	unsigned long	creationDate;
X	unsigned long	modDate;
X	OSType	fType;			/* file type */
X	OSType	fCreator;		/* er... */
X	unsigned short FndrFlags;	/* copy of Finder flags.  For our
X						purposes, we can clear:
X						busy,onDesk */
X	unsigned char	fill2[18];	/* ??? */
X	unsigned short	datacrc;	/* checksum */
X	unsigned short	rsrccrc;
X	unsigned short	hdrcrc;		/* true crc */
X};
X
Xtypedef struct fileCHdr {		/* 84 bytes */
X	unsigned char	magic[4];	/* "\253\315\000\124" */
X	unsigned long	dataLength;	/* lengths */
X	unsigned long	dataCLength;
X	unsigned long	rsrcLength;
X	unsigned long	rsrcCLength;
X	unsigned char	datamethod;	/* compression method used */
X	unsigned char	rsrcmethod;
X	unsigned char	info1;		/* flags ??? */
X	unsigned char	fill3;
X	unsigned long	modDate;
X	unsigned long	creationDate;
X	OSType	fType;			/* file type */
X	OSType	fCreator;		/* er... */
X	unsigned short FndrFlags;	/* copy of Finder flags.  For our
X						purposes, we can clear:
X						busy,onDesk */
X	unsigned char	fill1[6];	/* ??? */
X	unsigned short	datacrc;	/* checksum */
X	unsigned short	rsrccrc;
X	unsigned char	info2;		/* flags ??? */
X	unsigned char	fill4;
X	unsigned short	datainfo;	/* ??? */
X	unsigned short	rsrcinfo;	/* ??? */
X	unsigned char	fill2[20];	/* ??? */
X	unsigned short	datacrc2;	/* other checksum */
X	unsigned short	rsrccrc2;
X	unsigned short	hdrcrc;		/* true crc */
X};
X
X#define	DD_FILE	0
X#define	DD_COPY	1
X#define	DD_SDIR	2
X#define	DD_EDIR	3
X#define	DD_IVAL	4
X
X/* Methods used */
X#define	nocomp		0
X#define lzc		1
X#define method2		2
X#define rle		3
X#define huffman		4
X#define method5		5
X#define	method6		6
X#define lzss		7
X#define	cpt_compat	8
X#define	method9		9
X
X#define	ESC		0x144	/* Repeat packing escape */
X
SHAR_EOF
if test 3113 -ne "`wc -c < 'dd.h'`"
then
	echo shar: "error transmitting 'dd.h'" '(should have been 3113 characters)'
fi
fi
echo shar: "extracting 'dd.c'" '(25074 characters)'
if test -f 'dd.c'
then
	echo shar: "will not over-write existing file 'dd.c'"
else
sed 's/^X//' << \SHAR_EOF > 'dd.c'
X#include "macunpack.h"
X#ifdef DD
X#include "globals.h"
X#include "dd.h"
X#include "crc.h"
X#include "../fileio/machdr.h"
X#include "../fileio/wrfile.h"
X#include "../fileio/fileglob.h"
X#include "../util/masks.h"
X#include "../util/util.h"
X
Xextern char *malloc();
Xextern char *realloc();
Xextern char *strcpy();
Xextern char *strncpy();
Xextern void cpt_wrfile1();
Xextern void core_compress();
Xextern void de_compress();
X
Xstatic void dd_name();
Xstatic int dd_filehdr();
Xstatic void dd_cfilehdr();
Xstatic int dd_valid();
Xstatic int dd_valid1();
Xstatic char *dd_methname();
Xstatic unsigned long dd_checksum();
Xstatic void dd_chksum();
Xstatic unsigned long dd_checkor();
Xstatic void dd_do_delta();
Xstatic void dd_delta();
Xstatic void dd_delta3();
Xstatic void dd_copy();
Xstatic void dd_copyfile();
Xstatic void dd_expand();
Xstatic void dd_expandfile();
Xstatic void dd_nocomp();
Xstatic void dd_lzc();
X#ifdef UNTESTED
Xstatic void dd_rle();
X#ifdef NOTIMPLEMENTED
Xstatic void dd_huffman();
X#endif /* NOTIMPLEMENTED */
Xstatic void dd_lzss();
Xstatic int dd_getbits();
X#endif /* UNTESTED */
Xstatic void dd_cpt_compat();
X
Xtypedef struct methodinfo {
X	char *name;
X	int number;
X};
X
Xstatic struct methodinfo methods[] = {
X    {"NoComp",  nocomp},
X    {"LZC",     lzc},
X    {"???",	method2},
X    {"RLE",     rle},
X    {"Huffman", huffman},
X    {"???",	method5},
X    {"???",	method6},
X    {"LZSS",	lzss},
X    {"RLE/LZH",	cpt_compat},
X    {"???",	method9},
X};
Xstatic unsigned char *dd_archive;
Xstatic unsigned char *dd_data_ptr;
Xstatic int dd_archive_size;
Xstatic int dd_max_archive_size;
Xstatic unsigned char *dd_dirst;
Xstatic int dd_dirstptr;
Xstatic int dd_dirstmax;
Xstatic int dd_xor;
Xstatic long dd_bitbuf;
Xstatic int dd_bitcount;
Xstatic unsigned char *dd_bitptr;
Xstatic char dd_LZbuff[2048];
X
Xvoid dd_file(bin_hdr)
Xunsigned char *bin_hdr;
X{
X    unsigned long data_size;
X    int i;
X    struct fileCHdr cf;
X    char ftype[5], fauth[5];
X
X    updcrc = binhex_updcrc;
X    crcinit = binhex_crcinit;
X    dd_name(bin_hdr);
X    for(i = 0; i < INFOBYTES; i++) {
X	info[i] = bin_hdr[i];
X    }
X    transname(info + I_NAMEOFF + 1, text, (int)info[I_NAMEOFF] & BYTEMASK);
X    data_size = get4(info + I_DLENOFF);
X    if(data_size > dd_max_archive_size) {
X	if(dd_max_archive_size == 0) {
X	    dd_archive = (unsigned char *)malloc((unsigned)data_size);
X	} else {
X	    dd_archive = (unsigned char *)realloc((char *)dd_archive,
X						(unsigned)data_size);
X	}
X	dd_max_archive_size = data_size;
X	if(dd_archive == NULL) {
X	    (void)fprintf(stderr, "Insufficient memory.\n");
X	    exit(1);
X	}
X    }
X    dd_archive_size = data_size;
X    if(fread((char *)dd_archive, 1, (int)data_size, infp) != data_size) {
X	(void)fprintf(stderr, "Premature EOF\n");
X#ifdef SCAN
X	do_error("Premature EOF");
X#endif /* SCAN */
X	exit(1);
X    }
X    dd_data_ptr = dd_archive;
X    dd_cfilehdr(&cf);
X    write_it = 1;
X    if(list) {
X	do_indent(indent);
X	transname(info + I_TYPEOFF, ftype, 4);
X	transname(info + I_AUTHOFF, fauth, 4);
X	(void)fprintf(stderr,
X		"name=\"%s\", type=%4.4s, author=%4.4s, data=%ld, rsrc=%ld",
X		text, ftype, fauth,
X		(long)get4(info + I_DLENOFF), (long)get4(info + I_RLENOFF));
X	if(info_only) {
X	    write_it = 0;
X	}
X	if(query) {
X	    write_it = do_query();
X	} else {
X	    (void)fputc('\n', stderr);
X	}
X    }
X    if(!dd_valid((int)cf.datamethod, (int)cf.rsrcmethod)) {
X	(void)fprintf(stderr, "\tUnimplemented method found: %d %d\n",
X		cf.datamethod, cf.rsrcmethod);
X#ifdef SCAN
X	do_error("macunpack: Unimplemented method found");
X#endif /* SCAN */
X	return;
X    }
X
X    if(write_it) {
X	define_name(text);
X    }
X    if(write_it || list) {
X	dd_expand(cf, dd_data_ptr);
X    }
X}
X
Xvoid dd_arch(bin_hdr)
Xunsigned char *bin_hdr;
X{
X    unsigned long data_size;
X    unsigned long crc, filecrc;
X    struct fileHdr f;
X    struct fileCHdr cf;
X    char locname[64];
X    int i, nlength;
X
X    updcrc = binhex_updcrc;
X    crcinit = binhex_crcinit;
X    data_size = get4((char *)bin_hdr + I_DLENOFF);
X    if(data_size > dd_max_archive_size) {
X	if(dd_max_archive_size == 0) {
X	    dd_archive = (unsigned char *)malloc((unsigned)data_size);
X	} else {
X	    dd_archive = (unsigned char *)realloc((char *)dd_archive,
X						(unsigned)data_size);
X	}
X	dd_max_archive_size = data_size;
X    }
X    dd_archive_size = data_size;
X    if(fread((char *)dd_archive, 1, (int)data_size, infp) != data_size) {
X	(void)fprintf(stderr, "Insufficient memory.\n");
X	exit(1);
X    }
X    dd_name(bin_hdr);
X    nlength = bin_hdr[I_NAMEOFF];
X    for(i = 0; i < INFOBYTES; i++) {
X	info[i] = 0;
X    }
X    info[I_NAMEOFF] = nlength;
X    for(i = 1; i <= nlength; i++) {
X	info[I_NAMEOFF + i] = bin_hdr[I_NAMEOFF + i];
X    }
X    transname(info + I_NAMEOFF + 1, text, nlength);
X    (void)strcpy(locname, text);
X    if(list) {
X	do_indent(indent);
X	(void)fprintf(stderr, "folder=\"%s\"", text);
X	if(query) {
X	    if(!do_query()) {
X		return;
X	    }
X	} else {
X	    (void)fputc('\n', stderr);
X	}
X	indent++;
X    }
X    if(!info_only) {
X	do_mkdir(text, info);
X    }
X
X    if(strncmp((char *)dd_archive, "DDAR", 4)) {
X	(void)fprintf(stderr, "Magic archive header error\n");
X#ifdef SCAN
X	do_error("macunpack: Magic archive header error");
X#endif /* SCAN */
X	exit(1);
X    }
X    crc = (*updcrc)(crcinit, dd_archive, ARCHHDRSIZE - 2);
X    filecrc = get2((char *)dd_archive + ARCHHDRCRC);
X    if(crc != filecrc) {
X	(void)fprintf(stderr, "Header CRC mismatch: got 0x%02x, need 0x%02x\n",
X		(int)crc, (int)filecrc);
X#ifdef SCAN
X	do_error("macunpack: Header CRC mismatch");
X#endif /* SCAN */
X	exit(1);
X    }
X    dd_data_ptr = dd_archive + ARCHHDRSIZE;
X    while(dd_data_ptr < dd_archive + data_size) {
X	switch(dd_filehdr(&f, &cf, dir_skip)) {
X	case DD_FILE:
X	    dd_chksum(f, dd_data_ptr);
X	    dd_expand(cf, dd_data_ptr);
X	case DD_IVAL:
X	    dd_data_ptr += f.dataLength - CFILEHDRSIZE;
X	    break;
X	case DD_COPY:
X	    dd_copy(f, dd_data_ptr);
X	    dd_data_ptr += f.dataLength + f.rsrcLength;
X	    break;
X	case DD_SDIR:
X	    if(write_it || info_only) {
X		if(write_it) {
X		    do_mkdir(text, info);
X		}
X		if(dd_dirstptr == dd_dirstmax) {
X		    if(dd_dirstmax == 0) {
X			dd_dirst = (unsigned char *)malloc(64);
X		    } else {
X			dd_dirst = (unsigned char *)realloc((char *)dd_dirst,
X						(unsigned)dd_dirstmax + 64);
X		    }
X		    dd_dirstmax += 64;
X		}
X		for(i = 0; i < 64; i++) {
X		    dd_dirst[dd_dirstptr + i] = text[i];
X		}
X		dd_dirst += 64;
X		indent++;
X	    } else {
X		dir_skip++;
X	    }
X	    break;
X	case DD_EDIR:
X	    if(dir_skip) {
X		dir_skip--;
X	    } else {
X		dd_dirst -= 64;
X		indent--;
X		if(list) {
X		    do_indent(indent);
X		    (void)fprintf(stderr, "leaving folder \"%s\"\n",
X			    dd_dirst + dd_dirstptr);
X		}
X		if(!info_only) {
X		    enddir();
X		}
X	    }
X	}
X    }
X    if(!info_only) {
X	enddir();
X    }
X    if(list) {
X	indent--;
X	do_indent(indent);
X	(void)fprintf(stderr, "leaving folder \"%s\"\n", locname);
X    }
X}
X
Xstatic void dd_name(bin_hdr)
Xunsigned char *bin_hdr;
X{
X    int nlength;
X    unsigned char *extptr;
X
X    nlength = bin_hdr[I_NAMEOFF] & BYTEMASK;
X    extptr = bin_hdr + I_NAMEOFF + nlength - 3;
X    if(!strncmp((char *)extptr, ".sea", 4) ||
X       !strncmp((char *)extptr, ".Sea", 4) ||
X       !strncmp((char *)extptr, ".SEA", 4)) {
X	nlength -= 4;
X	extptr[0] = 0;
X	extptr[1] = 0;
X	extptr[2] = 0;
X	extptr[3] = 0;
X	bin_hdr[I_NAMEOFF] = nlength;
X	return;
X    }
X    extptr++;
X    if(!strncmp((char *)extptr, ".dd", 3)) {
X	nlength -=3;
X	extptr[0] = 0;
X	extptr[1] = 0;
X	extptr[2] = 0;
X	bin_hdr[I_NAMEOFF] = nlength;
X	return;
X    }
X    if(nlength < 31) {
X	nlength++;
X    }
X    bin_hdr[I_NAMEOFF + nlength] = 0xA5;
X    bin_hdr[I_NAMEOFF] = nlength;
X}
X
Xstatic int dd_filehdr(f, cf, skip)
Xstruct fileHdr *f;
Xstruct fileCHdr *cf;
Xint skip;
X{
X    register int i;
X    unsigned long crc;
X    int n, to_uncompress;
X    unsigned char *hdr;
X    char ftype[5], fauth[5];
X    unsigned long datalength, rsrclength;
X
X    to_uncompress = DD_COPY;
X    hdr = dd_data_ptr;
X    dd_data_ptr += FILEHDRSIZE;
X    for(i = 0; i < INFOBYTES; i++) {
X	info[i] = '\0';
X    }
X    crc = INIT_CRC;
X    crc = (*updcrc)(crc, hdr, FILEHDRSIZE - 2);
X
X    f->hdrcrc = get2((char *)hdr + D_HDRCRC);
X    if(f->hdrcrc != crc) {
X	(void)fprintf(stderr, "Header CRC mismatch: got 0x%04x, need 0x%04x\n",
X		f->hdrcrc & WORDMASK, (int)crc);
X#ifdef SCAN
X	do_error("macunpack: Header CRC mismatch");
X#endif /* SCAN */
X	exit(1);
X    }
X
X    n = hdr[D_FNAME] & BYTEMASK;
X    if(n > F_NAMELEN) {
X	n = F_NAMELEN;
X    }
X    info[I_NAMEOFF] = n;
X    copy(info + I_NAMEOFF + 1, (char *)hdr + D_FNAME + 1, n);
X    transname((char *)hdr + D_FNAME + 1, text, n);
X
X    if(!hdr[D_ISDIR]) {
X	f->datacrc = get2((char *)hdr + D_DATACRC);
X	f->rsrccrc = get2((char *)hdr + D_RSRCCRC);
X	f->dataLength = get4((char *)hdr + D_DATALENGTH);
X	f->rsrcLength = get4((char *)hdr + D_RSRCLENGTH);
X	copy(info + I_DLENOFF, (char *)hdr + D_DATALENGTH, 4);
X	copy(info + I_RLENOFF, (char *)hdr + D_RSRCLENGTH, 4);
X	copy(info + I_CTIMOFF, (char *)hdr + D_CTIME, 4);
X	copy(info + I_MTIMOFF, (char *)hdr + D_MTIME, 4);
X	copy(info + I_TYPEOFF, (char *)hdr + D_FTYPE, 4);
X	copy(info + I_AUTHOFF, (char *)hdr + D_CREATOR, 4);
X	copy(info + I_FLAGOFF, (char *)hdr + D_FNDRFLAGS, 2);
X    }
X
X    if(hdr[D_ISDIR]) {
X	to_uncompress = DD_SDIR;
X    } else if(hdr[D_ENDDIR]) {
X	to_uncompress = DD_EDIR;
X    } else if(!no_dd && ((hdr[D_FNDRFLAGS] & 0x80) == 0)) {
X	dd_cfilehdr(cf);
X	to_uncompress = DD_FILE;
X	datalength = cf->dataLength;
X	rsrclength = cf->rsrcLength;
X    } else {
X	datalength = f->dataLength;
X	rsrclength = f->rsrcLength;
X    }
X    hdr[D_FNDRFLAGS] &= 0x7f;
X    write_it = !skip;
X    if(list && !skip) {
X	if(to_uncompress != DD_EDIR) {
X	    do_indent(indent);
X	}
X	if(to_uncompress == DD_SDIR) {
X	    (void)fprintf(stderr, "folder=\"%s\"", text);
X	} else if(to_uncompress != DD_EDIR) {
X	    transname(info + I_TYPEOFF, ftype, 4);
X	    transname(info + I_AUTHOFF, fauth, 4);
X	    (void)fprintf(stderr,
X		    "name=\"%s\", type=%4.4s, author=%4.4s, data=%ld, rsrc=%ld",
X		    text, ftype, fauth, (long)datalength, (long)rsrclength);
X	}
X	if(info_only) {
X	    write_it = 0;
X	}
X	if(to_uncompress != DD_EDIR) {
X	    if(query) {
X		write_it = do_query();
X	    } else {
X		(void)fputc('\n', stderr);
X	    }
X	}
X	if(to_uncompress == DD_FILE) {
X	    if(!dd_valid((int)cf->datamethod, (int)cf->rsrcmethod)) {
X		(void)fprintf(stderr, "\tUnimplemented method found: %d %d\n",
X		    cf->datamethod, cf->rsrcmethod);
X#ifdef SCAN
X		do_error("macunpack: Unimplemented method found");
X#endif /* SCAN */
X		return DD_IVAL;
X	    }
X	}
X    }
X
X    if(write_it) {
X	define_name(text);
X    }
X    return to_uncompress;
X}
X
Xstatic void dd_cfilehdr(f)
Xstruct fileCHdr *f;
X{
X    unsigned long crc;
X    unsigned char *hdr;
X
X    hdr = dd_data_ptr;
X    dd_data_ptr += CFILEHDRSIZE;
X    crc = INIT_CRC;
X    crc = (*updcrc)(crc, hdr, CFILEHDRSIZE - 2);
X
X    f->hdrcrc = get2((char *)hdr + C_HDRCRC);
X    if(f->hdrcrc != crc) {
X	(void)fprintf(stderr, "Header CRC mismatch: got 0x%04x, need 0x%04x\n",
X		f->hdrcrc & WORDMASK, (int)crc);
X#ifdef SCAN
X	do_error("macunpack: Header CRC mismatch");
X#endif /* SCAN */
X	exit(1);
X    }
X
X    f->dataLength = get4((char *)hdr + C_DATALENGTH);
X    f->dataCLength = get4((char *)hdr + C_DATACLENGTH);
X    f->rsrcLength = get4((char *)hdr + C_RSRCLENGTH);
X    f->rsrcCLength = get4((char *)hdr + C_RSRCCLENGTH);
X    f->datamethod = hdr[C_DATAMETHOD];
X    f->rsrcmethod = hdr[C_RSRCMETHOD];
X    f->datacrc = get2((char *)hdr + C_DATACRC);
X    f->rsrccrc = get2((char *)hdr + C_RSRCCRC);
X    f->datainfo = get2((char *)hdr + C_DATAINFO);
X    f->rsrcinfo = get2((char *)hdr + C_RSRCINFO);
X    f->datacrc2 = get2((char *)hdr + C_DATACRC2);
X    f->rsrccrc2 = get2((char *)hdr + C_RSRCCRC2);
X    f->info1 = hdr[C_INFO1];
X    f->info2 = hdr[C_INFO2];
X    copy(info + I_DLENOFF, (char *)hdr + C_DATALENGTH, 4);
X    copy(info + I_RLENOFF, (char *)hdr + C_RSRCLENGTH, 4);
X    copy(info + I_CTIMOFF, (char *)hdr + C_CTIME, 4);
X    copy(info + I_MTIMOFF, (char *)hdr + C_MTIME, 4);
X    copy(info + I_TYPEOFF, (char *)hdr + C_FTYPE, 4);
X    copy(info + I_AUTHOFF, (char *)hdr + C_CREATOR, 4);
X    copy(info + I_FLAGOFF, (char *)hdr + C_FNDRFLAGS, 2);
X    if(f->info1 >= 0x2a && (f->info2 & 0x80) == 0) {
X	dd_xor = 0x5a;
X    } else {
X	dd_xor = 0;
X    }
X}
X
Xstatic int dd_valid(dmethod, rmethod)
Xint dmethod, rmethod;
X{
X    return dd_valid1(dmethod) | dd_valid1(rmethod);
X}
X
Xstatic int dd_valid1(method)
Xint method;
X{
X    switch(method) {
X    case nocomp:
X    case lzc:
X#ifdef UNTESTED
X    case rle:
X#ifdef NOTIMPLEMENTED
X    case huffman:
X#endif /* NOTIMPLEMENTED */
X    case lzss:
X#endif /* UNTESTED */
X    case cpt_compat:
X	return 1;
X    }
X    return 0;
X}
X
Xstatic char *dd_methname(n)
Xint n;
X{
Xint i, nmeths;
X    nmeths = sizeof(methods) / sizeof(struct methodinfo);
X    for(i = 0; i < nmeths; i++) {
X	if(methods[i].number == n) {
X	    return methods[i].name;
X	}
X    }
X    return NULL;
X}
X
Xstatic unsigned long dd_checksum(init, buffer, length)
Xunsigned long init;
Xchar *buffer;
Xunsigned long length;
X{
X    int i;
X    unsigned long cks;
X
X    cks = init;
X    for(i = 0; i < length; i++) {
X	cks += *buffer++ & BYTEMASK;
X    }
X    return cks & WORDMASK;
X}
X
Xstatic void dd_chksum(hdr, data)
Xstruct fileHdr hdr;
Xunsigned char *data;
X{
X    unsigned long cks;
X
X    if(write_it) {
X	cks = dd_checksum(INIT_CRC, (char *)data - CFILEHDRSIZE,
X			  hdr.dataLength);
X	if(hdr.datacrc != cks) {
X	    (void)fprintf(stderr,
X		"Checksum error on compressed file: need 0x%04x, got 0x%04x\n",
X		hdr.datacrc, (int)cks);
X#ifdef SCAN
X	    do_error("macunpack: Checksum error on compressed file");
X#endif /* SCAN */
X	    exit(1);
X	}
X    }
X}
X
Xstatic unsigned long dd_checkor(init, buffer, length)
Xunsigned long init;
Xchar *buffer;
Xunsigned long length;
X{
X    int i;
X    unsigned long cks;
X
X    cks = init;
X    for(i = 0; i < length; i++) {
X	cks ^= *buffer++ & BYTEMASK;
X    }
X    return cks & WORDMASK;
X}
X
Xstatic void dd_do_delta(out_ptr, nbytes, kind)
Xchar *out_ptr;
Xunsigned long nbytes;
Xint kind;
X{
X    switch(kind) {
X    case 0:
X	break;
X    case 1:
X	dd_delta(out_ptr, nbytes);
X	break;
X    case 2:
X	dd_delta3(out_ptr, nbytes);
X	break;
X    default:
X	(void)fprintf(stderr, "Illegal kind value found: %d\n", kind);
X#ifdef SCAN
X	do_error("Illegal kind value found");
X#endif /* SCAN */
X	exit(1);
X    }
X}
X
Xstatic void dd_delta(out_ptr, nbytes)
Xchar *out_ptr;
Xunsigned long nbytes;
X{
X    int i, sum = 0;
X
X    for(i = 0; i < nbytes; i++) {
X	sum = (sum + *out_ptr) & BYTEMASK;
X	*out_ptr++ = sum;
X    }
X}
X
Xstatic void dd_delta3(out_ptr, nbytes)
Xchar *out_ptr;
Xunsigned long nbytes;
X{
X    int i, sum1 = 0, sum2 = 0, sum3 = 0;
X
X    for(i = 0; i < nbytes; i += 3) {
X	sum1 = (sum1 + *out_ptr) & BYTEMASK;
X	*out_ptr++ = sum1;
X	if(i < nbytes - 1) {
X	    sum2 = (sum2 + *out_ptr) & BYTEMASK;
X	    *out_ptr++ = sum2;
X	    if(i < nbytes) {
X		sum3 = (sum3 + *out_ptr) & BYTEMASK;
X		*out_ptr++ = sum3;
X	    }
X	}
X    }
X}
X
X/*---------------------------------------------------------------------------*/
X/*	Archive only, no compression					     */
X/*---------------------------------------------------------------------------*/
Xstatic void dd_copy(hdr, data)
Xstruct fileHdr hdr;
Xunsigned char *data;
X{
X    unsigned long cks;
X
X    if(write_it) {
X	start_info(info, hdr.rsrcLength, hdr.dataLength);
X    }
X    if(verbose) {
X	(void)fprintf(stderr, "\tNo compression");
X    }
X    if(write_it) {
X	start_data();
X    }
X    dd_copyfile(hdr.dataLength, data);
X    data += hdr.dataLength;
X    if(write_it) {
X	cks = dd_checksum(INIT_CRC, out_buffer, hdr.dataLength);
X	if(hdr.datacrc != cks) {
X	    (void)fprintf(stderr,
X		"Checksum error on data fork: need 0x%04x, got 0x%04x\n",
X		hdr.datacrc, (int)cks);
X#ifdef SCAN
X	    do_error("macunpack: Checksum error on data fork");
X#endif /* SCAN */
X	    exit(1);
X	}
X    }
X    if(write_it) {
X	start_rsrc();
X    }
X    dd_copyfile(hdr.rsrcLength, data);
X    data += hdr.rsrcLength;
X    if(write_it) {
X	cks = dd_checksum(INIT_CRC, out_buffer, hdr.rsrcLength);
X	if(hdr.rsrccrc != cks) {
X	    (void)fprintf(stderr,
X		"Checksum error on resource fork: need 0x%04x, got 0x%04x\n",
X		hdr.rsrccrc, (int)cks);
X#ifdef SCAN
X	    do_error("macunpack: Checksum error on resource fork");
X#endif /* SCAN */
X	    exit(1);
X	}
X	end_file();
X    }
X    if(verbose) {
X	(void)fprintf(stderr, ".\n");
X    }
X}
X
Xstatic void dd_copyfile(obytes, data)
Xunsigned long obytes;
Xunsigned char *data;
X{
X    if(obytes == 0) {
X	return;
X    }
X    if(write_it) {
X	copy(out_ptr, (char *)data, (int)obytes);
X    }
X}
X
X/*---------------------------------------------------------------------------*/
X/*	Possible compression, and perhaps in an archive			     */
X/*---------------------------------------------------------------------------*/
Xstatic void dd_expand(hdr, data)
Xstruct fileCHdr hdr;
Xunsigned char *data;
X{
X    unsigned long cks;
X    char *out_buf;
X
X    if(write_it) {
X	start_info(info, hdr.rsrcLength, hdr.dataLength);
X    }
X    if(verbose) {
X	(void)fprintf(stderr, "\tData: ");
X    }
X    if(write_it) {
X	start_data();
X    }
X    out_buf = out_buffer;
X    dd_expandfile(hdr.dataLength, hdr.dataCLength, (int)hdr.datamethod, 
X	(int)hdr.datainfo, data, (unsigned long)hdr.datacrc);
X    data += hdr.dataCLength;
X    if(write_it) {
X	if((hdr.info2 & 0x40) && (hdr.dataLength != 0)) {
X	    cks = arc_updcrc(INIT_CRC, (unsigned char *)out_buf,
X			     (int)hdr.dataLength);
X	    if(cks != hdr.datacrc2) {
X		(void)fprintf(stderr,
X		    "Checksum error on data fork: need 0x%04x, got 0x%04x\n",
X		    (int)hdr.datacrc2, (int)cks);
X#ifdef SCAN
X		do_error("macunpack: Checksum error on data fork");
X#endif /* SCAN */
X		exit(1);
X	    }
X	}
X    }
X    if(verbose) {
X	(void)fprintf(stderr, ", Rsrc: ");
X    }
X    if(write_it) {
X	start_rsrc();
X    }
X    out_buf = out_buffer;
X    dd_expandfile(hdr.rsrcLength, hdr.rsrcCLength, (int)hdr.rsrcmethod,
X	(int)hdr.rsrcinfo, data, (unsigned long)hdr.rsrccrc);
X    data += hdr.rsrcCLength;
X    if(write_it) {
X	if((hdr.info2 & 0x40) && (hdr.rsrcLength != 0)) {
X	    cks = arc_updcrc(INIT_CRC, (unsigned char *)out_buf,
X			     (int)hdr.rsrcLength);
X	    if(cks != hdr.rsrccrc2) {
X		(void)fprintf(stderr,
X		   "Checksum error on resource fork: need 0x%04x, got 0x%04x\n",
X		    (int)hdr.rsrccrc2, (int)cks);
X#ifdef SCAN
X		do_error("macunpack: Checksum error on resource fork");
X#endif /* SCAN */
X		exit(1);
X	    }
X	}
X	end_file();
X    }
X    if(verbose) {
X	(void)fprintf(stderr, ".\n");
X    }
X}
X
Xstatic void dd_expandfile(obytes, ibytes, method, kind, data, chksum)
Xunsigned long obytes, ibytes, chksum;
Xint method, kind;
Xunsigned char *data;
X{
X    int sub_method, m1, m2;
X    char *optr = out_ptr;
X    unsigned long cksinit;
X
X    if(obytes == 0) {
X	if(verbose) {
X	    (void)fprintf(stderr, "empty");
X	}
X	return;
X    }
X    switch(method & 0x7f) {
X    case nocomp:
X	if(verbose) {
X	    (void)fprintf(stderr, "No compression");
X	}
X	if(write_it) {
X	    dd_nocomp(obytes, data);
X	}
X	break;
X    case lzc:
X	m1 = (*data++ & BYTEMASK) ^ dd_xor;
X	m2 = (*data++ & BYTEMASK) ^ dd_xor;
X	sub_method = (*data++ & BYTEMASK) ^ dd_xor;
X	cksinit = m1 + m2 + sub_method;
X	sub_method = sub_method & 0x1f;
X	if(verbose) {
X	    (void)fprintf(stderr, "LZC(%d) compressed (%4.1f%%)",
X		    sub_method, 100.0 * ibytes / obytes);
X	}
X	if(write_it) {
X	    dd_lzc(ibytes - 3, obytes, data, sub_method, chksum, cksinit);
X	}
X	break;
X#ifdef UNTESTED
X    case rle:
X	if(verbose) {
X	    (void)fprintf(stderr, "RLE compressed (%4.1f%%)",
X		    100.0 * ibytes / obytes);
X	}
X	if(write_it) {
X	    dd_rle(ibytes, data);
X	}
X	break;
X#ifdef NOTIMPLEMENTED
X    case huffman:
X	if(verbose) {
X	    (void)fprintf(stderr, "Huffman compressed (%4.1f%%)",
X		    100.0 * ibytes / obytes);
X	}
X	if(write_it) {
X	    dd_huffman(ibytes, data);
X	}
X	break;
X#endif /* NOTIMPLEMENTED */
X    case lzss:
X	if(verbose) {
X	    (void)fprintf(stderr, "LZSS compressed (%4.1f%%)",
X		    100.0 * ibytes / obytes);
X	}
X	if(write_it) {
X	    dd_lzss(data, chksum);
X	}
X	break;
X#endif /* UNTESTED */
X    case cpt_compat:
X	sub_method = get2((char *)data);
X	data += 16;
X	if(sub_method != 0) {
X	    sub_method = 0;
X	} else {
X	    sub_method = 1;
X	}
X	if(verbose) {
X	    if(!sub_method) {
X		(void)fprintf(stderr, "RLE compressed (%4.1f%%)",
X			100.0 * ibytes / obytes);
X	    } else {
X		(void)fprintf(stderr, "RLE/LZH compressed (%4.1f%%)",
X			100.0 * ibytes / obytes);
X	    }
X	}
X	if(write_it) {
X	    dd_cpt_compat(ibytes, obytes, data, sub_method, chksum);
X	}
X	break;
X    default:
X	break;
X    }
X    if(write_it) {
X	dd_do_delta(optr, obytes, kind);
X    }
X}
X
X/*---------------------------------------------------------------------------*/
X/*	Method 0: no compression					     */
X/*---------------------------------------------------------------------------*/
Xstatic void dd_nocomp(obytes, data)
Xunsigned char *data;
Xunsigned long obytes;
X{
X    copy(out_ptr, (char *)data, (int)obytes);
X}
X
X/*---------------------------------------------------------------------------*/
X/*	Method 1: LZC compressed					     */
X/*---------------------------------------------------------------------------*/
Xstatic void dd_lzc(ibytes, obytes, data, mb, chksum, ckinit)
Xunsigned char *data;
Xunsigned long ibytes, obytes, chksum, ckinit;
Xint mb;
X{
X    int i;
X    char *out_buf;
X    unsigned long cks;
X
X    out_buf = out_buffer;
X    core_compress((char *)data);
X    de_compress(ibytes, mb);
X    out_buffer = out_buf;
X    if(dd_xor != 0) {
X	for(i = 0; i < obytes; i++) {
X	    *out_buf++ ^= dd_xor;
X	}
X    }
X    cks = dd_checksum(ckinit, out_buffer, obytes);
X    if(chksum != cks) {
X	(void)fprintf(stderr,
X	    "Checksum error on fork: need 0x%04x, got 0x%04x\n",
X	    (int)chksum, (int)cks);
X#ifdef SCAN
X	do_error("macunpack: Checksum error on fork");
X#endif /* SCAN */
X	exit(1);
X    }
X}
X
X#ifdef UNTESTED
X/*---------------------------------------------------------------------------*/
X/*	Method 3: Run length encoding					     */
X/*---------------------------------------------------------------------------*/
Xstatic void dd_rle(ibytes, data)
Xunsigned char *data;
Xunsigned long ibytes;
X{
X    int ch, lastch, n, i;
X
X    while(ibytes != 0) {
X	ch = *data++;
X	ibytes--;
X	if(ch == ESC) {
X	    n = *data++ - 1;
X	    ibytes--;
X	    if(n < 0) {
X		*out_ptr++ = ESC;
X		lastch = ESC;
X	    } else {
X		for(i = 0; i < n; i++) {
X		    *out_ptr++ = lastch;
X		}
X	    }
X	} else {
X	    *out_ptr++ = ch;
X	    lastch = ch;
X	}
X    }
X}
X
X#ifdef NOTIMPLEMENTED
X/*---------------------------------------------------------------------------*/
X/*	Method 4: Huffman encoding					     */
X/*---------------------------------------------------------------------------*/
Xstatic void dd_huffman(ibytes, data)
Xunsigned char *data;
Xunsigned long ibytes;
X{
X}
X#endif /* NOTIMPLEMENTED */
X
X/*---------------------------------------------------------------------------*/
X/*	Method 7: Slightly improved LZSS				     */
X/*---------------------------------------------------------------------------*/
Xstatic void dd_lzss(data, chksum)
Xunsigned char *data;
Xunsigned long chksum;
X{
X    int i, LZptr, LZbptr, LZlength;
X    char *optr = out_ptr;
X    unsigned char cks;
X
X    data += get4((char *)data + 6);
X    LZptr = 0;
X    while(1) {
X	if(dd_getbits(1) == 0) {
X	    *out_ptr++ = dd_LZbuff[LZptr++] = dd_getbits(8);
X	    LZptr &= 0x7ff;
X	} else {
X	    if(dd_getbits(1) == 0) {
X		LZbptr = dd_getbits(11);
X	    } else {
X		LZbptr = dd_getbits(7);
X	    }
X	    if(LZbptr == 0) {
X		break;
X	    }
X	    LZbptr = (LZptr - LZbptr) & 0x7ff;
X	    LZlength = dd_getbits(2);
X	    if(LZlength == 3) {
X		LZlength += dd_getbits(2);
X		if(LZlength == 6) {
X		    do {
X			i = dd_getbits(4);
X			LZlength += i;
X		    } while(i == 15);
X		}
X	    }
X	    LZlength += 2;
X	    for(i = 0; i < LZlength; i++) {
X		*out_ptr++ = dd_LZbuff[LZptr++] = dd_LZbuff[LZbptr++];
X		LZptr &= 0x7ff;
X		LZbptr &= 0x7ff;
X	    }
X	}
X    }
X    cks = dd_checkor(INIT_CRC, optr, (unsigned long)(out_ptr - optr));
X    if(chksum != cks) {
X	(void)fprintf(stderr,
X	    "Checksum error on fork: need 0x%04x, got 0x%04x\n",
X	    chksum, (int)cks);
X#ifdef SCAN
X	do_error("macunpack: Checksum error on fork");
X#endif /* SCAN */
X	exit(1);
X    }
X}
X
Xstatic int dd_getbits(n)
Xint n;
X{
X    int r;
X
X    while(dd_bitcount < n) {
X	dd_bitbuf = (dd_bitbuf << 8) | (~(*dd_bitptr++) & BYTEMASK);
X	dd_bitcount += 8;
X    }
X    dd_bitcount -= n;
X    r = (dd_bitbuf >> dd_bitcount);
X    dd_bitbuf ^= (r << dd_bitcount);
X    return r;
X}
X
X#endif /* UNTESTED */
X
X/*---------------------------------------------------------------------------*/
X/*	Method 8: Compactor compatible compression			     */
X/*---------------------------------------------------------------------------*/
Xstatic void dd_cpt_compat(ibytes, obytes, data, sub_method, chksum)
Xunsigned char *data;
Xunsigned long ibytes, obytes, chksum;
Xint sub_method;
X{
X    unsigned long cks;
X    char *optr = out_buffer;
X
X    cpt_wrfile1(data, ibytes, obytes, sub_method, (unsigned long)0x0fff0);
X    cks = arc_updcrc(INIT_CRC, (unsigned char *)optr, (int)obytes);
X    if(chksum != cks) {
X	(void)fprintf(stderr,
X	    "Checksum error on fork: need 0x%04x, got 0x%04x\n",
X	    (int)chksum, (int)cks);
X#ifdef SCAN
X	do_error("macunpack: Checksum error on fork");
X#endif /* SCAN */
X	exit(1);
X    }
X}
X#else /* DD */
Xint dd; /* keep lint and some compilers happy */
X#endif /* DD */
X
SHAR_EOF
if test 25074 -ne "`wc -c < 'dd.c'`"
then
	echo shar: "error transmitting 'dd.c'" '(should have been 25074 characters)'
fi
fi
echo shar: "done with directory 'macunpack'"
cd ..
echo shar: "extracting 'makefile'" '(1609 characters)'
if test -f 'makefile'
then
	echo shar: "will not over-write existing file 'makefile'"
else
sed 's/^X//' << \SHAR_EOF > 'makefile'
XSHELL =	/bin/sh
XBINDIR =	/ufs/dik/tmpbin
X# Use the following flags on the CF macro definition as needed.
X#
X# -DBSD if you are on a BSD system
X#
X# -DTYPES_H if your system has /usr/include/sys/types.h
X#
X# -DDIRENT_H if your system has /usr/include/dirent.h
X#
X# -DNODOT if you do not want to create files with an initial period
X#
X# -DLATIN1 if your system supports LATIN-1 and you want to use it
X#
X# Note you can use at most one of the following four!
X#
X# -DNOMKDIR if your system does not have the mkdir system call
X#
X# -DAUFS if you want to use an AUFS file system
X#
X# -DAUFSPLUS if you use CAP 6.0 and want to use times on files
X#
X# -DAPPLEDOUBLE if you want to be able to use an AppleDouble file system
X#
XCF =	-DBSD -DTYPES_H -DDIRENT_H -DNODOT -DAPPLEDOUBLE
X
Xall:
X	(cd crc; make CF='$(CF)')
X	(cd util; make CF='$(CF)')
X	(cd fileio; make CF='$(CF)')
X	(cd macunpack; make CF='$(CF)')
X	(cd hexbin; make CF='$(CF)')
X	(cd mixed; make CF='$(CF)')
X
Xclean:
X	(cd crc; make clean)
X	(cd util; make clean)
X	(cd fileio; make clean)
X	(cd macunpack; make clean)
X	(cd hexbin; make clean)
X	(cd mixed; make clean)
X
Xclobber:
X	(cd crc; make clean)
X	(cd util; make clean)
X	(cd fileio; make clean)
X	(cd macunpack; make clobber)
X	(cd hexbin; make clobber)
X	(cd mixed; make clobber)
X
Xlint:
X	(cd macunpack; make CF='$(CF)' lint)
X	(cd hexbin; make CF='$(CF)' lint)
X	(cd mixed; make CF='$(CF)' lint)
X
Xinstall:
X	cp macunpack/macunpack $(BINDIR)/.
X	cp hexbin/hexbin $(BINDIR)/.
X	cp mixed/macsave $(BINDIR)/.
X	cp mixed/macstream $(BINDIR)/.
X
Xdistr:
X	shar -a README makefile crc util fileio macunpack hexbin mixed doc man >macutil.shar
X
SHAR_EOF
if test 1609 -ne "`wc -c < 'makefile'`"
then
	echo shar: "error transmitting 'makefile'" '(should have been 1609 characters)'
fi
fi
if test ! -d 'hexbin'
then
	echo shar: "creating directory 'hexbin'"
	mkdir 'hexbin'
fi
echo shar: "entering directory 'hexbin'"
cd 'hexbin'
echo shar: "extracting 'hexbin.c'" '(7767 characters)'
if test -f 'hexbin.c'
then
	echo shar: "will not over-write existing file 'hexbin.c'"
else
sed 's/^X//' << \SHAR_EOF > 'hexbin.c'
X#ifdef TYPES_H
X#include <sys/types.h>
X#endif /* TYPES_H */
X#include <sys/stat.h>
X#include "globals.h"
X#include "crc.h"
X#include "readline.h"
X#include "../util/masks.h"
X#include "../util/util.h"
X#include "../util/patchlevel.h"
X#include "../fileio/wrfile.h"
X#include "../fileio/wrfileopt.h"
X#include "../fileio/machdr.h"
X#include "../fileio/kind.h"
X#include "../util/curtime.h"
X#include "hexbin.h"
X
X#define LOCALOPT	"ilvcn:qVH"
X
Xextern void exit();
Xextern void backtrans();
X#ifdef DL
Xextern void dl();
X#endif /* DL */
X#ifdef HECX
Xextern void hecx();
X#endif /* HECX */
X#ifdef HQX
Xextern void hqx();
X#endif /* HQX */
X#ifdef MU
Xextern void mu();
X#endif /* MU */
X
Xstatic void usage();
Xstatic void do_files();
Xstatic int find_header();
X
Xstatic char options[128];
X
Xint main(argc, argv)
Xint argc;
Xchar **argv;
X{
X    char *filename;
X    char macname[32];
X    extern int optind;
X    extern char *optarg;
X    int errflg;
X    int c;
X
X    set_wrfileopt(0);
X    (void)strcat(options, get_wrfileopt());
X    (void)strcat(options, LOCALOPT);
X    errflg = 0;
X    filename = "";
X    macname[0] = 0;
X
X    while((c = getopt(argc, argv, options)) != EOF) {
X	if(!wrfileopt((char)c)) {
X	    switch(c) {
X	    case 'l':
X		listmode++;
X		break;
X	    case 'v':
X		verbose++;
X		break;
X	    case 'i':
X		info_only++;
X		break;
X	    case 'c':
X		uneven_lines++;
X		break;
X	    case 'n':
X		backtrans(macname, optarg);
X		break;
X	    case '?':
X		errflg++;
X		break;
X	    case 'H':
X		give_wrfileopt();
X		(void)fprintf(stderr, "Hexbin specific options:\n");
X		(void)fprintf(stderr,
X			"-i:\tgive information only, do not convert\n");
X		(void)fprintf(stderr, "-l:\tgive listing\n");
X		(void)fprintf(stderr,
X			"-v:\tgive verbose listing, including lines skipped\n");
X		(void)fprintf(stderr,
X			"-c:\tdo not check for equal line lengths\n");
X		(void)fprintf(stderr, "-n nm:\tname to be generated\n");
X		(void)fprintf(stderr,
X			"-V:\tgive information about this version\n");
X		(void)fprintf(stderr, "-H:\tthis message\n");
X		(void)fprintf(stderr, "Default is silent conversion\n");
X		exit(0);
X	    case 'V':
X		(void)fprintf(stderr, "Version %s, ", VERSION);
X		(void)fprintf(stderr, "patchlevel %d", PATCHLEVEL);
X		(void)fprintf(stderr, "%s.\n", get_mina());
X		(void)fprintf(stderr, "Hexified files recognized:\n");
X#ifdef DL
X		(void)fprintf(stderr, "\tDownload (.dl)\n");
X#endif /* DL */
X#ifdef HECX
X		(void)fprintf(stderr, "\tBinHex 2.0 (.hex)\n");
X		(void)fprintf(stderr, "\tBinHex 3.0 (.hcx)\n");
X#endif /* HECX */
X#ifdef HQX
X		(void)fprintf(stderr, "\tBinHex 4.0 (.hqx)\n");
X#endif /* HQX */
X#ifdef MU
X		(void)fprintf(stderr, "\tUUTool (.mu)\n");
X#endif /* MU */
X		exit(0);
X	    }
X	}
X    }
X    if(errflg) {
X	usage();
X	exit(1);
X    }
X    if(info_only || verbose) {
X	listmode++;
X    }
X
X    do {
X	if(optind == argc) {
X	    filename = "-";
X	} else {
X	    filename = argv[optind];
X	    optind++;
X#ifdef SCAN
X	    do_idf(filename, UNIX_NAME);
X#endif /* SCAN */
X	}
X	do_files(filename, macname);
X    } while(optind < argc);
X    exit(0);
X    /* NOTREACHED */
X}
X
Xstatic char *extensions[] = {
X#ifdef DL
X    ".dl",
X#endif /* DL */
X#ifdef HECX
X    ".hex",
X    ".Hex",
X    ".hcx",
X    ".Hcx",
X#endif /* HECX */
X#ifdef HQX
X    ".hqx",
X    ".Hqx",
X#endif /* HQX */
X#ifdef MU
X    ".mu",
X#endif /* MU */
X    "",
X    NULL
X};
X
Xstatic void do_files(filename, macname)
Xchar *filename;	/* input file name -- extension optional */
Xchar *macname;	/* name to use on the mac side of things */
X{
X    char namebuf[256];
X    char **ep;
X    struct stat stbuf;
X    long curtime;
X    int qformat;
X    int again;
X
X    if(filename[0] == '-') {
X	ifp = stdin;
X	filename = "stdin";
X    } else {
X	/* find input file and open it */
X	for(ep = extensions; *ep != NULL; ep++) {
X	    (void)sprintf(namebuf, "%s%s", filename, *ep);
X	    if(stat(namebuf, &stbuf) == 0) {
X		break;
X	    }
X	}
X	if(*ep == NULL) {
X	    perror(namebuf);
X	    exit(1);
X	}
X	ifp = fopen(namebuf, "r");
X	if(ifp == NULL) {
X	    perror(namebuf);
X	    exit(1);
X	}
X    }
X    again = 0;
Xnexttry:
X    if(ifp == stdin) {
X	curtime = (long)time((time_t *)0) + TIMEDIFF;
X	mh.m_createtime = curtime;
X	mh.m_modifytime = curtime;
X    } else {
X	mh.m_createtime = stbuf.st_mtime + TIMEDIFF;
X	mh.m_modifytime = stbuf.st_mtime + TIMEDIFF;
X    }
X
X    qformat = find_header(again); /* eat mailer header &cetera, intuit format */
X
X    switch (qformat) {
X#ifdef DL
X    case form_dl:
X	dl(macname, filename);
X	break;
X#endif /* DL */
X#ifdef HECX
X    case form_hecx:
X	hecx(macname, filename);
X	break;
X#endif /* HECX */
X#ifdef HQX
X    case form_hqx:
X	hqx(macname);
X	again = 1;
X	goto nexttry;
X#endif /* HQX */
X#ifdef MU
X    case form_mu:
X	mu(macname);
X	again = 1;
X	goto nexttry;
X#endif /* MU */
X    default:
X	break;
X    }
X    (void)fclose(ifp);
X}
X
X/* eat characters until header detected, return which format */
Xstatic int find_header(again)
Xint again;
X{
X    int c, dl_start, llen;
X    char *cp;
X    char header[INFOBYTES];
X    int ds, rs;
X
X    if(again && was_macbin) {
X	while(to_read-- > 0) {
X	    c = fgetc(ifp);
X	}
X    }
X    was_macbin = 0;
X    c = fgetc(ifp);
X    (void)ungetc(c, ifp);
X    if(c == 0) {
X	was_macbin = 1;
X	if(fread(header, 1, INFOBYTES, ifp) != INFOBYTES) {
X	    (void)fprintf(stderr, "Premature EOF\n");
X#ifdef SCAN
X	    do_error("hexbin: Premature EOF");
X#endif /* SCAN */
X	    exit(1);
X	}
X	ds = get4(header + I_DLENOFF);
X	rs = get4(header + I_RLENOFF);
X	ds = (((ds + 127) >> 7) << 7);
X	rs = (((rs + 127) >> 7) << 7);
X	to_read = ds + rs;
X	if(strncmp(header + I_TYPEOFF, "TEXT", 4)) {
X	    (void)fprintf(stderr, "This file is not a proper BinHexed file.\n");
X#ifdef SCAN
X	    do_error("hexbin: not a proper BinHexed file");
X#endif /* SCAN */
X	    exit(1);
X	}
X	if(listmode) {
X	    (void)fprintf(stderr, "This file is probably packed by ");
X	    if(!strncmp(header + I_AUTHOFF, "BNHQ", 4)) {
X		(void)fprintf(stderr, "\"BinHex\"");
X	    } else if(!strncmp(header + I_AUTHOFF, "BthX", 4)) {
X		(void)fprintf(stderr, "\"BinHqx\"");
X	    } else if(!strncmp(header + I_AUTHOFF, "BnHq", 4)) {
X		(void)fprintf(stderr, "\"StuffIt\"");
X	    } else if(!strncmp(header + I_AUTHOFF, "ttxt", 4)) {
X		(void)fprintf(stderr, "\"Compactor\"");
X	    } else if(!strncmp(header + I_AUTHOFF, "BSWU", 4)) {
X		(void)fprintf(stderr, "\"UUTool\"");
X	    } else {
X		(void)fprintf(stderr, "an unknown program");
X	    }
X	    (void)fprintf(stderr, ".\n");
X	}
X    }
X    /*	look for "(This file ...)" or "(Convert with...)" line. */
X    /*	or for "begin " */
X    /*	dl format starts with a line containing only the symbols '@' to 'O',
X	or '|'. */
X    while(readline()) {
X	llen = strlen(line);
X#ifdef HQX
X	if((strncmp(line, "(This file", 10) == 0) ||
X	    (strncmp(line, "(Convert with", 13) == 0)) {
X	    if(verbose) {
X		(void)fprintf(stderr, "Skip:%s\n", line);
X	    }
X	    break;
X	}
X#endif /* HQX */
X#ifdef MU
X	if(strncmp(line, "begin ", 6) == 0) {
X	    return form_mu;
X	}
X#endif /* MU */
X#ifdef DL
X	/* Do not allow bogus false starts */
X	if(llen > 40 && (llen & 1) == 0) {
X	    dl_start = 1;
X	    for(cp = &line[0]; *cp != 0; cp++) {
X		if((*cp < '@' || *cp > 'O') && *cp != '|') {
X		    dl_start = 0;
X		    break;
X		}
X	    }
X	    if(dl_start && cp > &line[1]) {
X		return form_dl;
X	    }
X	}
X#endif /* DL */
X	if(llen != 0 && verbose) {
X	    (void)fprintf(stderr, "Skip:%s\n", line);
X	}
X    }
X    while(readline()) {
X	switch (line[0]) {
X#ifdef HQX
X	case ':':
X	    return form_hqx;
X#endif /* HQX */
X#ifdef HECX
X	case '#':
X	    return form_hecx;
X#endif /* HECX */
X	default:
X	    break;
X	}
X    }
X
X    if(!again) {
X	(void)fprintf(stderr, "unexpected EOF\n");
X#ifdef SCAN
X	do_error("hexbin: unexpected EOF");
X#endif /* SCAN */
X	exit(1);
X    }
X    return form_none;
X}
X
Xstatic void usage()
X{
X    (void)fprintf(stderr, "Usage: hexbin [-%s] [filenames]\n", options);
X    (void)fprintf(stderr, "Use \"hexbin -H\" for help.\n");
X}
X
SHAR_EOF
if test 7767 -ne "`wc -c < 'hexbin.c'`"
then
	echo shar: "error transmitting 'hexbin.c'" '(should have been 7767 characters)'
fi
fi
echo shar: "extracting 'makefile'" '(2504 characters)'
if test -f 'makefile'
then
	echo shar: "will not over-write existing file 'makefile'"
else
sed 's/^X//' << \SHAR_EOF > 'makefile'
XCFLAGS=	-O $(CF)
X
XSRCS =	hexbin.c \
X	dl.c \
X	hecx.c \
X	hqx.c \
X	mu.c \
X	buffer.c \
X	crc.c \
X	readline.c \
X	printhdr.c \
X	globals.c
X
XOBJS =	hexbin.o \
X	dl.o \
X	hecx.o \
X	hqx.o \
X	mu.o \
X	buffer.o \
X	crc.o \
X	readline.o \
X	printhdr.o \
X	globals.o
X
XLIB =	../crc/libcrc.a
XTNAME =	../util/transname
XBNAME =	../util/backtrans
XUNAME =	../util/util
XONAME =	../fileio/wrfile
XGNAME =	../fileio/fileglob
XXOBJS =	$(TNAME).o $(BNAME).o $(UNAME).o $(ONAME).o $(GNAME).o
XXSRCS =	$(TNAME).c $(BNAME).c $(UNAME).c $(ONAME).c $(GNAME).c
XCRCS =	../crc/binhex.c
X
Xhexbin:	$(OBJS) $(LIB) $(XOBJS)
X	$(CC) $(CFLAGS) -o hexbin $(OBJS) $(XOBJS) $(LIB)
X
X$(LIB):	../crc/makecrc.c
X	(cd ../crc; make CC=$(CC) CF="$(CF)" )
X
X$(TNAME).o:	$(TNAME).c
X	(cd ../util; make CC=$(CC) CF="$(CF)" )
X
X$(BNAME).o:	$(BNAME).c
X	(cd ../util; make CC=$(CC) CF="$(CF)" )
X
X$(UNAME).o:	$(UNAME).c
X	(cd ../util; make CC=$(CC) CF="$(CF)" )
X
X$(ONAME).o:	$(ONAME).c
X	(cd ../fileio; make CC=$(CC) CF="$(CF)" )
X
X$(GNAME).o:	$(GNAME).c
X	(cd ../fileio; make CC=$(CC) CF="$(CF)" )
X
Xlint:
X	lint $(CF) $(LFLAGS) $(SRCS) $(XSRCS) $(CRCS)
X
Xclean:
X	-rm -f *.o
X
Xclobber:clean
X	-rm -f hexbin
X
Xhexbin.o:	globals.h
Xhexbin.o:	crc.h
Xhexbin.o:	readline.h
Xhexbin.o:	../util/masks.h
Xhexbin.o:	../util/util.h
Xhexbin.o:	../util/patchlevel.h
Xhexbin.o:	../fileio/wrfile.h
Xhexbin.o:	../fileio/wrfileopt.h
Xhexbin.o:	../fileio/machdr.h
Xhexbin.o:	../fileio/kind.h
Xhexbin.o:	../util/curtime.h
Xhexbin.o:	hexbin.h
Xdl.o:	hexbin.h
Xdl.o:	globals.h
Xdl.o:	crc.h
Xdl.o:	readline.h
Xdl.o:	../fileio/machdr.h
Xdl.o:	../fileio/wrfile.h
Xdl.o:	../util/util.h
Xdl.o:	buffer.h
Xdl.o:	printhdr.h
Xhecx.o:	hexbin.h
Xhecx.o:	globals.h
Xhecx.o:	crc.h
Xhecx.o:	readline.h
Xhecx.o:	../util/masks.h
Xhecx.o:	../util/util.h
Xhecx.o:	../fileio/machdr.h
Xhecx.o:	../fileio/wrfile.h
Xhecx.o:	buffer.h
Xhecx.o:	printhdr.h
Xhqx.o:	hexbin.h
Xhqx.o:	globals.h
Xhqx.o:	readline.h
Xhqx.o:	crc.h
Xhqx.o:	buffer.h
Xhqx.o:	../fileio/machdr.h
Xhqx.o:	../fileio/wrfile.h
Xhqx.o:	../util/util.h
Xhqx.o:	printhdr.h
Xmu.o:	hexbin.h
Xmu.o:	globals.h
Xmu.o:	readline.h
Xmu.o:	../util/masks.h
Xmu.o:	../util/util.h
Xmu.o:	../fileio/machdr.h
Xmu.o:	../fileio/wrfile.h
Xmu.o:	buffer.h
Xmu.o:	printhdr.h
Xbuffer.o:	globals.h
Xbuffer.o:	../util/util.h
Xbuffer.o:	buffer.h
Xbuffer.o:	../fileio/wrfile.h
Xcrc.o:	hexbin.h
Xcrc.o:	crc.h
Xcrc.o:	../util/masks.h
Xcrc.o:	globals.h
Xreadline.o:	readline.h
Xreadline.o:	globals.h
Xprinthdr.o:	printhdr.h
Xprinthdr.o:	globals.h
Xglobals.o:	globals.h
Xglobals.o:	../fileio/machdr.h
Xglobals.o:	../fileio/wrfile.h
Xglobals.o:	../fileio/kind.h
X
SHAR_EOF
if test 2504 -ne "`wc -c < 'makefile'`"
then
	echo shar: "error transmitting 'makefile'" '(should have been 2504 characters)'
fi
fi
echo shar: "extracting 'crc.c'" '(757 characters)'
if test -f 'crc.c'
then
	echo shar: "will not over-write existing file 'crc.c'"
else
sed 's/^X//' << \SHAR_EOF > 'crc.c'
X/* crc.c; do crc calculation. */
X
X#include <stdio.h>
X#include "hexbin.h"
X#include "crc.h"
X#include "../util/masks.h"
X#include "globals.h"
X
Xextern void exit();
X
Xunsigned long crc;
X
X#ifdef HQX
Xvoid comp_q_crc(c)
Xregister unsigned int c;
X{
X    unsigned char cc = c;
X
X    crc = binhex_updcrc(crc, &cc, 1);
X}
X
Xvoid comp_q_crc_n(s, e)
Xregister unsigned char *s, *e;
X{
X    crc = binhex_updcrc(crc, s, e - s);
X}
X#endif /* HQX */
X
Xvoid verify_crc(calc_crc, file_crc)
Xunsigned long calc_crc, file_crc;
X{
X    calc_crc &= WORDMASK;
X    file_crc &= WORDMASK;
X
X    if(calc_crc != file_crc) {
X        (void)fprintf(stderr, "CRC mismatch: got 0x%04lx, need 0x%04lx\n",
X		file_crc, calc_crc);
X#ifdef SCAN
X	do_error("hexbin: CRC error");
X#endif /* SCAN */
X	exit(1);
X    }
X}
X
SHAR_EOF
if test 757 -ne "`wc -c < 'crc.c'`"
then
	echo shar: "error transmitting 'crc.c'" '(should have been 757 characters)'
fi
fi
echo shar: "extracting 'globals.c'" '(372 characters)'
if test -f 'globals.c'
then
	echo shar: "will not over-write existing file 'globals.c'"
else
sed 's/^X//' << \SHAR_EOF > 'globals.c'
X#include "globals.h"
X#include "../fileio/machdr.h"
X#include "../fileio/wrfile.h"
X#include "../fileio/kind.h"
X
Xstruct macheader mh;
X
Xchar info[INFOBYTES];
Xchar trname[64];
X
Xint listmode;
Xint info_only;
Xint verbose;
Xint uneven_lines;
Xint to_read;
Xint was_macbin;
X
XFILE *ifp;
X
X#ifdef SCAN
Xvoid do_error(string)
Xchar *string;
X{
X    do_idf(string, ERROR);
X}
X#endif /* SCAN */
X
SHAR_EOF
if test 372 -ne "`wc -c < 'globals.c'`"
then
	echo shar: "error transmitting 'globals.c'" '(should have been 372 characters)'
fi
fi
echo shar: "extracting 'globals.h'" '(636 characters)'
if test -f 'globals.h'
then
	echo shar: "will not over-write existing file 'globals.h'"
else
sed 's/^X//' << \SHAR_EOF > 'globals.h'
X#include <stdio.h>
X#include <string.h>
X#ifdef BSD
Xextern char *rindex();
X#define search_last rindex
X#else /* BSD */
Xextern char *strrchr();
X#define search_last strrchr
X#endif /* BSD */
X
Xextern void transname();
X
Xextern char info[];
Xextern char trname[];
X
Xtypedef struct macheader {
X	char m_name[128];
X	char m_type[4];
X	char m_author[4];
X	short m_flags;
X	long m_datalen;
X	long m_rsrclen;
X	long m_createtime;
X	long m_modifytime;
X};
X
Xextern struct macheader mh;
X
Xextern int listmode;
Xextern int verbose;
Xextern int info_only;
Xextern int uneven_lines;
Xextern int to_read;
Xextern int was_macbin;
X
Xextern FILE *ifp;
X
Xextern void do_error();
X
SHAR_EOF
if test 636 -ne "`wc -c < 'globals.h'`"
then
	echo shar: "error transmitting 'globals.h'" '(should have been 636 characters)'
fi
fi
echo shar: "extracting 'crc.h'" '(215 characters)'
if test -f 'crc.h'
then
	echo shar: "will not over-write existing file 'crc.h'"
else
sed 's/^X//' << \SHAR_EOF > 'crc.h'
X#define INITCRC binhex_crcinit
X
Xextern unsigned long crc;
Xextern unsigned long binhex_crcinit;
Xextern unsigned long binhex_updcrc();
X
Xextern void comp_q_crc();
Xextern void comp_q_crc_n();
Xextern void verify_crc();
X
SHAR_EOF
if test 215 -ne "`wc -c < 'crc.h'`"
then
	echo shar: "error transmitting 'crc.h'" '(should have been 215 characters)'
fi
fi
echo shar: "extracting 'dl.c'" '(2716 characters)'
if test -f 'dl.c'
then
	echo shar: "will not over-write existing file 'dl.c'"
else
sed 's/^X//' << \SHAR_EOF > 'dl.c'
X#include "hexbin.h"
X#ifdef DL
X#include "globals.h"
X#include "crc.h"
X#include "readline.h"
X#include "../fileio/machdr.h"
X#include "../fileio/wrfile.h"
X#include "../util/util.h"
X#include "buffer.h"
X#include "printhdr.h"
X
Xextern void exit();
X
Xstatic long dl_fork();
Xstatic int nchar();
Xstatic int nextc();
X
Xstatic char *icp = &line[0];
X
X/* oldest format -- process .dl files */
Xvoid dl(macname, filename)
Xchar *macname, *filename;
X{
X    int n;
X
X    if(listmode) {
X	(void)fprintf(stderr, "This file is in \"dl\" format.\n");
X    }
X    for(n = 0; n < INFOBYTES; n++) {
X	info[n] = 0;
X    }
X    /* set up for Mac name */
X    if(macname[0] == '\0') {
X	/* strip directories */
X	macname = search_last(filename, '/');
X	if(macname == NULL) {
X	    macname = filename;
X	} else {
X	    macname++;
X	}
X	/* strip extension */
X	n = strlen(macname);
X	if(n > 3) {
X	    n -= 3;
X	    if(!strncmp(macname + n, ".dl", 3)) {
X		macname[n] = '\0';
X	    }
X	}
X    }
X    n = strlen(macname);
X    if(n > F_NAMELEN) {
X	n = F_NAMELEN;
X    }
X    (void)strncpy(mh.m_name, macname, n);
X    (void)strncpy(mh.m_type, "APPL", 4);
X    (void)strncpy(mh.m_author, "????", 4);
X    mh.m_name[n] = '\0';
X    transname(mh.m_name, trname, n);
X    define_name(trname);
X    print_header0(0);
X    print_header1(0, 0);
X    set_put(1);
X    mh.m_datalen = 0;
X    set_put(0);
X    mh.m_rsrclen = dl_fork();
X    info[I_NAMEOFF] = n;
X    (void)strncpy(info + I_NAMEOFF + 1, mh.m_name, n);
X    (void)strncpy(info + I_TYPEOFF, mh.m_type, 4);
X    (void)strncpy(info + I_AUTHOFF, mh.m_author, 4);
X    put4(info + I_DLENOFF, (unsigned long)mh.m_datalen);
X    put4(info + I_RLENOFF, (unsigned long)mh.m_rsrclen);
X    put4(info + I_CTIMOFF, (unsigned long)mh.m_createtime);
X    put4(info + I_MTIMOFF, (unsigned long)mh.m_modifytime);
X    print_header2(0);
X    end_put();
X}
X
Xstatic long dl_fork()
X{
X    register unsigned long i, v, c;
X    register unsigned long n, bytes;
X
X    n = 0;
X    bytes = 0;
X    v = 0;
X    crc = 0;
X    while((i = nchar()) != '|') {
X	if(i < '@' || i > 'O') {
X	    continue;
X	}
X	v = (v << 4) | (i & 0xF);
X	if((++n & 1) == 0) {
X	    put_byte((char)v);
X	    crc += v;
X	    v = 0;
X	    bytes++;
X	}
X    }
X    c = 0;
X    for(i = 0 ; i < 8 ; i++) {
X	c = (c << 4) | (nchar() & 0xF);
X    }
X    verify_crc(bytes + crc, c);
X    return bytes;
X}
X
Xstatic int nchar()
X{
X    int i;
X
X    if((i = nextc()) == EOF) {
X	(void)fprintf(stderr, "Premature EOF\n");
X#ifdef SCAN
X	do_error("hexbin: Premature EOF");
X#endif /* SCAN */
X	exit(1);
X    }
X    return i & 0177;
X}
X
Xstatic int nextc()
X{
X    while(*icp == 0) {
X	if(readline() == 0) {
X	    return EOF;
X	}
X	icp = &line[0];
X    }
X    return *icp++;
X}
X#else /* DL */
Xint dl; /* keep lint and some compilers happy */
X#endif /* DL */
X
SHAR_EOF
if test 2716 -ne "`wc -c < 'dl.c'`"
then
	echo shar: "error transmitting 'dl.c'" '(should have been 2716 characters)'
fi
fi
echo shar: "extracting 'hqx.c'" '(9295 characters)'
if test -f 'hqx.c'
then
	echo shar: "will not over-write existing file 'hqx.c'"
else
sed 's/^X//' << \SHAR_EOF > 'hqx.c'
X#include "hexbin.h"
X#ifdef HQX
X#include "globals.h"
X#include "readline.h"
X#include "crc.h"
X#include "buffer.h"
X#include "../fileio/machdr.h"
X#include "../fileio/wrfile.h"
X#include "../util/util.h"
X#include "printhdr.h"
X
Xextern void exit();
X
Xstatic void get_header();
Xstatic void oflush();
Xstatic int getq();
Xstatic long get2q();
Xstatic long get4q();
Xstatic getqbuf();
X
Xstatic char *g_macname;
X
X/* New stuff which hopes to improve the speed. */
X
X#define RUNCHAR 0x90
X
X#define DONE 0x7F
X#define SKIP 0x7E
X#define FAIL 0x7D
X
Xstatic char lookup[256] = {
X/*       ^@    ^A    ^B    ^C    ^D    ^E    ^F    ^G   */
X/* 0*/	FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,
X/*       \b    \t    \n    ^K    ^L    \r    ^N    ^O   */
X/* 1*/	FAIL, FAIL, SKIP, FAIL, FAIL, SKIP, FAIL, FAIL,
X/*       ^P    ^Q    ^R    ^S    ^T    ^U    ^V    ^W   */
X/* 2*/	FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,
X/*       ^X    ^Y    ^Z    ^[    ^\    ^]    ^^    ^_   */
X/* 3*/	FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,
X/*              !     "     #     $     %     &     '   */
X/* 4*/	FAIL, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
X/*        (     )     *     +     ,     -     .     /   */
X/* 5*/	0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, FAIL, FAIL,
X/*        0     1     2     3     4     5     6     7   */
X/* 6*/	0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, FAIL,
X/*        8     9     :     ;     <     =     >     ?   */
X/* 7*/	0x14, 0x15, DONE, FAIL, FAIL, FAIL, FAIL, FAIL,
X/*        @     A     B     C     D     E     F     G   */
X/* 8*/	0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D,
X/*        H     I     J     K     L     M     N     O   */
X/* 9*/	0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, FAIL,
X/*        P     Q     R     S     T     U     V     W   */
X/*10*/	0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, FAIL,
X/*        X     Y     Z     [     \     ]     ^     _   */
X/*11*/	0x2C, 0x2D, 0x2E, 0x2F, FAIL, FAIL, FAIL, FAIL,
X/*        `     a     b     c     d     e     f     g   */
X/*12*/	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, FAIL,
X/*        h     i     j     k     l     m     n     o   */
X/*13*/	0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, FAIL, FAIL,
X/*        p     q     r     s     t     u     v     w   */
X/*14*/	0x3D, 0x3E, 0x3F, FAIL, FAIL, FAIL, FAIL, FAIL,
X/*        x     y     z     {     |     }     ~    ^?   */
X/*15*/	FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,
X/*16*/	FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,
X	FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,
X	FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,
X	FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,
X	FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,
X	FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,
X	FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,
X	FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,
X	FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,
X	FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,
X	FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,
X	FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,
X	FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,
X	FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,
X	FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,
X	FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,
X};
X
Xstatic int stop = 0;
X
Xstatic unsigned char obuf[BUFSIZ];
Xstatic unsigned char *op = obuf;
Xstatic unsigned char *oq;
X
X#define S_HEADER    0
X#define S_DATAOPEN    1
X#define S_DATAWRITE    2
X#define S_DATAC1    3
X#define S_DATAC2    4
X#define S_RSRCOPEN    5
X#define S_RSRCWRITE    6
X#define S_RSRCC1    7
X#define S_RSRCC2    8
X#define S_EXCESS    9
X
Xstatic int ostate = S_HEADER;
X
Xstatic unsigned long calc_crc;
Xstatic unsigned long file_crc;
X
Xstatic long todo;
X
X#define output(c) { *op++ = (c); if(op >= &obuf[BUFSIZ]) oflush(); }
X
Xvoid hqx(macname)
Xchar *macname;
X{
X    int n, normlen, c;
X    register char *in, *out;
X    register int b6, b8, data, lastc = 0;
X    char state68 = 0, run = 0, linestate, first = 1;
X
X    g_macname = macname;
X
X    ostate = S_HEADER;
X    stop = 0;
X
X    while(!stop) {
X	n = strlen((char *)line);
X	while(n > 0 && line[n - 1] == ' ') {
X	    n--;
X	}
X	out = line+n;
X	if(uneven_lines) {
X	     goto skipcheck;
X	}
X	if(first) {
X	    normlen = n;
X	}
X	/* Check line for intermediate garbage */
X	linestate = SKIP;
X	for(in = line; in < out; in++) {
X	    if((linestate = lookup[*in & 0xff]) == FAIL ||
X		((linestate == DONE) && !first)) {
X		break;
X	    }
X	}
X	if(linestate != FAIL && n != normlen && linestate != DONE) {
X	    c = fgetc(ifp);
X	    (void)ungetc(c, ifp);
X	    if(lookup[c] == DONE) {
X		linestate = DONE;
X	    }
X	}
X	if(linestate == FAIL || (n != normlen && linestate != DONE)) {
X	    if(verbose && n > 0) {
X		*out = 0;
X		(void)fprintf(stderr, "Skip:%s\n", line);
X	    }
X	    if(readline()) {
X		continue;
X	    } else {
X		break;
X	    }
X	}
Xskipcheck:
X	in = line;
X	do {
X	    if((b6 = lookup[*in & 0xff]) >= 64) {
X		switch (b6) {
X		case DONE:
X		    first = !first;
X		    if(first) {
X			goto done;
X		    }
X		case SKIP:
X		    break;
X		default:
X		    if(uneven_lines) {
X			break;
X		    }
X		    (void)fprintf(stderr, "bad char '%c'(%d)\n", *in, *in);
X		    goto done;
X		}
X	    } else {
X		/* Pack 6 bits to 8 bits */
X		switch (state68++) {
X		case 0:
X		    b8 = b6<<2;
X		    continue; /* No data byte */
X		case 1:
X		    data = b8.html | (b6>>4);
X		    b8 = (b6&0xF) << 4;
X		    break;
X		case 2:
X		    data = b8.html | (b6>>2);
X		    b8 = (b6&0x3) << 6;
X		    break;
X		case 3:
X		    data = b8.html | b6;
X		    state68 = 0;
X		    break;
X		}
X		if(!run) {
X		    if(data == RUNCHAR) {
X			run = 1;
X		    } else {
X			output(lastc = data);
X		    }
X		}
X		else {
X		    if(data == 0) {
X			output(lastc = RUNCHAR);
X		    } else {
X			while(--data > 0) {
X			    output(lastc);
X			}
X		    }
X		    run = 0;
X		}
X	    }
X	} while(++in < out);
X	if(!stop) {
X	    if(!readline()) {
X		break;
X	    }
X	}
X    }
Xdone:
X    oflush();
X    if(!stop && ostate != S_EXCESS) {
X	(void)fprintf(stderr, "premature EOF\n");
X#ifdef SCAN
X	do_error("hexbin: premature EOF");
X#endif /* SCAN */
X	exit(1);
X    }
X    end_put();
X    print_header2(verbose);
X}
X
Xstatic void get_header()
X{
X    int n;
X    unsigned long calc_crc, file_crc;
X
X    crc = INITCRC;			/* compute a crc for the header */
X
X    for(n = 0; n < INFOBYTES; n++) {
X	info[n] = 0;
X    }
X    n = getq();			/* namelength */
X    n++;				/* must read trailing null also */
X    getqbuf(trname, n);		/* read name */
X    if(g_macname[0] == '\0') {
X	g_macname = trname;
X    }
X
X    n = strlen(g_macname);
X    if(n > F_NAMELEN) {
X	n = F_NAMELEN;
X    }
X    (void)strncpy(mh.m_name, g_macname, n);
X    mh.m_name[n] = '\0';
X
X    getqbuf(mh.m_type, 4);
X    getqbuf(mh.m_author, 4);
X    mh.m_flags = get2q();
X    mh.m_datalen = get4q();
X    mh.m_rsrclen = get4q();
X
X    calc_crc = crc;
X    file_crc = get2q();
X    verify_crc(calc_crc, file_crc);
X    if(listmode) {
X	(void)fprintf(stderr, "This file is in \"hqx\" format.\n");
X    }
X    transname(mh.m_name, trname, n);
X    define_name(trname);
X    print_header0(0);
X    print_header1(0, verbose);
X    info[I_NAMEOFF] = n;
X    (void)strncpy(info + I_NAMEOFF + 1, mh.m_name, n);
X    (void)strncpy(info + I_TYPEOFF, mh.m_type, 4);
X    (void)strncpy(info + I_AUTHOFF, mh.m_author, 4);
X    put2(info + I_FLAGOFF, (unsigned long)mh.m_flags);
X    put4(info + I_DLENOFF, (unsigned long)mh.m_datalen);
X    put4(info + I_RLENOFF, (unsigned long)mh.m_rsrclen);
X    put4(info + I_CTIMOFF, (unsigned long)mh.m_createtime);
X    put4(info + I_MTIMOFF, (unsigned long)mh.m_modifytime);
X}
X
Xstatic void oflush()
X{
X    int n, i;
X
X    oq = obuf;
X    while(oq < op && !stop) {
X	switch (ostate) {
X	case S_HEADER:
X	    get_header();
X	    ++ostate;
X	    break;
X	case S_DATAOPEN:
X	    set_put(1);
X	    todo = mh.m_datalen;
X	    crc = INITCRC;
X	    ++ostate;
X	    break;
X	case S_RSRCOPEN:
X	    set_put(0);
X	    todo = mh.m_rsrclen;
X	    crc = INITCRC;
X	    ++ostate;
X	    break;
X	case S_DATAWRITE:
X	case S_RSRCWRITE:
X	    n = op-oq;
X	    if(n > todo) {
X		n = todo;
X	    }
X	    for(i = 0; i < n; i++) {
X		put_byte((char)(oq[i]));
X	    }
X	    comp_q_crc_n(oq, oq+n);
X	    oq += n;
X	    todo -= n;
X	    if(todo <= 0) {
X		++ostate;
X	    }
X	    break;
X	case S_DATAC1:
X	case S_RSRCC1:
X	    calc_crc = crc;
X	    file_crc = getq() << 8;
X	    ++ostate;
X	    break;
X	case S_DATAC2:
X	case S_RSRCC2:
X	    /* Skip crc bytes */
X	    file_crc |= getq();
X	    verify_crc(calc_crc, file_crc);
X	    ++ostate;
X	    break;
X	case S_EXCESS:
X	    (void)fprintf(stderr, "%d excess bytes ignored\n", op-oq);
X	    oq = op;
X	    break;
X	}
X    }
X    op = obuf;
X}
X
Xstatic int getq()
X{
X    int c;
X
X    if(oq >= op) {
X	(void)fprintf(stderr, "premature EOF\n");
X#ifdef SCAN
X	do_error("hexbin: premature EOF");
X#endif /* SCAN */
X	exit(1);
X    }
X    c = *oq++ & 0xff;
X    comp_q_crc((unsigned)c);
X    return c;
X}
X
X/* get2q(); q format -- read 2 bytes from input, return short */
Xstatic long get2q()
X{
X    short high = getq() << 8;
X    return high | getq();
X}
X
X/* get4q(); q format -- read 4 bytes from input, return long */
Xstatic long get4q()
X{
X    int i;
X    long value = 0;
X
X    for(i = 0; i < 4; i++) {
X	value = (value<<8) | getq();
X    }
X    return value;
X}
X
X/* getqbuf(); q format -- read n characters from input into buf */
Xstatic getqbuf(buf, n)
X    char *buf;
X    int n;
X{
X    int i;
X
X    for(i = 0; i < n; i++) {
X	*buf++ = getq();
X    }
X}
X#else /* HQX */
Xint hqx; /* keep lint and some compilers happy */
X#endif /* HQX */
X
SHAR_EOF
if test 9295 -ne "`wc -c < 'hqx.c'`"
then
	echo shar: "error transmitting 'hqx.c'" '(should have been 9295 characters)'
fi
fi
echo shar: "extracting 'printhdr.c'" '(925 characters)'
if test -f 'printhdr.c'
then
	echo shar: "will not over-write existing file 'printhdr.c'"
else
sed 's/^X//' << \SHAR_EOF > 'printhdr.c'
X#include "printhdr.h"
X#include "globals.h"
X
X/* print out header information in human-readable format */
Xvoid print_header0(skip)
Xint skip;
X{
X    if(listmode) {
X	(void)fprintf(stderr, "name=\"%s\", ", trname);
X	if(skip) {
X	    (void)fprintf(stderr, "\n");
X	}
X    }
X}
X
X/* print out header information in human-readable format */
Xvoid print_header1(skip1, skip2)
Xint skip1, skip2;
X{
X    char ftype[5], fauth[5];
X
X    transname(mh.m_type, ftype, 4);
X    transname(mh.m_author, fauth, 4);
X    if(listmode) {
X	if(skip1) {
X	    (void)fprintf(stderr, "\t");
X	}
X	(void)fprintf(stderr, "type=%4.4s, author=%4.4s, ", ftype, fauth);
X	if(skip2) {
X	    (void)fprintf(stderr, "\n");
X	}
X    }
X}
X
X/* print out header information in human-readable format */
Xvoid print_header2(skip)
X{
X    if(listmode) {
X	if(skip) {
X	    (void)fprintf(stderr, "\t");
X	}
X	(void)fprintf(stderr, "data=%ld, rsrc=%ld\n",
X	    mh.m_datalen, mh.m_rsrclen);
X    }
X}
X
SHAR_EOF
if test 925 -ne "`wc -c < 'printhdr.c'`"
then
	echo shar: "error transmitting 'printhdr.c'" '(should have been 925 characters)'
fi
fi
echo shar: "extracting 'readline.h'" '(21 characters)'
if test -f 'readline.h'
then
	echo shar: "will not over-write existing file 'readline.h'"
else
sed 's/^X//' << \SHAR_EOF > 'readline.h'
Xextern char line[];
X
SHAR_EOF
if test 21 -ne "`wc -c < 'readline.h'`"
then
	echo shar: "error transmitting 'readline.h'" '(should have been 21 characters)'
fi
fi
echo shar: "extracting 'readline.c'" '(703 characters)'
if test -f 'readline.c'
then
	echo shar: "will not over-write existing file 'readline.c'"
else
sed 's/^X//' << \SHAR_EOF > 'readline.c'
X#include "globals.h"
X#include "readline.h"
X
Xchar line[1024];	/* Allow a lot! */
X
X/* Read a line.  Allow termination by CR or LF or both.  Also allow for
X   a non-terminated line at end-of-file.  Returns 1 if a line is read,
X   0 otherwise. */
Xint readline()
X{
X    int ptr = 0, c;
X
X    while(1) {
X	if(was_macbin && to_read-- <= 0) {
X	    c = EOF;
X	} else {
X	    c = getc(ifp);
X	}
X	if(c == EOF || c == '\n' || c == '\r' || ptr == 1023) {
X	    break;
X	}
X	line[ptr++] = c;
X    }
X    line[ptr++] = 0;
X    if(c == EOF) {
X	if(ptr == 1) {
X	    return 0;
X	} else {
X	    return 1;
X	}
X    }
X    c = getc(ifp);
X    if(c != '\n' || c != '\r') {
X	(void)ungetc(c, ifp);
X    } else {
X	to_read--;
X    }
X    return 1;
X}
X
SHAR_EOF
if test 703 -ne "`wc -c < 'readline.c'`"
then
	echo shar: "error transmitting 'readline.c'" '(should have been 703 characters)'
fi
fi
echo shar: "extracting 'buffer.h'" '(140 characters)'
if test -f 'buffer.h'
then
	echo shar: "will not over-write existing file 'buffer.h'"
else
sed 's/^X//' << \SHAR_EOF > 'buffer.h'
Xextern char *data_fork, *rsrc_fork;
Xextern int data_size, rsrc_size;
Xextern void put_byte();
Xextern void set_put();
Xextern void end_put();
X
SHAR_EOF
if test 140 -ne "`wc -c < 'buffer.h'`"
then
	echo shar: "error transmitting 'buffer.h'" '(should have been 140 characters)'
fi
fi
echo shar: "extracting 'mu.c'" '(4891 characters)'
if test -f 'mu.c'
then
	echo shar: "will not over-write existing file 'mu.c'"
else
sed 's/^X//' << \SHAR_EOF > 'mu.c'
X#include "hexbin.h"
X#ifdef MU
X#include "globals.h"
X#include "readline.h"
X#include "../util/masks.h"
X#include "../util/util.h"
X#include "../fileio/machdr.h"
X#include "../fileio/wrfile.h"
X#include "buffer.h"
X#include "printhdr.h"
X
Xextern void exit();
X
Xstatic void do_mu_fork();
Xstatic int mu_comp_to_bin();
Xstatic int mu_convert();
X
X/* mu format -- process .mu files */
Xvoid mu(macname)
Xchar *macname;
X{
X    int n;
X
X    for(n = 0; n < INFOBYTES; n++) {
X	info[n] = 0;
X    }
X
X    /* set up name for output files */
X    if(macname[0] == '\0') {
X	n = 0;
X	while(line[n] != '"') {
X	    n++;
X	}
X	macname = line + n + 1;
X	line[strlen(line) - 1] = 0;
X    }
X    n = strlen(macname);
X    if(n > F_NAMELEN) {
X	n = F_NAMELEN;
X    }
X    (void)strncpy(mh.m_name, macname, n);
X    mh.m_name[n] = '\0';
X    info[I_NAMEOFF] = n;
X    (void)strncpy(info + I_NAMEOFF + 1, mh.m_name, n);
X
X    if(listmode) {
X	(void)fprintf(stderr, "This file is in \"mu\" format.\n");
X    }
X    transname(mh.m_name, trname, n);
X    define_name(trname);
X    print_header0(0);
X    set_put(0);
X    set_put(1);
X    do_mu_fork();
X    mh.m_datalen = data_size;
X    if(!readline()) {
X	(void)fprintf(stderr, "Premature EOF\n");
X#ifdef SCAN
X	do_error("hexbin: Premature EOF");
X#endif /* SCAN */
X	exit(1);
X    }
X    if(strncmp(line, "begin ", 6)) {
X	(void)fprintf(stderr, "No UU header found.\n");
X#ifdef SCAN
X	do_error("hexbin: No UU header found");
X#endif /* SCAN */
X	exit(1);
X    }
X    if(!strncmp(line + 10, " .rsrc", 6)) {
X	set_put(0);
X	do_mu_fork();
X	mh.m_rsrclen = rsrc_size;
X	if(!readline()) {
X	    (void)fprintf(stderr, "Premature EOF\n");
X#ifdef SCAN
X	    do_error("hexbin: Premature EOF");
X#endif /* SCAN */
X	    exit(1);
X	}
X	if(strncmp(line, "begin ", 6)) {
X	    (void)fprintf(stderr, "No UU header found.\n");
X#ifdef SCAN
X	    do_error("hexbin: No UU header found");
X#endif /* SCAN */
X	    exit(1);
X	}
X    } else {
X	mh.m_rsrclen = 0;
X    }
X    if(strncmp(line + 10, " .finfo", 7)) {
X	(void)fprintf(stderr, "No finder info found.\n");
X#ifdef SCAN
X	do_error("hexbin: No finder info found");
X#endif /* SCAN */
X	exit(1);
X    }
X    if(!readline()) {
X	(void)fprintf(stderr, "Premature EOF\n");
X#ifdef SCAN
X	do_error("hexbin: Premature EOF");
X#endif /* SCAN */
X	exit(1);
X    }
X    (void)mu_convert(line, info + I_TYPEOFF);
X    if(!readline()) {
X	(void)fprintf(stderr, "Premature EOF\n");
X#ifdef SCAN
X	do_error("hexbin: Premature EOF");
X#endif /* SCAN */
X	exit(1);
X    }
X    if(mu_convert(line, line)) {
X	(void)fprintf(stderr, "Long finderinfo.\n");
X#ifdef SCAN
X	do_error("hexbin: Long finderinfo");
X#endif /* SCAN */
X	exit(1);
X    }
X    if(!readline()) {
X	(void)fprintf(stderr, "Premature EOF\n");
X#ifdef SCAN
X	do_error("hexbin: Premature EOF");
X#endif /* SCAN */
X	exit(1);
X    }
X    if(strncmp(line, "end", 3)) {
X	(void)fprintf(stderr, "\"end\" line missing.\n");
X#ifdef SCAN
X	do_error("hexbin: \"end\" line missing");
X#endif /* SCAN */
X	exit(1);
X    }
X
X    (void)strncpy(mh.m_type, info + I_TYPEOFF, 4);
X    (void)strncpy(mh.m_author, info + I_AUTHOFF, 4);
X    print_header1(0, 0);
X    put4(info + I_DLENOFF, (unsigned long)mh.m_datalen);
X    put4(info + I_RLENOFF, (unsigned long)mh.m_rsrclen);
X    put4(info + I_CTIMOFF, (unsigned long)mh.m_createtime);
X    put4(info + I_MTIMOFF, (unsigned long)mh.m_modifytime);
X    print_header2(0);
X    end_put();
X}
X
Xstatic void do_mu_fork()
X{
X    long newbytes;
X
X    while(readline()) {
X	if(line[0] == 0) {
X	    continue;
X	}
X	newbytes = mu_comp_to_bin();
X	if(newbytes != 0) {
X	    continue;
X	}
X	if(!readline()) {
X	    (void)fprintf(stderr, "Premature EOF\n");
X#ifdef SCAN
X	    do_error("hexbin: Premature EOF");
X#endif /* SCAN */
X	    exit(1);
X	}
X	if(strncmp(line, "end", 3)) {
X	    (void)fprintf(stderr, "\"end\" line missing.\n");
X#ifdef SCAN
X	    do_error("hexbin: \"end\" line missing");
X#endif /* SCAN */
X	    exit(1);
X	}
X	return;
X    }
X    (void)fprintf(stderr, "Premature EOF\n");
X#ifdef SCAN
X    do_error("hexbin: Premature EOF");
X#endif /* SCAN */
X    exit(1);
X    /*NOTREACHED*/
X}
X
Xstatic int mu_comp_to_bin()
X{
X    char obuf[BUFSIZ];
X    int outcount, n;
X
X    outcount = mu_convert(line, obuf);
X    for(n = 0; n < outcount; n++) {
X	put_byte(obuf[n]);
X    }
X    return outcount;
X}
X
X#define SIXB(c) (((c)-0x20) & 0x3f)
X
Xstatic int mu_convert(ibuf, obuf)
Xchar *ibuf, *obuf;
X{
X    register char *ip = ibuf;
X    register char *op = obuf;
X    register int n, outcount;
X    int numread, incount;
X
X    numread = strlen(ip);
X    outcount = SIXB(ip[0]);
X    incount = ((outcount / 3) + 1) * 4;
X    for(n = numread; n < incount; n++) {  /* restore lost spaces */
X	ip[n] = ' ';
X    }
X    ip++;
X
X    n = 0;
X    while(n <= outcount) {
X	*op++ = SIXB(ip[0]) << 2 | SIXB(ip[1]) >> 4;
X	*op++ = SIXB(ip[1]) << 4 | SIXB(ip[2]) >> 2;
X	*op++ = SIXB(ip[2]) << 6 | SIXB(ip[3]);
X	ip += 4;
X	n += 3;
X    }
X    return outcount;
X}
X#else /* MU */
Xint mu; /* keep lint and some compilers happy */
X#endif /* MU */
X
SHAR_EOF
if test 4891 -ne "`wc -c < 'mu.c'`"
then
	echo shar: "error transmitting 'mu.c'" '(should have been 4891 characters)'
fi
fi
echo shar: "extracting 'printhdr.h'" '(88 characters)'
if test -f 'printhdr.h'
then
	echo shar: "will not over-write existing file 'printhdr.h'"
else
sed 's/^X//' << \SHAR_EOF > 'printhdr.h'
Xextern void print_header0();
Xextern void print_header1();
Xextern void print_header2();
X
SHAR_EOF
if test 88 -ne "`wc -c < 'printhdr.h'`"
then
	echo shar: "error transmitting 'printhdr.h'" '(should have been 88 characters)'
fi
fi
echo shar: "extracting 'buffer.c'" '(1460 characters)'
if test -f 'buffer.c'
then
	echo shar: "will not over-write existing file 'buffer.c'"
else
sed 's/^X//' << \SHAR_EOF > 'buffer.c'
X#include "globals.h"
X#include "../util/util.h"
X#include "buffer.h"
X#include "../fileio/wrfile.h"
X
Xextern char *malloc();
Xextern char *realloc();
Xextern void exit();
X
Xchar *data_fork, *rsrc_fork;
Xint data_size, rsrc_size;
Xstatic int max_data_size, max_rsrc_size;
Xstatic int do_data;
X
Xvoid put_byte(c)
Xchar c;
X{
X    if(do_data) {
X	if(data_size >= max_data_size) {
X	    if(max_data_size == 0) {
X		data_fork = malloc(1024);
X	    } else {
X		data_fork = realloc(data_fork, (unsigned)max_data_size + 1024);
X	    }
X	    max_data_size += 1024;
X	    if(data_fork == NULL) {
X		(void)fprintf(stderr, "Insufficient memory.\n");
X		exit(1);
X	    }
X	}
X	data_fork[data_size++] = c;
X    } else {
X	if(rsrc_size >= max_rsrc_size) {
X	    if(max_rsrc_size == 0) {
X		rsrc_fork = malloc(1024);
X	    } else {
X		rsrc_fork = realloc(rsrc_fork, (unsigned)max_rsrc_size + 1024);
X	    }
X	    max_rsrc_size += 1024;
X	    if(rsrc_fork == NULL) {
X		(void)fprintf(stderr, "Insufficient memory.\n");
X		exit(1);
X	    }
X	}
X	rsrc_fork[rsrc_size++] = c;
X    }
X}
X
Xvoid set_put(data)
Xint data;
X{
X    do_data = data;
X    if(do_data) {
X	data_size = 0;
X    } else {
X	rsrc_size = 0;
X    }
X}
X
Xvoid end_put()
X{
X    if(info_only) {
X	return;
X    }
X    start_info(info, (unsigned long)rsrc_size, (unsigned long)data_size);
X    if(data_size != 0) {
X	start_data();
X	copy(out_ptr, data_fork, data_size);
X    }
X    if(rsrc_size != 0) {
X	start_rsrc();
X	copy(out_ptr, rsrc_fork, rsrc_size);
X    }
X    end_file();
X}
X
SHAR_EOF
if test 1460 -ne "`wc -c < 'buffer.c'`"
then
	echo shar: "error transmitting 'buffer.c'" '(should have been 1460 characters)'
fi
fi
echo shar: "extracting 'hexbin.h'" '(264 characters)'
if test -f 'hexbin.h'
then
	echo shar: "will not over-write existing file 'hexbin.h'"
else
sed 's/^X//' << \SHAR_EOF > 'hexbin.h'
X#define	DL	/* recognize dl format */
X#define	HECX	/* recognize hex and hcx formats */
X#define	HQX	/* recognize hqx format */
X#define	MU	/* recognize mu format */
X
X#define	form_dl		0
X#define	form_hecx	1
X#define	form_hqx	2
X#define	form_mu		3
X#define	form_none	(-1)
X
SHAR_EOF
if test 264 -ne "`wc -c < 'hexbin.h'`"
then
	echo shar: "error transmitting 'hexbin.h'" '(should have been 264 characters)'
fi
fi
echo shar: "extracting 'hecx.c'" '(5468 characters)'
if test -f 'hecx.c'
then
	echo shar: "will not over-write existing file 'hecx.c'"
else
sed 's/^X//' << \SHAR_EOF > 'hecx.c'
X#include "hexbin.h"
X#ifdef HECX
X#include "globals.h"
X#include "crc.h"
X#include "readline.h"
X#include "../util/masks.h"
X#include "../util/util.h"
X#include "../fileio/machdr.h"
X#include "../fileio/wrfile.h"
X#include "buffer.h"
X#include "printhdr.h"
X
Xextern void exit();
X
Xstatic void do_o_forks();
Xstatic long make_file();
Xstatic void comp_c_crc();
Xstatic void comp_e_crc();
Xstatic int comp_to_bin();
Xstatic int hex_to_bin();
Xstatic int hexit();
X
Xstatic int compressed;
X
X/* old format -- process .hex and .hcx files */
Xvoid hecx(macname, filename)
Xchar *macname, *filename;
X{
X    int n;
X
X    for(n = 0; n < INFOBYTES; n++) {
X	info[n] = 0;
X    }
X    compressed = 0;
X    /* set up name for output files */
X    if(macname[0] == '\0') {
X	/* strip directories */
X	macname = search_last(filename, '/');
X	if(macname == NULL) {
X	    macname = filename;
X	} else {
X	    macname++;
X	}
X
X	/* strip extension */
X	n = strlen(macname);
X	if(n > 4) {
X	    n -= 4;
X	    if(!strncmp(macname + n, ".hex", 4) ||
X	       !strncmp(macname + n, ".hcx", 4)) {
X		macname[n] = '\0';
X	    }
X	}
X    }
X    n = strlen(macname);
X    if(n > F_NAMELEN) {
X	n = F_NAMELEN;
X    }
X    (void)strncpy(mh.m_name, macname, n);
X    mh.m_name[n] = '\0';
X
X    /* "#TYPEAUTH$flag"  line already read */
X    n = strlen(line);
X    if(n >= 6 && line[0] == '#' && line[n-5] == '$') {
X	if(n >= 10) {
X	    (void)strncpy(mh.m_type, &line[1], 4);
X	}
X	if(n >= 14) {
X	    (void)strncpy(mh.m_author, &line[5], 4);
X	}
X	(void)sscanf(&line[n-4], "%4hx", &mh.m_flags);
X    }
X    transname(mh.m_name, trname, n);
X    define_name(trname);
X    do_o_forks();
X    if(listmode) {
X	if(!compressed) {
X	    (void)fprintf(stderr, "This file is in \"hex\" format.\n");
X	} else {
X	    (void)fprintf(stderr, "This file is in \"hcx\" format.\n");
X	}
X    }
X    print_header0(0);
X    print_header1(0, 0);
X    info[I_NAMEOFF] = n;
X    (void)strncpy(info + I_NAMEOFF + 1, mh.m_name, n);
X    (void)strncpy(info + I_TYPEOFF, mh.m_type, 4);
X    (void)strncpy(info + I_AUTHOFF, mh.m_author, 4);
X    put2(info + I_FLAGOFF, (unsigned long)mh.m_flags);
X    put4(info + I_DLENOFF, (unsigned long)mh.m_datalen);
X    put4(info + I_RLENOFF, (unsigned long)mh.m_rsrclen);
X    put4(info + I_CTIMOFF, (unsigned long)mh.m_createtime);
X    put4(info + I_MTIMOFF, (unsigned long)mh.m_modifytime);
X    print_header2(0);
X    end_put();
X}
X
Xstatic void do_o_forks()
X{
X    int forks = 0, found_crc = 0;
X    unsigned long calc_crc, file_crc;
X
X    crc = 0;    /* calculate a crc for both forks */
X
X    set_put(0);
X    set_put(1);
X    while(!found_crc && readline()) {
X	if(line[0] == 0) {
X	    continue;
X	}
X	if(forks == 0 && strncmp(line, "***COMPRESSED", 13) == 0) {
X	    compressed++;
X	    continue;
X	}
X	if(strncmp(line, "***DATA", 7) == 0) {
X	    set_put(1);
X	    mh.m_datalen = make_file(compressed);
X	    forks++;
X	    continue;
X	}
X	if(strncmp(line, "***RESOURCE", 11) == 0) {
X	    set_put(0);
X	    mh.m_rsrclen = make_file(compressed);
X	    forks++;
X	    continue;
X	}
X	if(compressed && strncmp(line, "***CRC:", 7) == 0) {
X	    found_crc++;
X	    calc_crc = crc;
X	    (void)sscanf(&line[7], "%lx", &file_crc);
X	    break;
X	}
X	if(!compressed && strncmp(line, "***CHECKSUM:", 12) == 0) {
X	    found_crc++;
X	    calc_crc = crc & BYTEMASK;
X	    (void)sscanf(&line[12], "%lx", &file_crc);
X	    file_crc &= BYTEMASK;
X	    break;
X	}
X    }
X
X    if(found_crc) {
X	verify_crc(calc_crc, file_crc);
X    } else {
X	(void)fprintf(stderr, "missing CRC\n");
X#ifdef SCAN
X	do_error("hexbin: missing CRC");
X#endif /* SCAN */
X	exit(1);
X    }
X}
X
Xstatic long make_file(compressed)
Xint compressed;
X{
X    register long nbytes = 0L;
X
X    while(readline()) {
X	if(line[0] == 0) {
X	    continue;
X	}
X	if(strncmp(line, "***END", 6) == 0) {
X	    break;
X	}
X	if(compressed) {
X	    nbytes += comp_to_bin();
X	} else {
X	    nbytes += hex_to_bin();
X	}
X    }
X    return nbytes;
X}
X
Xstatic void comp_c_crc(c)
Xunsigned char c;
X{
X    crc = (crc + c) & WORDMASK;
X    crc = ((crc << 3) & WORDMASK) | (crc >> 13);
X}
X
Xstatic void comp_e_crc(c)
Xunsigned char c;
X{
X    crc += c;
X}
X
X#define SIXB(c) (((c)-0x20) & 0x3f)
X
Xstatic int comp_to_bin()
X{
X    char obuf[BUFSIZ];
X    register char *ip = line;
X    register char *op = obuf;
X    register int n, outcount;
X    int numread, incount;
X
X    numread = strlen(line);
X    outcount = (SIXB(ip[0]) << 2) | (SIXB(ip[1]) >> 4);
X    incount = ((outcount / 3) + 1) * 4;
X    for(n = numread; n < incount; n++) {  /* restore lost spaces */
X	line[n] = ' ';
X    }
X
X    n = 0;
X    while(n <= outcount) {
X	*op++ = SIXB(ip[0]) << 2 | SIXB(ip[1]) >> 4;
X	*op++ = SIXB(ip[1]) << 4 | SIXB(ip[2]) >> 2;
X	*op++ = SIXB(ip[2]) << 6 | SIXB(ip[3]);
X	ip += 4;
X	n += 3;
X    }
X
X    for(n = 1; n <= outcount; n++) {
X	comp_c_crc((unsigned)obuf[n]);
X	put_byte(obuf[n]);
X    }
X    return outcount;
X}
X
Xstatic int hex_to_bin()
X{
X    register char *ip = line;
X    register int n, outcount;
X    int c;
X
X    n = strlen(line);
X    outcount = n / 2;
X    for(n = 0; n < outcount; n++) {
X	c = hexit((int)*ip++);
X	comp_e_crc((unsigned)(c = (c << 4) | hexit((int)*ip++)));
X	put_byte((char)c);
X    }
X    return outcount;
X}
X
Xstatic int hexit(c)
Xint c;
X{
X    if('0' <= c && c <= '9') {
X	return c - '0';
X    }
X    if('A' <= c && c <= 'F') {
X	return c - 'A' + 10;
X    }
X
X    (void)fprintf(stderr, "illegal hex digit: %c", c);
X#ifdef SCAN
X    do_error("hexbin: illegal hex digit");
X#endif /* SCAN */
X    exit(1);
X    /* NOTREACHED */
X}
X#else /* HECX */
Xint hecx; /* keep lint and some compilers happy */
X#endif /* HECX */
X
SHAR_EOF
if test 5468 -ne "`wc -c < 'hecx.c'`"
then
	echo shar: "error transmitting 'hecx.c'" '(should have been 5468 characters)'
fi
fi
echo shar: "done with directory 'hexbin'"
cd ..
if test ! -d 'util'
then
	echo shar: "creating directory 'util'"
	mkdir 'util'
fi
echo shar: "entering directory 'util'"
cd 'util'
echo shar: "extracting 'makefile'" '(291 characters)'
if test -f 'makefile'
then
	echo shar: "will not over-write existing file 'makefile'"
else
sed 's/^X//' << \SHAR_EOF > 'makefile'
XCFLAGS=	-O $(CF)
X
Xall:	util.o transname.o backtrans.o
X	touch all
X
Xutil.o:	util.c
X
Xtransname.o:	transname.c
X
Xbacktrans.o:	backtrans.c
X
Xclean:
X	-rm -f util.o
X	-rm -f transname.o
X	-rm -f backtrans.o
X	-rm -f all
X
Xutil.o:	../fileio/fileglob.h
Xutil.o:	masks.h
Xutil.o:	util.h
Xbacktrans.o:	masks.h
X
SHAR_EOF
if test 291 -ne "`wc -c < 'makefile'`"
then
	echo shar: "error transmitting 'makefile'" '(should have been 291 characters)'
fi
fi
echo shar: "extracting 'util.h'" '(465 characters)'
if test -f 'util.h'
then
	echo shar: "will not over-write existing file 'util.h'"
else
sed 's/^X//' << \SHAR_EOF > 'util.h'
Xtypedef struct real_time {
X	int year;
X	int month;
X	int day;
X	int hours;
X	int minutes;
X	int seconds;
X} real_time;
X
Xextern unsigned long get4();
Xextern unsigned long get4i();
Xextern unsigned long get2();
Xextern unsigned long get2i();
Xextern unsigned char getb();
Xextern void copy();
Xextern int do_query();
Xextern void put4();
Xextern void put2();
Xextern void do_indent();
Xextern real_time set_time();
Xextern unsigned long tomactime();
Xextern real_time frommactime();
X
SHAR_EOF
if test 465 -ne "`wc -c < 'util.h'`"
then
	echo shar: "error transmitting 'util.h'" '(should have been 465 characters)'
fi
fi
echo shar: "extracting 'util.c'" '(3583 characters)'
if test -f 'util.c'
then
	echo shar: "will not over-write existing file 'util.c'"
else
sed 's/^X//' << \SHAR_EOF > 'util.c'
X#include <stdio.h>
X#include "../fileio/fileglob.h"
X#include "masks.h"
X#include "util.h"
X
Xextern void exit();
X
X#define MACTIMOFFS    1904
X
Xstatic int mlength[] = {0, 31, 61, 92, 122, 153, 184, 214, 245, 275, 306, 337};
X
Xunsigned long get4(bp)
Xchar *bp;
X{
X    register int i;
X    long value = 0;
X
X    for(i = 0; i < 4; i++) {
X	value <<= 8;
X	value |= (*bp & BYTEMASK);
X	bp++;
X    }
X    return value;
X}
X
X/* For if integers are stored wrong-endian. */
Xunsigned long get4i(bp)
Xchar *bp;
X{
X    register int i;
X    long value = 0;
X
X    bp += 3;
X    for(i = 0; i < 4; i++) {
X        value <<= 8;
X        value |= (*bp & BYTEMASK);
X        bp--;
X    }
X    return value;
X}
X
Xunsigned long get2(bp)
Xchar *bp;
X{
X    register int i;
X    int value = 0;
X
X    for(i = 0; i < 2; i++) {
X	value <<= 8;
X	value |= (*bp & BYTEMASK);
X	bp++;
X    }
X    return value;
X}
X
X/* For if integers are stored wrong-endian. */
Xunsigned long get2i(bp)
Xchar *bp;
X{
X    register int i;
X    long value = 0;
X
X    bp += 1;
X    for(i = 0; i < 2; i++) {
X        value <<= 8;
X        value |= (*bp & BYTEMASK);
X        bp--;
X    }
X    return value;
X}
X
Xunsigned char getb(fp)
XFILE *fp;
X{
X    int c;
X
X    bytes_read += 1;
X    c = getc(fp);
X    if(c == EOF) {
X	(void)fprintf(stderr, "\nPremature EOF\n");
X	exit(1);
X    }
X    return c & BYTEMASK;
X}
X
Xvoid copy(d, s, n)
Xchar *d, *s;
Xint n;
X{
X    while(--n >= 0) {
X	*d++ = *s++;
X    }
X}
X
Xint do_query()
X{
X    char *tp, temp[10];
X
X    (void)fprintf(stderr, "? ");
X    (void) fflush(stdout);
X    (void) read(2, temp, sizeof(temp));
X    temp[sizeof(temp) - 1] = 0;
X    tp = temp;
X    while(*tp != 0) {
X	if(*tp == 'y' || *tp == 'Y') {
X	    return 1;
X	} else {
X	    tp++;
X	}
X    }
X    return 0;
X}
X
Xvoid put4(dest, value)
Xchar *dest;
Xunsigned long value;
X{
X    *dest++ = (value >> 24) & BYTEMASK;
X    *dest++ = (value >> 16) & BYTEMASK;
X    *dest++ = (value >> 8) & BYTEMASK;
X    *dest++ = value & BYTEMASK;
X}
X
Xvoid put2(dest, value)
Xchar *dest;
Xunsigned long value;
X{
X    *dest++ = (value >> 8) & BYTEMASK;
X    *dest++ = value & BYTEMASK;
X}
X
Xvoid do_indent(indent)
Xint indent;
X{
X    int i;
X
X    for(i = 0; i < indent; i++) {
X	(void)fputc(' ', stderr);
X    }
X}
X
Xreal_time set_time(year, month, day, hours, minutes, seconds)
Xint year, month, day, hours, minutes, seconds;
X{
X    real_time toset;
X
X    toset.year = year;
X    toset.month = month;
X    toset.day = day;
X    toset.hours = hours;
X    toset.minutes = minutes;
X    toset.seconds = seconds;
X    return toset;
X}
X
Xunsigned long tomactime(time)
Xreal_time time;
X{
X    long accum;
X    int year;
X
X    accum = time.month - 3;
X    year = time.year;
X    if(accum < 0) {
X	accum += 12;
X	year--;
X    }
X    accum = time.day + mlength[accum] + 59;
X    accum += (year - MACTIMOFFS) * 365 + year / 4 - MACTIMOFFS / 4;
X    accum = ((accum * 24 + time.hours) * 60 + time.minutes) * 60 + time.seconds;
X    return (unsigned)accum;
X}
X
Xreal_time frommactime(accum)
Xunsigned long accum;
X{
Xlong tmp1, tmp2;
Xreal_time time;
X
X    time.seconds = tmp1 = accum % 60;
X    accum /= 60;
X    time.minutes = tmp1 = accum % 60;
X    accum /= 60;
X    time.hours = tmp1 = accum % 24;
X    accum /= 24;
X    tmp1 = (long)accum - 60;
X    tmp2 = tmp1 % 1461;
X    if(tmp2 < 0) {
X	tmp2 += 1461;
X    }
X    tmp1 = (tmp1 - tmp2) / 1461;
X    time.year = tmp1 * 4;
X    tmp1 = tmp2 / 365;
X    if(tmp1 > 3) {
X	tmp1 = 3;
X    }
X    time.year += tmp1 + MACTIMOFFS;
X    tmp2 -= tmp1 * 365;
X    tmp1 = 12;
X    while(mlength[--tmp1] > tmp2);
X    time.day = tmp2 + 1 - mlength[tmp1];
X    time.month = tmp1 + 3;
X    if(tmp1 > 9) {
X	time.month = tmp1 - 9;
X	time.year++;
X    }
X    return time;
X}
X
SHAR_EOF
if test 3583 -ne "`wc -c < 'util.c'`"
then
	echo shar: "error transmitting 'util.c'" '(should have been 3583 characters)'
fi
fi
echo shar: "extracting 'masks.h'" '(87 characters)'
if test -f 'masks.h'
then
	echo shar: "will not over-write existing file 'masks.h'"
else
sed 's/^X//' << \SHAR_EOF > 'masks.h'
X#define	NIBBLEMASK	0x0000000f
X#define	BYTEMASK	0x000000ff
X#define	WORDMASK	0x0000ffff
X
SHAR_EOF
if test 87 -ne "`wc -c < 'masks.h'`"
then
	echo shar: "error transmitting 'masks.h'" '(should have been 87 characters)'
fi
fi
echo shar: "extracting 'transname.c'" '(4465 characters)'
if test -f 'transname.c'
then
	echo shar: "will not over-write existing file 'transname.c'"
else
sed 's/^X//' << \SHAR_EOF > 'transname.c'
X#include <sys/types.h>
X#include <sys/dir.h>
X
Xchar *strncpy();
X
X#ifdef MAXNAMLEN	/* 4.2 BSD */
X#define FNAMELEN MAXNAMLEN
X#else
X#define FNAMELEN DIRSIZ
X#endif
X
X/* Create a Unix file name based on the Mac filename.  First off we have
X * possible problems with filename sizes (Sys V) and also with allowable
X * characters.  Mac filename characters can be anything from 1 to 254 (I
X * think 0 and 255 are not allowed) with colon disallowed.  Unix filenames
X * have also a lot of freedom, but cannot contain 0 or '/'.  Also on Unix
X * non-printable are a trouble (you will never see the filename correctly;
X * and it may even lock your terminal with some versions of Unix).
X * So first off non-printable characters are mapped to underscore.
X * Although there are Unix systems that allow the high order bit set in
X * a filename character in all programs, nearly all implementations do not
X * allow that, so also characters in the range 0200-0377 are mapped to
X * underscore (except as noted below).  Some people would also like to
X * remap characters that are special to some shells (open brackets,
X * asterisks, exclamation point (csh), etc.)  I did elect not to do so
X * because there is no end.  (The previous code disallowed a lot, but not
X * the braces that are special to some shells, obviously he was a C-shell user!)
X * Characters in the range 0200-0377 are in part accented letters
X * (the Swedes, Norwegians and Danes would not agree, but who listens to
X * them!); those are mapped to the unaccented version.  All other characters
X * in this range are mapped to underscore.  Note: this is based on the
X * Geneva font!
X * This stuff is now largely table driven.
X * One day I may modify this so that an environment variable may be used
X * to define mappings. */
X
Xstatic char char_mapping[] = {
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X	 '_',  '!',  '"',  '#',  '$',  '%',  '&', '\'',
X	 '(',  ')',  '*',  '+',  ',',  '-',  '.',  '_',
X	 '0',  '1',  '2',  '3',  '4',  '5',  '6',  '7',
X	 '8',  '9',  ':',  ';',  '<',  '=',  '>',  '?',
X	 '@',  'A',  'B',  'C',  'D',  'E',  'F',  'G',
X	 'H',  'I',  'J',  'K',  'L',  'M',  'N',  'O',
X	 'P',  'Q',  'R',  'S',  'T',  'U',  'V',  'W',
X	 'X',  'Y',  'Z',  '[', '\\',  ']',  '^',  '_',
X	 '`',  'a',  'b',  'c',  'd',  'e',  'f',  'g',
X	 'h',  'i',  'j',  'k',  'l',  'm',  'n',  'o',
X	 'p',  'q',  'r',  's',  't',  'u',  'v',  'w',
X	 'x',  'y',  'z',  '{',  '|',  '}',  '~',  '_',
X#ifndef LATIN1
X	 'A',  'A',  'C',  'E',  'N',  'O',  'U',  'a',
X	 'a',  'a',  'a',  'a',  'a',  'c',  'e',  'e',
X	 'e',  'e',  'i',  'i',  'i',  'i',  'n',  'o',
X	 'o',  'o',  'o',  'o',  'u',  'u',  'u',  'u',
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  'O',
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  'o',
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X	 '_',  '_',  '_',  'A',  'A',  'O',  '_',  '_',
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X	 'y',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X#else /* LATIN1 */
X	0304, 0305, 0307, 0311, 0321, 0326, 0334, 0341,
X	0340, 0342, 0344, 0343, 0345, 0347, 0351, 0350,
X	0352, 0353, 0355, 0354, 0356, 0357, 0361, 0363,
X	0362, 0364, 0366, 0365, 0372, 0371, 0373, 0374,
X	 '_', 0260, 0242, 0243, 0247, 0267, 0266, 0337,
X	0256, 0251,  '_', 0264, 0250,  '_', 0306, 0330,
X	 '_', 0261,  '_',  '_', 0245,  '_',  '_',  '_',
X	 '_',  '_',  '_',  '_',  '_',  '_', 0346, 0370,
X	0277, 0241, 0254,  '_',  '_',  '_',  '_', 0253,
X	0273,  '_',  '_', 0300, 0303, 0325,  '_',  '_',
X	 '_',  '_',  '_',  '_',  '_',  '_', 0367, 0244,
X	0377,  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X#endif /* LATIN1 */
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_'};
X
Xvoid transname(name, namebuf, n)
Xchar *name, *namebuf;
Xint n;
X{
X    char *np;
X
X    /* make sure host file name doesn't get truncated beyond recognition */
X    if (n > FNAMELEN - 2) {
X	n = FNAMELEN - 2;
X    }
X    (void)strncpy(namebuf, name, n);
X    namebuf[n] = '\0';
X
X    /* now: translate name */
X    for (np = namebuf; *np; np++){
X	*np = char_mapping[*np & 0xff];
X    }
X#ifdef NODOT
X    if(*namebuf == '.') {
X	*namebuf = '_';
X    }
X#endif /* NODOT */
X}
X
SHAR_EOF
if test 4465 -ne "`wc -c < 'transname.c'`"
then
	echo shar: "error transmitting 'transname.c'" '(should have been 4465 characters)'
fi
fi
echo shar: "extracting 'backtrans.c'" '(3367 characters)'
if test -f 'backtrans.c'
then
	echo shar: "will not over-write existing file 'backtrans.c'"
else
sed 's/^X//' << \SHAR_EOF > 'backtrans.c'
X#include "masks.h"
X
X/* Map a command line given name to a Mac name.  If LATIN1 is not defined
X   the translation is direct, except that \ is handled special.  \\ is
X   translated to \, \ddd (three digits) is translated to the octal code.
X   If LATIN1 is defined, special care has been taken with the 8 bit chars
X   to get a proper mapping, if possible.  Note: colon is translated to _. */
Xstatic char char_mapping[] = {
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X	 ' ',  '!',  '"',  '#',  '$',  '%',  '&', '\'',
X	 '(',  ')',  '*',  '+',  ',',  '-',  '.',  '/',
X	 '0',  '1',  '2',  '3',  '4',  '5',  '6',  '7',
X	 '8',  '9',  '_',  ';',  '<',  '=',  '>',  '?',
X	 '@',  'A',  'B',  'C',  'D',  'E',  'F',  'G',
X	 'H',  'I',  'J',  'K',  'L',  'M',  'N',  'O',
X	 'P',  'Q',  'R',  'S',  'T',  'U',  'V',  'W',
X	 'X',  'Y',  'Z',  '[', '\\',  ']',  '^',  '_',
X	 '`',  'a',  'b',  'c',  'd',  'e',  'f',  'g',
X	 'h',  'i',  'j',  'k',  'l',  'm',  'n',  'o',
X	 'p',  'q',  'r',  's',  't',  'u',  'v',  'w',
X	 'x',  'y',  'z',  '{',  '|',  '}',  '~', 0177,
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X#ifndef LATIN1
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_',
X	 '_',  '_',  '_',  '_',  '_',  '_',  '_',  '_'};
X#else /* LATIN1 */
X	 '_', 0301, 0242, 0243, 0327, 0265,  '_', 0244,
X	0254, 0251,  '_', 0307, 0302,  '_', 0250,  '_',
X	0241, 0261,  '_',  '_', 0253,  '_', 0246, 0245,
X	 '_',  '_',  '_', 0310,  '_',  '_',  '_', 0300,
X	0313, 0207, 0211, 0313, 0200, 0201, 0256, 0202,
X	0217, 0203, 0220, 0221, 0223, 0314, 0224, 0225,
X	 '_', 0204, 0230, 0227, 0231, 0233, 0205,  '_',
X	0257, 0235, 0234, 0236, 0206,  '_',  '_', 0247,
X	0210, 0207, 0211, 0213, 0212, 0214, 0276, 0215,
X	0217, 0216, 0220, 0221, 0223, 0222, 0224, 0225,
X	 '_', 0226, 0230, 0227, 0231, 0233, 0232, 0326,
X	0277, 0235, 0234, 0236, 0237,  '_',  '_', 0330};
X#endif /* LATIN1 */
X
Xvoid backtrans(macname, name)
Xchar *macname, *name;
X{
X    char *in, *out;
X    int c, count = 0;
X
X    out = macname;
X    for (in = name; *in; in++){
X	if(count == 31) {
X	    break;
X	}
X	if(*in != '\\') {
X	    *out++ = char_mapping[*in & BYTEMASK];
X	    count++;
X	    continue;
X	}
X	in++;
X	if(*in == 0) {
X	    break;;
X	}
X	if(*in < '0' || *in > '9') {
X	    *out++ = char_mapping[*in & BYTEMASK];
X	    count++;
X	    continue;
X	}
X	c = *in - '0';
X	in++;
X	if(*in < '0' || *in > '9') {
X	    *out++ = c;
X	    count++;
X	    in--;
X	    continue;
X	}
X	c = (c << 3) + *in - '0';
X	in++;
X	if(*in < '0' || *in > '9') {
X	    *out++ = c;
X	    count++;
X	    in--;
X	    continue;
X	}
X	c = (c << 3) + *in - '0';
X	*out++ = c;
X	count++;
X    }
X    *out++ = 0;
X}
X
SHAR_EOF
if test 3367 -ne "`wc -c < 'backtrans.c'`"
then
	echo shar: "error transmitting 'backtrans.c'" '(should have been 3367 characters)'
fi
fi
echo shar: "extracting 'patchlevel.h'" '(61 characters)'
if test -f 'patchlevel.h'
then
	echo shar: "will not over-write existing file 'patchlevel.h'"
else
sed 's/^X//' << \SHAR_EOF > 'patchlevel.h'
X#define	VERSION		"2.0b1 (26-APR-1992)"
X#define PATCHLEVEL	0
X
SHAR_EOF
if test 61 -ne "`wc -c < 'patchlevel.h'`"
then
	echo shar: "error transmitting 'patchlevel.h'" '(should have been 61 characters)'
fi
fi
echo shar: "extracting 'curtime.h'" '(240 characters)'
if test -f 'curtime.h'
then
	echo shar: "will not over-write existing file 'curtime.h'"
else
sed 's/^X//' << \SHAR_EOF > 'curtime.h'
X#ifdef TYPES_H
X#include <sys/types.h>
X#endif /* TYPES_H */
X
X#ifdef BSD
X#include <sys/time.h>
Xextern time_t time();
X#else /* BSD */
X#include <time.h>
X#endif /* BSD */
X
X/* Mac time of 00:00:00 GMT, Jan 1, 1970 */
X#define TIMEDIFF 0x7c25b080
X
SHAR_EOF
if test 240 -ne "`wc -c < 'curtime.h'`"
then
	echo shar: "error transmitting 'curtime.h'" '(should have been 240 characters)'
fi
fi
echo shar: "done with directory 'util'"
cd ..
if test ! -d 'mixed'
then
	echo shar: "creating directory 'mixed'"
	mkdir 'mixed'
fi
echo shar: "entering directory 'mixed'"
cd 'mixed'
echo shar: "extracting 'macsave.c'" '(1929 characters)'
if test -f 'macsave.c'
then
	echo shar: "will not over-write existing file 'macsave.c'"
else
sed 's/^X//' << \SHAR_EOF > 'macsave.c'
X#include "globals.h"
X#include "../util/patchlevel.h"
X#include "../fileio/wrfile.h"
X#include "../fileio/wrfileopt.h"
X#include "../util/util.h"
X
X#define LOCALOPT	"ilqVH"
X
Xextern char *strcat();
Xvoid macbinary();
X
Xstatic void usage();
X
Xstatic char options[128];
X
Xint main(argc, argv)
Xint argc;
Xchar *argv[];
X{
X    int c;
X    extern int optind;
X    extern char *optarg;
X    int errflg;
X
X    set_wrfileopt(0);
X    set_s_wrfileopt(1);
X    (void)strcat(options, get_wrfileopt());
X    (void)strcat(options, LOCALOPT);
X    errflg = 0;
X
X    while((c = getopt(argc, argv, options)) != EOF) {
X	if(!wrfileopt((char)c)) {
X	    switch(c) {
X	    case 'l':
X		list++;
X		break;
X	    case 'q':
X		query++;
X		break;
X	    case 'i':
X		info_only++;
X		break;
X	    case '?':
X		errflg++;
X		break;
X	    case 'H':
X		give_wrfileopt();
X		(void)fprintf(stderr, "Macsave specific options:\n");
X		(void)fprintf(stderr,
X			"-i:\tgive information only, do not save\n");
X		(void)fprintf(stderr, "-l:\tgive listing\n");
X		(void)fprintf(stderr,
X			"-q:\tquery for every file/folder before saving\n");
X		(void)fprintf(stderr,
X			"-V:\tgive information about this version\n");
X		(void)fprintf(stderr, "-H:\tthis message\n");
X		(void)fprintf(stderr, "Default is silent saving\n");
X		exit(0);
X	    case 'V':
X		(void)fprintf(stderr, "Version %s, ", VERSION);
X		(void)fprintf(stderr, "patchlevel %d", PATCHLEVEL);
X		(void)fprintf(stderr, "%s.\n", get_mina());
X		exit(0);
X	    }
X	}
X    }
X    if(errflg || optind != argc) {
X	usage();
X	exit(1);
X    }
X
X    infp = stdin;
X
X    if(info_only || query) {
X	list++;
X    }
X    c = getc(infp);
X    (void)ungetc(c, infp);
X    switch(c) {
X    case 0:
X	macbinary();
X	break;
X    default:
X	(void)fprintf(stderr, "Input is not MacBinary\n");
X	exit(1);
X    }
X    exit(0);
X    /* NOTREACHED */
X}
X
Xstatic void usage()
X{
X    (void)fprintf(stderr, "Usage: macsave [-%s]\n", options);
X    (void)fprintf(stderr, "Use \"macsave -H\" for help.\n");
X}
X
SHAR_EOF
if test 1929 -ne "`wc -c < 'macsave.c'`"
then
	echo shar: "error transmitting 'macsave.c'" '(should have been 1929 characters)'
fi
fi
echo shar: "extracting 'macstream.c'" '(4060 characters)'
if test -f 'macstream.c'
then
	echo shar: "will not over-write existing file 'macstream.c'"
else
sed 's/^X//' << \SHAR_EOF > 'macstream.c'
X#include <stdio.h>
X#include "../fileio/machdr.h"
X#include "../fileio/rdfile.h"
X#include "../fileio/rdfileopt.h"
X#include "../util/patchlevel.h"
X
Xextern char *malloc();
Xextern char *realloc();
Xextern char *strcat();
Xextern void exit();
Xextern void transname();
Xextern void do_indent();
X
X#define LOCALOPT	"ilqVH"
X
Xstatic void usage();
X
Xstatic char options[128];
Xstatic char *dir_stack;
Xstatic int dir_ptr = -64;
Xstatic int dir_max;
X
Xint main(argc, argv)
Xint argc;
Xchar **argv;
X{
X    int c, i, j, n;
X    extern int optind;
X    extern char *optarg;
X    int errflg;
X    char text[32], ftype[5], fauth[5];
X    int dir_skip = 0, write_it, query = 0, list = 0, info_only = 0;
X    int indent = 0;
X
X    (void)strcat(options, get_rdfileopt());
X    (void)strcat(options, LOCALOPT);
X    errflg = 0;
X
X    while((c = getopt(argc, argv, options)) != EOF) {
X	if(!rdfileopt((char)c)) {
X	    switch(c) {
X	    case 'l':
X		list++;
X		break;
X	    case 'q':
X		query++;
X		break;
X	    case 'i':
X		info_only++;
X		break;
X	    case '?':
X		errflg++;
X		break;
X	    case 'H':
X		give_rdfileopt();
X		(void)fprintf(stderr, "Macstream specific options:\n");
X		(void)fprintf(stderr,
X			"-i:\tgive information only, do not write\n");
X		(void)fprintf(stderr, "-l:\tgive listing\n");
X		(void)fprintf(stderr,
X			"-q:\tquery for every file/folder before writing\n");
X		(void)fprintf(stderr,
X			"-V:\tgive information about this version\n");
X		(void)fprintf(stderr, "-H:\tthis message\n");
X		(void)fprintf(stderr, "Default is silent writing\n");
X		exit(0);
X	    case 'V':
X		(void)fprintf(stderr, "Version %s, ", VERSION);
X		(void)fprintf(stderr, "patchlevel %d", PATCHLEVEL);
X		(void)fprintf(stderr, "%s.\n", get_minb());
X		exit(0);
X	    }
X	}
X    }
X    if(errflg || optind == argc) {
X	usage();
X	exit(1);
X    }
X
X    if(info_only || query) {
X	list++;
X    }
X
X    setup(argc - optind, argv + optind);
X    while((i = nextfile()) != ISATEND) {
X	if(dir_skip) {
X	    if(i == ISDIR) {
X		dir_skip++;
X	    } else if(i == ENDDIR) {
X		dir_skip--;
X	    }
X	    continue;
X	}
X
X	write_it = 1;
X	n = file_info[I_NAMEOFF] & 0x7f;
X	transname(file_info + I_NAMEOFF + 1, text, n);
X	if(i == ISFILE) {
X	    transname(file_info + I_TYPEOFF, ftype, 4);
X	    transname(file_info + I_AUTHOFF, fauth, 4);
X	}
X	if(list) {
X	    if(i == ISFILE) {
X		do_indent(indent);
X		(void)fprintf(stderr,
X		    "name=\"%s\", type=%4.4s, author=%4.4s, data=%ld, rsrc=%ld",
X		    text, ftype, fauth, (long)data_size, (long)rsrc_size);
X	    } else if(i == ISDIR) {
X		do_indent(indent);
X		dir_ptr += 64;
X		if(dir_ptr == dir_max) {
X		    if(dir_max == 0) {
X			dir_stack = malloc(64);
X		    } else {
X			dir_stack = realloc(dir_stack, (unsigned)dir_max + 64);
X		    }
X		    dir_max += 64;
X		    if(dir_stack == NULL) {
X			(void)fprintf(stderr, "Insufficient memory\n");
X			exit(1);
X		    }
X		}
X		for(j = 0; j <= n; j++) {
X		    dir_stack[dir_ptr + j] = text[j];
X		}
X		(void)fprintf(stderr, "folder=\"%s\"", text);
X		indent++;
X	    } else {
X		indent--;
X		do_indent(indent);
X		(void)fprintf(stderr, "leaving folder \"%s\"",
X			dir_stack + dir_ptr);
X		dir_ptr -= 64;
X	    }
X	    if(info_only) {
X		write_it = 0;
X	    }
X	    if(query) {
X		if(i != ENDDIR) {
X		    write_it = do_query();
X		} else {
X		    (void)fputc('\n', stderr);
X		}
X		if(!write_it && i == ISDIR) {
X		    dir_skip = 1;
X		    indent--;
X		    dir_ptr -= 64;
X		}
X	    } else {
X		(void)fputc('\n', stderr);
X	    }
X	}
X
X	if(write_it) {
X	    (void)fwrite(file_info, 1, 128, stdout);
X	    if(i == ISFILE) {
X		if(data_size != 0) {
X		    (void)fwrite(data_fork, 1, data_size, stdout);
X		    i = (((data_size + 127) >> 7) << 7) - data_size;
X		    while(i-- > 0) {
X			(void)fputc(0, stdout);
X		    }
X		}
X		if(rsrc_size != 0) {
X		    (void)fwrite(rsrc_fork, 1, rsrc_size, stdout);
X		    i = (((rsrc_size + 127) >> 7) << 7) - rsrc_size;
X		    while(i-- > 0) {
X			(void)fputc(0, stdout);
X		    }
X		}
X	    }
X	}
X    }
X    exit(0);
X    /* NOTREACHED */
X}
X
Xstatic void usage()
X{
X    (void)fprintf(stderr, "Usage: macstream [-%s] files\n", options);
X    (void)fprintf(stderr, "Use \"macstream -H\" for help.\n");
X}
X
SHAR_EOF
if test 4060 -ne "`wc -c < 'macstream.c'`"
then
	echo shar: "error transmitting 'macstream.c'" '(should have been 4060 characters)'
fi
fi
echo shar: "extracting 'all'" '(0 character)'
if test -f 'all'
then
	echo shar: "will not over-write existing file 'all'"
else
sed 's/^X//' << \SHAR_EOF > 'all'
SHAR_EOF
if test 0 -ne "`wc -c < 'all'`"
then
	echo shar: "error transmitting 'all'" '(should have been 0 characters)'
fi
fi
echo shar: "extracting 'dir.c'" '(1357 characters)'
if test -f 'dir.c'
then
	echo shar: "will not over-write existing file 'dir.c'"
else
sed 's/^X//' << \SHAR_EOF > 'dir.c'
X#include "globals.h"
X#include "../fileio/machdr.h"
X#include "../fileio/wrfile.h"
X#include "../util/util.h"
X#include "../util/masks.h"
X
Xextern char *malloc();
Xextern char *realloc();
X
Xstatic char *dir_stack;
Xstatic int dir_ptr = -64;
Xstatic int dir_max;
X
Xvoid dir(hdr)
Xchar *hdr;
X{
Xint doit;
X
X    if((hdr[I_NAMEOFF] & BYTEMASK) == 0x80) {
X	if(dir_skip) {
X	    dir_skip--;
X	    return;
X	}
X	indent--;
X	if(list) {
X	    do_indent(indent);
X	    (void)fprintf(stderr, "leaving folder \"%s\"\n",
X		    dir_stack + dir_ptr);
X	}
X	if(!info_only) {
X	    enddir();
X	}
X	dir_ptr -= 64;
X	return;
X    }
X    if(dir_skip) {
X	dir_skip++;
X	return;
X    }
X    dir_ptr += 64;
X    if(dir_ptr == dir_max) {
X	if(dir_max == 0) {
X	    dir_stack = malloc(64);
X	} else {
X	    dir_stack = realloc(dir_stack, (unsigned)dir_max + 64);
X	}
X	dir_max += 64;
X	if(dir_stack == NULL) {
X	    (void)fprintf(stderr, "Insufficient memory\n");
X	    exit(1);
X	}
X    }
X    transname(hdr + I_NAMEOFF + 1, dir_stack + dir_ptr,
X	      (int)(hdr[I_NAMEOFF] & 0x7f));
X    doit = 1;
X    if(list) {
X	do_indent(indent);
X	(void)fprintf(stderr, "folder=\"%s\"", dir_stack + dir_ptr);
X	if(query) {
X	    doit = do_query();
X	} else {
X	    (void)fputc('\n', stderr);
X	}
X    }
X    if(!doit) {
X	dir_ptr -= 64;
X	dir_skip = 1;
X	return;
X    }
X    if(!info_only) {
X	do_mkdir(dir_stack + dir_ptr, hdr);
X    }
X    indent++;
X}
X
SHAR_EOF
if test 1357 -ne "`wc -c < 'dir.c'`"
then
	echo shar: "error transmitting 'dir.c'" '(should have been 1357 characters)'
fi
fi
echo shar: "extracting 'globals.c'" '(250 characters)'
if test -f 'globals.c'
then
	echo shar: "will not over-write existing file 'globals.c'"
else
sed 's/^X//' << \SHAR_EOF > 'globals.c'
X#include "globals.h"
X#include "../fileio/machdr.h"
X
Xchar info[INFOBYTES];
Xchar text[F_NAMELEN+1];
X
Xint list, info_only, query, write_it, indent, dir_skip;
XFILE *infp;
Xint in_data_size = -1;
Xint in_rsrc_size = -1;
Xint in_ds, in_rs, ds_skip, rs_skip;
X
SHAR_EOF
if test 250 -ne "`wc -c < 'globals.c'`"
then
	echo shar: "error transmitting 'globals.c'" '(should have been 250 characters)'
fi
fi
echo shar: "extracting 'globals.h'" '(262 characters)'
if test -f 'globals.h'
then
	echo shar: "will not over-write existing file 'globals.h'"
else
sed 's/^X//' << \SHAR_EOF > 'globals.h'
X#include <stdio.h>
X
Xextern void exit();
Xextern void transname();
X
Xextern char info[];
Xextern char text[];
X
Xextern int list, info_only, query, write_it, indent, dir_skip;
Xextern FILE *infp;
X
Xextern int in_data_size, in_rsrc_size, in_ds, in_rs, ds_skip, rs_skip;
X
SHAR_EOF
if test 262 -ne "`wc -c < 'globals.h'`"
then
	echo shar: "error transmitting 'globals.h'" '(should have been 262 characters)'
fi
fi
echo shar: "extracting 'macbinary.c'" '(2696 characters)'
if test -f 'macbinary.c'
then
	echo shar: "will not over-write existing file 'macbinary.c'"
else
sed 's/^X//' << \SHAR_EOF > 'macbinary.c'
X#include "globals.h"
X#include "../fileio/machdr.h"
X#include "../fileio/kind.h"
X#include "../util/util.h"
X
Xextern void dir();
Xextern void mcb();
Xextern void do_indent();
X
Xstatic void skip_file();
X#ifdef SCAN
Xstatic void get_idf();
X#endif /* SCAN */
X
Xvoid macbinary()
X{
X    char header[INFOBYTES];
X    int c;
X
X    while(1) {
X	if((c = fgetc(infp)) == EOF) {
X	    break;
X	}
X	(void)ungetc(c, infp);
X	if(fread(header, 1, INFOBYTES, infp) != INFOBYTES) {
X	    (void)fprintf(stderr, "Can't read MacBinary header.\n");
X	    exit(1);
X	}
X	if(header[I_NAMEOFF] & 0x80) {
X	    dir(header);
X	    continue;
X	}
X	in_data_size = get4(header + I_DLENOFF);
X	in_rsrc_size = get4(header + I_RLENOFF);
X	in_ds = (((in_data_size + 127) >> 7) << 7);
X	in_rs = (((in_rsrc_size + 127) >> 7) << 7);
X	ds_skip = in_ds - in_data_size;
X	rs_skip = in_rs - in_rsrc_size;
X	if(dir_skip != 0) {
X	    skip_file(in_ds + in_rs);
X	    continue;
X	}
X#ifdef SCAN
X	if(header[I_NAMEOFF] == 0) {
X	    get_idf((int)header[I_NAMEOFF + 1]);
X	    skip_file(ds_skip + in_rs);
X	    continue;
X	}
X#endif /* SCAN */
X	if(header[0] == 0 /* MORE CHECKS HERE! */) {
X	    mcb(header, (unsigned long)in_rsrc_size,
X			(unsigned long)in_data_size, in_ds + in_rs);
X	    continue;
X	} else {
X	    (void)fprintf(stderr, "Unrecognized header.\n");
X	    exit(1);
X	}
X    }
X}
X
Xstatic void skip_file(skip)
X    int skip;
X{
X    char buff[1024];
X    int n;
X
X    while(skip > 0) {
X	n = (skip < 1024 ? skip : 1024);
X	if(fread(buff, 1, n, infp) != n) {
X	    (void)fprintf(stderr, "Incomplete file.\n");
X	    exit(1);
X	}
X	skip -= n;
X    }
X}
X
X#ifdef SCAN
Xstatic void get_idf(kind)
X    int kind;
X{
X    char filename[1024], filename1[255];
X
X    if(fread(filename, 1, in_data_size, infp) != in_data_size) {
X	(void)fprintf(stderr, "Incomplete file.\n");
X	exit(1);
X    }
X    filename[in_data_size] = 0;
X    if(list) {
X	do_indent(indent);
X	switch(kind) {
X	case UNIX_NAME:
X	    (void)fprintf(stderr, "Unix filename: \"%s\"\n", filename);
X	    break;
X	case PACK_NAME:
X	    transname(filename, filename1, in_data_size);
X	    (void)fprintf(stderr, "Packed filename: \"%s\"\n", filename1);
X	    break;
X	case ARCH_NAME:
X	    transname(filename, filename1, in_data_size);
X	    (void)fprintf(stderr, "Archive name: \"%s\"\n", filename1);
X	    break;
X	case UNKNOWN:
X	    (void)fprintf(stderr, "Unknown method detected\n");
X	    break;
X	case ERROR:
X	    (void)fprintf(stderr, "Error detected\n");
X	    break;
X	case PROTECTED:
X	    (void)fprintf(stderr, "Protected file detected\n");
X	    break;
X	case COPY:
X	    (void)fprintf(stderr, "Copied file found\n");
X	    break;
X	default:
X	    (void)fprintf(stderr, "Do not understand this identification\n");
X	    exit(1);
X	}
X    }
X}
X#endif /* SCAN */
X
SHAR_EOF
if test 2696 -ne "`wc -c < 'macbinary.c'`"
then
	echo shar: "error transmitting 'macbinary.c'" '(should have been 2696 characters)'
fi
fi
echo shar: "extracting 'makefile'" '(1946 characters)'
if test -f 'makefile'
then
	echo shar: "will not over-write existing file 'makefile'"
else
sed 's/^X//' << \SHAR_EOF > 'makefile'
XCFLAGS = -O $(CF)
X
XSRCS1 =	macsave.c \
X	globals.c \
X	macbinary.c \
X	dir.c \
X	mcb.c
X
XSRCS2 =	macstream.c
X
XOBJS1 =	macsave.o \
X	globals.o \
X	macbinary.o \
X	dir.o \
X	mcb.o
X
XOBJS2 =	macstream.o
X
XTNAME =	../util/transname
XUNAME =	../util/util
XONAME =	../fileio/wrfile
XINAME = ../fileio/rdfile
XGNAME =	../fileio/fileglob
XXOBJS1=	$(TNAME).o $(UNAME).o $(ONAME).o $(GNAME).o
XXSRCS1=	$(TNAME).c $(UNAME).c $(ONAME).c $(GNAME).c
XXOBJS2=	$(TNAME).o $(UNAME).o $(INAME).o $(GNAME).o
XXSRCS2=	$(TNAME).c $(UNAME).c $(INAME).c $(GNAME).c
XXOBJS3=	$(UNAME).o $(ONAME).o $(GNAME).o
XXSRCS3=	$(UNAME).c $(ONAME).c $(GNAME).c
X
Xall:	macsave macstream
X	touch all
X
Xmacsave:	$(OBJS1) $(XOBJS1)
X	$(CC) $(CFLAGS) -o macsave $(OBJS1) $(XOBJS1)
X
Xmacstream:	$(OBJS2) $(XOBJS2)
X	$(CC) $(CFLAGS) -o macstream $(OBJS2) $(XOBJS2)
X
X$(TNAME).o:	$(TNAME).c
X	(cd ../util; make CC=$(CC) CF="$(CF)" )
X
X$(UNAME).o:	$(UNAME).c
X	(cd ../util; make CC=$(CC) CF="$(CF)" )
X
X$(ONAME).o:	$(ONAME).c
X	(cd ../fileio; make CC=$(CC) CF="$(CF)" )
X
X$(INAME).o:	$(INAME).c
X	(cd ../fileio; make CC=$(CC) CF="$(CF)" )
X
X$(GNAME).o:	$(GNAME).c
X	(cd ../fileio; make CC=$(CC) CF="$(CF)" )
X
Xlint:
X	lint $(CF) $(LFLAGS) $(SRCS1) $(XSRCS1)
X	lint $(CF) $(LFLAGS) $(SRCS2) $(XSRCS2)
X
Xclean:
X	-rm -f *.o
X
Xclobber:clean
X	-rm -f macsave macstream
X
Xmacsave.o:	globals.h
Xmacsave.o:	../util/patchlevel.h
Xmacsave.o:	../fileio/wrfile.h
Xmacsave.o:	../fileio/wrfileopt.h
Xmacsave.o:	../util/util.h
Xglobals.o:	globals.h
Xglobals.o:	../fileio/machdr.h
Xmacbinary.o:	globals.h
Xmacbinary.o:	../fileio/machdr.h
Xmacbinary.o:	../fileio/kind.h
Xmacbinary.o:	../util/util.h
Xdir.o:	globals.h
Xdir.o:	../fileio/machdr.h
Xdir.o:	../fileio/wrfile.h
Xdir.o:	../util/util.h
Xdir.o:	../util/masks.h
Xmcb.o:	globals.h
Xmcb.o:	../fileio/machdr.h
Xmcb.o:	../fileio/wrfile.h
Xmcb.o:	../util/masks.h
Xmcb.o:	../util/util.h
Xmacstream.o:	../fileio/machdr.h
Xmacstream.o:	../fileio/rdfile.h
Xmacstream.o:	../fileio/rdfileopt.h
Xmacstream.o:	../util/patchlevel.h
X
SHAR_EOF
if test 1946 -ne "`wc -c < 'makefile'`"
then
	echo shar: "error transmitting 'makefile'" '(should have been 1946 characters)'
fi
fi
echo shar: "extracting 'mcb.c'" '(2030 characters)'
if test -f 'mcb.c'
then
	echo shar: "will not over-write existing file 'mcb.c'"
else
sed 's/^X//' << \SHAR_EOF > 'mcb.c'
X#include "globals.h"
X#include "../fileio/machdr.h"
X#include "../fileio/wrfile.h"
X#include "../util/masks.h"
X#include "../util/util.h"
X
Xstatic int mcb_read;
X
Xstatic void mcb_wrfile();
X
Xvoid mcb(hdr, rsrcLength, dataLength, toread)
Xchar *hdr;
Xunsigned long rsrcLength, dataLength;
Xint toread;
X{
X    register int i;
X    int n;
X    char ftype[5], fauth[5];
X
X    mcb_read = toread;
X    for(i = 0; i < INFOBYTES; i++) {
X	info[i] = hdr[i];
X    }
X
X    n = hdr[I_NAMEOFF] & BYTEMASK;
X    if(n > F_NAMELEN) {
X	n = F_NAMELEN;
X    }
X    info[I_NAMEOFF] = n;
X    transname(hdr + I_NAMEOFF + 1, text, n);
X    if(hdr[I_LOCKOFF] & 1) {
X	hdr[I_FLAGOFF + 1] = PROTCT_MASK;
X	hdr[I_LOCKOFF] &= ~1;
X    }
X
X    write_it = 1;
X    if(list) {
X	transname(hdr + I_TYPEOFF, ftype, 4);
X	transname(hdr + I_AUTHOFF, fauth, 4);
X	do_indent(indent);
X	(void)fprintf(stderr,
X		"name=\"%s\", type=%4.4s, author=%4.4s, data=%ld, rsrc=%ld",
X		text, ftype, fauth, (long)dataLength, (long)rsrcLength);
X	if(info_only) {
X	    write_it = 0;
X	}
X	if(query) {
X	    write_it = do_query();
X	} else {
X	    (void)fputc('\n', stderr);
X	}
X    }
X
X    if(write_it) {
X	define_name(text);
X	start_info(info, rsrcLength, dataLength);
X	start_data();
X    }
X    mcb_wrfile(dataLength);
X    if(write_it) {
X	start_rsrc();
X    }
X    mcb_wrfile(rsrcLength);
X    if(write_it) {
X	end_file();
X    }
X}
X
Xstatic void mcb_wrfile(ibytes)
Xunsigned long ibytes;
X{
X    int n;
X
X    if(write_it) {
X	if(ibytes == 0) {
X	    return;
X	}
X	n = fread(out_buffer, 1, (int)ibytes, infp);
X	if(n != ibytes) {
X	    (void)fprintf(stderr, "Premature EOF\n");
X	    exit(1);
X	}
X	mcb_read -= n;
X	n = ((n + 127) / 128) * 128 - n;
X	if(n > mcb_read) {
X	    n = mcb_read;
X	}
X	mcb_read -= n;
X	while(n-- > 0) {
X	    if(getc(infp) == EOF) {
X		(void)fprintf(stderr, "Premature EOF\n");
X		exit(1);
X	    }
X	}
X    } else {
X	n = ((ibytes + 127) / 128) * 128;
X	if(n > mcb_read) {
X	    n = mcb_read;
X	}
X	mcb_read -= n;
X	while(n-- > 0) {
X	    if(getc(infp) == EOF) {
X		(void)fprintf(stderr, "Premature EOF\n");
X		exit(1);
X	    }
X	}
X    }
X}
X
SHAR_EOF
if test 2030 -ne "`wc -c < 'mcb.c'`"
then
	echo shar: "error transmitting 'mcb.c'" '(should have been 2030 characters)'
fi
fi
echo shar: "done with directory 'mixed'"
cd ..
if test ! -d 'man'
then
	echo shar: "creating directory 'man'"
	mkdir 'man'
fi
echo shar: "entering directory 'man'"
cd 'man'
echo shar: "extracting 'macunpack.1'" '(2386 characters)'
if test -f 'macunpack.1'
then
	echo shar: "will not over-write existing file 'macunpack.1'"
else
sed 's/^X//' << \SHAR_EOF > 'macunpack.1'
X.TH MACUNPACK L "July 13, 1991"
X.UC
X.SH NAME
Xmacunpack \- Macintosh file de-archiver
X.SH SYNOPSIS
X.B macunpack
X[
X.B \- options
X] [ file ]
X.br
X.SH DESCRIPTION
X.I macunpack
Xtakes the specified Macintosh MacBinary archive specified in
X.I file
X(or standard input if none is specified) and extracts the files it
Xcontains subject to the
X.I options
Xspecified.
XThe program will also accept the data fork of the archive for some kinds
Xof archive.
X.SH OPTIONS
XIn the absence of any options,
X.I macunpack
Xtakes the specified archive and silently extracts the file(s) it contains
Xinto MacBinary format, giving the output files ".bin" extensions and
Xplacing them in the current working directory.
XSubdirectories are created for embedded folders.
X.TP
X.B \-3 
XWrite files in fork format (.info, .data and .rsrc files)
X.TP
X.B \-f 
XAs -3, but empty data and rsrc files are not created
X.TP
X.B \-r
XWrite resource forks only (.rsrc files)
X.TP
X.B \-d
XWrite data forks only (.data files)
X.TP
X.B \-u
XAs -d, but the codes for CR and LF are interchanged
X.TP
X.B \-a
XWrite files in AUFS format.
XThis option is only valid if the program is compiled with AUFS support.
XThe current directory must be a valid AUFS folder.
X.TP
X.B \-s
XWrite extracted files to standard output in MacBinary format.
X.TP
X.B \-l
XList every file extracted (and every directory/folder created etc.)
X.TP
X.B \-v
XLike -l, but more verbose (Implies -l)
X.TP
X.B \-i
XDo not extract, give information only (Implies -l)
X.TP
X.B \-q
XAsk the user for every file/folder whether it should be extracted
X(implies -l)
X.TP
X.B \-V
XGives the patchlevel of the program, and other information.
XOther options are ignored and the program quits immediately.
X.TP
X.B \-H
XGive short information about the options.
XOther options are ignored and the program quits immediately.
X.SH BUGS
XAs this is a beta release, there may still be some problems.  Archives
Xthat are password protected, multi-file archives, and files archived
Xusing Stuffit Deluxe's compression methods 6 or 8 (Fixed Huffman and
XBigram compression) are not dealt with.
X.SH AUTHOR
XDik T. Winter, Amsterdam, The Netherlands (dik@cwi.nl)
X.sp 1
XParts of the code are based on codes from:
XSteve Davies,
XRahul Dhesi,
XCasper H.S. Dik,
XJim McKie,
XMark G. Mendel,
XHaruhiko Okumura,
XJoe Orost,
XSamuel H. Smith,
XYooichi Tagawa,
XSpencer W. Thomas,
XKen Turkowski,
XAllan G. Weber,
XJames A. Woods and
XHaruyasu Yoshizaki.
SHAR_EOF
if test 2386 -ne "`wc -c < 'macunpack.1'`"
then
	echo shar: "error transmitting 'macunpack.1'" '(should have been 2386 characters)'
fi
fi
echo shar: "extracting 'hexbin.1'" '(2830 characters)'
if test -f 'hexbin.1'
then
	echo shar: "will not over-write existing file 'hexbin.1'"
else
sed 's/^X//' << \SHAR_EOF > 'hexbin.1'
X.TH MACUNPACK L "July 13, 1991"
X.UC
X.SH NAME
Xhexbin \- Macintosh file de-debinhexer
X.SH SYNOPSIS
X.B hexbin
X[
X.B \- options
X] [ files ]
X.br
X.SH DESCRIPTION
X.I hexbin
Xtakes the specified text file specified in
X.I files
X(or standard input if none is specified) and converts the files it
Xcontains subject to the
X.I options
Xspecified.
X.SH OPTIONS
XIn the absence of any options,
X.I hexbin
Xtakes the specified files and silently converts the file(s) it contains
Xinto MacBinary format, giving the output files ".bin" extensions and
Xplacing them in the current working directory.
X.TP
X.B \-3 
XWrite files in fork format (.info, .data and .rsrc files)
X.TP
X.B \-f 
XAs -3, but empty data and rsrc files are not created
X.TP
X.B \-r
XWrite resource forks only (.rsrc files)
X.TP
X.B \-d
XWrite data forks only (.data files)
X.TP
X.B \-u
XAs -d, but the codes for CR and LF are interchanged
X.TP
X.B \-a
XWrite files in AUFS format.
XThis option is only valid if the program is compiled with AUFS support.
XThe current directory must be a valid AUFS folder.
X.TP
X.B \-s
XWrite extracted files to standard output in MacBinary format.
X.TP
X.B \-l
XList every file extracted (and every directory/folder created etc.)
X.TP
X.B \-v
XLike -l, but more verbose.
XWhen this option is specified all lines skipped because they do not
Xbelong to the hexified format are listed (Implies -l)
X.TP
X.B \-i
XDo not convert, give information only (Implies -l)
X.TP
X.B \-c
XDo not check whether the hexified lines have equal size.
XNormally the hexifiers gives text files with equal length line size,
Xhexbin uses this in its heuristics to determine whether a line must
Xbe skipped.
XThere are however hexified files that do not conform to that pattern.
XIf this option is specified hexbin will in general be unable to detect
Xwhether a line is garbage or not, so you have to remove the garbage by
Xhand.
X.TP
X.B \-n name
XGives the Unix base file name for the converted files.
XFor files hexified with BinHex 4.0 or compatible hexifiers this flag
Xis not needed; hexbin will determine the Unix file name based on the
XMac file name.
XFor files in dl, hex or hcx format this parameter may be needed as
Xthese formats do not include the Mac filename.
XNormally hexbin will in those cases base the Unix file name on the
Xtext file name, but that can be overruled with this parameter.
X.TP
X.B \-V
XGives the patchlevel of the program, and other information.
XOther options are ignored and the program quits immediately.
X.TP
X.B \-H
XGive short information about the options.
XOther options are ignored and the program quits immediately.
X.SH BUGS
XAs this is a beta release, there may still be some problems.
X.SH AUTHOR
XDik T. Winter, Amsterdam, The Netherlands (dik@cwi.nl)
X.sp 1
XParts of the code are based on codes from:
Xahm (?),
XDarin Adler,
XJim Budler,
XDave Johnson,
XDan LaLiberte,
XJeff Meyer,
XGuido van Rossum.
SHAR_EOF
if test 2830 -ne "`wc -c < 'hexbin.1'`"
then
	echo shar: "error transmitting 'hexbin.1'" '(should have been 2830 characters)'
fi
fi
echo shar: "extracting 'macsave.1'" '(1784 characters)'
if test -f 'macsave.1'
then
	echo shar: "will not over-write existing file 'macsave.1'"
else
sed 's/^X//' << \SHAR_EOF > 'macsave.1'
X.TH MACUNPACK L "July 13, 1991"
X.UC
X.SH NAME
Xmacsave \- Save Mac files read fromn standard input
X.SH SYNOPSIS
X.B macsave
X[
X.B \- options
X]
X.br
X.SH DESCRIPTION
X.I macsave
Xreads a sequence of Macintosh MacBinary files from standard input and writes
Xthe files it contains subject to the
X.I options
Xspecified.
X.SH OPTIONS
XIn the absence of any options,
X.I macsave
Xreads standard input and silently writes the file(s) it contains
Xinto MacBinary format, giving the output files ".bin" extensions and
Xplacing them in the current working directory.
XSubdirectories are created for embedded folders.
X.TP
X.B \-3 
XWrite files in fork format (.info, .data and .rsrc files)
X.TP
X.B \-f 
XAs -3, but empty data and rsrc files are not created
X.TP
X.B \-r
XWrite resource forks only (.rsrc files)
X.TP
X.B \-d
XWrite data forks only (.data files)
X.TP
X.B \-u
XAs -d, but the codes for CR and LF are interchanged
X.TP
X.B \-a
XWrite files in AUFS format.
XThis option is only valid if the program is compiled with AUFS support.
XThe current directory must be a valid AUFS folder.
X.TP
X.B \-s
XWrite extracted files to standard output in MacBinary format.
X.TP
X.B \-l
XList every file extracted (and every directory/folder created etc.)
X.TP
X.B \-v
XLike -l, but more verbose (Implies -l)
X.TP
X.B \-i
XDo not extract, give information only (Implies -l)
X.TP
X.B \-q
XAsk the user for every file/folder whether it should be extracted
X(implies -l)
X.TP
X.B \-V
XGives the patchlevel of the program, and other information.
XOther options are ignored and the program quits immediately.
X.TP
X.B \-H
XGive short information about the options.
XOther options are ignored and the program quits immediately.
X.SH BUGS
XAs this is a beta release, there may still be some problems.
X.SH AUTHOR
XDik T. Winter, Amsterdam, The Netherlands (dik@cwi.nl)
SHAR_EOF
if test 1784 -ne "`wc -c < 'macsave.1'`"
then
	echo shar: "error transmitting 'macsave.1'" '(should have been 1784 characters)'
fi
fi
echo shar: "done with directory 'man'"
cd ..
if test ! -d 'doc'
then
	echo shar: "creating directory 'doc'"
	mkdir 'doc'
fi
echo shar: "entering directory 'doc'"
cd 'doc'
echo shar: "extracting 'README'" '(21641 characters)'
if test -f 'README'
then
	echo shar: "will not over-write existing file 'README'"
else
sed 's/^X//' << \SHAR_EOF > 'README'
XThis is version 2.0b1 of macutil (26-APR-1992).
X
XThis package contains the following utilities:
X	macunpack
X	hexbin
X	macsave
X
XRequirements:
Xa.  Of course a C compiler.
Xb.  A 32-bit machine with large memory (or at least the ability to 'malloc'
X    large chunks of memory).  For reasons of efficiency and simplicity the
X    programs work 'in-core', also many files are first read in core.
X    If somebody can take the trouble to do it differently, go ahead!
X    There are also probably in a number of places implicit assumptions that
X    an int is 32 bits.  If you encounter such occurrences feel free to
X    notify me.
Xc.  A Unix (tm) machine, or something very close.  There are probably quite
X    a lot of Unix dependencies.  Also here, if you have replacements, feel
X    free to send comments.
Xd.  This version normally uses the 'mkdir' system call available on BSD Unix
X    and some versions of SysV Unix.  You can change that, see the makefile for
X    details.
X
XFile name translation:
X
XThe programs use a table driven program to do Mac filename -> Unix filename
Xtranslation.  When compiled without further changes the translation is as
Xfollows:
X    Printable ASCII characters except space and slash are not changed.
X    Slash and space are changed to underscore, as are all characters that
X    do not fall in the following group.
X    Accented letters are translated to their unaccented counterparts.
XIf your system supports the Latin-1 character set, you can change this
Xtranslation scheme by specifying '-DLATIN1' for the 'CF' macro in the
Xmakefile.  This will translate all accented letters (and some symbols)
Xto their Latin-1 counterpart.  This feature is untested (I do not have
Xaccess to systems that cater for Latin-1), so use with care.
XFuture revisions of the program will have user settable conversions.
X
XAnother feature of filename translation is that when the -DNODOT flag is
Xspecified in the CF macro an initial period will be translated to underscore.
X
XAppleshare support:
X
XOptionally the package can be compiled for systems that support the sharing
Xof Unix and Mac filesystems.  The package supports AUFS (AppleTalk Unix File
XServer) from CAP (Columbia AppleTalk Package) and AppleDouble (from Apple).
XIt will not support both at the same time.  Moreover this support requires
Xthe existence of the 'mkdir' system call.  And finally, as implemented it
Xprobably will work on big-endian BSD compatible systems.  If you have a SysV
Xsystem with restricted filename lengths you can get problems.  I do not know
Xalso whether the structures are stored native or Apple-wise on little-endian
Xsystems.  And also, I did not test it fully; having no access to either AUFS
Xor AppleDouble systems.
X
XAcknowledgements:
Xa.  Macunpack is for a large part based on the utilities 'unpit' and 'unsit'
X    written by:
X	Allan G. Weber
X	weber%brand.usc.edu@oberon.usc.edu
X    (wondering whether that is still valid!).  I combined the two into a
X    single program and did a lot of modification.  For information on the
X    originals, see the files README.unpit and README.unsit.
Xb.  The crc-calculating routines are based on a routine originally written by:
X	Mark G. Mendel
X	UUCP: ihnp4!umn-cs!hyper!mark
X    (this will not work anymore for sure!).  Also here I modified the stuff
X    and expanded it, see the files README.crc and README.crc.orig.
Xc.  LZW-decompression is taken from the sources of compress that are floating
X    around.  Probably I did not use the most efficient version, but this
X    program was written to get it done.  The version I based it on (4.0) is
X    authored by:
X	Steve Davies            (decvax!vax135!petsd!peora!srd)
X	Jim McKie               (decvax!mcvax!jim)  (Hi Jim!)
X	Joe Orost               (decvax!vax135!petsd!joe)
X	Spencer W. Thomas       (decvax!harpo!utah-cs!utah-gr!thomas)
X	Ken Turkowski           (decvax!decwrl!turtlevax!ken)
X	James A. Woods          (decvax!ihnp4!ames!jaw)
X    I am sure those e-mail addresses also will not work!
Xd.  Optional AUFS support comes from information supplied by:
X	Casper H.S. Dik
X	University of Amsterdam
X	Kruislaan  409
X	1098 SJ  Amsterdam
X	Netherlands
X
X	phone: +31205922022
X	email: casper@fwi.uva.nl
X    This is an e-mail address that will work.
X    See the makefile.
X    Some caveats are applicable:
X    1.  I did not fully test it (we do not use it).  But the unpacking
X	appears to be correct.  Anyhow, as the people who initially compile
X	it and use it will be system administrators I am confident they are
X	able to locate bugs!  (What if an archive contains a Macfile with
X	the name .finderinfo or .resource?  I have had two inputs for AUFS
X	support [I took Caspers; his came first], but both do not deal with
X	that.  Does CAP deal with it?)  Also I have no idea whether this
X	version supports it under SysV, so beware.
X    2.	From one of the README's supplied by Casper:
X	    Files will not appear in an active folder, because Aufs doesn't like
X	    people working behind it's back.
X	    Simply opening and closing the folder will suffice.
X	Appears to be the same problem as when you are unpacking or in some
X	other way creating files in a folder open to multifinder.  I have seen
X	bundle bits disappear this way.  So if after unpacking you see the
X	generic icon; check whether a different icon should appear and check
X	the bundle bit.
X	    The desktop isn't updated, but that doesn't seem to matter. 
X	I dunno, not using it.
Xe.  Man pages are now supplied.  The base was provided by:
X	Douglas Siebert
X	ISCA
X	dsiebert@icaen.uiowa.edu
Xf.  Because of some problems the Uncompactor has been rewritten, it is now
X    based on sources from the dearchiver unzip (of PC fame).  Apparently the
X    base code is by:
X	Samuel H. Smith
X    I have no further address available, but as soon as I find a better
X    attribution, I will include it.
Xg.  UnstuffIt's LZAH code comes from lharc (also of PC fame) by:
X	Haruhiko Okumura,
X	Haruyasu Yoshizaki,
X	Yooichi Tagawa.
Xh.  Zoom's code comes from information supplied by Jon W{tte
X    (d88-jwa@nada.kth.se).  The Zoo decompressor is based on the routine
X    written by Rahul Dhesi (dhesi@cirrus.COM).  This again is based on
X    code by Haruhiko Okumura.  See also the file README.zoom.
Xi.  MacLHa's decompressors are identical to the ones mentioned in g and h.
Xj.  Most of hexbin's code is based on code written/modified by:
X	Dave Johnson, Brown University Computer Science
X	Darin Adler, TMQ Software
X	Jim Budler, amdcad!jimb
X	Dan LaLiberte, liberte@uiucdcs
X	ahm (?)
X	Jeff Meyer, John Fluke Company
X	Guido van Rossum, guido@cwi.nl (Hi!)
X    (most of the e-mail addresses will not work, the affiliation may also
X    be incorrect by now.)  See also the file README.hexbin.
Xk.  The dl code in hexbin comes is based on the original distribution of
X    SUMacC.
Xl.  The mu code in hexbin is a slight modification of the hcx code (the
X    compressions are identical).
Xm.  The MW code for StuffIt is loosely based on code by Daniel H. Bernstein
X    (brnstnd@acf10.nyu.edu).
X
X-------------------------------------------------------------------------------
XMacunpack will unpack PackIt, StuffIt, Diamond, Compactor/Compact Pro, most
XStuffItClassic/StuffItDeluxe, and all Zoom and LHarc/MacLHa archives.
XAlso it will decode files created by BinHex5.0, MacBinary, UMCP,
XCompress It, ShrinkToFit, MacCompress and DiskDoubler.
X
X(PackIt, StuffIt, Diamond, Compactor, Compact/Pro, Zoom and LHarc/MacLHa are
Xarchivers written by respectively: Harry R. Chesley, Raymond Lau, Denis Sersa,
XBill Goodman, Jon W{tte* and Kazuaki Ishizaki.  BinHex 5.0, MacBinary and
XUMCP are by respectively: Yves Lempereur, Gregory J. Smith, Information
XElectronics.  ShrinkToFit is by Roy T. Hashimoto, Compress It by Jerry
XWhitnell, and MacCompress and DiskDoubler are both by Lloyd Chambers.)
X
X* from his signature:
X	Jon W{tte - Yes, that's a brace - Damn Swede.
XActually it is an a with two dots above; some (German inclined) people
Xrefer to it (incorrectly) as a-umlaut.
X
XIt does not deal with:
Xa.  Password protected archives.
Xb.  Multi-segment archives.
Xc.  Plugin methods for Zoom.
Xd.  MacLHa archives not packed in MacBinary mode (the program deals very
X    poorly with that!).
X
XBackground:
XThere are millions of ways to pack files, and unfortunately, all have been
Ximplemented one way or the other.  Below I will give some background
Xinformation about the packing schemes used by the different programs
Xmentioned above.  But first some background about compression (I am no
Xexpert, more comprehensive information can be found in for instance:
XTomothy Bell, Ian H. Witten and John G. Cleary, Modelling for Text
XCompression, ACM Computing Surveys, Vol 21, No 4, Dec 1989, pp 557-591).
X
XHuffman encoding (also called Shannon-Fano coding or some other variation
X    of the name).  An encoding where the length of the code for the symbols
X    depends on the frequency of the symbols.  Frequent symbols have shorter
X    codes than infrequent symbols.  The normal method is to first scan the
X    file to be compressed, and to assign codes when this is done (see for
X    instance: D. E. Knuth, the Art of Computer Programming).  Later methods
X    have been designed to create the codes adaptively; for a survey see:
X    Jeremy S. Vetter, Design and Analysis of Dynamic Huffman Codes, JACM,
X    Vol 34, No 4, Oct 1987, pp 825-845.
XLZ77: The first of two Ziv-Lempel methods.  Using a window of past encoded
X    text, output consists of triples for each sequence of newly encoded
X    symbols: a back pointer and length of past text to be repeated and the
X    first symbol that is not part of that sequence.  Later versions allowed
X    deviation from the strict alternation of pointers and uncoded symbols
X    (LZSS by Bell).  Later Brent included Huffman coding of the pointers
X    (LZH).
XLZ78: While LZ77 uses a window of already encoded text as a dictionary,
X    LZ78 dynamically builds the dictionary.  Here again pointers are strictly
X    alternated with unencoded new symbols.  Later Welch (LZW) managed to
X    eliminate the output of unencoded symbols.  This algorithm is about
X    the same as the one independently invented by Miller and Wegman (MW).
X    A problem with these two schemes is that they are patented.  Thomas
X    modified LZW to LZC (as used in the Unix compress command).  While LZ78
X    and LZW become static once the dictionary is full, LZC has possibilities
X    to reset the dictionary.  Many LZC variants are in use, depending on the
X    size of memory available.  They are distinguished by the maximum number
X    of bits that are used in a code.
XA number of other schemes are proposed and occasionally used.  The main
Xadvantage of the LZ type schemes is that (especially) decoding is fairly fast.
X
XPrograms background:
X
XPlain programs:
XBinHex 5.0:
X    Unlike what its name suggest this is not a true successor of BinHex 4.0.
X    BinHex 5.0 takes the MacBinary form of a file and stores it in the data
X    fork of the newly created file.
X    Although BinHex 5.0 does not create BinHex 4.0 compatible files, StuffIt
X    will give the creator type of BinHex 5.0 (BnHq) to its binhexed files,
X    rather than the creator type of BinHex 4.0 (BNHQ).  The program knows
X    about that.
XMacBinary:
X    As its name suggests, it does the same as BinHex 5.0.
XUMCP:
X    Looks similar, but the file as stored by UMCP is not true MacBinary.
X    Size fields are modified, the result is not padded to a multiple of 128,
X    etc.  Macunpack deals with all that, but until now is not able to
X    correctly restore the finder flags of the original file.  Also, UMCP
X    created files have type "TEXT" and creator "ttxt", which can create a
X    bit of confusion.  Macunpack will recognize these files only if the
X    creator has been modified to "UMcp".
X
XCompressors:
XShrinkToFit:
X    This program uses a Huffman code to compress.  It has an option (default
X    checked for some reason), COMP, for which I do not yet know the
X    meaning.  Compressing more than a single file in a single run results
X    in a failure for the second and subsequent files.
XCompress It:
X    Also uses a Huffman code to compress.
XMacCompress:
X    MacCompress has two modes of operation, the first mode is (confusingly)
X    MacCompress, the seecond mode is (again confusingly) UnixCompress.  In
X    MacCompress mode both forks are compressed using the LZC algorithm.
X    In UnixCompress mode only the data fork is compressed, and some shuffling
X    of resources is performed.  Upto now macunpack only deals with MacCompress
X    mode.  The LZC variant MacCompress uses depends on memory availability.
X    12 bit to 16 bit LZC can be used.
X
XArchivers:
XArcMac:
X    Nearly PC-Arc compatible.  Arc knows 8 compression methods, I have seen
X    all of them used by ArcMac, except the LZW techniques.  Here they are:
X    1:	No compression, shorter header
X    2:	No compression
X    3:	(packing) Run length encoding
X    4:	(squeezing) RLE followed by Huffman encoding
X    5:	(crunching) LZW
X    6:	(crunching) RLE followed by LZW
X    7:	(crunching) as the previous but with a different hash function
X    8:	(crunching) RLE followed by 12-bit LZC
X    9:	(squashing) 13-bit LZC
XPackIt:
X    When archiving a file PackIt either stores the file uncompressed or
X    stores the file Huffman encoded.  In the latter case both forks are
X    encoded using the same Huffman tree.
XStuffIt and StuffIt Classic/Deluxe:
X    These have the ability to use different methods for the two forks of a
X    file.  The following standard methods I do know about (the last three
X    are only used by the Classic/Deluxe version 2.0 of StuffIt):
X    0:	No compression
X    1:	Run length encoding
X    2:	14-bit LZC compression
X    3:	Huffman encoding
X    5:	LZAH: like LZH, but the Huffman coding used is adaptive
X    6:	A Huffman encoding using a fixed (built-in) Huffman tree
X    8:	A MW encoding
XDiamond:
X    Uses a LZ77 like frontend plus a Fraenkel-Klein like backend (see
X    Apostolico & Galil, Combinatorial Algorithms on Words, pages 169-183).
XCompactor/Compact Pro:
X    Like StuffIt, different encodings are possible for data and resource fork.
X    Only two possible methods are used:
X    0:	Run length encoding
X    1:	RLE followed by some form of LZH
XZoom:
X    Data and resource fork are compressed with the same method.  The standard
X    uses either no compression or some form of LZH
XMacLHa:
X    Has two basic modes of operation, Mac mode and Normal mode.  In Mac mode
X    the file is archived in MacBinary form.  In normal mode only the forks
X    are archived.  Normal mode should not be used (and can not be unpacked
X    by macunpack) as all information about data fork size/resource fork size,
X    type, creator etc. is lost.  It knows quite a few methods, some are
X    probably only used in older versions, the only methods I have seen used
X    are -lh0-, -lh1- and -lh5-.  Methods known by MacLHa:
X    -lz4-:  No compression
X    -lz5-:  LZSS
X    -lzs-:  LZSS, another variant
X    -lh0-:  No compression
X    -lh1-:  LZAH (see StuffIt)
X    -lh2-:  Another form of LZAH
X    -lh3-:  A form of LZH, different from the next two
X    -lh4-:  LZH with a 4096 byte buffer (as far as I can see the coding in
X	    MacLHa is wrong)
X    -lh5-:  LZH with a 8192 byte buffer
XDiskDoubler:
X    The older version of DiskDoubler is compatible with MacCompress.  It does
X    not create archives, it only compresses files.  The newer version (since
X    3.0) does both archiving and compression.  The older version uses LZC as
X    its compression algorithm, the newer version knows a number of different
X    compression algorithms.  Many (all?) are algorithms used in other
X    archivers.  Probably this is done to simplify conversion from other formats
X    to DiskDoubler format archives.  I have seen actual DiskDoubler archives
X    that used methods 0, 1 and 8:
X    0:	No compression
X    1:	LZC
X    2:	???
X    3:	RLE
X    4:	Huffman (or no compression)
X    5:	???
X    6:	???
X    7:	An improved form of LZSS
X    8:	Compactor/Compact Pro compatible RLE/LZH or RLE only
X    9:	???
X    The DiskDoubler archive format contains many subtle twists that make it
X    difficult to properly read the archive (or perhaps this is on purpose?).
X
XNaming:
XSome people have complained about the name conflict with the unpack utility
Xthat is already available on Sys V boxes.  I had forgotten it, so there
Xreally was a problem.  The best way to solve it was to trash pack/unpack/pcat
Xand replace it by compress/uncompress/zcat.  Sure, man uses it; but man uses
Xpcat, so you can retain pcat.  If that was not an option you were able to feel
Xfree to rename the program.  But finally I relented.  It is now macunpack.
X
XWhen you have problems unpacking an archive feel free to ask for information.
XI am especially keen when the StuffIt part detects Fixed Huffman or bigram
Xcompression methods.  If you encounter such an archive, please, mail a
X'binhexed' copy of the archive to me so that I can deal with it.  Password
Xprotected archives are (as already stated) not implemented.  I do not have much
Xinclination to do that.  Also I feel no inclination to do multi-segment
Xarchives.
X
X-------------------------------------------------------------------------------
XHexbin will de-hexify files created in BinHex 4.0 compatible format (hqx)
Xbut also the older format (dl, hex and hcx).  Moreover it will uudecode
Xfiles uuencoded by UUTool (the only program I know that does UU hexification
Xof all Mac file information).
X
XThere are currently many programs that are able to create files in BinHex 4.0
Xcompatible format.  There are however some slight differences, and most
Xde-hexifiers are not able to deal with all the variations.  This program is
Xvery simple minded.  First it will intuit (based on the input) whether the
Xfile is in dl, hex, hcx or hqx format.  Next it will de-hexify the file.
XWhen the format is hqx, it will check whether more files follow, and continue
Xprocessing.  So you can catenate multiple (hqx) hexified files together and
Xfeed them as a single file to hexbin.  Also hexbin does not mind whether lines
Xare separated by CR's, LF's or combinations of the two.  Moreover, it will
Xstrip all leading, trailing and intermediate garbage introduced by mailers
Xetc.  Next, it does not mind if a file is not terminated by a CR or an LF
X(as StuffIt 1.5.1 and earlier did), but in that case a second file is not
Xallowed to follow it.  Last, while most hexifiers output lines of equal length,
Xsome do not.  Hexbin will deal with that, but there are some caveats; see the
X-c option in the man page.
X
XBackground:
X
Xdl format:
X    This was the first hexified format used.  Programs to deal with it came
X    from SUMacC.  This format only coded resource forks, 4 bits in a byte.
Xhex format:
X    I think this is the first format from Yves Lempereur.  Like dl format,
X    it codes 4 bits in a byte, but is able to code both resource and
X    data fork.  Is it BinHex 2.0?
Xhcx format:
X    A compressing variant of hex format.  Codes 6 bits in a byte.
X    Is it BinHex 3.0?
Xhqx format:
X    Like hcx, but using a different coding (possibly to allow for ASCII->EBCDIC
X    and EBCDIC->ASCII translation, which not always results in an identical
X    file).  Moreover this format also encodes the original Mac filename.
Xmu format:
X    The conversion can be done by the UUTool program from Octavian Micro
X    Development.  It encodes both forks and also some finder info.  You will
X    in general not use this with uudecode on non Mac systems, with uudecode
X    only the data fork will be uudecoded.  UU hexification is well known (and
X    fairly old) in Unix environments.  Moreover it has been ported to lots of
X    other systems.
X-------------------------------------------------------------------------------
XMacsave will read a MacBinary stream from standard input and writes the
Xfiles according to the options.
X-------------------------------------------------------------------------------
XThis is an ongoing project, more stuff will appear.
X
XAll comments are still welcome.  Thanks for the comments I already received.
X
Xdik t. winter, amsterdam, nederland
Xemail: dik@cwi.nl
X
X--
XNote:
XIn these programs all algorithms are implemented based on publicly available
Xsoftware to prevent any claim that would prevent redistribution due to
XCopyright.  Although parts of the code would indeed fall under the Copyright
Xby the original author, use and redistribution of all such code is explicitly
Xallowed.  For some parts of it the GNU software license does apply.
X--
XAppendix.
X
XBinHex 4.0 compatible file creators:
X
XType	Creator		Created by
X
X"TEXT"	"BthX"		BinHqx
X"TEXT"	"BNHQ"		BinHex
X"TEXT"	"BnHq"		StuffIt and StuffIt Classic
X"TEXT"	"ttxt"		Compactor
X
XFiles recognized by macunpack:
X
XType	Creator		Recognized as
X
X"APPL"	"DSEA"		"DiskDoubler"		Self extracting
X"APPL"	"EXTR"		"Compactor"		Self extracting
X"APPL"	"Mooz"		"Zoom"			Self extracting
X"APPL"	"Pack"		"Diamond"		Self extracting
X"APPL"	"arc@"		"ArcMac"		Self extracting (not yet)
X"APPL"	"aust"		"StuffIt"		Self extracting
X"ArCv"	"TrAS"		"AutoSqueeze"				(not yet)
X"COMP"	"STF "		"ShrinkToFit"
X"DD01"	"DDAP"		"DiskDoubler"
X"DDAR"	"DDAP"		"DiskDoubler"
X"DDF."	"DDAP"		"DiskDoubler" (any fourth character)
X"DDf."	"DDAP"		"DiskDoubler" (any fourth character)
X"LARC"	"LARC"		"MacLHa (LHARC)"
X"LHA "	"LARC"		"MacLHa (LHA)"
X"PACT"	"CPCT"		"Compactor"
X"PIT "	"PIT "		"PackIt"
X"Pack"	"Pack"		"Diamond"
X"SIT!"	"SIT!"		"StuffIt"
X"SITD"	"SIT!"		"StuffIt Deluxe"
X"Smal"	"Jdw "		"Compress It"
X"TEXT"	"BnHq"		"BinHex 5.0"
X"TEXT"	"GJBU"		"MacBinary 1.0"
X"TEXT"	"UMcp"		"UMCP"
X"ZIVM"	"LZIV"		"MacCompress(M)"
X"ZIVU"	"LZIV"		"MacCompress(U)"			(not yet)
X"mArc"	"arc*"		"ArcMac"				(not yet)
X"zooM"	"zooM"		"Zoom"
X
SHAR_EOF
if test 21641 -ne "`wc -c < 'README'`"
then
	echo shar: "error transmitting 'README'" '(should have been 21641 characters)'
fi
fi
echo shar: "extracting 'README.unpit'" '(2202 characters)'
if test -f 'README.unpit'
then
	echo shar: "will not over-write existing file 'README.unpit'"
else
sed 's/^X//' << \SHAR_EOF > 'README.unpit'
X/*
X *	@(#)unpit.c	1.2	(CWI)	87/11/05
X */
X
X/*
X
X		unpit - Macintosh PackIt file unpacker
X
X		Version 2, for PackIt II
X
XThis program will unpack a Macintosh PackIt file into separate files.  The
Xdata fork of a PackIt file contains both the data and resource forks of the
Xpacked files.  The program will unpack each Mac file into separate .data,
X.rsrc., and .info files that can be downloaded to a Mac using macput.
X
XThe program syntax is much like macput/macget:
X
X	unpit [-rdu] packit-file.data
X
XThe  -r and -d flags will cause only the resource and data forks to be
Xwritten.  The -u flag will cause only the data fork to be written and
Xto have carriage return characters changed to Unix newline characters.
X
XSome of the program is borrowed from the macput.c/macget.c programs.
X
X	Author: Allan G. Weber, (Weber%Brand@USC-ECL)		
X	Date:   September 30, 1985
X	Revised: January 24, 1986 - added CRC checking
X		 March 25, 1986 - support compressed mode of PackIt II,
X				  check for illegal Unix file names
X
X*/
X
X/* There is some confusion as to what to do with the "inited" flag in the
X   finder info bytes that are in the header of each file in the packit file.
X   If this flag bit is copied to the .info file, it seems to confuse
X   MacTerminal into placing the file icons in the upper left corner of the
X   window on top of each other.  Setting this bit to zero in the .info file
X   seems to fix that problem but may cause others.  I haven't been able to
X   find any .info files that have this flag set so making it zero may be OK.
X   Anyway, MacTerminal seems to set the flag when it create the file on the
X   Mac.  The "#define INITED_BUG" can be used to try both settings.  */
X
X/*
XFormat of a Packit file:
X
XRepeat the following sequence for each file in the Packit file:
X
X	4 byte identifier ("PMag" = not compressed, "Pma4" = compressed)
X	variable length compression data (if compressed file)
X	92 byte header (see struct pit_header below) *
X	2 bytes CRC number *
X	data fork (length from header) *
X	resource fork (length from header) *
X	2 bytes CRC number *
X
XLast file is followed by the 4 byte Ascii string, "Pend", and then the EOF.
X
X* these are in compressed form if compression is on for the file
X
X*/
X
SHAR_EOF
if test 2202 -ne "`wc -c < 'README.unpit'`"
then
	echo shar: "error transmitting 'README.unpit'" '(should have been 2202 characters)'
fi
fi
echo shar: "extracting 'README.unsit'" '(1916 characters)'
if test -f 'README.unsit'
then
	echo shar: "will not over-write existing file 'README.unsit'"
else
sed 's/^X//' << \SHAR_EOF > 'README.unsit'
X/*
X		unsit - Macintosh StuffIt file extractor
X
X			Version 1, for StuffIt 1.31
X
XThis program will unpack a Macintosh StuffIt file into separate files.
XThe data fork of a StuffIt file contains both the data and resource
Xforks of the packed files.  The program will unpack each Mac file into
Xseparate .data, .rsrc., and .info files that can be downloaded to a
XMac using macput.  The program is much like the "unpit" program for
Xbreaking apart Packit archive files.
X
X			***** IMPORTANT *****
XTo extract StuffIt files that have been compressed with the Lempel-Ziv
Xcompression method, unsit pipes the data through the "compress"
Xprogram with the appropriate switches, rather than incorporate the
Xuncompression routines within "unsit".  Therefore, it is necessary to
Xhave the "compress" program on the system and in the search path to
Xmake "unsit" work.  "Compress" is available from the comp.sources.unix
Xarchives.
X
XThe program syntax is much like unpit and macput/macget, with some added
Xoptions:
X
X	unsit [-rdulvq] stuffit-file.data
X
XThe -r and -d flags will cause only the resource and data forks to be
Xwritten.  The -u flag will cause only the data fork to be written and
Xto have carriage return characters changed to Unix newline characters.
XThe -l flag will make the program only list the files in the StuffIt
Xfile.  The -v flag causes the program to list the names, sizes, type,
Xand creators of the files it is writing.  The -q flag causes it to
Xlist the name, type and size of each file and wait for a 'y' or 'n'
Xfor either writing that file or skipping it, respectively.
X
XSome of the program is borrowed from the macput.c/macget.c programs.
XMany, many thanks to Raymond Lau, the author of StuffIt, for including 
Xinformation on the format of the StuffIt archives in the documentation.
X
X	Author: Allan G. Weber
X		weber%brand.usc.edu@oberon.usc.edu
X		...sdcrdcf!usc-oberon!brand!weber
X	Date:   January 15, 1988
X
X*/
X
SHAR_EOF
if test 1916 -ne "`wc -c < 'README.unsit'`"
then
	echo shar: "error transmitting 'README.unsit'" '(should have been 1916 characters)'
fi
fi
echo shar: "extracting 'README.zoom'" '(3389 characters)'
if test -f 'README.zoom'
then
	echo shar: "will not over-write existing file 'README.zoom'"
else
sed 's/^X//' << \SHAR_EOF > 'README.zoom'
XTaken from the file plugins.h in the Zoom distribution.
X
X/*
X * The Zoom archive format is:
X *
X * (char) Magic1
X * (char) Magic2 - or - (char) Magic2B
X * (char) Magic3
X * (char) Magic4
X * 
X * IF Magic2B was received THEN
X *		(long) logicalEof /* For multi-file archives * /
X * END IF
X * 
X * <EntryChain>
X * 
X * The format of <EntryChain> is a linked list of
X * EntryInfo, where "next" points to the next logical address
X * on disk. "next" as 0 means no more entries.
X *
X * For a directory, the "creator" field points to the
X * first file/folder entry inside the directory.
X *
X * For a file, IF the "what" field is ZOOM_PLUGIN,
X * the EntryInfo is followed by a length byte and that
X * many characters naming the compression engine.
X * Right after that (or right after the EntryInfo in the
X * case of uncompressed files or default compressed files)
X * follows the data fork compressed, followed by the
X * resource fork compressed.
X *
X * Note that there is no "end of compressed data" marker;
X * your compressor engine will have to figure that out by
X * itself. You could for instance do an ftell before
X * compressing; writing a (long)0 and then write your
X * compressed data, seek back and write the actual length.
X *
X * Note that new entries always are added last in the file,
X * so you need not worry about overrunning anything else.
X */
X
X/*
X * The default compressor in Zoom is the same as used in
X * "better" compression mode in ZOO 2.10. A Zoo extractor
X * or convertor could parse the ZOO header format, and use
X * the built-in engine for "lzh" compressed files.
X *
X * The simplest way to do this is to call SetEngine(-1) and
X * call Encode / Decode. -1 is the default compressor, 0 is
X * the null compressor (fork copy)
X *
X * Likewise, a UNIX zoom packer/unpacker could use the source
X * for zoo 2.10 functions "lzh_encode" and "lzh_decode"
X * (they're wrappers) for compression.
X */
X
X/*
X * This "EntryInfo" is presently also a file header.
X * Some fields may be non-obvious. Don't use these.
X * For instance, "comment" is currently unsupported,
X * and should be left as 0
X */
X#ifndef ZOOM_TYPES
Xtypedef enum zoomWhatType {
X	ZOOM_NOTHING , ZOOM_FILE , ZOOM_UCFILE , ZOOM_DIR , ZOOM_PLUGIN
X} ZoomWhatType ;
X#define ZOOM_TYPES
X#endif
X
X/*
X * Remember to fill in "hlen" correctly as well. When reading a header,
X * Zoom checks with this field to see if it should skip some more data
X * or seek back a little, so as to make future field additions at the
X * end possible. You should NOT add your own fields to this structure.
X */
Xtypedef struct EntryInfo {
X
X	/* "what" is a ZoomWhatType */
X	char			what ;			/* Negative if deleted */
X	unsigned char	hlen ;			/* Header length */
X	unsigned short	boolFlags ;		/* Boolean flags */
X	long			next ;			/* Next entry */
X
X	long			complen ;		/* Length of compressed data */
X	long			compdata ;		/* Data fork portion of compressed data - for dirs, number of entries */
X	long			uclen ;			/* Length of uncompressed entry */
X	long			ucdata ;		/* Data fork part of uncompressed */
X
X	long			type ;			/* File type */
X	long			creator ;		/* File creator - for dir, offset of file */
X	long			mdate ;			/* Modification date */
X	long			comment ;		/* Comment offset */
X	short			flags ;			/* Macintosh file flags */
X
X	short			dataCrc ;		/* Data fork crc */
X	short			resCrc ;		/* Resource fork crc */
X
X	unsigned char	name [ 32 ] ;	/* File/Dir name */
X
X} EntryInfo ;
X
SHAR_EOF
if test 3389 -ne "`wc -c < 'README.zoom'`"
then
	echo shar: "error transmitting 'README.zoom'" '(should have been 3389 characters)'
fi
fi
echo shar: "extracting 'README.hexbin'" '(1421 characters)'
if test -f 'README.hexbin'
then
	echo shar: "will not over-write existing file 'README.hexbin'"
else
sed 's/^X//' << \SHAR_EOF > 'README.hexbin'
XThe comment for the predecessor of hexbin.
X
X/*
X * xbin -- unpack BinHex format file into suitable
X * format for downloading with macput
X * Dave Johnson, Brown University Computer Science
X *
X * (c) 1984 Brown University
X * may be used but not sold without permission
X *
X * created ddj 12/16/84
X * revised ddj 03/10/85 -- version 4.0 compatibility, other minor mods
X * revised ddj 03/11/85 -- strip LOCKED bit from m_flags
X * revised ahm 03/12/85 -- System V compatibility
X * revised dba 03/16/85 -- (Darin Adler, TMQ Software)  4.0 EOF fixed,
X *			   4.0 checksum added
X * revised ddj 03/17/85 -- extend new features to older formats: -l, stdin
X * revised ddj 03/24/85 -- check for filename truncation, allow multiple files
X * revised ddj 03/26/85 -- fixed USG botches, many problems w/multiple files
X * revised jcb 03/30/85 -- (Jim Budler, amdcad!jimb), revised for compatibility
X *			   with 16-bit int machines
X * revised dl  06/16/85 -- (Dan LaLiberte, liberte@uiucdcs) character
X *			   translation speedup
X * revised ddj 09/30/85 -- fixed problem with run of RUNCHAR
X * revised gvr 11/15/86 -- speed-up: rewrote .hqx decoding (mcvax!guido)
X * revised jwm 04/26/88 -- now recognizes "(Convert with" as a starting line
X *		      -- the widely-used Stuffit uses this as a header
X * revised dtw ../../89 -- hqx format will skip garbage lines; undoes some of
X *			-- gvr's work.  will now also recognize .dl format.
X */
X
SHAR_EOF
if test 1421 -ne "`wc -c < 'README.hexbin'`"
then
	echo shar: "error transmitting 'README.hexbin'" '(should have been 1421 characters)'
fi
fi
echo shar: "extracting 'README.crc'" '(237 characters)'
if test -f 'README.crc'
then
	echo shar: "will not over-write existing file 'README.crc'"
else
sed 's/^X//' << \SHAR_EOF > 'README.crc'
XThis code is based on the code described in README.ORIG.
XChanges are:
X1.	A program (makecrc) will create the different C source
X	files to do crc calculations.
X2.	The crc calculation method of binhex is added.
X3.	32 bit crc's are added.
X
SHAR_EOF
if test 237 -ne "`wc -c < 'README.crc'`"
then
	echo shar: "error transmitting 'README.crc'" '(should have been 237 characters)'
fi
fi
echo shar: "extracting 'README.crc.orig'" '(5926 characters)'
if test -f 'README.crc.orig'
then
	echo shar: "will not over-write existing file 'README.crc.orig'"
else
sed 's/^X//' << \SHAR_EOF > 'README.crc.orig'
X/* updcrc(3), crc(1) - calculate crc polynomials
X *
X * Calculate, intelligently, the CRC of a dataset incrementally given a 
X * buffer full at a time.
X * 
X * Usage:
X * 	newcrc = updcrc( oldcrc, bufadr, buflen )
X * 		unsigned int oldcrc, buflen;
X * 		char *bufadr;
X *
X * Compiling with -DTEST creates a program to print the CRC of stdin to stdout.
X * Compile with -DMAKETAB to print values for crctab to stdout.  If you change
X *	the CRC polynomial parameters, be sure to do this and change
X *	crctab's initial value.
X *
X * Notes:
X *  Regards the data stream as an integer whose MSB is the MSB of the first
X *  byte recieved.  This number is 'divided' (using xor instead of subtraction)
X *  by the crc-polynomial P.
X *  XMODEM does things a little differently, essentially treating the LSB of
X * the first data byte as the MSB of the integer. Define SWAPPED to make
X * things behave in this manner.
X *
X * Author:	Mark G. Mendel, 7/86
X *		UUCP: ihnp4!umn-cs!hyper!mark, GEnie: mgm
X */
X
X/* The CRC polynomial.
X * These 4 values define the crc-polynomial.
X * If you change them, you must change crctab[]'s initial value to what is
X * printed by initcrctab() [see 'compile with -DMAKETAB' above].
X */
X    /* Value used by:	    		CITT	XMODEM	ARC  	*/
X#define	P	 0xA001	 /* the poly:	0x1021	0x1021	A001	*/
X#define INIT_CRC 0L	 /* init value:	-1	0	0	*/
X#define SWAPPED		 /* bit order:	undef	defined	defined */
X#define W	16	 /* bits in CRC:16	16	16	*/
X
X    /* data type that holds a W-bit unsigned integer */
X#if W <= 16
X#  define WTYPE	unsigned short
X#else
X#  define WTYPE   unsigned long
X#endif
X
X    /* the number of bits per char: don't change it. */
X#define B	8
X
Xstatic WTYPE crctab[1<<B] = /* as calculated by initcrctab() */ {
X0x0,  0xc0c1,  0xc181,  0x140,  0xc301,  0x3c0,  0x280,  0xc241,
X0xc601,  0x6c0,  0x780,  0xc741,  0x500,  0xc5c1,  0xc481,  0x440,
X0xcc01,  0xcc0,  0xd80,  0xcd41,  0xf00,  0xcfc1,  0xce81,  0xe40,
X0xa00,  0xcac1,  0xcb81,  0xb40,  0xc901,  0x9c0,  0x880,  0xc841,
X0xd801,  0x18c0,  0x1980,  0xd941,  0x1b00,  0xdbc1,  0xda81,  0x1a40,
X0x1e00,  0xdec1,  0xdf81,  0x1f40,  0xdd01,  0x1dc0,  0x1c80,  0xdc41,
X0x1400,  0xd4c1,  0xd581,  0x1540,  0xd701,  0x17c0,  0x1680,  0xd641,
X0xd201,  0x12c0,  0x1380,  0xd341,  0x1100,  0xd1c1,  0xd081,  0x1040,
X0xf001,  0x30c0,  0x3180,  0xf141,  0x3300,  0xf3c1,  0xf281,  0x3240,
X0x3600,  0xf6c1,  0xf781,  0x3740,  0xf501,  0x35c0,  0x3480,  0xf441,
X0x3c00,  0xfcc1,  0xfd81,  0x3d40,  0xff01,  0x3fc0,  0x3e80,  0xfe41,
X0xfa01,  0x3ac0,  0x3b80,  0xfb41,  0x3900,  0xf9c1,  0xf881,  0x3840,
X0x2800,  0xe8c1,  0xe981,  0x2940,  0xeb01,  0x2bc0,  0x2a80,  0xea41,
X0xee01,  0x2ec0,  0x2f80,  0xef41,  0x2d00,  0xedc1,  0xec81,  0x2c40,
X0xe401,  0x24c0,  0x2580,  0xe541,  0x2700,  0xe7c1,  0xe681,  0x2640,
X0x2200,  0xe2c1,  0xe381,  0x2340,  0xe101,  0x21c0,  0x2080,  0xe041,
X0xa001,  0x60c0,  0x6180,  0xa141,  0x6300,  0xa3c1,  0xa281,  0x6240,
X0x6600,  0xa6c1,  0xa781,  0x6740,  0xa501,  0x65c0,  0x6480,  0xa441,
X0x6c00,  0xacc1,  0xad81,  0x6d40,  0xaf01,  0x6fc0,  0x6e80,  0xae41,
X0xaa01,  0x6ac0,  0x6b80,  0xab41,  0x6900,  0xa9c1,  0xa881,  0x6840,
X0x7800,  0xb8c1,  0xb981,  0x7940,  0xbb01,  0x7bc0,  0x7a80,  0xba41,
X0xbe01,  0x7ec0,  0x7f80,  0xbf41,  0x7d00,  0xbdc1,  0xbc81,  0x7c40,
X0xb401,  0x74c0,  0x7580,  0xb541,  0x7700,  0xb7c1,  0xb681,  0x7640,
X0x7200,  0xb2c1,  0xb381,  0x7340,  0xb101,  0x71c0,  0x7080,  0xb041,
X0x5000,  0x90c1,  0x9181,  0x5140,  0x9301,  0x53c0,  0x5280,  0x9241,
X0x9601,  0x56c0,  0x5780,  0x9741,  0x5500,  0x95c1,  0x9481,  0x5440,
X0x9c01,  0x5cc0,  0x5d80,  0x9d41,  0x5f00,  0x9fc1,  0x9e81,  0x5e40,
X0x5a00,  0x9ac1,  0x9b81,  0x5b40,  0x9901,  0x59c0,  0x5880,  0x9841,
X0x8801,  0x48c0,  0x4980,  0x8941,  0x4b00,  0x8bc1,  0x8a81,  0x4a40,
X0x4e00,  0x8ec1,  0x8f81,  0x4f40,  0x8d01,  0x4dc0,  0x4c80,  0x8c41,
X0x4400,  0x84c1,  0x8581,  0x4540,  0x8701,  0x47c0,  0x4680,  0x8641,
X0x8201,  0x42c0,  0x4380,  0x8341,  0x4100,  0x81c1,  0x8081,  0x4040,
X} ;
X
XWTYPE
Xupdcrc( icrc, icp, icnt )
X    WTYPE icrc;
X    unsigned char *icp;
X    int icnt;
X{
X    register WTYPE crc = icrc;
X    register unsigned char *cp = icp;
X    register int cnt = icnt;
X
X    while( cnt-- ) {
X#ifndef SWAPPED
X	crc = (crc<<B) ^ crctab[(crc>>(W-B)) ^ *cp++];
X#else
X	crc = (crc>>B) ^ crctab[(crc & ((1<<B)-1)) ^ *cp++]; 
X#endif SWAPPED
X    }
X
X    return( crc );
X}
X
X#ifdef MAKETAB
X
X#include <stdio.h>
Xmain()
X{
X    initcrctab();
X}
X
Xinitcrctab()
X{
X    register  int b, i;
X    WTYPE v;
X
X    
X    for( b = 0; b <= (1<<B)-1; ++b ) {
X#ifndef SWAPPED
X	for( v = b<<(W-B), i = B; --i >= 0; )
X	    v = v & ((WTYPE)1<<(W-1)) ? (v<<1)^P : v<<1;
X#else
X	for( v = b, i = B; --i >= 0; )
X	    v = v & 1 ? (v>>1)^P : v>>1;
X#endif	    
X	crctab[b] = v;
X
X	printf( "0x%lx,", v & ((1L<<W)-1L));
X	if( (b&7) == 7 )
X	    printf("\n" );
X	else
X	    printf("  ");
X    }
X}
X#endif
X
X#ifdef TEST
X
X#include <stdio.h>
X#include <fcntl.h>
X
X#define MAXBUF	4096
X
X
X
Xmain( ac, av )
X    int ac; char **av;
X{
X    int fd;
X    int nr;
X    int i;
X    char buf[MAXBUF];
X    WTYPE crc, crc2;
X
X    fd = 0;
X    if( ac > 1 )
X	if( (fd = open( av[1], O_RDONLY )) < 0 ) {
X	    perror( av[1] );
X	    exit( -1 );
X	}
X    crc = crc2 = INIT_CRC;
X
X    while( (nr = read( fd, buf, MAXBUF )) > 0 ) {
X	crc = updcrc( crc, buf, nr );
X    }
X
X    if( nr != 0 )
X	perror( "reading" );
X    else {
X	printf( "%lx\n", crc );
X    }
X
X#ifdef MAGICCHECK
X    /* tack one's complement of crc onto data stream, and
X       continue crc calculation.  Should get a constant (magic number)
X       dependent only on P, not the data.
X     */
X    crc2 = crc ^ -1L;
X    for( nr = W-B; nr >= 0; nr -= B ) {
X	buf[0] = (crc2 >> nr);
X	crc = updcrc(crc, buf, 1);
X    }
X
X    /* crc should now equal magic */
X    buf[0] = buf[1] = buf[2] = buf[3] = 0;
X    printf( "magic test: %lx =?= %lx\n", crc, updcrc(-1, buf, W/B));
X#endif MAGICCHECK
X}
X
X#endif
X****************************************************************************
X
SHAR_EOF
if test 5926 -ne "`wc -c < 'README.crc.orig'`"
then
	echo shar: "error transmitting 'README.crc.orig'" '(should have been 5926 characters)'
fi
fi
echo shar: "done with directory 'doc'"
cd ..
echo shar: "done with directory 'macutil'"
cd ..
exit 0
#	End of shell archive
