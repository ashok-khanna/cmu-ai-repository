;********************************************************************
;
;   Allied Telesyn AT-2500TX Miniport Driver OEMSETUP File
;   for WinNT 3.5x, WinNT 4.0
;   (NDIS 4.0 driver)
;
;********************************************************************

[Identification]
    OptionType = NetAdapter

[PlatformsSupported]
    PCI

[Options]
    AT2500

[FileConstants]
    UtilityInf                  = "UTILITY.INF"
    subroutineinf               = "SUBROUTN.INF"
    SoftwareType                = "driver"
    Exit_Code                   = 0
;;;1997,06,10    NetEventDLL                 = "%SystemRoot%\System32\netevent.dll;%SystemRoot%\System32\drivers\a25v3m4.SYS"
    NetEventDLL                 = "%SystemRoot%\System32\netevent.dll;%SystemRoot%\System32\drivers\a25v3m4.SYS"
    IoLogMsgDLL                 = "%SystemRoot%\System32\IoLogMsg.dll"

    Manufacturer                = "Allied Telesyn"
    ProductMajorVersion         = "03"
    ProductMinorVersion         = "11"
    ProductVersion              = $(ProductMajorVersion)"."$(ProductMinorVersion)
    ProductSoftwareName         = "AT-2500v2"
    ProductSoftwareImagePath    = "%SystemRoot%\System32\drivers\a25v3m4.SYS"
    NetRuleSoftwareType         = "AT2500Sys ndisDriver AT2500Driver"
    NetRuleSoftwareUse          = $(SoftwareType)
    NetRuleSoftwareBindForm     = """AT2500Sys"" yes no container"
    NetRuleSoftwareClass        = {"AT2500Driver basic"}
    NetRuleSoftwareBindable     = {"AT2500Driver AT2500Adapter non exclusive 100"}
    ProductHardwareName         = "AT-2500v2"
    NetRuleHardwareBindForm     = " yes yes container"

    ProductKeyName              = $(!NTN_SoftwareBase)"\"$(Manufacturer)"\"$(ProductSoftwareName)"\CurrentVersion"
    ParamKeyName                = $(!NTN_ServiceBase)"\"$(ProductHardwareName)"\Parameters"

    FunctionTitle               = "Allied Telesyn AT-2500TX PCI 10/100 Ethernet Adapter Setup"
    ProductSoftwareDescription  = "Allied Telesyn AT-2500TX PCI 10/100 Ethernet Adapter Driver"
    ProductSoftwareTitle        = "Allied Telesyn AT-2500TX PCI 10/100 Ethernet Adapter Driver"

    ProductHardwareAT2500Title   = "Allied Telesyn AT-2500TX PCI 10/100 Ethernet Adapter"
    ProductHardwareAT2500Description = "Allied Telesyn AT-2500TX PCI 10/100 Ethernet Adapter"
    NetRuleHardwareAT2500Type    = "AT2500 AT2500Adapter"
    NetRuleHardwareAT2500Class   = {"AT2500Adapter basic"}

    AdapterAT2500Type            = 5             ;; PCI board

    AT2500CFID                   = 2168000748    ;; 0x813910EC

[GeneralConstants]
    from      = ""
    to        = ""
    ExitCodeOk     = 0
    ExitCodeCancel = 1
    ExitCodeFatal  = 2
    KeyNull         = ""
    MAXIMUM_ALLOWED   = 33554432
    RegistryErrorIndex = NO_ERROR
    KeyProduct      = ""
    KeyParameters   = ""
    TRUE            = 1
    FALSE           = 0
    NoTitle            = 0
    ExitState   = "Active"
    OldVersionExisted = $(FALSE)
    DriverPath      = $(!STF_NTPATH)\drivers
    NT350VersionConstant = "3.50"
    NT310VersionConstant = "3.10"

[date]
    Now = {} ? $(!LIBHANDLE) GetSystemDate

;
; The [Identify] section is the first section executed by Setup. It
; returns information to Setup about the type of drivers that can
; be installed by this .INF file (in our case, network drivers).
;
[Identify]
    read-syms Identification
    set Status     = STATUS_SUCCESSFUL
    set Identifier = $(OptionType)
    set Media      = #("Source Media Descriptions", 1, 1)
    Return $(Status) $(Identifier) $(Media)
    
;
; If the [Identify] section indicates that the .INF file supports
; the appropriate type of driver, Setup calls the [ReturnOptions]
; section.  Setup passes a single parameter to this section,
; indicating the language to be used for dialog strings.  This
; section returns information to the Setup program, listing the
; names of any drivers which can be installed by this .INF file.
; It also returns the text strings for each driver to be used in
; the dialog box asking the user to select the driver to install.
;
[ReturnOptions]
    ;
    ; Initialize variables to failure state.
    ;
    set Status        = STATUS_FAILED
    set OptionList     = {}
    set OptionTextList = {}

    ;
    ; See if our language list supports the language specified.
    ; If a second parameter was passed in, see if it is a supported
    ; platform.
    ;
    set LanguageList = ^(LanguagesSupported, 1)
    Ifcontains(i) $($0) in $(LanguageList)
    ifstr(i) $($1) == ""
        goto returnoptions
    endif
        set PlatformList = ^(PlatformsSupported, 1)
    Ifcontains(i) $($1) in $(PlatformList)
        goto returnoptions
    else
        set Status = STATUS_NOTSUPPORTED
        goto finish_ReturnOptions
    endif
    else
        set Status = STATUS_NOLANGUAGE
        goto finish_ReturnOptions
    endif


    ;
    ; If we get here, we are successful, so return the option list.
    ;
returnoptions = +
    set OptionList     = ^(Options, 1)
    set OptionTextList = ^(OptionsText$($0), 1)
    set Status         = STATUS_SUCCESSFUL

    ;
    ; Exit from this section.
    ;
finish_ReturnOptions = +
    Return $(Status) $(OptionList) $(OptionTextList)

;
; If the [ReturnOptions] section returns successfully, indicating
; the language is supported, Setup displays a dialog box from which
; the user can select a driver to install.  Setup then calls the
; [InstallOption] section, with the following parameters:
;
;       Language to use
;       OptionID to install
;       SourceDirectory
;       AddCopy  (yes/no)
;       DoCopy   (yes/no)
;       DoConfig (yes/no)
;
; ScrDir seems to always be A:\, even when you later install from
; the oemnad#.inf which is copied to the system32 directory.
;
; AddCopy and DoCopy are valid only when NTN_InstallMode = install.
; AddCopy is yes if the files should be added to the copy list.
; DoCopy is yes if CopyFilesInCopyList should be called.
;
; DoConfig is not used for network cards.
;
; This .INF file is automatically copied to the SYSTEM32 directory,
; by WinNT, and renamed so as to have a unique name.
;
[InstallOption]
    ;;;
    ;;; Change "Set !G:DebugOutputControl=0" to 1 in NCAPSHEL.INF for debug support.
    ;;;
    ;;; set !G:DebugOutputControl=1     ;; Debug output {1=turned on, 0= turned off}

    ;
    ; Read input parameters.
    ;
    set Option   = $($1)
    set SrcDir   = $($2)
    set AddCopy  = $($3)
    set DoCopy   = $($4)
    set DoConfig = $($5)

    ;
    ; Check if specified language is supported.
    ;
    set LanguageList = ^(LanguagesSupported, 1)
    Ifcontains(i) $($0) NOT-IN $(LanguageList)
    Return STATUS_NOLANGUAGE
    endif

    ;
    ; Set up local variables and constant values.
    ;
    set-subst LF = "\n"
    read-syms GeneralConstants
    read-syms FileConstants
;   set NetRuleSoftwareBindable = $($R1)
    read-syms DialogConstants$(!STF_LANGUAGE)
    ifstr(i) $(!NTN_Origination) == "NCPA"
    set Continue = "OK"
    endif
    read-syms FileConstants$(!STF_LANGUAGE)
    read-syms FileDependentDlg$(!STF_LANGUAGE)
    set OptionHelpFile = AT2500.hlp
    SetHelpFile $(!STF_WINDOWSSYSPATH)"\"$(OptionHelpFile) $(MinHelpId) $(MaxHelpId)
    detect date
    set-title  $(Function$(Option)Title)
    set to   = Begin
    set from = Begin
    set CommonStatus = STATUS_SUCCESSFUL
    EndWait

    ;; ;
    ;; ; Problem was discovered using unattend.txt files for automatic
    ;; ; installation.  It was found that $2 passed into this section does
    ;; ; not have an appropriate value when using unattend.txt.  It was
    ;; ; found that during manual AND unattended installations, the variable
    ;; ; STF_SRCDIR_OVERRIDE did contain an appropriate value.
    ;; ;
    ;; ifstr(i) $(!STF_SRCDIR_OVERRIDE) != ""
    ;;     set SrcDir = $(!STF_SRCDIR_OVERRIDE)
    ;; endif

Begin = +

    ;;
    ;; Get the Version of Windows NT we are installing on.  This will allow us to use the
    ;; PCI Support that will be included in NT v3.51
    ;;
    set CurrentVersionValue = ""
    OpenRegKey $(!REG_H_LOCAL) "" "SOFTWARE\Microsoft\Windows Nt\CurrentVersion" $(!REG_KEY_READ) KeyNt
    Ifstr(i) $(KeyNt) != ""
    GetRegValue $(KeyNt) "CurrentVersion" CurrentVersionValue
    Debug-Output "$(InfFile) $(Option): WinNT CurrentVersion ="$(CurrentVersionValue)
    CloseRegKey $(KeyNt)
    Endif

    ifstr(i) (*($(CurrentVersionValue),4)) == $(NT310VersionConstant)    ;; NT v3.10 not supported!
        Debug-Output "$(InfFile) $(Option): Configureadapter"
    set Error = "Windows NT v3.10 is not support by this product"
    goto fatal
    endif

;    set ActivateDetection = FALSE

    ;
    ; NTN_InstallMode
    ;   install   - this is a primary or original installation, it
    ;               may be an upgrade
    ;   deinstall - this product and its binaries are to be removed
    ;               from the disk
    ;   configure - this product is to be (re-) configured
    ;   bind      - this product's relationships to other products
    ;               have changed and should be reviewed.
    ;
    Ifstr(i) $(!NTN_InstallMode) == deinstall
        set StartLabel = removeadapter
    else-Ifstr(i) $(!NTN_InstallMode) == Update
        set StartLabel = UpgradeSoftware
    else-Ifstr(i) $(!NTN_InstallMode) == bind
        set StartLabel = bindingadapter
    else-Ifstr(i) $(!NTN_InstallMode) == configure
        Ifstr(i) $(ProductKeyName) == $(!NTN_RegBase)
            Shell $(UtilityInf),RegistryErrorString,CANNOT_CONFIGURE_SOFTWARE
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
            goto ShellCodeError
            endif
            set Error = $($R0)
            set from = end
            set to = end
            goto nonfatalinfo
        else
            set StartLabel = configureadapter
        endif
    else
        set StartLabel = installadapter
        set OEM_ABANDON_OPTIONS = {}
        set OEM_ABANDON_SOFTWARE = FALSE
        set OEM_ABANDON_ON = TRUE
    endif

    ;; ;
    ;; ; HARDWARE_PUT_IN_REGISTRY gets set to true once the hardware
    ;; ; component is installed.  That way if we get an error we know
    ;; ; to uninstall it.  HWList has the path to the hardware that
    ;; ; is needed by RemoveHardwareComponent.
    ;; ;
    ;; ; SOFTWARE_PUT_IN_REGISTRY gets set to true once the software
    ;; ; component is installed.
    ;; ;
    ;; set HARDWARE_PUT_IN_REGISTRY = $(FALSE)
    ;; set HWList = ""
    ;; set SOFTWARE_PUT_IN_REGISTRY = $(FALSE)

    Debug-Output "$(InfFile) $(Option): =================================================="
    Debug-Output "$(InfFile) $(Option): STF_CWDIR is: "$(!STF_CWDIR)
    Debug-Output "$(InfFile) $(Option): STF_SRCDIR is: "$(!STF_SRCDIR)
    Debug-Output "$(InfFile) $(Option): STF_LANGUAGE is: "$(!STF_LANGUAGE)
    Debug-Output "$(InfFile) $(Option): Option is: "$(Option)
    Debug-Output "$(InfFile) $(Option): !STF_NCN_InstallMode is:"$(!NTN_InstallMode)
    Debug-Output "$(InfFile) $(Option): !STF_NCDETECT  is: "$(!STF_NCDETECT)
    Debug-Output "$(InfFile) $(Option): !STF_NCOPTION  is: "$(!STF_NCOPTION)
    Debug-Output "$(InfFile) $(Option): !STF_NCDETCARD is: "$(!STF_NCDETCARD)
    Debug-Output "$(InfFile) $(Option): !STF_NCDETINFO is: "$(!STF_NCDETINFO)
    Debug-Output "$(InfFile) $(Option): !STF_GUI_UNATTENDED is: "$(!STF_GUI_UNATTENDED)
    Debug-Output "$(InfFile) $(Option): !STF_BusType is $(!STF_BUSTYPE)"            ;; Primary Bus
    Debug-Output "$(InfFile) $(Option): !STF_BusTypeList is $(!STF_BUSTYPELIST)"    ;; All Buses
    Debug-Output "$(InfFile) $(Option): =================================================="

    Set EtherID = ""
    Set NetworkAddress = "000000000000"
    set from = $(fatal)
    set to = $(fatal)
    goto $(StartLabel)

;------------------------------------------------------------------------
; InstallMode = install
; Came here straight from figuring out which platform we are on.
; Option, SrcDir, AddCopy, DoCopy, and DoConfig are valid.
;
installadapter = +

    install "Install-Hlp"

    Debug-Output "$(InfFile) $(Option): Installadapter"
    ;
    ; Get open handle KeyProduct.
    ; Returns an empty string if key does not exist.
    ;
    ; NTN_RegBase appears empty on the installation of the first card.
    ; KeyProduct will be KeyNull on the installation of the first card.
    ;
    OpenRegKey $(!REG_H_LOCAL) "" $(ProductKeyName) $(MAXIMUM_ALLOWED) KeyProduct
    Ifstr $(KeyProduct) != $(KeyNull)
        CloseRegKey $(KeyProduct)
        ifstr(i) !(NTN_RegBase) == $(ProductKeyName)
;           Shell $(UtilityInf), VerExistedDlg, $(ProductSoftwareTitle),+
;              $(ProductVersion)
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                Debug-Output "ShellCode error: cannot get an error string."
                goto ShellCodeError
            endif
            goto end
        else
;           Shell $(UtilityInf), CardExistedDlg
;           ifint $($ShellCode) != $(!SHELL_CODE_OK)
;               Debug-Output "ShellCode error: cannot get an error string."
;               goto ShellCodeError
;           endif
;           ifstr(i) $($R1) != "OK"
;               set CommonStatus = STATUS_USERCANCEL
;               goto end
;           endif
            set OldVersionExisted = $(TRUE)
        endif
    Endif
   Shell $(UtilityInf), DoAskSource, $(!STF_CWDDIR), $(SrcDir) NO
   Ifint $($ShellCode) != $(!SHELL_CODE_OK)
       Goto ShellCodeError
   Else-Ifstr(i) $($R0) == STATUS_FAILED
       Shell $(UtilityInf) RegistryErrorString "ASK_SOURCE_FAIL"
       ifint $($ShellCode) != $(!SHELL_CODE_OK)
           goto ShellCodeError
       endif
       set Error = $($R0)
       Goto fatal
   Else-Ifstr(i) $($R0) == STATUS_USERCANCEL
      Goto successful
   Endif

 ;  Set SrcDir = $($R1)
 ;  Set SrcDir = "A:\DRIVER"

;      Goto adapteroptions
          Goto installproduct

configureadapter = +
    Debug-Output "$(InfFile) $(Option): Configureadapter"

   Ifstr(i) $(KeyProduct) == $(KeyNull)
        OpenRegKey $(!REG_H_LOCAL) "" $(!NTN_RegBase) $(MAXIMUM_ALLOWED) KeyProduct
        Ifstr $(KeyProduct) == $(KeyNull)
            Set RegistryErrorIndex = CANNOT_FIND_COMPONENT_SERVICE
           Goto fatalregistry
        Endif
    Endif
    Shell $(UtilityInf) FindService, $(KeyProduct)
    Ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Goto ShellCodeError
    Endif
    Ifstr(i) $($R0) != NO_ERROR
        Goto fatalregistry
    endif
    set KeyParameters = $($R2)
    CloseRegKey $($R1)
    Ifstr $(KeyParameters) == $(KeyNull)
        set RegistryErrorIndex = CANNOT_FIND_COMPONENT_SERVICE
        goto fatalregistry
    endif
    set OldVersionExisted = $(TRUE)
    set ValueName = ""
    set ValueData = ""
    set ValueStr  = ""
    set ValueList = {}
    EnumRegValue $(KeyParameters) ValueList
    ForListDo $(ValueList)
        set ValueItem = $($)
        set ValueName = *($(ValueItem),1)
        set ValueData = *($(ValueItem),4)
        Ifstr(i) $(ValueName) == "DuplexMode"
            set DuplexModeIndex = $(ValueData)
        else-ifstr(i) $(ValueName) == "EtherID"
            set EtherID = $(ValueData)
        else-ifstr(i) $(ValueName) == "NetworkAddress"
            set NetworkAddress = $(ValueData)
        else-ifstr(i) $(ValueName) == "EarlyTxThreshold"   ;luke add3 show preseting vlue
            set EarlyTxThreshold = $(ValueData)
        endif
    EndForListDo
    set DuplexModeValue = *($(DuplexModeList), ~($(DuplexModeValues),$(DuplexModeIndex)))
    ifstr(i) $(DuplexModeValue) == ""
        set DuplexModeValue = *($(DuplexModeList), 1)
    endif
;;;    set Error = "Cannot configure the software component"
;;;    goto fatal

adapteroptions = +
    Debug-Output "$(InfFile) $(Option): Adapteroptions"
    set from = adapteroptions

   read-syms FileDependentDlg$(!STF_LANGUAGE)
   SetHelpFile $(!STF_WINDOWSSYSPATH)"\"$(OptionHelpFile) $(MinHelpId) $(MaxHelpId) $(Help$(Option)Id)
   ;SetHelpFile $(!STF_WINDOWSSYSPATH)"\"At2500.hlp 10 30
   ui start "InputDlg"

;   ifstr(i) $(DLGEVENT) == "CONTINUE"
;      set DuplexModeIndex = $(Combo1Out)
;      ui pop 1
;   else-ifstr(i) $(DLGEVENT) == "BACK"
;      set CommonStatus = STATUS_USERCANCEL
;      ui pop 1
;      goto end
;   else
;      ui pop 1
;      goto end
;   endif

   ifstr(i) $(DLGEVENT) == "CONTINUE"
      set DuplexModeIndex = $(Combo1Out)
      ui pop 1
   else-ifstr(i) $(DLGEVENT) == "BACK"
      set CommonStatus = STATUS_USERCANCEL
      ui pop 1
      goto end
   else
      ui pop 1
      goto end
   endif

   set DuplexModeValue = *($(DuplexModeValues), ~($(DuplexModeList),$(DuplexModeIndex)))

   set EtherID = ""
   ;;;;;;;;;;;;;;;;;;Ether ID;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
       read-syms NetworkAddressDlg$(!STF_LANGUAGE)
       ui start "InputDlg"
       ifstr(i) $(DLGEVENT) == "CONTINUE"
                   ;;set EtherID = $(EditTextOut)
                   set NetworkAddress = $(EditTextOut)
                   ui pop 1
       else-ifstr(i) $(DLGEVENT) == "EXIT"
                   ui pop 1
       else
                   ui pop 1
                   goto end
       endif

;   set EarlyTxThreshold = "09"
   ;;;;;;;;;;;;;;;;;;Ether ID;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
       read-syms EarlyTxThresholdDlg$(!STF_LANGUAGE)
       ui start "InputDlg"
       ifstr(i) $(DLGEVENT) == "CONTINUE"
                   set EarlyTxThreshold = $(EditTextOut)
                   ui pop 1
       else-ifstr(i) $(DLGEVENT) == "EXIT"
                   ui pop 1
       else
                   ui pop 1
                   goto end
       endif

    ifstr(i) $(!NTN_InstallMode) == configure
       goto updateparameters
    endif
    ;; ifstr(i) $(!NTN_InstallMode) == configure
    ;;    goto updateparameters
    ;; endif

installproduct =+
    Debug-Output "$(InfFile) $(Option): installproduct"
    StartWait
    set AdapterList = $($R1)
    ifint $(OldVersionExisted) == $(FALSE)
        Ifstr(i) $(DoCopy) == "YES"
            Shell $(UtilityInf), DoAskSource, $(!STF_CWDDIR), $(SrcDir) NO
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                Goto ShellCodeError
            Else-Ifstr(i) $($R0) == STATUS_FAILED
                Shell $(UtilityInf) RegistryErrorString "ASK_SOURCE_FAIL"
                ifint $($ShellCode) != $(!SHELL_CODE_OK)
                    goto ShellCodeError
                endif
                set Error = $($R0)
                Goto fatal
            Else-Ifstr(i) $($R0) == STATUS_USERCANCEL
                Goto successful
            Endif
            Set SrcDir = $($R1)
        Endif

        install "Install-Option"
        ifstr(i) $(STF_INSTALL_OUTCOME) != STF_SUCCESS
            Shell $(UtilityInf) RegistryErrorString "UNABLE_COPY_FILE"
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                goto ShellCodeError
            endif
            set Error = $($R0)
            goto fatal
        endif
    endif

    ;
    ; Check to see if the Product Software key exists already in the system service keys
    ; before we try to add the software component.
    ;
    OpenRegKey $(!REG_H_LOCAL) "" $(!NTN_ServiceBase)"\"$(ProductHardwareName) $(!REG_KEY_READ) KeyNt
    CloseRegKey $(KeyNt)

    Ifstr(i) $(KeyNt) == ""
        Debug-Output "$(InfFile) $(Option): AddSoftwareComponent"
        Debug-Output "$(InfFile) $(Option): --> $(Manufacturer)"
        Debug-Output "$(InfFile) $(Option): --> $(ProductSoftwareName)"
        Debug-Output "$(InfFile) $(Option): --> $(ProductSoftwareTitle)"
        Debug-Output "$(InfFile) $(Option): --> $(STF_CONTEXTINFNAME)"
        Debug-Output "$(InfFile) $(Option): --> $(ProductSoftwareImagePath)"
        Debug-Output "$(InfFile) $(Option): --> $(NetEventDLL)"

        Shell $(UtilityInf), AddSoftwareComponent, $(Manufacturer), +
        $(ProductSoftwareName), +
        $(ProductSoftwareName), +
        $(ProductSoftwareTitle), $(STF_CONTEXTINFNAME), +
        $(ProductSoftwareImagePath), "kernel", "NDIS", {}, "",+
        $(NetEventDLL)

        Set OEM_ABANDON_SOFTWARE = TRUE
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            goto ShellCodeError
        endif
        set RegistryErrorIndex = $($R0)
        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            EndWait
            CloseRegKey $($R1)
            CloseRegKey $($R2)
            CloseRegKey $($R3)
            CloseRegKey $($R4)
            CloseRegKey $($R5)
            goto fatalregistry
        endif
        Set SoftProductKey      = $($R1)
        Set SoftNetRuleKey      = $($R2)
        Set SoftServiceKey      = $($R3)
        Set SoftParameterKey    = $($R4)
        Set SoftLinkageKey      = $($R5)
        set NewValueList = {{SoftwareType,$(NoTitle),$(!REG_VT_SZ),$(SoftwareType)},+
               {MajorVersion,$(NoTitle),$(!REG_VT_DWORD),$(ProductMajorVersion)},+
               {MinorVersion,$(NoTitle),$(!REG_VT_DWORD),$(ProductMinorVersion)},+
               {Title,$(NoTitle),$(!REG_VT_SZ),$(ProductSoftwareTitle)},+
               {Description,$(NoTitle),$(!REG_VT_SZ),$(ProductSoftwareDescription)},+
               {ServiceName,$(NoTitle),$(!REG_VT_SZ),$(ProductSoftwareName)},+
               {InstallDate,$(NoTitle),$(!REG_VT_DWORD),*($(Now),1)}}
        Shell  $(UtilityInf), AddValueList, $(SoftProductKey), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            goto ShellCodeError
        endif
        set RegistryErrorIndex = $($R0)
        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            EndWait
            CloseRegKey $(SoftProductKey)
            CloseRegKey $(SoftNetRuleKey)
            CloseRegKey $(SoftServiceKey)
            CloseRegKey $(SoftParameterKey)
            CloseRegKey $(SoftLinkageKey)
            goto fatalregistry
        endif
        set NewValueList = {{type,$(NoTitle),$(!REG_VT_SZ),$(NetRuleSoftwareType)},+
                {use,$(NoTitle),$(!REG_VT_SZ),$(NetRuleSoftwareUse)}, +
                {bindform,$(NoTitle),$(!REG_VT_SZ),$(NetRuleSoftwareBindForm)}, +
                {class,$(NoTitle),$(!REG_VT_MULTI_SZ),$(NetRuleSoftwareClass)}, +
                {bindable,$(NoTitle),$(!REG_VT_MULTI_SZ),$(NetRuleSoftwareBindable)}, +
                {InfOption,$(NoTitle),$(!REG_VT_SZ),$(Option)}}
        Shell  $(UtilityInf), AddValueList, $(SoftNetRuleKey), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            goto ShellCodeError
        endif
        set RegistryErrorIndex = $($R0)
        CloseRegKey $(SoftProductKey)
        CloseRegKey $(SoftNetRuleKey)
        CloseRegKey $(SoftServiceKey)
        CloseRegKey $(SoftParameterKey)
        CloseRegKey $(SoftLinkageKey)
        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            EndWait
            goto fatalregistry
        endif
    endif ;; Does Services\AT2500 exist?

    set NTDetected = $(FALSE)

        Debug-Output "$(InfFile) $(Option): About to look for AT2500 PCI Cards"
        ;;
        ;; we must be installing a PCI card.
        ;;
        ;; Note: If we are are on WinNT v3.51 and above, we have PCI detection support
        ;; and are able to setup the adapter without user intervention. Otherwise, we can
        ;; only do one card at a time.
        ;;
        set TargetVersion = *($(CurrentVersionValue),4)
        Debug-Output "$(InfFile) $(Option): Current Version:"$(TargetVersion)

        ifstr $(TargetVersion) == $(NT350VersionConstant)   ;; We need to ask on v3.50
            Debug-Output "Running on WindowsNT 3.50"
            set Version350 = $(TRUE)
        else
            Debug-Output "Running on WindowsNT 3.51"
            set Version350 = $(FALSE)
        endif

        ifint $(Version350) == $(TRUE)
            Debug-Output "Running on WindowsNT v3.50, Not using PCI Detection!!!"
            ifstr $(!STF_GUI_UNATTENDED) == "YES"
                Debug-Output "$(InfFile) $(Option): Running in GUI unattended mode"
                ifstr(i) $(!AutoNetInterfaceType) != ""
                    set BusInterfaceType = $(!AutoNetInterfaceType)
                else
                    set BusInterfaceType = 5
                endif
                ifstr(i) $(!AutoNetBusNumber) != ""
                    set BusNumber = $(!AutoNetBusNumber)
                else
                    set BusNumber = 0
                endif
                set NTDetected = $(FALSE)
                set AdapterList = $(Option)   ;; 1 Item to install
                Debug-Output "$(InfFile) $(Option): BusInterfaceType = $(BusInterfaceType)"
                Debug-Output "$(InfFile) $(Option): BusNumber = $(BusNumber)"
            else
                Debug-Output "$(InfFile) $(Option): Running 3.50 Bus Dialog"
                set BusInterfaceType = 5
                set BusNumber = 0
                set NTDetected = $(FALSE)
                Shell $(UtilityInf),GetBusTypeDialog,$(ProductHardware$(Option)Description) $(BusInterfaceType) $(BusNumber)
                ifint $($ShellCode) != $(!SHELL_CODE_OK)
                    Debug-Output "ShellCode error."
                    goto ShellCodeError
                endif
                set BusInterfaceType = $($R1)
                set BusNumber = $($R2)
                set AdapterList = $(Option)   ;; 1 Item to install
                Debug-Output "$(InfFile) $(Option): BusInterfaceType = $(BusInterfaceType)"
                Debug-Output "$(InfFile) $(Option): BusNumber = $(BusNumber)"
            endif
        else
            Debug-Output "$(InfFile) $(Option): Running 3.51 using PCI Dectection"
            ;;
            ;; v3.51 has PCI detection code built in.
            ;;
            ;;set BusInterfaceType = 5
            ;;set BusNumber = 0
            ;; Shell $(UtilityInf),GetBusTypeDialog,$(ProductHardware$(Option)Description) $(BusInterfaceType) $(BusNumber)

            set NTDetected = $(TRUE)
            set VendorID = 4332       ;; 0x10EC is REALTEK's Vendor ID
            set DeviceID = 33081      ;; 0x8139 is AT2500's Device ID
            ;;set-div CFID = $($(Option)CFID) 1
            Debug-Output "$(InfFile) $(Option): VendorID = $(VendorID)"
            Debug-Output "$(InfFile) $(Option): DeviceID = $(DeviceID)"
            ;;Shell $(UtilityInf), GetPCIInformation, $(VendorID) $(CFID)
            Shell $(UtilityInf), GetPCIInformation, $(VendorID) $(DeviceID)
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                goto ShellCodeError
            endif
            ifstr(i) $($R0) == {}
                set Error = $(CANNOT_FIND_ANY_CARD)
                set CommonStatus = USER_CANCEL
                set from = end
                goto nonfatal
            endif
            set AdapterList = $($R0)
        endif   ;;; NT v3.50
    endif  ;;; Looking for PCI cards in Option.

    ; "AdapterList" has the list of currently installed adatpers in the system!
    ;
    Debug-Output "$(InfFile) $(Option): Adapterlist = $(AdatperList)"
    ForListDo $(AdapterList)
        Set InstallCard = "YES"
        ifint $(NTDetected) == $(TRUE)
            set DetectedBusNum = *($($),1)
            set DetectedSlotNum = *($($),2)
            Debug-Output "$(InfFile) $(Option): DetectedBusNumber = $(DetectedBusNum)"
            Debug-Output "$(InfFile) $(Option): DetectedSlotNum = $(DetectedSlotNum)"

            Shell $(UtilityInf), IsNetCardAlreadyInstalled, $(DetectedBusNum), +
            $(DetectedSlotNum), $(ProductHardware$(Option)Description), $(ProductHardwareName)

            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                goto ShellCodeError
            endif
            ifstr $($R0) != "NO_ERROR"
                set Error = $($R0)
                goto fatal
            endif
            ifstr(i) $($R1) == "YES"
                set InstallCard = "NO"  ;; Don't want to re-install, it's there already
            endif
        endif
        ;;
        ;; Are we installing the card?
        ;;
        ifstr(i) $(InstallCard) == "NO"
            Debug-Output "$(InfFile) $(Option): Card Already at $(DetectedBusNum):$(DetectedSlotNum) already installed!"
            set Error = "An adapter at $(DetectedBusNum):$(DetectedSlotNum) is already installed!"
            Shell $(subroutineinf) SetupMessage, $(!STF_LANGUAGE), $(Severity), $(Error)
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                goto ShellCodeError
            endif
        else
            Debug-Output "$(InfFile) $(Option): Installing Card at $(DetectedBusNum):$(DetectedSlotNum)!"
            Shell $(UtilityInf), AddHardwareComponent, $(ProductHardwareName),$(STF_CONTEXTINFNAME),$(ProductKeyName)
            ifint $($R4) != -1
                Set OEM_ABANDON_OPTIONS = >($(OEM_ABANDON_OPTIONS), $(!NTN_SoftwareBase)"\Microsoft\Windows NT\CurrentVersion\NetworkCards\"$($R4))
            endif
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                goto ShellCodeError
            endif
            set RegistryErrorIndex = $($R0)
            Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
                EndWait
                CloseRegKey $($R1)
                CloseRegKey $($R2)
                CloseRegKey $($R3)
                goto fatalregistry
            endif

            set EarlyTxThreshold = 09
            set DuplexModeValue = *($(DuplexModeValues), ~($(DuplexModeList),$(DuplexModeIndex)))

            ifstr(i) $(!STF_GUI_UNATTENDED) == "YES"   ; luke add1 unattend
                Debug-Output "$(InfFile) $(Option): Running in GUI unattended mode"
                ifstr(i) $(!AutoNetInterfaceType) != ""
                    set BusInterfaceType = $(!AutoNetInterfaceType)
                else
                    set BusInterfaceType = 5
                endif
                ifstr(i) $(!AutoNetBusNumber) != ""
                    set BusNumber = $(!AutoNetBusNumber)
                else
                    set BusNumber = 0
                endif
				goto skiplaa1
            endif
            read-syms FileDependentDlg$(!STF_LANGUAGE)
            SetHelpFile $(!STF_WINDOWSSYSPATH)"\"$(OptionHelpFile) $(MinHelpId) $(MaxHelpId) $(Help$(Option)Id)
            ;SetHelpFile $(!STF_WINDOWSSYSPATH)"\"At2500.hlp 10 30
            ui start "InputDlg"

            ifstr(i) $(DLGEVENT) == "CONTINUE"
               set DuplexModeIndex = $(Combo1Out)
               ui pop 1
            else-ifstr(i) $(DLGEVENT) == "BACK"
               set CommonStatus = STATUS_USERCANCEL
               ui pop 1
               goto end
            else
               ui pop 1
               goto end
            endif

            set DuplexModeValue = *($(DuplexModeValues), ~($(DuplexModeList),$(DuplexModeIndex)))

            set EtherID = ""
               ;;;;;;;;;;;;;;;;;;Ether ID;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                   read-syms NetworkAddressDlg$(!STF_LANGUAGE)
                   ui start "InputDlg"
                   ifstr(i) $(DLGEVENT) == "CONTINUE"
                               ;;set EtherID = $(EditTextOut)
                               
                               set NetworkAddress = $(EditTextOut)
                               ui pop 1
                   else-ifstr(i) $(DLGEVENT) == "EXIT"
                               ui pop 1
                   else
                               ui pop 1
                               goto end
                   endif


;            set EarlyTxThreshold = 09
                   read-syms EarlyTxThresholdDlg$(!STF_LANGUAGE)
                   ui start "InputDlg"
                   ifstr(i) $(DLGEVENT) == "CONTINUE"
                               set EarlyTxThreshold = $(EditTextOut)
                               ui pop 1
                   else-ifstr(i) $(DLGEVENT) == "EXIT"
                               ui pop 1
                   else
                               ui pop 1
                               goto end
                   endif
skiplaa1 =+
            Set HardNetCardKey      = $($R1)
            Set HardNetRuleKey      = $($R2)
            Set HardParameterKey    = $($R3)
            set AdapterNumber = $($R4)
            set NewValueList = {{Manufacturer,$(NoTitle),$(!REG_VT_SZ),$(Manufacturer)},+
                    {Title,$(NoTitle),$(!REG_VT_SZ),"["$($R4)"] "$(ProductHardware$(Option)Title)},+
                    {Description,$(NoTitle),$(!REG_VT_SZ),$(ProductHardware$(Option)Description)},+
                    {ProductName,$(NoTitle),$(!REG_VT_SZ),$(ProductHardwareName)},+
                    {ServiceName,$(NoTitle),$(!REG_VT_SZ),$($R5)},+
                    {InstallDate,$(NoTitle),$(!REG_VT_DWORD),*($(Now),1)}}
            Shell  $(UtilityInf), AddValueList, $(HardNetCardKey), $(NewValueList)
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                goto ShellCodeError
            endif

                ;
                ; PCI
                ;
                set BusTypeNum = 5
                set BusMaster = "YES"
                set Bus = "PCI"
                ifstr(i) $(Option) == "AT2500"
                    set CardType = 2
                else
                    set CardType = 0
                endif

            ;;
            ;; If we used the OS to dected the card, then we already know bus and slot information.
            ;;
            ifint $(NTDetected) == $(TRUE)
                set BusNumber = $(DetectedBusNum)
                set SlotNum = $(DetectedSlotNum)
                set BusInterfaceType = $(BusTypeNum)
                ;
                ; Note: we need to record SlotNumber too so that we can use the
                ; "IsNetCardAlreadyInstalled" routine
                ;
                Set NewValueList =  {+
                    {BusNumber,$(NoTitle),$(!REG_VT_DWORD),$(BusNumber)},+
                    {Slot,$(NoTitle),$(!REG_VT_DWORD),$(SlotNum)}+
                    }
                Debug-Output "$(InfFile) $(Option): Set HardwareParameterKey = $(NewValueList)"
                Shell  $(UtilityInf), AddValueList, $(HardParameterKey), $(NewValueList)
                ifint $($ShellCode) != $(!SHELL_CODE_OK)
                    goto ShellCodeError
                endif

                Set NewValueList = { {SlotNumber,$(NoTitle),$(!REG_VT_DWORD),$(SlotNum)} }
                Debug-Output "$(InfFile) $(Option): Set HardwareParameterKey = $(NewValueList)"
                Shell  $(UtilityInf), AddValueList, $(HardParameterKey), $(NewValueList)
                ifint $($ShellCode) != $(!SHELL_CODE_OK)
                    goto ShellCodeError
                endif
            else
                Set NewValueList =  {+
                    {BusNumber,$(NoTitle),$(!REG_VT_DWORD),$(BusNumber)},+
                    }
                Debug-Output "$(InfFile) $(Option): Set HardwareParameterKey = $(NewValueList)"
                Shell  $(UtilityInf), AddValueList, $(HardParameterKey), $(NewValueList)
                ifint $($ShellCode) != $(!SHELL_CODE_OK)
                    goto ShellCodeError
                endif
            endif

            Set NewValueList =  {+
                {BusType,$(NoTitle),$(!REG_VT_DWORD),$(BusInterfaceType)},+
                {CardType,$(NoTitle),$(!REG_VT_DWORD),$(CardType)},+
                {MediaType,$(NoTitle),$(!REG_VT_DWORD),1},+
                {AdapterCFID,$(NoTitle),$(!REG_VT_DWORD),$($(Option)CFID)},+
                }

            Debug-Output "$(InfFile) $(Option): Set HardwareParameterKey = $(NewValueList)"
            Shell  $(UtilityInf), AddValueList, $(HardParameterKey), $(NewValueList)
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                goto ShellCodeError
            endif

            set NewValueList = {{DuplexMode,$(NoTitle),$(!REG_VT_DWORD),$(DuplexModeValue)},+
                                {NetworkAddress,$(NoTitle),$(!REG_VT_SZ),$(NetworkAddress)},+
                                {EarlyTxThreshold,$(NoTitle),$(!REG_VT_DWORD),$(EarlyTxThreshold)}}
            Shell  $(UtilityInf), AddValueList, $(HardParameterKey), $(NewValueList)

		    ifstr(i) $(!STF_GUI_UNATTENDED) == "YES"  ; luke add2	Input parameter
		        Shell $(UtilityInf),AddDefaultNetCardParameters,$(HardParameterKey)
		    endif
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
               goto ShellCodeError
            endif
            set TempProdName = """"$(ProductHardwareName)$(AdapterNumber)""""
            set TempBindForm = $(TempProdName)$(NetRuleHardwareBindForm)
            set NewValueList = {{type,$(NoTitle),$(!REG_VT_SZ),$(NetRuleHardware$(Option)Type)},+
                    {bindform,$(NoTitle),$(!REG_VT_SZ),$(TempBindForm)}, +
                    {class,$(NoTitle),$(!REG_VT_MULTI_SZ),$(NetRuleHardware$(Option)Class)}, +
                    {InfOption,$(NoTitle),$(!REG_VT_SZ),$(Option)}}

            Debug-Output "$(InfFile) $(Option): HardwareRuleKey = $(NewValueList)"
            Shell  $(UtilityInf), AddValueList, $(HardNetRuleKey), $(NewValueList)
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                goto ShellCodeError
            endif
            CloseRegKey $(HardNetCardKey)
            CloseRegKey $(HardNetRuleKey)
            CloseRegKey $(HardParameterKey)
        endif
    EndForListDo
    EndWait
    goto successful

updateparameters =+
    Debug-Output "$(InfFile) $(Option): Updateparameters"
    set HardParameterKey    = $($R3)

    set NewValueList = {{DuplexMode,$(NoTitle),$(!REG_VT_DWORD),$(DuplexModeValue)},+
                        {NetworkAddress,$(NoTitle),$(!REG_VT_SZ),$(NetworkAddress)},+
                        {EarlyTxThreshold,$(NoTitle),$(!REG_VT_DWORD),$(EarlyTxThreshold)}}

    Shell  $(UtilityInf), AddValueList, $(KeyParameters), $(NewValueList)

    ifstr(i) $(!STF_GUI_UNATTENDED) == "YES"  ; luke add2	Input parameter
        Shell $(UtilityInf),AddDefaultNetCardParameters,$(HardParameterKey)
    endif
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
    goto ShellCodeError
    endif
    CloseRegKey $(KeyParameters)
    goto successful

bindingadapter =+
    Debug-Output "$(InfFile) $(Option): bindingadapter"
    set Error = "Binding: Sorry, not yet implemented."
    goto fatal

removeadapter = +
    Debug-Output "$(InfFile) $(Option): removeadapter"
    Debug-Output "$(InfFile) $(Option): ----> $(ProductKeyName), $(!NTN_RegBase)"
    Ifstr(i) $(ProductKeyName) == $(!NTN_RegBase)
        Shell $(UtilityInf), RemoveSoftwareComponent, $(Manufacturer), +
        $(ProductSoftwareName)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto ShellCodeError
        endif
        set RegistryErrorIndex = $($R0)
    Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
        goto fatalregistry
    endif
    else
    Shell $(UtilityInf), RemoveHardwareComponent, $(Manufacturer), +
        $(ProductSoftwareName), $(!NTN_RegBase)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto ShellCodeError
    endif
    set RegistryErrorIndex = $($R0)
    Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
        goto fatalregistry
    endif
    endif
    goto end

UpgradeSoftware = +
    Debug-Output "$(InfFile) $(Option): UpdateSoftware"
     OpenRegKey $(!REG_H_LOCAL) "" $(ProductKeyName) $(MAXIMUM_ALLOWED) KeyProduct
     Ifstr $(KeyProduct) != $(KeyNull)
       Shell $(UtilityInf), GetInfFileNameFromRegistry, $(KeyProduct)
       ifint $($ShellCode) != $(!SHELL_CODE_OK)
           Debug-Output "ShellCode error"
           goto ShellCodeError
       endif
       set !UG_Filename = $($R0)
       install "Install-Update"
       ifstr(i) $(STF_INSTALL_OUTCOME) != STF_SUCCESS
           goto fatal
       endif
       SetRegValue $(KeyProduct) {MajorVersion,$(NoTitle),$(!REG_VT_SZ),$(ProductMajorVersion)}
       SetRegValue $(KeyProduct) {MinorVersion,$(NoTitle),$(!REG_VT_SZ),$(ProductMinorVersion)}
       CloseRegKey $(KeyProduct)
     else
       goto fatalregistry
     endif
     goto end

successful = +
    Debug-Output "$(InfFile) $(Option): Successful"
    goto end

abandon = +
    Debug-Output "$(InfFile) $(Option): Abandon"
    ForListDo $(OEM_ABANDON_OPTIONS)
    Shell $(UtilityInf), RemoveHardwareComponent, $(Manufacturer), +
        $(ProductSoftwareName), $($)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto ShellCodeError
    endif
    set RegistryErrorIndex = $($R0)
    Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
        goto fatalregistry
    endif
    EndForListDo
    Ifstr(i) $(OEM_ABANDON_SOFTWARE) == TRUE
    Shell $(UtilityInf), RemoveSoftwareComponent, $(Manufacturer), +
        $(ProductSoftwareName), FALSE
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto ShellCodeError
    endif
    set RegistryErrorIndex = $($R0)
    Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
        goto fatalregistry
    endif
    endif
    goto end

warning = +
    Debug-Output "$(InfFile) $(Option): warning"
    Shell $(subroutineinf) SetupMessage, $(!STF_LANGUAGE), "WARNING", $(Error)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
    goto ShellCodeError
    endif
    ifstr(i) $($R1) == "OK"
    goto $(to)
    else-ifstr(i) $($R1) == "CANCEL"
    goto $(from)
    else
    goto "end"
    endif

nonfatalinfo = +
    Debug-Output "$(InfFile) $(Option): nonfatalinfo"
    Set CommonStatus = STATUS_USERCANCEL
    Set Severity = STATUS
    goto nonfatalmsg

nonfatal = +
    Debug-Output "$(InfFile) $(Option): nonfatal"
    Set Severity = NONFATAL
    goto nonfatalmsg

nonfatalmsg = +
    Debug-Output "$(InfFile) $(Option): nonfatalmsg"
    ifstr(i) $(Error) == ""
    Set Severity = NONFATAL
    Shell $(UtilityInf) RegistryErrorString "SETUP_FAIL"
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto ShellCodeError
    endif
    set Error = $($R0)
    endif
    Shell $(subroutineinf) SetupMessage, $(!STF_LANGUAGE), $(Severity), $(Error)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
    goto ShellCodeError
    endif
    ifstr(i) $($R1) == "OK"
    goto $(from)
    else
    ;   goto "end"
    goto "RemoveAdapter"
    endif

fatalregistry = +
    Debug-Output "$(InfFile) $(Option): fatalregistry"
    Shell $(UtilityInf) RegistryErrorString $(RegistryErrorIndex)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
    goto ShellCodeError
    endif
    set Error = $($R0)
    goto fatal

fatal = +
    Debug-Output "$(InfFile) $(Option): fatal"
    ifstr(i) $(Error) == ""
    Shell $(UtilityInf) RegistryErrorString "SETUP_FAIL"
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto ShellCodeError
    endif
    set Error = $($R0)
    endif
    Shell $(subroutineinf) SetupMessage, $(!STF_LANGUAGE), "FATAL", $(Error)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
    goto ShellCodeError
    endif
    goto setfailed

ShellCodeError = +
    Debug-Output "$(InfFile) $(Option): ShellCodeError"
    set DlgType      = "MessageBox"
    set STF_MB_TITLE = $(ShellCodeErrorTitle)
    set STF_MB_TEXT  = $(ShellCodeErrorText)
    set STF_MB_TYPE  = 1
    set STF_MB_ICON  = 3
    set STF_MB_DEF   = 1
    ui start "Error Message"
    goto setfailed

setfailed = +
    Debug-Output "$(InfFile) $(Option): Setfailed"
    set CommonStatus = STATUS_FAILED
    ifstr(i) $(OEM_ABANDON_ON) == TRUE
    set OEM_ABANDON_ON = FALSE
    goto abandon
    endif
    goto end

end = +
    goto term

term = +
    Return $(CommonStatus)

[Install-Option]
    set STF_VITAL = ""
    ifstr(i) $(AddCopy) == "YES"
    AddSectionFilesToCopyList Files-$(Option) $(SrcDir) $(!STF_WINDOWSSYSPATH)\drivers
    endif
    ifstr(i) $(DoCopy) == "YES"
       set !STF_NCPA_FLUSH_COPYLIST = TRUE
       CopyFilesInCopyList
    endif
    Exit

[Install-Hlp]
   set STF_VITAL = ""
   AddSectionFilesToCopyList Files-Hlp $(SrcDir)  $(!STF_WINDOWSSYSPATH)
   set !STF_NCPA_FLUSH_COPYLIST = TRUE
   CopyFilesInCopyList
   Exit

[Install-Update]
   set STF_VITAL        = ""
   set STF_OVERWRITE    = "VERIFYSOURCEOLDER"
   AddSectionFilesToCopyList Files-Hlp $(SrcDir) $(!STF_WINDOWSSYSPATH)
   AddSectionFilesToCopyList Files-Inf $(SrcDir) $(!STF_WINDOWSSYSPATH)
   AddSectionFilesToCopyList Files-$(Option) $(SrcDir) $(!STF_WINDOWSSYSPATH)\drivers
   set !STF_NCPA_FLUSH_COPYLIST = TRUE
   CopyFilesInCopyList
   exit

[Source Media Descriptions]
     1 = "Allied Telesyn AT-2500TX CardAsistant Disk"

[ProductType]
STF_PRODUCT  = Winnt
STF_PLATFORM = I386

[Files-Inf]
1,      oemsetnt.inf,    SIZE=1000,     RENAME=$(!UG_Filename)

[Files-Hlp]
1, AT2500.HLP , SIZE=10000

;
; Driver files
;
[Files-AT2500]
1,a25v3m4.SYS , SIZE=50000

[LanguagesSupported]
    ENG

[OptionsTextENG]
    AT2500     = "Allied Telesyn AT-2500TX PCI 10/100 Ethernet Adapter"

[FileConstantsENG]
    ProCaption   = "Windows NT Setup"
    ProCancel    = "Cancel"
    ProCancelMsg = "Windows NT Networking is not correctly installed. "+
                   "Are you sure you want to cancel copying files?"
    ProCancelCap = "Network Setup Message"
    ProText1     = "Copying:"
    ProText2     = "To:"

DuplexModeList  = ^(DuplexModeDlg, 1)
DuplexModeValues = ^(DuplexModeDlg, 2)
NoList  = ^(NoChoices, 1)
NoValues = ^(NoChoices, 2)
ShellCodeErrorTitle = "Error: "$(Function$(Option)Title)
ShellCodeErrorText      = "Shell Code Error."
CANNOT_FIND_ANY_CARD    = "The AT-2500TX is not present in the system"

[DialogConstantsENG]
Help        = "&Help"
Exit        = "Cancel"
OK          = "OK"
;HelpContext = ""
Continue    = "Continue"
Cancel      = "Cancel"

[FileDependentDlgENG]
DlgText = "Choose the Duplex Mode from the pull-down list."$(!LF)
          
Combo1Label = "Speed/Duplex Setting: "

DlgTemplate = "ADAP_PROTO_COMBO"
DlgType = "Combination"
;Caption = $(Function$(Option)Title)
Caption = "Duplex Mode "
Combo1List = $(DuplexModeList)
Combo1Out  = $(DuplexModeValue)
ComboListItemsIn  = {Combo1List}
ComboListItemsOut = {Combo1Out}
EditTextLim = ""
CBOptionsGreyed = {}
MinHelpId = 10
MaxHelpId = 40
;HelpContext = $(Help$(Option)Id)
HelpContext = 20

[DuplexModeDlg]
    DuplexMode_0 = "Use Hardware Settings (SETUP25)", 0
    DuplexMode_1 = "Auto-Sense", 1
    DuplexMode_2 = "10Mb / Half Duplex", 2
    DuplexMode_3 = "10Mb / Full Duplex", 3
    DuplexMode_4 = "100Mb / Half Duplex", 4
    DuplexMode_5 = "100Mb / Full Duplex", 5

[NetworkAddressDlgENG]
Caption        = "Network Address (LAA)"
DlgText        = "This option is only required when you need to "+
                 "override the factory-programmed MAC address"
Edit1Label     = "&Network Address:"
Continue       = "&OK"
Exit           = "&Skip"
Help           = "&Help"
DlgType        = "Edit"
DlgTemplate    = "QUERY_COMPUTER_NAME"
EditTextLim    = 17
EditTextIn     = $(NetworkAddress)
EditFocus      = "ALL"
HelpContext    = 30

[EarlyTxThresholdDlgENG]
Caption        = "Early TX Threshold"
DlgText        = "Value range: 0 - 3f (hex)"
Edit1Label     = "&Threshold Value:"
Continue       = "&OK"
Exit           = "&Skip"
Help           = "&Help"
DlgType        = "Edit"
DlgTemplate    = "QUERY_COMPUTER_NAME"
EditTextLim    = 2
EditTextIn     = $(EarlyTxThreshold)
EditFocus      = "ALL"
HelpContext    = 40


