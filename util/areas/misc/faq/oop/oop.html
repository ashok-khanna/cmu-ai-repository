Newsgroups: comp.object,comp.answers,news.answers
From: Bob Hathaway <rjh@geodesic.com>
Subject: Comp.Object FAQ Version 1.0.5 (12-13) Announcement
Followup-To: comp.object
Summary: Frequently Asked Questions (FAQ) List and Available Systems For Object-Oriented Technology
Organization: Geodesic Systems
Approved: news-answers-request@MIT.Edu

Archive-name: object-faq/announce
Last-Modified: 12/13/93
Version: 1.0.5

This announces the December version 1.0.5 of the Comp.Object FAQ!  It has many
updates and corrections and has several very up-to-date appendices on object-
oriented methodologies and systems.  While a new section on miscellaneous
commercial systems and libraries is still in the works for completeness, this
document may very well comprise the latest and most up-to-date collection of
object-oriented systems and terms in the world today!  There is also a
potential upcoming merge with the new C++ Libraries FAQ.

New noteworthy additions are the OO methodologies and OOA/OOD sections and ever
expanding appendices.  Future FAQs will contain a diff file.  The FAQ is
updated and posted monthly.  Comments, suggestions, additions, updates, and new
systems and site entries should be sent to rjh@geodesic.com.  

The FAQ is posted to the comp.object, comp.answers and news.answers newsgroups
and is available via anonymous ftp from zaphod.uchicago.edu and rtfm.mit.edu,
although new versions may take a short period of time to be installed.

Anonymous FTP Sites and Hypertext Server:
  anonymous@zaphod.uchicago.edu:/pub/comp.object-faq.1.0.5(.Z) (128.135.72.61)
  anonymous@rtfm.mit.edu:/pub/usenet/comp.object/*_Part_*
  http://cui_www.unige.ch/OSG/FAQ/OO-FAQ/index.html

Mail Server:  (See also section 1.24)
  mail mail-server@rtfm.mit.edu
  Subject:
  send usenet/comp.object/*

Zaphod is preferred over rtfm for anonymous ftp retrieval, as it provides a
single file.  Rtfm contains the FAQ as posted.

To use the hypertext system, see APPENDIX E, entries 27.

Again, a short period of time may be required to retrieve the latest version,
allowing the posted version to propagate and get out as quickly as possible.

Thank you to the many people who have contributed their time and effort into
helping this document spread the word about object-oriented technology and
available systems!  It is hoped it will be most useful in that endeavor.

Best Regards!
bob
COMP.OBJECT FAQ
Version: 1.0.5
Date:    12/13/1993


Author:
  Bob Hathaway
  Geodesic Systems
  rjh@geodesic.com


Anonymous FTP Sites and Hypertext Server:
  anonymous@zaphod.uchicago.edu:/pub/comp.object-faq.1.0.5(.Z) (128.135.72.61)
  anonymous@rtfm.mit.edu:/pub/usenet/comp.object/*_Part_*
  http://cui_www.unige.ch/OSG/FAQ/OO-FAQ/index.html

Mail Server:  (See also section 1.24)
  mail mail-server@rtfm.mit.edu
  Subject:
  send usenet/comp.object/*

Zaphod is preferred over rtfm for anonymous ftp retrieval, as it provides a
single file.  Rtfm contains the FAQ as posted.

To use the hypertext system, see APPENDIX E, entries 27.
There is currently no comp.object archive.


Copyright 1992-1994  Bob Hathaway
All rights reserved.

Permission is granted to freely copy and distribute this document but only at
no cost to others and with the exception of a nominal distribution fee, if
any.  No sale, resale or reprinting is granted without the explicit written
permission of the author.

Contributors:  Per Abrahamsen, Stewart Clamen, Edwardo Casais, Dennis De
  Champeaux, Mike DeVaney, Eric Dujardin, Piercarlo Grandi, Brian Henderson-
  Sellers, Urs Hoelzle, Paul Johnson, Bill Kinnersley, James Odell, Eoin Woods
  and many others whose contributions have helped this document to fulfull its
  objective of bringing object-oriented concepts and systems to everyone.

Objective:
  In the spirit of other FAQs, to provide a simple document to answer the most
  frequently asked and recurring questions and to allow new users to understand
  frequently discussed topics and terms used in comp.object.   This should
  bring new comp.object readers and/or writers to at least an introductory
  level of comprehension as soon as possible.  Other goals (hopes) are to
  provide a quick and current reference on available systems such as object-
  oriented languages, CASE, OODB and etc. and to provide good references to
  current and relevant OO systems, groups, texts and literature.

Disclaimer:
  This document does not necessarily reflect the opinions of the author's or
  any contributor's companies.  There are no explicit or implicit guarantees
  implied by this document.

While object systems are a constantly changing and moving target with a broad
diversity of often conflicting methodologies, constructs, terminologies,
approaches, languages, implementations and etc. and comp.object has a wide
diversity of readers and writers ranging from students, professors and
researchers in academia to beginners, professionals, top-notch experts and
leaders in industry with a broad range of experience and backgrounds ranging
across many paradigms, this FAQ can certainly not aspire to satisfy all of them
completely but instead attempts to provide the most well-rounded treatment of
object-oriented concepts and realizations primarily from the mainstream and
popular authors and systems and further to provide a collection of available
systems and tools in the appendices.

It should be understood that it is not possible to present a complete,
unbiased, and perfect document on the subject to be everything to all
people; however, herein lies at least one effort to provide a reasonable
compromise.

Several improvements are planned for future FAQs, including a glossary.


SECTION 1:  BASICS
  1.1)  What Is An Object?
  1.2)  What Is Object Encapsulation (Or Protection)?
  1.3)  What Is A Class?
  1.4)  What Is A Meta-Class?
  1.5)  What Is The Infinite Regress Of Objects And Classes?
  1.6)  What are MOPs and Reflection?
  1.7)  What Is Inheritance?
  1.8)  What Is Multiple Inheritance?
  1.9)  Does Multiple Inheritance Pose Any Additional Difficulties?
  1.10) What Is Dynamic Inheritance?
  1.11) What Is Shared (Repeated) Inheritance?
  1.12) Why Use Inheritance?
  1.13) Why Don't Some People Like Inheritance?
  1.14) What Is Specialization/Generalization/Overriding?
  1.15) What Is The Difference Between Object-Based And Object-Oriented?
  1.16) Is A Class An Object?
  1.17) Is An Object A Class?
  1.18) What Is A Method? (And Receiver And Message)
  1.19) What Are Multi-Methods And Multiple-Polymorphism?
  1.20) What Is OOP?
  1.21) What Is OOA/OOD (And Where Can I Get What I Need On It)?
  1.22) Where Did Object-Orientation Come From?
  1.23) What Are The Benefits Of Object-Orientation?
  1.24) What Other FAQs Are available?

SECTION 2:  TYPING
  2.1)  What Is Polymorphism?
  2.2)  What Does Polymorphism Boil Down To In OO Programming Languages?
  2.3)  What Is Dynamic Binding?
  2.4)  Is There A Difference Between Being A Member Or Instance Of A Class?
  2.5)  What Is This I Read About ML And Functional Programming Languages?
  2.6)  What Is the Difference Between Static And Dynamic Typing?
  2.7)  What Is A Separation Between Type And Class (Representation)?
  2.8)  What Are Generics And Templates?

SECTION 3:  GENERAL
  3.1)  What Is The "Classical" Object-Oriented Paradigm?
  3.2)  What Is The "Delegation/Prototyping" Object-Oriented Paradigm?
  3.3)  Are There Any Other Object-Oriented Paradigms?
  3.4)  What Are The Major Object-Oriented Programming Languages Today?
  3.5)  What Are Object-Oriented Databases And Persistence?
  3.6)  What Are Object-Oriented Operating Systems?
  3.7)  What Are The Current Object-Oriented Methodologies?
  3.8)  What Is The OMG/OMA/ORB/CORBA?
  3.9)  Why Is Garbage Collection A Good Thing?
  3.10) What Can I Do To Teach OO To The Kids?
  3.11) What Is Available On Object-Oriented Testing?
  3.12) What Distributed Systems Are Available?
  3.13) What Is The MVC Framework?
  3.14) What is Real-Time?

SECTION 4:  COMMONLY ASKED LANGUAGE SPECIFIC QUESTIONS
  4.1)  What Is Downcasting?
  4.2)  What Are Virtual Functions?
  4.3)  Can I Use Multiple-Polymorphism Or Multi-Methods In C++?
  4.4)  Can I Use Dynamic Inheritance In C++?

ANNOTATED BIBLIOGRAPHY

APPENDIXES
  APPENDIX A  VIPS
  APPENDIX B  OBJECT-ORIENTED DATABASES AND VENDORS
  APPENDIX C  OBJECT-ORIENTED LANGUAGES AND VENDORS
  APPENDIX D  OBJECT-ORIENTED CASE (OOA/D/P TOOLS) AND VENDORS
  APPENDIX E  ANONYMOUS FTP SITES
  APPENDIX F  MAGAZINES, JOURNALS AND NEWSLETTERS

[Another appendix on miscellaneous commercial object-oriented systems should
 be added soon for completeness]


SECTION 1:  BASICS
==================

Suggested Readings:
  [Booch 91, 94]
  Others to be added...


1.1) What Is An Object?
-----------------------

There are many definitions of an object, such as found in [Booch 91, p77]:
"An object has state, behavior, and identity; the structure and behavior of
similar objects are defined in their common class; the terms instance and
object are interchangeable".  This is a "classical languages" definition, as
defined in [Coplien 92, p280], where "classes play a central role in the
object model", since they do not in prototyping/delegation languages.  
"The term object was first formally applied in the Simula language, and
objects typically existed in Simula programs to simulate some aspect of
reality" [Booch 91, p77].  Other definitions referenced by Booch include
Smith and Tockey: "an object represents an individual, identifiable item,
unit, or entity, either real or abstract, with a well-defined role in the
problem domain." and [Cox 91]: "anything with a crisply defined boundary"
(in context, this is "outside the computer domain".  A more conventional
definition appears on pg 54).  Booch goes on to describe these definitions
in depth.  [Martin 92, p 241] defines: "An "object" is anything to which a
concept applies", and "A concept is an idea or notion we share that applies
to certain objects in our awareness".  [Rumbaugh 91] defines: "We define an
object as a concept, abstraction or thing with crisp boundaries and meaning for
the problem at hand." [Shlaer 88, p 14] defines: "An object is an abstraction
of a set of real-world things such that:
  * all of the real-world things in the set - the instances - have the same
    characteristics
  * all instances are subject to and conform to the same rules"
and on identifying objects: "What are the *things* in this problem?  Most of
the things are likely to fall into the following five categories: Tangible
things, Roles, Incidents, Interactions, and Specifications."  [Booch 91, 4.3]
covers "Identifying Key Abstractions" for objects and classes based on an
understanding of the problem domain and [Jacobson 92] provides a novel approach
to identifying objects through use-cases.

The implementation of objects could roughly be categorized into descriptor-
based, capability-based, and simple static-based approaches.  Descriptor-
based approaches (e.g. Smalltalk handles) allow powerful dynamic typing, as
do the capability-based approaches which are typically found in object-
oriented databases and operating systems (object id's).  A "proxy" based
approach with an added layer of indirection to Smalltalk's handles is found
in Distributed Smalltalk which allows transparent, distributed, and migrating
objects [Kim 89, ch 19 and Yaoqing 93].  Simple static approaches are found
in languages such as C++, although the new RTTI facility will supply simple
dynamic typing, which is also present in new versions of Eiffel.

Descriptor-based approaches can have pointer semantics and can be statically
typeless (or just "typeless", as in Smalltalk) where references (variables)
have no type, but the objects (values) they point to always do.  An untyped
pointer (such as void* in C++) and an embedded dynamic typing scheme are used
in more conventional languages to fully emulate this style of dynamically typed
programming (see sections 2.3, 4.3, and [Coplien 92]).

Below is a simple example to show a most trivial case of OO implementation.
It is primarily intended to introduce new terms.  See [Cardelli 85] for
another semantic definition of OO using functions for methods and for
a view of types as sets of values.

Simple statically-typed objects (static and auto vars and temps in C++ and
expanded types in Eiffel) can be viewed as instances of a record type,
whose record fields are called instance variables (Smalltalk) or member data
(C++).  The record (class) may also contain operations which are called
methods (Smalltalk) or member functions (C++) which are equivalent to a
function taking an object of the record type, called the receiver, as the
first parameter.  The receiver is called self (Smalltalk) or this (C++).
Members will denote both instance variables and methods.  Inheritance is
roughly equivalent to a loosely coupled variant record, with derived classes
as variant parts and with multiple-inheritance concatenating several records
to serve as a base.

A virtual member in statically typed languages is a base class member that can
be set or respecified by a derived class.  This is roughly equivalent to a
pointer or function pointer in the base class being set by the derived class.
[Stroustrup 90] covers the implementation details of virtual member functions
in C++, which also involve an offset for the receiver to handle multiple-
inheritance.  This is an example of dynamic binding, which replaces a
switch statement on variant parts with a single call, reducing code size
and program complexity (fewer nested programming constructs) and allowing
variants to be added without modifying client code (which causes higher defect
injection rates during maintanance and debugging).

Virtual members in dynamically typed languages are more flexible because
static typechecking requirements are dropped.  See section 2.5.

The terms method/member function, instance variable/member data, subclass/
derived class, parent class/base class, and etc. will be used interchangeably.
As pointed out in [Stroustrup 90, p197], the base/derived class terminology
may be preferable to the sub/super-class terminology, and is preferred in
this document also.

Delegation/prototyping languages [Kim 89, ch3; Ungar 87, Sciore 89] have a more
flexible kind of object which can play the role of classes in classical OO
languages.  Since there is no separate class construct in these languages, and
only objects, they are referred to as single-hierarchy, or 1 Level systems.
Objects contain fields, methods and delegates (pseudo parents), whereas
classical object-oriented languages associate method, field and parent
definitions with classes (and only associate state and class with objects,
although vtables of function pointers for dynamic binding is an exception).
However, one-level objects often play the role of classes to take advantage of
sharing and often instances will simply delegate to parents to access methods
or shared state, otherwise idiosyncratic objects, a powerful and natural
concept, will result.  Typical 1 Level objects can contain any number of
fields, methods and parents and any object can be used as a template/exemplar,
thus performing the classical role of a class.  In typical prototyping systems,
parents (as any other member) can be added or changed dynamically, providing
dynamic multiple inheritance (or more typically simple delegation).  Here, the
term "Prototype" usually refers to prototype theory, a recent theory of
classification where any object can be inherited from or cloned to serve as a
prototype for newly created instances.  [The Author also uses the term for
languages providing high quality support for rapid prototyping, although this
usage is atypical]  See [Booch 94, pp 154-155] for a brief discussion of
prototype theory in the context of OOA and OOD.

It is common in such systems for an object to "become" another kind of object
by changing its parent.  A good example is a window becoming an icon, since
window and icon objects display different behavior (although cognitive
differences are significant too:-)  Delegation refers to delegating the
search for an attribute to a delegate, and is therefore more of a pure
message passing mechanism (as with dynamic scoping) than inheritance, which
also typically specifies non-shared state when used for representation.

Chambers has proposed an interesting variation called "Predicate Classes"
[Chambers 93] as a part of his Cecil language.  These classes will only be
parents when certain predicates are true.  This can support a types/classes
as collections of objects view, which is the same as the types as sets of
values view taken by [Cardelli 85].  [Martin 92] provides some examples of
this view applied during OOA.

1 level systems therefore provide the most flexible and powerful capabilities.
Self is a good example of a delegation-based single hierarchy language [Ungar
87].


1.2)  What Is Object Encapsulation (Or Protection)?
---------------------------------------------------

[Booch 91, p. 45] defines: "Encapsulation is the process of hiding all of the
details of an object that do not contribute to its essential characteristics."

[Coad 91, 1.1.2] defines: "Encapsulation (Information Hiding).  A principle,
used when developing an overall program structure, that each component of a 
program should encapsulate or hide a single design decision...  The interface
to each module is defined in such a way as to reveal as little as possible
about its inner workings.  [Oxford, 1986]"

Some languages permit arbitrary access to objects and allow methods to be
defined outside of a class as in conventional programming.  Simula and
Object Pascal provide no protection for objects, meaning instance variables
may be accessed wherever visible.  CLOS and Ada allow methods to be defined
outside of a class, providing functions and procedures.  While both CLOS
and Ada have packages for encapsulation, CLOS's are optional while Ada's
methodology clearly specifies class-like encapsulation (Adts).

However most object-oriented languages provide a well defined interface to
their objects thru classes.  C++ has a very general encapsulation/protection
mechanism with public, private and protected members.  Public members (member
data and member functions) may be accessed from anywhere.  A Stack's Push and
Pop methods will be public.  Private members are only accessible from within
a class.  A Stack's representation, such as a list or array, will usually be
private.  Protected members are accessible from within a class and also from
within subclasses (also called derived classes).  A Stack's representation
could be declared protected allowing subclass access.  C++ also allows a
class to specify friends (other (sub)classes and functions), that can access
all members (its representation).  Eiffel 3.0 allows exporting access to
specific classes.

For another example, Smalltalk's class instance variables are not accessible
from outside of their class (they are not only private, but invisible).
Smalltalk's methods are all public (can be invoked from anywhere), but a
private specifier indicates methods should not be used from outside of the
class.  All Smalltalk instance variables can be accessed by subclasses, 
helping with abstract classes and overriding.

Another issue is per-object or per-class protection.  Per-class protection
is most common (e.g. Ada, C++, Eiffel), where class methods can access any
object of that class and not just the receiver.  Methods can only access the
receiver in per-object protection.  This supports a subtyping model, as any
object other than the receiver is only satisfying an abstract type interface,
whereby no method or object structure can be inferred in the general case.


1.3  What Is A Class?
--------------------

A class is a general term denoting classification and also has a new meaning
in object-oriented methods.  Within the OO context, a class is a specification
of structure (instance variables), behavior (methods), and inheritance
(parents, or recursive structure and behavior) for objects.  As pointed out
above, classes can also specify access permissions for clients and derived
classes, visibility and member lookup resolution.  This is a feature-based or
intensional definition, emphasizing a class as a descriptor/constructor of
objects (as opposed to a collection of objects, as with the more classical
extensional view, which may begin the analysis process).

Original Aristotlean classification defines a "class" as a generalization of
objects:
[Booch 91, p93]
  "a group, set, or kind marked by common attributes or a common attribute; a
   group division, distinction, or rating based on quality, degree of
   competence, or condition".
   
[Booch's definition in the context of OOD]
  "A class is a set of objects that share a common structure and a common
  behavior."  "A single object is simply an instance of a class."

The intension of a class is its semantics and its extension is its instances
[Martin 92].

[Booch 94, 4.2] proposes 3 views of classification as useful in OO analysis and
design: classical categorization (common properties), conceptual clustering
(conceptual descriptions), and prototype theory (resemblance to an exemplar).
He advocates starting with the former approach, turning to the second approach
upon unsatisfactory results, and finally the latter if the first two approaches
fail to suffice.


1.4)  What Is A Meta-Class?
---------------------------

[See also section 1.6]
 
A Meta-Class is a class' class.  If a class is an object, then that object
must have a class (in classical OO anyway).  Compilers provide an easy way to
picture Meta-Classes.  Classes must be implemented in some way; perhaps with
dictionaries for methods, instances, and parents and methods to perform all
the work of being a class.  This can be declared in a class named "Meta-Class".
The Meta-Class can also provide services to application programs, such as
returning a set of all methods, instances or parents for review (or even
modification).  [Booch 91, p 119] provides another example in Smalltalk with
timers.  In Smalltalk, the situation is more complex.  To make this easy, refer
to the following listing, which is based on the number of levels of distinct
instantiations:

1 Level System
  All objects can be viewed as classes and all classes can be viewed as
  objects (as in Self).  There is no need for Meta-Classes because objects
  describe themselves.  Also called "single-hierarchy" systems.
  There is only 1 kind of object.
2 Level System
  All Objects are instances of a Class but Classes are not accessible to
  programs (no Meta-Class except for in the compiler and perhaps for type-safe
  linkage, as in C++).
  There are 2 kinds of distinct objects: objects and classes.
3 Level System
  All objects are instances of a class and all classes are instances of
  Meta-Class.  The Meta-Class is a class and is therefore an instance of
  itself (really making this a 3 1/2 Level System).  This allows classes to
  be first class objects and therefore classes are available to programs.
  There are 2 kinds of distinct objects (objects and classes), with a
  distinguished class, the metaclass.
5 Level System
  What Smalltalk provides.  Like a 3 Level System, but there is an extra level
  of specialized Meta-Classes for classes.  There is still a Meta-Class as in 
  a 3 Level System, but as a class it also has a specialized Meta-Class, the
  "Meta-Class class" and this results in a 5 Level System: 
    object
    class
    class class (Smalltalk's Meta-Classes)
    Meta-Class
    Meta-Class class

  The "class class"es handle messages to classes, such as constructors and
  "new", and also "class variables" (a term from Smalltalk), which are
  variables shared between all instances of a class (static member data in
  C++).  There are 3 distinct kinds of objects (objects, classes, and
  metaclasses).


1.5)  What Is The Infinite Regress Of Objects And Classes?
----------------------------------------------------------

In the authors opinion, a myth.  The story goes an object is an instance of a
class (Meta-Object), a class is an instance of a Meta-Class, which must also
be an instance of a Meta-Meta-Class, which must also be an instance of a Meta-
Meta-Meta-Class, ...  Closure can be achieved with an instance-of loop, as with
a Meta-Class being an instance of itself or with a "Meta-Class - Meta-Class
class" instance-of loop (as in Smalltalk).


1.6)  What Are MOPs And Reflection?
-----------------------------------

MOP is an acronym for Meta-Object Protocol.  This is a system with
Meta-Classes accessible to users [Kiczales 92].  In CLOS terminology, an
introspective protocol provides a read only capability (e.g. what is this
object's class, give info on this class, etc.) and an intercessory protocol
provides a write capability which allows system modification (e.g. add the
following method or instance to this class, perform inheritance this way,
etc.).  Because inheritance can be used to perform differential changes,
intercessory protocols allow users to not only define new frameworks but
to specialize existing system frameworks differentially without affecting
them and their extant objects.  Thus, many frameworks can interoperate
together simultaneously.  This is a good example of object-oriented reuse,
since the compiler itself is reused thru specialization to provide new
frameworks.

"Reflective" systems are systems with MOPs (not to be confused with reflexive
systems, which often refer to systems implemented in terms of themselves, or
bootstrapped).  Reflective systems are inevitably reflexive (as are most
quality compilers), providing a direct program interface to the system.


1.7)  What Is Inheritance?
--------------------------

Inheritance provides a natural classification for kinds of objects and allows
for the commonality of objects to be explicitly taken advantage of in modeling
and constructing object systems.  See the example below using computers.

Inheritance is a relationship between classes where one class is the parent
(base/superclass/ancestor/etc.) class of another.  Inheritance provides
programming by extension (as opposed to programming by reinvention
[LaLonde 90]) and can be used as an is-a-kind-of (or is-a) relationship or
for differential programming.  Inheritance can also double for assignment
compatibility (see section 2.7).

In delegation languages, such as Self, inheritance is delegation where objects
refer to other objects to respond to messages (environment) and do not
respecify state by default.

Inherited parents can specify various flavors of state.  Delegation languages
don't specify new state by default (to do so requires cloning), C-based (C++,
Eiffel, Objective-C, etc.), lisp-based (CLOS, Flavors, Scheme, etc.), and
Pascal-based (Ada-9x, Modula-3, Object Pascal, etc.) OO languages do, but with
multiple-inheritance can also share parents within a class lattice (CLOS and
Eiffel provide this as a default at the level of slots and features,
respectively).

Inheritance also provides for member lookup, or internal environment.  Various
schemes exist, for example C++ finds the closest match within a scope but
causes an ambiguity error iff more than one parent has match, CLOS creates
a linear precedence list, Self provides parent priorities, and Eiffel forces
renaming for any parent member conflicts.

Defining inheritance (with a thorough description or denotational semantic
definition, or both) can avoid confusion about which inheritance scheme is
being used (especially in OOD), because inheritance has many variations and
combinations of state and environment (sometimes with complex rules).
Inheritance can also be used for typing, where a type or class can be used to
specify required attributes of a matching object (see sections 2.1, 2.7 and
[Cardelli 85]).  It would be more judicious to have discussions on how
inheritance should be defined instead of over what it is, since it has many
existing uses and semantics.

An example of the is-a-kind-of relationship is shown below.  Is-a is often
used synonymously, but can be used to show the "object is-a class"
instantiation relationship.  In classical OO, inheritance is a relationship
between classes only.  In one-level systems, is-a (object instantiation) and
is-a-kind-of (inheritance) are merged into one [Ungar 87, Madsen 93, Sciore
89].

                               Computer
                              /    |     \
                       Mainframe  Mini    Personal
                        /    \    ...       /   \
                  Data Proc  Scientific   PC    Workstation

Class hierarchies are subjective [Booch 91, 4.2; Lakoff 87] and usually drawn
with the parent class on top, but more demanding graphs (as is often the case
in [Rumbaugh 91]) allow any topology, with the head of an arrow indicating the
base class and the tail indicating the derived class.

Differential programming is the use of inheritance to reuse existing classes
by making a small change to a class.  Creating a subclass to alter a method
or to add a method to a parent class is an example.


1.8)  What Is Multiple Inheritance?
-----------------------------------

Multiple Inheritance occurs when a class inherits from more than one parent.
For example, a person is a mammal and an intellectual_entity, and a document
may be an editable_item and a kind of literature.

Mixin's is a style of MI (from flavors) where a class is created to provide
additional attributes or properties to other classes.  They are intended to be
inherited by any class requiring them.  Method combination, or calling
sequences of before, after, and around methods or even several primary methods
[Kim 89, ch 4], make good use of mixins by invoking their methods without
explicitly calling them, allowing client class code to remain unchanged [Booch
91, p 113].


1.9)  Does Multiple Inheritance Pose Any Additional Difficulties?
-----------------------------------------------------------------

Yes, it does.  Any name can be simply resolved to a class member with single
inheritance by simply accessing the first name encountered for data members
and by accessing the first signature match (or ambiguity) encountered for
methods (at least one way, C++ hides some member functions).  Since several
distinct parents can declare a member within a multiple inheritance hierarchy,
which to choose becomes an issue.  Eiffel forces derived classes to rename
parent members that conflict.  Self prioritizes parents.  CLOS merges member
"slots" (instance variables) with the same name into a single slot, as did
the earlier flavors.  C++ declares an error iff a conflict arises, but a
class qualifier can be used to explicitly disambiguate.  Smalltalk renders
same names for instance variables of subclasses illegal.

On the other hand, multiple-inheritance can be seen as required for basic
object-oriented programming, because many objects in the real world belong to
several classes.  In classical systems without MI, a class which should inherit
from more than one class must textually include all but one of those classes in
its interface, causing code duplication (and a messy interface).


1.10)  What Is Dynamic Inheritance?
-----------------------------------

Dynamic inheritance allows objects to change and evolve over time.  Since base
classes provide properties and attributes for objects, changing base classes
changes the properties and attributes of a class.  A previous example was a
window changing into an icon and then back again, which involves changing a
base class between a window and icon class.

More specifically, dynamic inheritance refers to the ability to add, delete,
or change parents from objects (or classes) at run-time.  Actors, CLOS, and
Smalltalk provide dynamic inheritance in some form or other.  Single hierarchy
systems, such as Self, provide dynamic inheritance in the form of delegation
[Ungar 87].

See also [Kim 89, chs 1, 3] for a discussion and [Coplien 92] for some
implementation discussion in C++.


1.11)  What Is Shared (Repeated) Inheritance?
---------------------------------------------

Multiple Inheritance brings up the possibility for a class to appear as a
parent more than once in a class graph (repeated inheritance), and there is
then a potential to share that class.  Only one instance of the class will
then appear in the graph (as is always the case in CLOS, because all *members*
with the same name will be shared (receive a single slot) with the greatest
common subtype as its type).  C++ provides an alternative, where only parents
specified as virtual (virtual bases) are shared within the same class lattice,
allowing both shared and non-shared occurrences of a parent to coexist.  All
"features" in Eiffel (C++ members) of a repeated parent that are not to be
shared must be renamed "along an inheritance path", else they are shared by
default.  This allows a finer granularity of control and consistent name
resolution but requires more work for parents with many features.


1.12)  Why Use Inheritance?
---------------------------

Inheritance is a natural way to model the world or a domain of discourse,
and so provides a natural model for OOA and OOD (and even OOP).  This is
common in the AI domain, where semantic nets use inheritance to understand
the world by using classes and concepts for generalization and categorization,
by reducing the real-world's inherent complexity.

Inheritance also provides for code and structural reuse.  In the above Computer
class diagram, all routines and structure available in class Computer are
available to all subclasses throughout the diagram.  All attributes available
in Personal computers are also available to all of its subclasses.  This kind
of reuse takes advantage of the is-a-kind-of relationship.  Class libraries
also allow reuse between applications, potentially allowing order-of-magnitude
increases in productivity and reductions in defect rates (program errors),
as library classes have already been tested and further use provides further
testing providing even greater reliability.

With differential programming, a class does not have to be modified if it is
close to what's required; a derived class can be created to specialize it.
This avoids code redundancy, since code would have to be copied and modified
otherwise.  See [Raj 89] for an alternative approach as found in Jade.

Polymorphism is often explicitly available in many OO languages (such as C++,
CLOS, Eiffel, etc.) based on inheritance when type and class are bound together
(typing based on subclassing, or subclass polymorphism), since only an object
which is a member of (inherits from) a class is polymorphically assignment
compatible with (can be used in place of) instances or references of that
class.  Such assignment can result in the loss of an object's dynamic type in
favor of a static type (or even loss of an object's representation to that of
the static class, as in C++ slicing).  Maintaining the dynamic type of objects
can be provided (and preferred); however, C++ provides both sliced and non-
sliced replacement in a statically typed environment (see section 2.1).


1.13)  Why Don't Some People Like Inheritance?
----------------------------------------------

Some people complain that inheritance is hierarchical (which is what most
object-oriented languages provide).  They would also like to see more
operations available (set operations are quite common in specialized systems).
The former is a kind of language dependent feature commonly found in object-
oriented languages which are then associated with the term "inheritance"
(although they don't need to be.  For example, delegation languages allow graph
inheritance stuctures).  Some don't like the coupling of classes (as in Jade),
but in the author's opinion many of their complaints are easily answered.  In
systems that provide inheritance, inheritance provides a simple and elegant way
to reuse code and to model the real world in a meaningful way.

Others complain multiple inheritance is too complicated because it brings up
the issues of shared bases and member conflict resolution.  But most modern
systems support Multiple Inheritance by employing semantic resolution
strategies or renaming, and most consider MI to be highly desirable.  See the
latter part of section 1.9 for an example of why MI is important.

Some prefer association to MI, claiming "roles" (as defined in [Rumbaugh 91])
should be associations and inheritance should be reserved for a single
hierarchy "creation" mechanism, however this loses polymorphism and loses the
use of inheritance for typical classification.  Representation "roles" can be
supported by dynamic multiple inheritance (DMI) in many situations.


1.14)  What Is Specialization/Generalization/Overriding?
--------------------------------------------------------

To create a subclass is specialization, to factor out common parts of
derived classes into a common base (or parent) is generalization [Booch 91,
p56].  Overriding is the term used in Smalltalk and C++ for redefining a
(virtual in Simula and C++) method in a derived class, thus providing
specialized behavior.  All routines in Smalltalk and Eiffel are overridable
(although in Eiffel they must be "redefined" in a derived class).  Whenever
a method is invoked on an object of the base class, the derived class method
is executed overriding the base class method, if any.  Overriding in Simula
is a combination of overloading and multiple-polymorphism because parameters do
not have to be declared.  Eiffel and Beta are examples of languages allowing
any member to be redefined and not just methods, as is typical.


1.15)  What Is The Difference Between Object-Based And Object-Oriented?
-----------------------------------------------------------------------

Object-Based Programming usually refers to objects without inheritance
[Cardelli 85] and hence without polymorphism, as in '83 Ada and Modula-2.
These languages support abstract data types (Adts) and not classes, which
provide inheritance and polymorphism.  Ada-9x and Modula-3; however, support
both inheritance and polymorphism and are object-oriented.  [Cardelli 85, p481]
state "that a language is object-oriented if and only if it satisfies the
following requirements:

  - It supports objects that are data abstractions with an interface of named
    operations and a hidden local state.
  - Objects have an associated type.
  - Types may inherit attributes from supertypes.

  object-oriented = data abstractions + object types + type inheritance

These definitions are also found in [Booch 91, Ch2 and Wegner 87].

[Coad 91] provides another model:

  Object-Oriented = Classes and Objects 
                    + Inheritance 
                    + Communication with messages

Stroustrup's first edition of [Stroustrup 91, '86 p. 37] defines object based
as: "... storing type identification in each object, brings us to a style of
programming often referred to as "object based"", which is quite different
from C+W's.

A more modern definition of "object-oriented" includes single-hierarchy
languages and perhaps object id's for unique objects.  Object id's support the
modern notion of relocatable, persistent and distributed objects that can
even migrate across machines.  Distributed Smalltalk's proxy objects [Kim 89,
ch 19 and Yaoqing 93] provide another example of a distributable and migratable
object facility.  Separate type system support is another extension.

[Booch 94, 2.2] proposes 7 "Elements of the Object Model"; 4 major and 3 minor:
  Major:
    Abstraction
    Encapsulation
    Modularity
    Hierarchy  (Inheritance)
  Minor:
    Typing
    Concurrency
    Persistence


1.16)  Is A Class An Object?
----------------------------

In C++ no, because C++ classes are not instances of an accessible class (a
Meta-Class) and because C++ classes are not accessible to programs.  Classes
are objects in 3 Level Systems and above because classes are instances of
meta-classes.  But classes play a dual role, because objects can only be
declared to be instances of a class (and class objects instances of a
meta-class).  In 1 Level (single-hierarchy) systems, all classes are objects.


1.17)  Is An Object A Class?
----------------------------

In a Level 3 System and above yes, but only instances of a Meta-Class are
Classes.  Instances of a Class (ordinary objects) are not classes (excluding
hybrid systems).  However, all objects may be classes in single hierarchy
systems, since any object may act as a class (provide object instantiation or
act as a shared parent).


1.18)  What Is A Method? (And Receiver And Message)
---------------------------------------------------

A method implements behavior, which is defined by [Booch 91, p80]:

  Behavior is how an object acts and reacts, in terms of its state changes
  and message passing.

A method is a function or procedure which is defined in a class and typically
can access the internal state of an object of that class to perform some
operation.  It can be thought of as a procedure with the first parameter as
the object to work on.  This object is called the receiver, which is the object
the method operates on.  An exception exists with C++'s static member functions
which do not have a receiver, or "this" pointer.  The following are some common
notations for invoking a method, and this invocation can be called a message
(or message passing, see below):

  receiver.message_name(a1, a2, a3)   
  receiver message_name: a1 parm1: a2 parm3: a3

Selector would be another good choice for message_name in the above examples,
although keywords (or formal parameter names, like named parameters) are
considered part of the selector in Smalltalk (and hence Objective-C).

If done statically, this can be referred to as invocation, and message passing
if done dynamically (true dynamic binding).  Statically typed dynamic binding
(e.g. C++ and Eiffel) is really in between (checked function pointers).

See also section 1.19 below for a discussion on the functional (prefix) verses
message based (receiver based) notation.


1.19)  What Are Multi-Methods And Multiple-Polymorphism?
--------------------------------------------------------

Multi-methods involve two primary concepts, multiple-polymorphism and lack of
encapsulation.  These issues are orthogonal.  Multiple-polymorphism implies
more than one parameter can be used in the selection of a method.  Lack of
encapsulation implies all arguments can be accessed by a multi-method (although
packages can be used to restrict access, as in CLOS).  Multi-methods can also
imply a functional prefix notation, although the CLOS designers (who coined the
term "multi-method") consider the functional and receiver based forms
(messages) equivalent.  Functional syntax was chosen "in order to minimize the
number of new mechanisms added to COMMON LISP" [Kim ch 4, p70 (D. Moon)].
[Chambers 93] discusses multi-methods in his new OO language, Cecil.

Multiple-polymorphism allows specialized functions or methods to be defined to
handle various cases:

  +(int, int)
  +(int, float)
  +(int, complex)
  +(int, real)
  +(float, complex)
  +(float, real)
  +(float, float)

The above functions are specialized to each of the cases required allowing
single, highly cohesive and loosely coupled functions to be defined.  This is
also the true essence of object-oriented polymorphism, which allows objects to
define methods for each specific case desired.  In addition to better coupling
and cohesion, multiple-polymorphism reduces program complexity by avoiding
coding logic (switch statements) and because small methods further reduce
complexity, as code complexity doesn't grow linearly with lines of code per
method, but perhaps exponentially.  This should be distinguished from double
dispatch, a fancy name for single dispatch after a call, which only provides
switching on a single argument per call (but for 2 levels), consistently
ignoring the inherent type of parameters in messaging.  Double dispatch is
used in languages with static typing for efficiency considerations.

If all of the above types are Numbers, code can be written without concern for
the actual classes of objects present:

  fn(one, two: Number): Number
    return one + two;

The addition expression above will invoke the correct "+" function based on the
inherent (true, actual, or dynamic) types of one and two.  Only the inherent
type of "one" would be used with double dispatch!  In the author's opinion,
this is a serious shortcoming.  Further, double dispatch would only allow
switching to the "fn" function based on the type of "one" also.  This could
lead to the use of switch statements based on type or complex coding in many
real-world programming situations, unnecessarily.  In the author's opinion,
this should only be used as necessary, e.g. if the implementation language
doesn't support multiple-polymorphism and either efficiency considerations
dominate and double dispatch can be suffered, or an embedded dynamic typing
scheme is used.

Why do multi-methods allow open access to parameters?  It allows for efficient
handling, like C++ friends, usually by allowing representation details of more
than one object to be exposed.  See [Kim ch 4, pp70-71 (D. Moon)] for an
alternative explanation.  While open access can be useful in some cases, it
typically isn't recommended as a general OO practise (see section 1.15, C+W's
requirement 1 for OO languages) and also violates subtype polymorphism, because
only subclass polymorphism is based on representation and not type.

Polymorphic languages can be statically typed to provide strong type checking,
efficiency, and to support a static programming idiom, but require restrictions
in many cases, such as requiring overriding methods to have identical
signatures with the methods they substitute (as in C++) or allowing covariant
parameters but limiting base class usage (as in Eiffel).  If these restrictions
are dropped, multiple-polymorphism results.  Thus a single overridable function
declared in a base class may have several functions overriding it in a derived
class differentiated only by their formal argument types.  This therefore
requires both static and dynamic typing, because no formal argument
differentiation is possible without static types, as in Smalltalk, and no
actual argument differentiation is possible without dynamic types (as in C++
and Eiffel).  See section 2.3 for another example of multiple-polymorphism.

There is some concern about the efficiency of run-time method selection as
can occur with multiple-polymorphism (or even dynamic message passing).
However, static analysis optimizations are commonly available in the
literature, potentially providing a single static selection in many cases
[See Agrawal 91, Chambers 92, Mugridge 91, and etc.].

But coupling the two cases of selector variables (as found in CLOS,
Objective-C, and etc.) and several possible known selectors together with the
general undecidability of dynamic types at compile-time renders dynamic typing
and run-time selection (or checking) as unavoidable in the general case [a
point often mistaken in comp.object.  E.g. simple statically/strongly typed
multi-methods still require dynamic types!]

See [Booch 91], multiple-polymorphism, for a good CLOS example.


1.20)  What Is OOP?
-------------------

OOP stands for Object-Oriented Programming, the usual programming/hacking and
etc. most programmers think of.  Modern software engineering methodologies;
however, consider OOP as the implementation/evolution of an OOD.


1.21)  What Is OOA/OOD (And Where Can I Get What I Need On It)?
---------------------------------------------------------------

  See also section 3.7, the Annotated Bibliography, and APPENDIX D.  The
  classified bibliography in [Booch 94] also contains entries on OOA(B), OOD(F)
  and OOP(G).

[Booch 91]
  "In OOA, we seek to model the world by identifying the classes and objects
  that form the vocabulary of the problem domain, and in OOD, we invent the
  abstractions and mechanisms that provide the behavior that this model
  requires."

[Coad 91]
  "OOA is the challenge of understanding the problem domain, and then the
  system's responsibilities in that light".
  "To us, analysis is the study of a problem domain, leading to a specification
  of externally observable behavior; a complete, consistent, and feasible
  statement of what is needed; a coverage of both functional and quantified
  operational characteristics (e.g. reliability, availability, performance)".
  "Design.  The practise of taking a specification of externally available
  behavior and adding details needed for actual computer system implementation,
  including human interaction, task management, and data management details."

And on Domain Analysis:

  "Whereas OOA typically focuses upon one specific problem at a time, domain
   analysis seeks to identify the classes and objects that are common to all
   applications within a given domain, [...]".  - [Booch 91]

  [The following quotes on domain analysis are from [Berard 93]]

  "An investigation of a specific application area that seeks to identify the
   operations, objects, and structures that commonly occur in software systems
   within this area.  - Dan McNicholl

  "Systems analysis states what is done for a specific problem in a domain
   while domain analysis states what can be done in a range of problems in a
   domain.  ...A domain analysis is only useful in many similar systems are to
   be built so that the cost of the domain analysis can be amortized over the
   cost of all the systems.

   The key to reusable software is captured in domain analysis in that it
   stresses the reusability of analysis and design, not code. - Jim Neighbors

  "The process of identifying, collecting, organizing, and representing the
  relevant information in a domain based on the study of existing systems and
  their development histories, knowledge captured from domain experts,
  underlying theory, and emerging technology within the domain."  - Kang et al.

  Object-oriented domain analysis (OODA) seeks to identify reusable items
  localized around objects, e.g., classes, instances, systems of interacting
  objects, and kits [frameworks]. OORA analysts and OOD designers will
  interact on a fairly frequent basis with the domain analysis effort.


OOA and OOD stand for Object-Oriented Analysis and Object-Oriented Design,
respectively.  OOA strives to understand and model, in terms of object-oriented
concepts (objects and classes), a particular problem within a problem domain
(from its requirements, domain and environment) from a user-oriented or domain
expert's perspective and with an emphasis on modeling the real-world (the
system and its context/(user-)environment).  The product, or resultant model,
of OOA specifies a complete system and a complete set of requirements and
external interface of the system to be built.

[Shlaer 88] is often credited as the first book on OOA, although their method
adds OO techniques to the traditional structured analysis principles of Yourdon
and Constantine. Their complete approach ([Shlaer 88, 92]) consists of
information modeling and recursive design, or OOA/RD and represents a recent
addition to the structured analysis family (as does Martin and Odell).
[Yourdon 92] provides a critique, although may only refer to their earlier
work.  Many other methodologies including Rumbaugh's OMT, Martin and Odell's
OOA/D, and many others, also share common ground with SA and other existing
analysis methodologies with such constructs as associations (E-R), functional
models, and even DFD's.  Booch, Jacobson, and Wirfs-Brock are examples of OO
methodologies representing a greater departure from the conventional
"structured" techniques, with greater emphasis on objects.  OOram [Reenskaug
 91] provides support and emphasis on types and roles as guiding principles,
which is quite powerful.  [Booch 94] presents a methodology which is an
evolutionary step beyond the first edition by incorporating a collection of the
best features from several of the major OO methodologies, as does HP's new
FUSION methodology.

The usual progression is from OOA to OOD to OOP (implementation) and this
Universal Process Model roughly corresponds to the Waterfall Model [Royce 70].
See [Humphrey 89] and [Yourdon 92] for a few of many discussions on software
life-cycle models and their use.  Humphrey also details Worldy and Atomic
Process Models for finer grained analysis and design in the Defined Process
(see below) and discusses other alternatives to the task oriented models.  He
also provides the following critisisms on the Waterfall Model which had led to
Boehm's seminal work on the Spiral Model:

  * It does not adequately address changes
  * It assumes a relatively uniform and orderly sequence of development steps
  * It does not provide for such methods as rapid prototyping or advanced
    languages

Modern OO methodologies directly address these points and emphasize the
incremental, iterative, evolutionary, concurrent and situational nature of
software development.  [Boehm 86] presents a seminal spiral life-cycle model
with a risk-driven prototyping approach.  [Booch 91, 6.1] proposes a "round-
trip gestalt" design with analyze-design iterations and an overall system
perspective and [Berard 93] proposes an (incremental) "parallel-recursive
design" with analyze-design-implement-test iterations.  [Coad 91b] presents
the following development cycle breakdown:

  Waterfall-
    Analysis
    Design
    Programming

  Spiral-
    Analysis, prototyping, risk management
    Design, prototyping, risk management
    Programming, prototyping, risk management
    [Boehm, 1988]  

  Incremental-
    A little analysis
    A little design
    A little programming
    Repeat
    [Gilb, 1988]

[Author's note: The spiral model may be incremental in many ways and ends with
 a waterfall.]

Since classes and objects are used in all phases of the OO software life-cycle,
the process is often referred to as seamless, meaning there is no conceptual
gap between the phases as is often the case in other software development
methodologies, such as the analysis (DFD's) to design (structure charts) to
programming gaps found in traditional structured analysis and design.
Seamlessness together with naturalness is a big advantage for consistency.

A problem domain has many realizations, or differing OOAs.  An OOA has many
realizations, or differing OODs, but a similar notation is often used for
the two.  An OOD also has many realizations, or differing OOPs, but allows a
selection from among various languages for implementation (choosing the best
language to implement the design).  But some, such as Bjarne Stroustrup, don't
like OOA and OOD getting too far from OOP (implementation independent), for
fear that great discrepancies could occur between OOD and OOP by losing sight
of the implementation language, which in some cases is predetermined.  See also
[Stroustrup 91].

From a greater perspective, the SEI has developed the Software Process Maturity
Model (SPMM), a 5 level model classifying the progressive levels of an
organization's software development [Humphrey 89].

 Level 1: Initial:    Every project is handled differently
 Level 2: Repeatable: Every project is handled similarly
 Level 3: Defined:    A standard process is now well defined for all projects
 Level 4: Managed:    A measurable basis for all improvements to the process
 Level 5: Optimizing: Emphasis on defect prevention and optimizing/continually
                      improving the process

See also [Yourdon 92], [Wilkie 93], and [Booch 94] for discussions on this
often cited model.  There is also an ISO 9000 standard on software quality.

Object-Oriented Information Engineering's "Enterprise Modeling" [Martin 92],
also found in [Jacobson 92], and some recent business "reengineering" efforts
place information systems within an organizational perspective by modeling
entire organizations or a large part of them, with the information processing
system and software products development as integrated components.  [Yourdon
92] even calls for "global modeling"!


1.22)  Where Did Object-Orientation Come From?
----------------------------------------------

Simula was the first object-oriented language providing objects, classes,
inheritance, and dynamic typing in 1967 (in addition to its Algol-60 subset).
It was intended as a conveyance of object-oriented design.  Simula 1 was a
simulation language, and the later general-purpose language Simula 67 is now
referred to as simply Simula.  Smalltalk was the next major contributor
including classes, inheritance, a high-powered graphical environment and a
powerful dynamic typing mechanism (although these existed to some extent in
Simula).  Self is somewhat of a Smalltalk-based next generation language, as is
Beta a followup to Simula (by its original designers).

[Meyer 88] contains a brief summary and history of Simula and Smalltalk, among
other OO languages.


1.23)  What Are The Benefits Of Object-Orientation?
---------------------------------------------------

Reuse, quality, an emphasis on modeling the real world (or a "stronger
equivalence" with the RW than other methodologies), a consistent and seamless
OOA/OOD/OOP package, naturalness (our "object concept") and etc.

[Harmon 93]:
  Faster development
  Increased Quality
  Easier maintenance
  Enhanced modifiability

[Booch 94]:
  Exploit power of OOPs
  Reuse of software and designs, frameworks
  Systems more change resilient, evolvable
  Reduced development risks for complex systems, integration spread out
  Appeals to human cognition, naturalness


1.24)  What Other FAQs Are Available?
-------------------------------------

FAQ's are cross-posted to news.answers and are archived on anonymous ftp from:

  rtfm.mit.edu:/pub/usenet		(also usenet-by-hierarchy, etc.)

rtfm archives several FAQs pertinent to OO (most are also archived elsewhere):

  comp.lang.ada         ajpo.sei.cmu.edu:public/comp-lang-ada/cla-faq[12]
  comp.lang.c++         sun.soe.clarkson.edu:pub/C++/FAQ [128.153.12.3]
  comp.lang.clos
  comp.lang.eiffel      ftp.cm.cf.ac.uk:/pub/eiffel/eiffel-faq
  comp.lang.oberon
  comp.lang.objective-c
  comp.lang.sather      ftp.ICSI.Berkeley.EDU:pub/sather [not on rtfm]
  comp.lang.scheme      ftp.think.com:/public/think/lisp/scheme-faq.text
  comp.lang.smalltalk   xcf.Berkeley.EDU:misc/smalltalk/FAQ/SmalltalkFAQ.entire
  comp.object           zaphod.uchicago.edu:/pub/comp.object-faq.1.0.5(.Z)
  comp.object.logic     ftp.cs.cmu.edu:*prg_1.faq,prg_2.faq  [128.2.206.173]
  comp.software-eng

  [xcf.Berkeley.EDU is 128.32.138.1]
  * /afs/cs.cmu.edu/project/ai-repository/ai/pubs/faqs/prolog/

A new C++ libraries FAQ is posted monthly to comp.lang.c++ and should be on
rtfm soon.  Contact cpplibs@trmphrst.demon.co.uk.  It contains anonymous ftp
sites and commercial libraries and may be merged with this FAQ soon.

Many FAQs are also available from mail-servers, however most can be accessed by
the rtfm mail-server.  Mail to mail-server@rtfm.mit.edu with help and index in
the body with no leading spaces and on separate lines for more information.

Example Unix Command (will retrieve this FAQ in about 26 pieces (and growing)):
  mail mail-server@rtfm.mit.edu
  Subject:
  send usenet/comp.object/*

There is also a great ftp site for sci.virtual-worlds on:
  stein.u.washington.edu (140.142.56.1)
          - home of sci.virtual-worlds, huge faq w/ great info!
          - if unable to use try ftp.u.washington.edu
          /public/virtual-worlds

[While vr may not be directly related to comp.object, it is most interesting!
   - The Author]


SECTION 2:  TYPING
==================

There are many definitions of type (and class and related concepts).  Many
authors define the terms as applied by their particular approach or language,
however we shall proceed in the face of this diversity.

  References
    [Blair 89]          Some typing topics.
    [Booch 91]          Small Section on Typing.
    [Cardelli 85]       Discussion on Object-Oriented Typing.
    [Kim 89, ch1]       Discussion on Some Research Topics.


2.1)  What Is Polymorphism?
---------------------------

Polymorphism is a ubiquitous concept in object-oriented programming and is
defined in many ways, so many definitions are presented from: Websters',
Author, Strachey, Cardelli and Wegner, Booch, Meyer, Stroustrup, and Rumbaugh.
Polymorphism is often considered the most powerful facility of an OOPL.

> Webster's New World Dictionary:

Polymorphism 1. State or condition of being polymorphous.  2. Cryall.
  crystallization into 2 or more chemically identical but
  crystallographically distinct forms.  3.  Zool., Bot. existence of an
  animal or plant in several forms or color varieties.

polymorphous adj. having, assuming, or passing through many or various forms,
  stages, or the like.  Also, polymorphic. [<Gk polymorphous multiform]


> Author's Definition:

Polymorphism is the ability of an object (or reference) to assume (be replaced
by) or become many different forms of object.  Inheritance (or delegation)
specifies slightly different or additional structure or behavior for an object,
and these more specific or additional attributes of an object of a base class
(or type) when assuming or becoming an object of a derived class characterizes
object-oriented polymorphism.  This is a special case of parametric
polymorphism, which allows an object (or reference) to assume or become any
object (possibly satisfying some implicit or explicit type constraints
(parametric type), or a common structure), with this common structure being
provided by base classes or types (subclass and subtype polymorphism,
respectively).

"Poly" means "many" and "morph" means "form".  The homograph polymorphism has
many uses in the sciences, all referring to objects that can take on or assume
many different forms.  Computer Science refers to Strachey's original
definitions of polymorphism, as divided into two major forms, parametric and
ad-hoc.  Cardelli and Wegner followup with another classification scheme,
adding inclusion polymorphism for subtyping and inheritance.


> Strachey's Original Definition [Strachey 67]:

"Parametric polymorphism is obtained when a function works uniformly on a range
of types; these types normally exhibit some common structure.  Ad-hoc
polymorphism is obtained when a function works, or appears to work, on several
different types (which may not exhibit a common structure) and may behave in
unrelated ways for each type."  

Parametric polymorphism is also referred to as "true" polymorphism, whereas
ad-hoc polymorphism isn't (apparent polymorphism).


> Cardelli and Wegner's Definition [Cardelli 85]:

C+W refine Strachey's definition by adding "inclusion polymorphism" to model
subtypes and subclasses (inheritance).  Strachey's parametric polymorphism is
divided into parametric and inclusion polymorphism, which are closely related,
but separated to draw a clear distinction between the two forms, which are then
joined as specializations of the new "Universal" polymorphism.

                                 |-- parametric
                 |-- universal --|
                 |               |-- inclusion
  polymorphism --|
                 |               |-- overloading
                 |-- ad hoc    --|
                                 |-- coercion

Polymorphic Languages: some values and variables may have more than one type.

Polymorphic Functions: functions whose operands (actual parameters) can
  have more than one type.  [...] If we consider a generic function to be
  a value, it has many functional types and is therefore polymorphic.

Polymorphic Types: types whose operations are applicable to operands of more
  than one type.

Parametric Polymorphism: a polymorphic function has an implicit or explicit
  type parameter which determines the type of the argument for each
  application of that function.

Inclusion Polymorphism: an object can be viewed as belonging to many different
  classes that need not be disjoint; that is, there may be inclusion of
  classes.

The two forms of "Universal Polymorphism", parametric and inclusion are closely
related, but are distinct enough in implementation to justify separate
classifications.

Parametric polymorphism is referred to as generics.  Generics can be syntactic,
where each instantiation creates a specialized version of the code allowing
fast running execution, but in a "true polymorphic system", only a single
implementation is used.

On inheritance is subtype polymorphism:
"Subtyping on record types corresponds to the concept of inheritance
(subclass) in languages, especially if records are allowed to have functional
components."

Author's Notes:
Implicit parametric polymorphism can be implemented with type inferencing
schemes [Aho 85].  ML is prototypical in providing this facility.

Inclusion polymorphism is common and is found in languages such as Simula,
Ada-9x, C++, CLOS, Eiffel and etc. (subclass polymorphism).  Smalltalk also
uses inclusion polymorphism; its used in declaring classes, and subclass
polymorphism is used in practice but not enforced.  For inheritance, inclusion
polymorphism specifies an instance of a subclass can appear wherever an
instance of a superclass is required.  For subtyping (subtype polymorphism),
the same applies because all operations required by the supertype are present
in the subtype (subtype is subset of supertype).  Cardelli and Wegner view
classes as sets of objects (resulting in subtype objects are a subset of
supertype objects, or an extentional view), as contrasted with a feature based
(intentional) approach (where subtypes are supersets of (contain) supertypes).
MI provides an interesting example here, as it is set intersection with an
extensional view and set union with an intentional view.  Details are left as
an exercise for the reader.

Ada generics and C++ templates provide explicit syntactic generics.  While
Ada may infer some actual generic parameters (operations) and C++ doesn't
require explicit instantiation of its template functions, formal generic
parameters must still be declared and many bodies are generated.

Inclusion polymorphism can refer to subtyping, or having at least as much or
more than required.  Since derived classes can inherit structure and behavior
from base classes, such inheritance is an example of inclusion polymorphism
with respect to representation (subclassing).  An example of inclusion
polymorphism with respect to assignment (and initialization, or replacement if
viewed in an almost symbolic way) occurs when object types may be specified and
assignment is based on actual object membership in that type (often of the CLOS
is-a-member-of form in OO).  Emerald provides another example of an object-
oriented language using inclusion polymorphism with respect to replacement;
however, inclusion is with respect to subtyping only with abstract types
("bounded quantification" by C+W.  C+W's parameters are subtype polymorphic
but lose the inherent type).  Any object possessing all required operations is
acceptable and no inheritance relation is required (subtype polymorphism).
They refer to this as "best-fitting" types [Black 86].  The original Trellis/
Owl also had such a facility but with two separate inheritance hierarchies,
although it was abandoned in favor of a single class-based approach for
simplicity.  See also section 2.7.

[As inclusion polymorphism covers both subtype and subclass polymorphism,
 perhaps IP could be further divided in C+W's above classification.]


> Booch's Definition [Booch 91, p. 517]:

polymorphism  A concept in type theory, according to which a name (such as a
variable declaration) may denote objects of many different classes that are
related by some common superclass; thus, any object denoted by this name is
able to respond to some common set of operations in different ways.

Booch also has several sections devoted to polymorphism.

[The author notes Booch's definition above is clearly in the context of
 conventional, classical OO and subclass polymorphism.]


> Meyer's Definition [Meyer 88, sect. 10.1.5 Polymorphism]:

"Polymorphism" means the ability to take several forms.  In object-oriented
programming, this refers to the ability of an entity to refer at run-time to
instances of various classes.  In a typed environment such as Eiffel, this is
constrained by inheritance: ...

[The Author notes Meyer has a following section 10.1.7 on Static Type,
 dynamic type, which is relevant, but claims "... there is no way the type
 of an object can ever change.  Only a reference can be polymorphic: ...".
 Meyer is clear between the concept and the Eiffel realization in his
 polymorphism definition above, but here neglects the "becomes" facility
 as found in several dynamically typed OO languages such as Actors, CLOS,
 Self and Smalltalk, which allows an object (and not just a reference) to
 change its class.]


> Stroustrup's Definition [Stroustrup 90, p. 209]:

The use of derived classes and virtual functions is often called "object-
oriented programming".  Furthermore, the ability to call a variety of
functions using exactly the same interface - as is provided by virtual
functions - is sometimes called "polymorphism".

[The Author notes this is a functional view of polymorphism (as provided in
C++).  [Stroustrup 91, p. 136] has an example of polymorphism with void *'s,
but a newer template function is incomparably preferable, as implied in
[Stroustrup 90, ch 14]]


Rumbaugh's Definition [Rumbaugh 91, p. 2]:

"Polymorphism" means that the same operation may behave differently on
different classes.


2.2)  What Does Polymorphism Boil Down To In OO Programming Languages?
----------------------------------------------------------------------

In C++, virtual functions provide polymorphism.  This is because a polymorphic
object (pointer or reference (or such parameter)) is assignment compatible with
any object of a derived class.  Is this polymorphism in itself?  Objects
can take on objects of different forms (the derived classes), but of what use
is it?  To make any difference, the differing forms must have some effect.  In
dynamically typed languages, polymorphic objects are passed messages and will
respond in whatever way the object has defined (usually starting from its most
derived class and working its way up).  But for static objects, a virtual
function is invoked.  This is the stored method from the derived class that
overrode the virtual method from its base class, providing specialized behavior
for the polymorphic object; and hence, polymorphism.  This common pure
statically typed example is, of course, an example of inclusion polymorphism,
subclass polymorphism to be more specific (see section 2.1).  Pure statically
typed subtype polymorphism, as provided in Emerald, can be implemented
similarly [Black 86].


2.3)  What Is Dynamic Binding?
------------------------------

Dynamic binding has two forms, static and dynamic.  Statically-typed dynamic
binding is found in languages such as C++ (virtual functions) and Eiffel
(redefinition).  It is not known which function will be called for a virtual
function at run-time because a derived class may override the function, in
which case the overriding function must be called.  Statically determining all
possibilities of usage is undecidable.  When the complete program is compiled,
all such functions are resolved (statically) for actual objects. Formal object
usage must have a consistent way of accessing these functions, as achieved thru
vtables of function pointers in the actual objects (C++) or equivalent,
providing statically-typed dynamic binding (this is really just defining simple
function pointers with static typechecking in the base class, and filling them
in in the derived class, along with offsets to reset the receiver).

The run-time selection of methods is another case of dynamic binding, meaning
lookup is performed (bound) at run-time (dynamically).  This is often desired
and even required in many applications including databases, distributed
programming and user interaction (e.g. GUIs).  Examples can be found in
[Garfinkel 93, p80] and [Cox 91, pp 64-67].  To extend Garfinkels example with
multiple-polymorphism, a cut operation in an Edit submenu may pass the cut
operation (along with parameters) to any object on the desktop, each of which
handles the message in its own way (OO).  If an (application) object can cut
many kinds of objects such as text and graphical objects, multiple-polymorphism
comes into play, as many overloaded cut methods, one per type of object to be
cut, are available in the receiving object, the particular method being
selected based on the actual type of object being cut (which in the GUI case is
not available until run-time).

Again, various optimizations exist for dynamic lookup to increase efficiency
(such as found in [Agrawal 91] and [Chambers 92]).

Dynamic binding allows new objects and code to be interfaced with or added to
a system without affecting existing code and eliminates switch statements.
This removes the spread of knowledge of specific classes throughout a system,
as each object knows what operation to support.  It also allows a reduction in
program complexity by replacing a nested construct (switch statement) with a
simple call.  It also allows small packages of behavior, improving coherence
and loose coupling.  Another benefit is that code complexity increases not
linearly but exponentially with lines of code, so that packaging code into
methods reduces program complexity considerably, even further that removing
the nested switch statement!  [Martin 92] covers some of these issues.


2.4)  Is There A Difference Between Being A Member Or Instance Of A Class?
--------------------------------------------------------------------------

Yes (but be careful of context).  To use C++ terminology, an object (not
a reference) is defined to be an instance of exactly one class (in classical
OO), called its most derived class.  An object not directly contained in any
other is called the complete object [Stroustrup 90].  An object is a member
of several classes, including all of the classes its declared (or most derived)
class inherits from.  With static typing and inclusion polymorphism based on
class, if a polymorphic object (or reference) is made to refer to an object,
that object must be a member of the polymorphic object's class.

This also provides a good example of differing definitions among object-
oriented languages, since a member is defined as above in CLOS, but a member of
a class is one of its instance variables in C++.


2.5)  What Is The Difference Between Static And Dynamic Typing?
---------------------------------------------------------------

Static typing refers to types declared in a program at compile-time, so no type
information is available on objects at run-time.  Dynamic typing uses the
inherent types of polymorphic objects, keeping track of the types of objects at
run-time.  Statically typed dynamic binding is a compromise (usually
implemented with tables of function pointers and offsets), and is how
statically-typed OO languages provide polymorphism.  Some approaches provide
both static and dynamic typing, sometimes with static typing providing type-
safe programs and dynamic typing providing multiple-polymorphism [Agrawal 91]
[Mugridge 91].  See also section 2.3.

Static typing is more efficient and reliable, but loses power.  Typical
restrictions include only allowing a common set of base class functions (or
any common functions for the more general subtyping or parametric polymorphic
cases) to be available on formal objects and a lack of multiple-polymorphism
(see section 1.19), both of which are overcome with dynamic typing.

Many languages provide dynamic typing: Smalltalk, Self, Objective-C, and etc.
A limited dynamic typing scheme, called RTTI (Run Time Type Identification),
is even being considered for the C++ standard.  A similar facility to safe
downcasting (historically known as type narrowing), the thrust of RTTI, can
also be found in recent versions of Eiffel.

See section 3.4 for a categorization of common OO languages by type system.


2.6)  What Is This I Hear About ML And Functional Programming Languages?
------------------------------------------------------------------------

ML, Metalanguage, is a functional programming language with a strongly typed
polymorphic type system [Wikstrom 87].  Russell (see Appendix E) is a more
recent functional language and Haskell [Hudak 92] provides a more modern and
"pure" example.  Section 2.5 discusses why static typing has less power/
flexibility than dynamic typing and the same applies to ML (although see the
appendixes for an experimental dynamic extension to ML, Alcool-90 and [Cardelli
85] for a proper placement of ML's type system).  ML doesn't use inheritance
for polymorphism; unlike OO languages, but provides the prototypical example of
parametric polymorphism, so no inheritance is required.  This is "true" or
"pure" statically (or strongly) checked parametric polymorphism, by Strachey's
(and Cardelli and Wegner's) definitions.

Smalltalk is an example of a dynamically-typed language which does not check
types during assignment (and hence for parameters) and therefore provides
parametric polymorphism without static constraints (by Strachey's definition).
However, Smalltalk's style uses inclusion polymorphism in practise and
inheritance for subclassing (representation).


2.7)  What Is A Separation Between Type And Class (Representation)?
-------------------------------------------------------------------

For a short answer:
  Subtype Polymorphism, as opposed to Subclass Polymorphism, is the best answer
  in OO.  Parametric polymorphism is a related concept where this is also true,
  but is of a different flavor (and usually requires object attributes by use.
  See also section 2.1).

A type can be considered a set of values and a set of operations on those
values.  This can insure type-safe programming.  However, the representation of
types (classes in OO) can be separated from the notion of type allowing many
representations per type while still maintaining reasonable type-safety.

In many languages, a type has a single representation insuring all operations
performed on that type are well defined (statically bound) and providing for
efficiency by taking advantage of that representation wherever used.  In many
OO languages, subclassing and dynamic binding provides for greater flexibility 
by providing object specialization.  However, in many OO languages classes are
used for assignment compatibility forcing an assigned object to inherit
(transitively) from any polymorphic object's class (inclusion polymorphism
based on class, or subclass polymorphism).  This insures all operations to be
performed on any polymorphic object are satisfied by any replacing objects.
This also insures all types share a common representation, or at least a
common base interface specification.

By separating type from class, or representation (or perhaps separating class
from type, by the aforementioned definition of type), a replacing object must
satisfy the operations or type constraints of a polymorphic object (subtype
polymorphism) but are not required to do to do so by an inheritance relation
(subclass polymorphism), as is typical in most OOPLs.  Dropping this
restriction is somewhat less type-safe, because accidental matches of method
signatures can occur, calling for greater care in use.  [Black 86] discusses
this issue in Emerald.  The same issue arises in parametric polymorphism
(generics/templates), as any method matching a required signature is accepted,
calling for careful matching of actual and formal generic parameters.  The
difference between static and dynamic binding in OO and dynamic binding and
subtyping seems similar.  A possible loss of semantic integrity/similarity is
contrasted with greater power.

It is possible to specify desired abstract properties of type specifications
with mechanisms similar to Eiffel's pre-, post-, and invariant conditions.
This helps to insure the semantic integrity of replacing objects and their
behavior.  [Liskov 93] provides a recent exposition.

Abstract classes ([Stroustrup 91] and [Meyer 88]) in typing provide a facility
similar to subtype polymorphism; however, ACs require type compatible classes
to inherit from them, providing a subclass polymorphism facility, and ACs can
also specify representation.  Subtyping is therefore most useful to avoid
spreading knowledge of classes throughout a system, which is a high priority
for loosely coupled modules and in distributed programming [Black 87].

The formal type system found in [Cardelli 85], Emerald/Jade [Black 86] and
[Raj 89], original trellis/Owl, an experimental C++ extension (See Appendix E,
Signatures), Sather (Eiffel-based), and an Eiffel superset [Jones 92] are all
examples of OO systems providing subtype polymorphism.  Functional languages
such as ML, Russell, and Haskell provide a separation with pure parametric
polymorphism (as is also commonly found in OO languages in additon to inclusion
polymorphism).


2.8)  What Are Generics And Templates?
--------------------------------------

Short Answer: Parametric Polymorphism (although various implementations
              provide various subsets).

Generics (or Templates in C++) refer to the ability to parameterize types
and functions with types.  This is useful for parameterized classes and
polymorphic functions as found in languages such as Ada, C++, Eiffel, and
etc., although these are "syntactic" or restricted forms [Cardelli 85].
Generics are orthogonal to inheritance, since types (and classes)
may be generically parameterized.  Generics provide for reusability in
programming languages.  An example is a Stack with a generically
parameterized base type.  This allows a single Stack class to provide
many instantiations such as a Stack of ints, a Stack of any fundamental
or user defined type, or even a Stack of Stacks of ...  Another example is
a polymorphic sort function taking a base type with a comparison operator.
The function can be called with any type (containing a comparison operator).
See [Booch 87b] for several examples in Ada and [Stroustrup xx] and [Murray
93] for examples in C++.

While generics have many advantages, typical limitations include a static
nature, which is an advantage for strong typechecking but a potential
disadvantage when causing dynamic compilation (leading to a time/space
efficiency tradeoff), and sources can cause inlining and create source code
dependencies and expand code size (unlike a single-body or "true"
parametrically polymorphic implementation.  Generics can also be viewed as a
special case of type variables.

Functions are typically generic in statically-typed parametrically-polymorphic
languages.  One such popular functional language is ML, in which all functions
are generic.  Russell and Haskel are more modern variants (references are
forthcoming, however see APPENDIX E).


SECTION 3:  GENERAL
===================

  References:   (many more are to come)
    [Coplien 92]    Covers C++, symbolic, exemplar (single-hierarchy), etc.
    [Kim 89]        Covers many OO systems.


3.1)  What Is The "Classical" Object-Oriented Paradigm?
-------------------------------------------------------

This refers to the usual class and object model.  Its any 2+ level system
as described in section 1.4.  See also [Coplien 92].


3.2)  What Is The "Delegation/Prototyping" Object-Oriented Paradigm?
--------------------------------------------------------------------

See [Kim 89, ch 1,3].

This is the 1 Level System as Described under Meta-Classes.  Delegation refers
to the delegating of responsibility and can be applied to inheritance.  When a
derived class does not have a desired attribute, it "delegates" responsibility
to one of its base classes.  In delegation systems, each object has a delegate
list instead of a parent list. Thus, delegation's primary emphasis is 
on message passing where an object could delegate responsibility of a message
it couldn't handle to objects that potentially could (its delegates).  Any
object can be added to the delegate list, giving dynamic inheritance (of a
sort).  Typically, delegation and prototyping languages also have "part
inheritance" in which fields and methods can be added and deleted from objects.
This makes for easy "prototyping", which allows for objects to be constructed
piece by piece at run-time, although the term "prototyping" in the context of
delegation languages usually refers to objects serving as prototypes for
object instantiation, or exemplars.

Next's NextStep OS provides delegation as an add-On to Objective-C, providing
an example of delegation in a class-based language [Garfinkel 93].


3.3)  Are There Any Other Object-Oriented Paradigms?
----------------------------------------------------

There are many alternatives in OO.  Emerald/Jade ([Black 86] and [Raj 89])
provides one, where inheritance is replaced with a roughly equivalent form
where reuse occurs at a finer degree of granularity - method and instance
variables - with subtype polymorphism making up the difference.

CLOS [Kim 89, ch 4] has a looser coupling of methods to classes and doesn't
distinguish a receiver, but packages can help make up the difference.

Object Specialization [Sciore 89] is an example of a hybrid approach between
delegation and classical systems, where parent classes have an extra level
of indirection and inheritance hierarchies are specified on a per object/class
basis.


3.4)  What Are The Major Object-Oriented Programming Languages Today?
---------------------------------------------------------------------

Statically-Typed:
  Add 1 To Cobol giving Cobol with Objects.
  Beta
  C++
  Classic-Ada
  Dragoon
  Emerald/Jade
  Object Pascal
  Trellis/Owl

Dynamically-Typed:
  Actors Languages
  Flavors
  Self
  Smalltalk

Both:
  Actor
  Ada-9x
  C++ (With RTTI)
  Cecil
  CLOS
  Eiffel
  Modula-3
  Objective-C
  Sather


3.5)  What Are Object-Oriented Databases And Persistence?
---------------------------------------------------------

See also Appendices B and E and the comp.database.object newsgroup.
Refs to be included in future FAQs.

Object-Oriented Databases are databases that support objects and classes.  They
are different from the more traditional relational databases because they allow
structured subobjects, each object has its own identity, or object-id (as
opposed to a purely value-oriented approach) and because of support for methods
and inheritance.  It is also possible to provide relational operations on an
object-oriented database.  OODBs allow all the benefits of object-orientation,
as well as the ability to have a strong equivalence with object-oriented
programs, an equivalence that would be lost if an alternative were chosen, as
with a purely relational database.

Another way of looking at Object-Oriented Databases is as a persistent object
store with a DBMS.

Persistence is often defined as objects (and their classes in the case of
OODBs) that outlive the programs that create them.  Object lifetimes can be
viewed as a hierarchy, with locals/automatics having the shortest default
lifetime and objects stored indefinitely in an OODB (which are persistent)
having the longest.  Persistent object stores do not support query or
interactive user interface facilities, as found in a fully supported OODBMS.

Appendix B also contains references for relational interfaces to OODBs.


3.6)  What Are Object-Oriented Operating Systems?
-------------------------------------------------

Refs to be included in future FAQs.  See also Appendix E.

Object-Oriented Operating Systems provide resources through objects, sometimes
all the way down to to the machine (OO architectures are found at the bottom).
They are almost always distributed systems (DOS or DPOS), allowing objects to
be passed freely between machines.  They are typically capability-based since
objects, and hence system resources, can only be accessed if a capability to
them is available to programs.

Here are some abstracts taken from several postings to the net.  This list is
by no means exhaustive.

Chorus Micro-kernel (written in C++)
Choices (research OS, University of Illinois, written in C++, supports SVR4)
GEOS    (GeoWorks', written in Object Assembler, OO superset of 8086) 
Mach    (CMU, supports BSD 4.3, really message-based)
NachOS  (written in C++, OS teaching/learning OS)
Ouverture Project (ESPRIT funded OMG IDL defines inter-module interfaces)
SOS
Spring      (Sun, written in C++)
PenPoint OS (Go, written in C++)


From: whitney@oberon.Meakins.McGill.CA ()

Insight ETHOS: On Object-Orientation in Operating Systems
ISBN 3 72811948 2

This thesis covers the design of an extensible object-oriented 
operating systems. The language used was Oberon-2. It includes
a generalization of the Rider/Carrier principle, Object Directories
as well as basic OS issues such as memory, file, tasking management. 
It covers extensible objected-oriented programming from hardware up.
It reviews other designs such as Clouds and Choices which where written
It reviews other designs such as Clouds and Choices which where written
on C++. [[ The lack of type-tests in C++ was a problem in other designs.]]
ETHOS was implemented as an operating system for the Ceres computers
at the ETH. 


3.7)  What Are The Current Object-Oriented Methodologies?
---------------------------------------------------------

Here is a list of OOSE Methodologies:

  Berard                        [Berard 93]
  BON                           [Nerson 92]
  Booch                         [Booch 94]
  Coad/Yourdon                  [Coad 91]
  Colbert                       [Colbert 89]
  de Champeaux                  [de Champeaux 93]
  Embley                        [Embley 92]
  EVB                           [Jurik 92]
  FUSION                        [Coleman 94]
  HOOD                          [HOOD 89]
  IBM                           [IBM 90,91]
  Jacobson                      [Jacobson 92]
  Martin/Odell                  [Martin 92]
  Reenskaug (OOram, was OORASS) [Reenskaug 91]
  ROOM                          [APPENDIX D, ObjecTime CASE Toolset]
  Rumbaugh et al.               [Rumbaugh 91]
  Shlaer and Mellor             [Shlaer 88 and 92]
  Wasserman                     [Wasserman 90]
  Winter Partners (OSMOSYS)     [Winter Partners]
  Wirfs-Brock et al.            [Wirfs-Brock 90]

Further Ideas And Techniques:
  Meyer                         [Meyer 88]
  Stroustrup                    [Stroustrup 91]

See APPENDIX D for CASE systems supporting these methodologies (several from
the originators themselves).

See also section 1.21 for a discussion on OOA/OOD and etc.

Summaries and comparisons will be provided in future FAQs.  Suggestions for
inclusion of other major or new methodologies should be sent to the FAQ author.

Here are some comparison studies posted to the net:

Arnold, P., Bodoff, S., Coleman, D., Gilchrist, H., Hayes, F., An Evolution of 
Five Object Oriented Development Methods, Research report, HP Laboratories, 
June 1991

de Champeaux, Dennis and Faure, Penelope. A comparative study of object-
oriented analysis methods. Journal of Object Oriented Programming (JOOP), pp
21-32.  Vol.5, No. 1, 3/4-92

Fichman R.G. & Kemerer C.F.  OO and Conventional Analysis and Design
Methodologies.  Computer, Oct 1992, Vol 25, No. 10, p 22-40

Fichman, Robert and Kemerer, Chris. Object-Oriented and Conventional Analysis
and Design Methods - Comparison and Critique.  IEEE-Comp, Oct, 1992, pp 22-39.
OOA, OOD, conventional analysis, conventional design, DeMarco SA, Yourdon SA,
Bailin OO requirements specification, Coad-Yourdon OOA, Shlaer-Mellor OOA,
Yourdon-Constantine SD, Martin information engineering design, Wasserman OOSD,
Booch OOD, Wirfs-Brock responsibility-driven design.

Hong, S., van den Goor, G., and Brinkkemper, S.  A Comparison of Object-
oriented Analysis and Design Methods. Working paper, Computer Information
Systems Department, Georgia State University, Atlanta USA, 1992, 12 pages. To
appear in the Proceedings of the 26th Hawaiian international conference on
System Sciences, IEEE Computer Science Press.

Hong, S., van den Goor, G., Brinkkemper, S. A Formal Approach to the Comparison
of Object-Oriented Analysis and Design Methodologies, Hawaii International 
Conference on System Sciences (HICSS) (IEEE Computer Society Press, Hawaii)
1993, Vol. IV, pp. 689-698.  Summary of [van den Goor et.al., 1992] below.

  Order procedure:
  Available from the authors at cisssh@gsusgi2.gsu.edu or sjbr@cs.utwente.nl.
  The authors, regretfully, cannot supply ftp, postscript, TEX, or 
  whatsoever.

Monarchi, David and Puhr, Gretchen I. A Research Typology for Object-Oriented
Analysis and Design.  CACM/September 1992/Vol.35, No.9, pp35.

[Wilkie 93] summarizes, compares, and provides examples of Booch, Wirfs-Brock,
Hood, Coad and Yourdon, Winter Partners, Shlaer and Mellor, Jacobson,
Wasserman et al, Rumbaugh, Reenskaug et al, and Colbert.

Wirfs-Brock, R.J. and Johnson, R.E., "Surveying Current Research in Object-
Oriented Design," The Communications of ACM, (33, 9) Sept. 1990, pp. 104-1124.

UNICOM. Approaches to Object-Oriented Analysis and Design.
tel: l 44 895 256 484. Ask the TOC and have a look at it.


Also commercially available:

An Evaluation of Object-Oriented Analysis and Design Methodologies (9)
J. Cribbs, C Roe, S. Moon
SIGS Books
(212) 274-0640
$149.

Object-Oriented Methodology Comparison Study (10 methodologies)
Berard, Booch, Coad/Yourdon, Colbert, Embley, IBM, Martin/Odell, Rumbaugh,
Shlaer/Mellor, Wirfs-Brock.  Also contains refs to several previous studies.
Berard Software Engineering
101 Lakeforest Blvd., Suite 360, Gaithersburg, MD 20877
Contact Person: Jim Youlio
Phone:        301-417-9884
Fax:          301-417-0021
email:        info@bse.com

[van den Goor et.al., 1992] G. van den Goor, S. Hong and S. Brinkkemper,
A Comparison of Six Object-oriented Analysis and Design Methods. Report
Center of Telematics and Information Technology, University of Twente,
the Netherlands, and Computer Information Systems Department, Georgia
State University, Atlanta, USA, 1992, 163 pages, US$ 70.

This report gives an in-depth analysis of six generally accepted
O-O methods, that are available in textbooks. The background, steps,
concepts, notations, and specification techniques of the methods
are extensively compared.

The six methods are:
-  Object Oriented Analysis & Object Oriented Design (OOA/OOD) of Coad &
      Yourdon (1991)
-  Designing Object Oriented Software (DOOS) of Wirfs-Brock et.al. (1990)
-  Object Modelling Technique (OMT) of Rumbaugh et.al. (1991)
-  Object Oriented Systems Analysis (OOSA) of Shlaer & Mellor (1988)
-  Object Oriented Design with Applications (OODA) of Booch (1991)
-  Object Oriented Analysis and Design (OOAD) of Martin & Odell (1992).

The comparison is performed by meta-modelling, resulting into detailed
information on the concepts of the methods (in EER notation) and on the
steps of the procedure of the methods (in Task Diagrams). Extensive
comparison tables of steps, concepts, techniques are included. Mappings of
the methodical concepts to the constructs of programming languages (C++,
Objective-C, Smalltalk-80, Object Pascal en CLOS) are given. A small
test case illustrates the application of the methods.

Order procedure:
Those who want to order the complete report (163 pp.) can order one by
specifying their postal address in an e-mail (sjbr@cs.utwente.nl) or fax
(+31.53.33.9605) attn. Sjaak Brinkkemper. The report will be send within
two weeks with an invoice for US$ 70. (seventy dollar; including shipping,
excl VAT).


3.8)  What Is the OMG/OMA/ORB/CORBA?
------------------------------------

Contents:
  (3.8.1)  Contact Information
  (3.8.2)  OMG Summary
  (3.8.3)  Mail Server Access
  (3.8.4)  OMG Publications
             - First Class (Bi-Monthly Newsletter)
             - Object Management Architecture Guide (OMA)
             - The Common Object Request Broker: Arch. and Spec. (Corba)
             - Pricing
  (3.8.5)  Implementations (Brief)
  (3.8.6)  Implementation Descriptions
  (3.8.7)  Books, Articles, And Literature


3.8.1  Contact Information
__________________________

Contact Person: Richard Soley (technical director) soley@omg.com

FTP Sites: 
  omg.org:pub/*
  omg.org:pub/NEC_DII/93-1-2.tar...            *CORBA (DII) (corba.ps.Z)
  omg.org:pub/OMG_IDL_CFE_1.2/bin*              idl.SunOS4.x, idl.Solaris2.x
  claude.ifi.unizh.ch:under pub/standards/spec  CORBA Spec

Headquarters:                            Marketing Office:
  492 Old Connecticut Path                 3823 Birchwood Drive
  Framingham, MA 01701                     Boulder, CO  80304
  Tel: 508-820-4300                        Tel: 303-444-8129
  Fax: 508-820-4303                        Fax: 303-444-8172


3.8.2  OMG Summary
__________________

From: soley@emerald.omg.ORG (Richard Mark Soley)
Subject: OMG

In answer to your general question about the OMG, here's a brief overview.
Feel free to call, fax or email for more information.

        -- Richard Soley
           Vice President & Technical Director
           Object Management Group, Inc.
           and coincidentally, MIT '82, SM '85, PhD '89 (EECS)

The Object Management Group (OMG) is an international software industry
consortium with two primary aims:

(*) promotion of the object-oriented approach to software engineering
    in general, and

(*) development of command models and a common interface for the development
    and use of large-scale distributed applications (open distributed
    processing) using object-oriented methodology.

In late 1990 the OMG published its Object Management Architecture
(OMA) Guide document. This document outlines a single terminology for
object-oriented languages, systems, databases and application
frameworks; an abstract framework for object-oriented systems; a set
of both technical and architectural goals; and an architecture
(reference model) for distributed applications using object-oriented
techniques.  To fill out this reference model, four areas of
standardization have been identified:

1) the Object Request Broker, or key communications element, for
   handling distribution of messages between application objects in
   a highly interoperable manner;

2) the Object Model, or single design-portability abstract model for
   communicating with OMG-conforming object-oriented systems;

3) the Object Services, which will provide the main functions for
   realising basic object functionality using the Object Request Broker -
   the logical modeling and physical storage of objects; and

4) the Common Facilities will comprise facilities which are useful in
many application domains and which will be made available through OMA
compliant class interfaces.

The OMG adoption cycle includes Requests for Information and
Proposals, requesting detailed technical and commercial availability
information from OMG members about existing products to fill
particular parts of the reference model architecture.  After passage
by Technical and Business committees to review these responses, the
OMG Board of Directors makes a final determination for technology adoption.
Adopted specifications are available on a fee-free basis to members and
non-members alike.

In late 1991 OMG adopted its first interface technology, for the Object
Request Broker portion of the reference model.  This technology, adopted
from a joint proposal (named "CORBA") of Hewlett-Packard, NCR Corp.,
HyperDesk Corp., Digital Equipment Corp., Sun Microsystems and Object
Design Inc. includes both static and dynamic interfaces to an inter-
application request handling software "bus."

Unlike other organizations, the OMG itself does not and will not
develop nor sell software of any kind.  Instead, it selects and promulgates
software interfaces; products which offer these interfaces continue to be
developed and offered by commercial companies.

In order to serve OMG membership interested in other object-oriented systems
arenas besides the distributed system problem, the Group supports Special
Interest Groups for discussion of possible standards in other areas.  These
groups at present are:

        1) Object Oriented Databases;
        2) OO Languages;
        3) End-User Requirements;
        4) Parallel Processing;
        5) Analysis & Design Methodologies;
        6) Smalltalk; and
        7) Class Libraries.

Any company, university/research institution or individual, whether
end-user or vendor, can become a member of this body.  Administrative
details are given at the end of this paper.


3.8.3  Mail Server Access
_________________________

Information via Mail Server:
  Send the following commands in a letter to the mail server.

mail omg_server@omg.org
help                             (how to use file server)
index                            (return a list of all available files)
get <file>                       (get files returned by  index)
log <info>                       (logs info on server)
address <e-mail address)         (use this address instead of sender)
list <directory> [match]         (index a directory, pattern 'match' files)
size <segment size>              (max file size to send)

list mail
list docs
get docs/doclist.txt             
get docs/91-12-1.ps               CORBA spec [although it looks a little old]


Recommended (from the net):

mail omg_server@omg.org
Subject: 
help
index
list
list mail
list docs
get docs/doclist.txt


3.8.4  OMG Publications
_______________________

Below is from omg.org:pub/CORBA


> First Class (Bi-Monthly Newsletter)

First Class is OMG's non-commercial bi-monthly 28-page
newsletter. First Class provides current information on Object
Technology developments, both technically and commercially. First
Class offers an open editorial forum on numerous Object
Technology topics and issues.  This publication features
commentaries from software industry leaders, informative user
case histories, OT training information and the latest object-
oriented product announcements.  All OMG activities and the
ongoing development of the Object Management Architecture are
regularly reported.


> Object Management Architecture Guide (OMA)

The members of the OMG have a shared goal of developing and using
integrated software systems.  These systems should be built using
a methodology that supports modular production of software;
encourages reuse of code; allows useful integration across lines
of developers, operating systems and hardware; and enhance long-
range maintenance of that code.  As an organization, OMG believes
that the object-oriented approach to software construction best
supports their goals.  The OMA publication outlines the
groundwork for technology response to Request for Proposals (RFP)
and the adoption of specifications.


> The Common Object Request Broker: Arch. and Spec. (Corba)

The CORBA, as defined by the OMG's Object Request Broker (ORB),
provides the mechanisms by which objects transparently make
requests and receive responses. The ORB provides interoperability
between applications on different machines in heterogeneous
distributed environments and seamlessly interconnects multiple
object systems. The Common Object Request Broker Architecture and
Specification described in this published document is a self-
contained response to the Request for Proposals (RFP) issued by
the ORB Task Force of the OMG.

> Pricing

[Here's why you don't see the specifications posted on the net!  These are
 from the list of literature and periodicals listed in omg.org:pub/CORBA]

o I would like a one year subscription to First Class
    ______ for $40 U.S.,  ______ for $50 outside U.S.

o I would like to order  ______ copy(s) of the Object Management
  Architecture (OMA) Guide for $50 each.

o I would like to order  ______ copy(s) of the CORBA for $50 each.

o [Combinations]

Contact documents@omg.org or omg_documents@omg.org for more of the same...


3.8.5  Implementations (Brief)
______________________________

> DEC ACA.  Maynard, MA

Runs on AIX,VMS,ULTRIX,,MS-WINDOWS,MAC,HP-UX,UNIX, NT(planned).


> HP ORB Plus and HP Distributed Smalltalk

Full implementation of the OMG CORBA 1.1 Object Request Broker.
Also DOMF

Hewlett-Packard
Distributed Computing Group
19447 Pruneridge Avenue
Cupertino, CA 95014-9974 (USA)
Ian Fuller ian@cup.hp.com (408) 447-4722


> HyperDesk (Westborough MA) HD-DOMS, joe_cordo@hyperdesk.com

Runs on SPARC, HP/UX, IBM RS-6000, Data General Aviion, MS-Windows (client
API only), NetWare (planned, Novell owns part of HyperDesk).


> IBM SOM (System Object Model)

Available on AIX and OS/2.  See Distributed Computing Monitor, March 93 for a
detailed review.


> IONA Technologies, Dublin Orbix, info@iona.ie

    runs on (Unix (Solaris 1.1) (now), DOS, Windows, NT (planned)


> ROLSCH CONSULTING (RC-ORB)

  implements ORB spec, DOS/Windows 3.1, 12 user license: $99.
  Ref: Datamation, LOOK AHEAD Section, August 1.  German Company.


> SuiteSoftware (Anaheim CA) SuiteDOME

    runs on VAX/VMS, Unix, PC


> Sun DOE


> Tivoli


> CS Dept. University of Zurich, Switzerland.  maffeis@ifi.unizh.ch

    The ELECTRA Toolkit (not finished)


3.8.6  Implementation Descriptions
___________________________________

The OMG also has a (Corporate) Membership list and "known CORBA supporters"
list with their info package.


> The ELECTRA Toolkit

CS Dept. University of Zurich, Switzerland.  maffeis@ifi.unizh.ch
The ELECTRA Toolkit

Subject: ORB Implementations
Date: Tue, 4 May 1993 13:12:36 +0200 (MET DST)
From: Silvano Maffeis <maffeis@ifi.unizh.ch>

  something like an Object Broker, but it is *not* CORBA compatible (yet).
  Electra is a research project and not available yet.

  Its a toolkit for building failure resilient, distributed applications
  in C++. It supports object-groups, virtual synchrony, multithreading
  etc. Electra is based on the HORUS toolkit (which is "the new ISIS
  implementation" developed at Cornell, Ithaca NY.)
  An overview paper to electra is available from:
  ftp.ifi.unizh.ch: pub/techreports/electra.ps.Z


> HD_DOMS

HD-DOMS (HyperDesk Distributed Object Management System).  A
CORBA-compliant DOMS.  Includes a GUI API driver for prototyping and
exercising objects, a bundled object database for persistent object
storage, a Kerberos-based authentication service, a location service, a
set of base classes to speed development, and a test script language.
Revision 1.0 has been shipping since beginning of '92.  Revision 1.1
(which includes support for CORBA's static client interface) is available
now, and a NetWare version is in the works.  Submitted a C++ language
mapping for IDL to the OMG recently.

HyperDesk Corporation
2000 West Park Drive
Westboro, MA 01581
(508)366-5050


> HP ORB Plus and HP Distributed Smalltalk

From: daryl@cup.hp.com (Daryl Odnert)
Subject: HP ORB Plus and Distributed SmallTalk
Summary: Official HP Press release on HP ORB Plus and DST 2.0
Date: Thu, 30 Sep 1993 20:13:48 GMT
Organization: Hewlett-Packard

  ============================================================================
  SUBJECT:  HP INTRODUCES DISTRIBUTED-COMPUTING SOLUTION FOR BUILDING
            SCALABLE, OBJECT-ORIENTED APPLICATIONS
  DATE:     September 27, 1993
  ----------------------------------------------------------------------------
 
   PALO ALTO, Calif.--(BUSINESS WIRE) via First! -- Hewlett-Packard Company
 today introduced a distributed-computing solution for building scalable,
 object-oriented applications.
 
   With HP ORB Plus, programmers can develop scalable, object-based
 applications that can be distributed throughout the enterprise.  HP also
 introduced an enhanced version of HP Distributed Smalltalk.
 
   HP ORB Plus and HP Distributed Smalltalk are major components of HP's
 overall distributed-computing strategy, which is designed to give customers
 integrated, desktop access to enterprise-wide information and resources in
 distributed heterogeneous systems environments.  Of all computer companies,
 HP believes it is best positioned to help customers take advantage of
 distributed computing. HP provides a wide variety of distributed-computing
 products, understands how to help customers adopt new technology for maximum
 business benefit, and offers worldwide support and training programs,
 ranging from analysis and design to deployment.
 
   HP ORB PLUS:  CORBA AND DCE COMBINED
 
   HP ORB Plus is the only environment that combines the complete CORBA 1.1
 specification from the Object Management Group with the DCE standard from
 the Open Software Foundation(tm) as its transport mechanism.  DCE is
 designed to let developers write one application and then deploy it --
 without modification -- on any other system that supports DCE.  HP ORB Plus
 reduces the complexity of developing distributed applications so programmers
 can concentrate on the application itself without needing to know multiple
 operating systems, networking protocols or where application objects are
 stored.
 
   The DCE (Distributed Computing Environment) standard provides an
 integrated set of services that can be used separately or together to
 provide a distributed computing environment that's easy to administer.  The
 CORBA (common-object-request-broker architecture) specification provides a
 standard for how objects (in applications, repositories or class libraries)
 make requests and receive responses across a distributed network.
 
   HP ORB PLUS DETAILS
 
   HP ORB Plus consists of several components: the Distributed Object
 Management Facility (DOMF), object services, developers' and administrative
 tools, and sample applications.  HP's DOMF provides a location-transparent
 object-communication mechanism across heterogeneous networks by using the
 DCE standard.  This object- enabling technology specification was jointly
 developed with SunSoft. By following a common specification, HP and SunSoft
 have made it easier for their customers to port applications between their
 platforms.
 
   In addition, HP is working with IBM to integrate HP's DOMF with IBM's
 System Object Model with extensions for distribution.  This integration will
 eventually provide users with complete scalability, portability and
 interoperability of distributed applications across HP and IBM platforms.
 This is part of the companies' planned approach toward a standards-based,
 "plug-and-play"  object-oriented environment.  This will give developers,
 system administrators and end users language-neutral, enterprise-wide,
 heterogeneous support for building, managing and using distributed object-
 oriented applications.
 
   "We're so convinced of the value of object technology that we're staking
 our entire company on it,"  said Richard Tanler, president and chief
 executive officer of Information Advantage, Inc.  "Our object-based
 applications for retailers provide the means to a competitive business edge.
 We plan to use HP ORB Plus to develop new object-based products that
 retailers can distribute to end users throughout headquarters, all chain
 stores, and warehousing and distribution operations."
 
   HP DISTRIBUTED SMALLTALK 2.0
 
   In a related announcement, HP introduced Version 2.0 of HP Distributed
 Smalltalk.  This toolset works with VisualWorks from ParcPlace Systems to
 provide programmers with a rapid development environment for creating and
 running distributed applications.  These applications can use object
 databases (currently OpenODB from HP and Gemstone from Servio) as their
 storage mechanism to facilitate the reuse of objects.
 
   Applications built using HP Distributed Smalltalk currently run without
 modification on HP, Sun and IBM UNIX(R) system-based workstations.  They
 also will run on Apple Macintosh computers and on any PC running the Windows
 3.1 or Windows NT operating systems from Microsoft(R) Corp., once
 VisualWorks 2.0 is released (expected within two months.)
 
   New HP Distributed Smalltalk 2.0 features include the following:
 
   --  easier deployment, with the ability to run multiple HP
       Distributed Smalltalk-based applications on a single system;
   --  up to 400 percent increased performance, through quicker
       sending and receiving of remote messages, and reusable
       object libraries;
   --  run-time version, for full production deployment; and
   --  easier development, with remote object browsing so
       developers can find and use objects more quickly.
 
   TECHNICAL DETAILS AND AVAILABILITY
 
   HP's DOMF includes the object request broker, interface- definition-
 language compiler, static and dynamic invocation interface and interface
 repository.  In addition to these OMG-specific features, most developers
 writing distributed, object-oriented applications require additional
 interfaces to use objects effectively.  So developers don't need to create
 their own, HP has supplied several object-service interfaces for developers
 to use. That's why HP ORB Plus includes OMG interfaces and implementations
 for properties, life cycle, associations, event notification and naming.
 
   HP's limited release of HP ORB Plus to key developers is designed so that
 customer input can be incorporated into the product early in its development
 cycle.  The initial version will work with the C++ programming language.
 For the generally available Developer's Kit, C++, C and Smalltalk
 interoperability is planned so objects written in different languages can be
 combined into one application.  The Developer's Kit is scheduled to be
 available mid- 1994; prices will be announced then.  HP ORB Plus runs on the
 HP Apollo 9000 Series 700 workstations and HP 9000 Series 800 business
 servers.
 
   Hewlett-Packard Company is an international manufacturer of measurement
 and computation products and systems recognized for excellence in quality
 and support.  The company's products and services are used in industry,
 business, engineering, science, medicine and education in approximately 110
 countries.  HP has 94,900 employees and had revenue of $16.4 billion in its
 1992 fiscal year.
 
 EDITORIAL CONTACTS:
	Hewlett-Packard Company
	Lynne Hanson, 408/447-1415, Cupertino, Calif.
	Jill Kramer, 408/447-4275, Cupertino, Calif.

 ==================
 Daryl Odnert       daryl@cup.hp.com
 Distributed Computing Program
 Hewlett-Packard Company
 Cupertino, California


> Iris RDOM

From: rcbc@cs.cornell.edu (Robert Cooper)
Subject: Re: DCE vs. CORBA
Reply-To: rcbc@isis.com
Product: Isis Reliable Distributed Object Manager(tm) (RDOM)
Company: Isis Distributed Systems, Inc., Ithaca NY, USA.

Isis RDOM(tm) is a fault tolerant distributed ORB platform for reliable
multi-lingual object-oriented applications. RDOM provides an "object group"
paradigm for constructing complex applications out of collections of
cooperating objects. RDOM is built on top of the Isis Distributed
Toolkit(tm). RDOM provides interfaces from Smalltalk (Parcplace),
Objective-C, and C++, and runs on most Unix workstations. RDOM is currently
not CORBA compliant, but will be brought to compliance during 3Q93.

Status: 

RDOM has been at beta test sites since January. General release of
the Smalltalk and Objective-C language interfaces is expected in June.
The C++ interface in August. Customers include AMD, Consilium and Swiss
Bank Corp).  


> Orbix

Orbix
Iona Technologies Ltd.
O'Reilly Institute
Westland Row
Dublin 2
Ireland

"ORB, CORBA compliant.
Product launched June, 93 at the OMG Object World.
Now shipping.  Provides C++ support (gives distributed
C++ programming using CORBA);  C++-IDL binding was jointly submitted with
SunSoft/HP to OMG recent call. "
etc etc

Chris Horn,                                        tel: +353-1-6790677
Iona Technologies,                                 fax: +353-1-6798039
O'Reilly Institute,                                email: horn@iona.ie
Westland Row
IRL - Dublin 2


3.8.7  Books, Articles, And Literature
--------------------------------------

This section is expected to grow considerably in the future.

"Distributed Object Computing With CORBA", C++ Report, July/August 1993

The Object Database Standard: ODMG-93
edited by: R.G.G. Cattell
published by Morgan Kaufmann Publishers, San Mateo, California
[Covers CORBA standards with respect to OODBs]


3.9)  Why Is Garbage Collection a Good Thing?
---------------------------------------------

  From: Paul Johnson (paj@gec-mrc.co.uk)

Garbage collection (GC) is a facility in the run-time system associated with a
language which will automatically reclaim objects which are no longer used.
OO Languages which require garbage collection include Eiffel, Smalltalk and
CLOS.  C and C++ can have garbage collection retrofitted (see [3] below).
[Ada has switchable GC, too -bob]

Without GC programmers must explicitly deallocate dynamic storage when
it is no longer needed (in C this is done by a call to free(3)).
There are a number of problems with this:

1: Bugs due to errors in storage deallocation are very hard to find,
   although products are available which can help.

2: In some circumstances the decision about whether to deallocate
   storage cannot be made by the programmer.  Drawing editors and
   interpreters often suffer from this.  The usual result is that the
   programmer has to write an application-specific garbage collector.

3: An object which is responsible for deallocating storage must be
   certain that no other object still needs that storage.  Thus many
   modules must co-operate closely.  This leads to a tight binding
   between supposedly independent modules.

4: Libraries with different deallocation strategies are often
   incompatible, hindering reuse.

5: In order to avoid problems 3 and 4, programmers may end up copying
   and comparing whole objects rather than just references.  This is a
   particular problem with temporary values produced by C++ overloaded
   operators.

6: Because keeping track of storage is extra work, programmers often
   resort to statically allocated arrays.  This in turn leads to
   arbitrary restrictions on input data which can cause failure when
   the assumptions behind the chosen limits no longer apply.  For
   instance many C compilers limit expression nesting, identifier
   length, include file nesting and macro stack depth.  This causes
   problems for programs that generate C.

One partial solution to a lack of GC is reference counting.  In this
scheme each object keeps a count of references to it.  When this count
drops to zero the object is automatically deallocated.  However this
is inefficient (swapping two references will result in three
decrements, three increments and six comparisons) and cannot reclaim
circular data structures.  Two systems that use a reference count GC
are the Interviews C++ graphics library and the Unix file system (the
link count).

Opponents of GC reply that it introduces an overhead which is
unacceptable in some applications.  However the overhead of manual
storage deallocation is probably as high as GC.  GC algorithms are
also available with good real-time behaviour.

[Further, GC can perform compaction improving locality of reference.]

Further Reading:

[1] "Object-Oriented Software Construction" by Meyer puts the argument
for GC.

[2] "Uniprocessor Garbage Collection Techniques," by Paul R. Wilson,
in Memory Management (proceedings of 1992 Int'l Workshop on Memory 
Management, Sept. 1992, St. Malo, France, Yves Bekkers and Jacques Cohen, 
eds.), Springer Verlag Lecture Notes in Computer Science #637.

This is an excellent summary of the state of the art in GC algorithms.  This
and other papers about garbage collection are available in PostScript via
anonymous ftp (cs.utexas.edu:pub/garbage/gcsurvey.ps.  [See APPENDIX E]

[3] "Garbage Collection in an Uncooperative Environment" by Boehm and
Weiser.  Software --- Practise and Experience vol 18(9), pp 807-820.
Sept 1988.  This describes GC in C and C++.

3.10)  What Can I Do To Teach OO To The Kids?
---------------------------------------------

Smalltalk (in its original 1972 version) was initially intended to make
computer programming easy enough for children.  The idea was that manipulating
objects was something more intuitive and natural than coding procedures.

Other entries or suggestions are welcome, please send to the author of the FAQ.

3.11) What Is Available On Object-Oriented Testing?
---------------------------------------------------

[This entry was donated by Doug Shaker and is certainly a FAQ]

Testing of Object-Oriented Programming (TOOP) FAQ/Resource Summary

Posted to comp.object, comp.lang.c++, comp.lang.smalltalk and
comp.software.testing.

Last revised on 93.10.27.  The most notable change is in the additions
to the Software section.  Also a couple of articles added to the
Written Material section.


> What?

This is a summary of resources on the Testing of Object-Oriented
Programming that have been mentioned to me over the net, in email,
or other means.  Sections include Written Material, Courses, and
Software.  It is kind of like an FAQ, though it isn't organized 
that way.

> Who?

I work for a Unix software house, Qualix Group, in the US.   Here is
my sig:
 - Doug Shaker
	voice:	415/572-0200
	fax:	415/572-1300
	email:	dshaker@qualix.com
	mail:	Qualix Group
		1900 S. Norfolk St., #224
		San Mateo, CA 94403
I am NOT a researcher on the testing of object-oriented programming.
I just collate the stuff that is sent to me by people who REALLY know
something.  See the section "ACKs" at the end.

I just think it is important.

> Why?

Why is this important? If classes are really to be reused in
confidence, they must be blatantly correct.  The classes must be easily
testable during initial evaluation by the client programmer.  They must
also be testable under different OS configurations, different compiler
optimizations, etc.  This means that testing modules must be
constructed in a way which is recognized as correct and the modules
must be shipped with the class libraries.  

As soon as one major class library vendor starts to ship real test code
with their libraries, all of the other vendors will be forced, by
market pressure, to do so as well, or face market share erosion.  Think
about it.  If you had to recommend a class library to a committee that
was choosing a basis for the next five years of work, wouldn't you feel
safer with a class library that could be auto-tested in your
environment?


> Written Material

Berard, Edward.  Essays on Object-Oriented Software Engineering.  
	Prentice-Hall, Englewood Cliffs, NJ. $35.
	This book has two chapters on testing of object-oriented software, 
	focusing on how to do it.

Berard, Edward.  Project Management Handbook.  Must be purchased
	direct from Berard Software Engineering, Ltd., 902 Wind River
	Lane, Suite 203, Gaithersburg, Maryland 20878.  $225.
	The book focuses on the management of OOP projects.  It
	includes one chapter on testing OO software and one chapter
	on quality assurance.

Bezier, Boris, "Software Testing Techniques", 2nd edition, Van Nostrand
	Reinhold, 1990, 503pp, $43, ISBN 0-442-20672-0.  While this is
	not specifically about testing of OOP, it is mentioned so often
	by so many people as a definitive software testing work, that
	I have to mention it anyway.

Cheatham Thomas J., and Lee Mellinger, "Testing Object-Oriented
	Software Systems",  Proceedings of the 18th ACM Annual Computer
	Science Conference, ACM, Inc., New York, NY, 1990, pp. 161-165.

Doong, Roong-Ko and Phyllis G. Frankl, "Case Studies on Testing 
	Object-Oriented Programs", Proceedings of the 4th Symposium on
	Testing, Analysis, and Verification (TAV4), 1991, ACM, Inc.,
	New York, NY, 1991, pp. 165-177.

Fiedler, Steven P., "Object-Oriented Unit Testing", Hewlett-Packard 
	Journal, April, 1989, pp. 69-74.

Firesmith, D.G., "Testing Object-Oriented Software", Proceedings 
	of 11th. TOOLS USA Conference, Santa Barbara, Aug 1993, pp 407-426.

Frankl, Phyllis G. and Roong-Ko Doong, "Tools for Testing 
	Object-Oriented Programs", Proceedings of the 8th Pacific
	Northwest Conference on Software Quality, 1990, pp. 309-324.
	One author can be reached at pfrankl@polyof.poly.edu.

Graham, J.A., Drakeford, A.C.T., Turner, C.D. 1993. The Verification, 
	Validation and Testing of Object Oriented Systems, BT Technol
	J.  Vol 11, No 3. One author's email address is
	jgraham@axion.bt.co.uk.

Harrold, Mary Jean, John D. McGregor, and Kevin J. Fitzpatrick, 
	"Incremental Testing of Object-Oriented Class Structures",
	International Conference on Software Engineering, May, 1992,
	ACM, Inc., pp. 68 - 80.

Hoffman, Daniel and Paul Strooper.  A Case Study in Class Testing.
	To be Presented at the IBM Center for Advanced Studies Fall
	Conference, October 1993, Toronto.  Email addresses for authors
	are dhoffman@csr.uvic.ca and pstropp@cs.uq.oz.au.  Describes an
	approach to testing which the authors call Testgraphs.  An
	example is worked out in C++ which tests a commercial class.

Hoffman, D. M.  A CASE Study in Module Testing.  In Proc. Conf. Software
	Maintenance, pp. 100-105. IEEE Computer Society, October 1989.

Hoffman, D.M. and P.A. Strooper.  Graph-Based Class Testing.  In 
	7th Australian Software Engineering Conference (to appear), 1993.

Klimas, Edward "Quality Assurance Issues for Smalltalk Based Applications", 
	The Smalltalk Report, Vol. 1, No. 9, pp.3-7.  The author's
	email address is "ac690@cleveland.freenet.edu".

Lakos, John S.  "Designing-In Quality in Large C++ Projects" Presented
	at the 10th Annual Pacific Northwest Software Quality Conference,
	Portland, Oregon, October 21, 1993.  Abstract:
		The focus of this paper is on ensuring quality by
		designing software that avoids acyclic component
		dependencies.  This in-turn permits incremental,
		hierarchical testing.  The importance of good physical
		design becomes a key factor only for large and very
		large projects.  Intuition gained from smaller projects
		leads to errors in large designs.  Compile-coupling
		("Insulation") is also discussed.
	Copies of the postscript file can be obtained by sending email
	to "john_lakos@warren.mentorg.com".

Leavens, G. T., "Modular Specification and Verification of 
	Object-Oriented Programs", IEEE Software, July 1991, pp. 72-80.

Love, Tom.  Object Lessons.  SIGS Books, 588 Broadway #604, New York, NY 
	10012. $49.
	This book eloquently elucidates the need for testing of object-
	oriented code and has a chapter on how it was done at Stepstone
	during the first release of their initial class library.

Marick, Brian.  The Craft of Software Testing, Prentice-Hall, in press.
	Makes the argument that testing of object-oriented software is
	simply a special case of testing software which retains state
	and which is resused.  The author can be reached at 
	info@testing.com.

Narick, Brian. "Testing Software that Reuses", Technical Note 2, Testing
	Foundations, Champaign, Illinois, 1992. Copies may be obtainable 
	via email. The author can be reached at info@testing.com.

Murphy, G.C., Wong, P. 1992, Towards a Testing Methodology for 
	Object Oriented Systems, M.P.R Teltech Ltd. A poster at the
	Conference on Object Oriented Programming Systems, Languages
	and Applications ACM. Copies of this paper can be obtained
	through townsend@mprgate.mpr.ca.

Murphy, G. and P. Wong.  Object-Oriented Systems Testing Methodlogy: An
	Overview.  Techical Report TR92-0656, MPR Teltech Ltd., October 
	1992.

Perry, D.E. and G.E. Kaiser, "Adequate Testing and Object-Oriented 
	Programming", Journal of Object-Oriented Programming, 
	2(5):13-19, Jan/Feb 1990.

Purchase, Jan A. and Russel L. Winder, "Debugging tools for 
	object-oriented programming", Journal of Object-Oriented 
	Programming, June, 1991, Vol. 4, No. 3, pp. 10 - 27.

Smith, M. D. and D. J. Robson, " A Framework for Testing Object-Oriented 
	Programs", JOOP, 5(3):45-53, June 1992.
	Describes ways in which the usual approach to software testing
	could be adapted for object-oriented software.
	This paper, or one with the same title and authors, is
	available by anonymouns ftp from vega.dur.ac.uk as
	"/pub/papers/foot.dvi".

Smith, M. D. and D. J. Robson, "Object-Oriented Programming - the 
	Problems of Validation",  Proceedings of the 6th International 
	Conference on Software Maintenance 1990, IEEE Computer Society 
	Press, Los Alamitos, CA., pp. 272-281.

Taylor, David. "A quality-first program for object technology", Object 
	Magazine, Vol. 2, No. 2, July-August 1992, pp17-18. SIGs
	Publications.  The article talks some about why testing is
	important for OOP and describes one quality program.

Theilen, David.  "No Bugs.  Delivering error free code in C and C++.",
	Addison-Wesley, 1992, ISBN:0-201-60890-1.

Turner, C. D. and D. J. Robson, "The Testing of Object-Oriented Programs",
	Technical Report TR-13/92, Computer Science Division, School of
	Engineering and Computer Sciences (SECS), University of Durham,
	England.
	Includes a survey of existing literature on testing of OO
	programs.  Testing of OOP is compared with traditional software
	testing.  A state-based approach is described.
	This paper is available by anonymous ftp from vega.dur.ac.uk in
	/pub/papers. Get "toop.ps.Z" for A4 paper and "toopus.ps.Z" for
	US letter paper formatting.

Turner, C. D. and D. J. Robson, "A Suite of Tools for the State-Based
	Testing of Object-Oriented Programs", Technical Report
	TR-14/92, Computer Science Division, School of Engineering and
	Computer Science (SECS), University of Durham, Durham,
	England.  Describes a series of tools for the generation and
	execution of test cases for OOP.  These tools assume a
	state-based testing approach.
	This paper is available by anonymous ftp from vega.dur.ac.uk in
	/pub/papers.  Get "tools.ps.Z" for A4 paper formatting or get
	"toolsus.ps.Z" for US letter formatting.

Turner, C. D. and D. J. Robson, "Guidance for the Testing of Object-
	Oriented Programs", Technical Report TR-2/93, Computer Science
	Division, School of Engineering and Computer Science (SECS),
	University of Durham, Durham, England.  Discusses different
	methods of making class declarations and the implications of
	those methods for testing.
	This paper is available by anonymous ftp from vega.dur.ac.uk in
	/pub/papers.  Get "guide.ps.Z" for A4 paper formatting or get
	"guideus.ps.Z" for US letter formatting.

Turner, C. D. and D. J. Robson, "State-Based Testing and Inheritance",
	Technical Report TR-1/93, Computer Science Division, School of
	Engineering and Computer Science (SECS), University of Durham,
	Durham, England.
	Discusses the implications of inheritance for testing,
	particularily incremental testing.
	This paper is available by anonymous ftp from vega.dur.ac.uk in
	/pub/papers.  Get toopinht.ps.Z" for A4 paper formatting or get
	"toopinhtus.ps.Z" for US letter formatting.

Wong, P. Automated Class Exerciser (ACE) User's Guide.  Technical
	Report TR92-0655, MPR Teltech Ltd., September 1992.
 
> Courses

Berard Software Engineering, Inc. teaches a seminar on Testing of
Object-Oriented Software (TOOS).  The next one scheduled that I know of
is November 8-12, in Washington.  Call 301-417-9884 for details.

Quality Fractals, Inc. has a course called "Testing Object-Oriented
Software".  Contact: 508-359-7273 (Box 337, Medfield, MA 02052).  The
course is taught by Shel Siegel of YESS!, Inc.  Contact: 916-944-1032.


> Software

There is a smalltalk class library in the Univ. of Illinois archives
which includes a simple Tester class written by Bruce Samuelson
(bruce@utafll.uta.edu). It is a general superclass for application
specific classes that test non-interactive objects such as trees,
collections, or numbers. It is not suitable for testing user interface
components such as windows, cursors, or scroll bars. The filein
includes Tree classes, Tester itself, and subclasses of Tester that are
used to validate the Tree classes. For ParcPlace Smalltalk (ObjectWorks
4.1 and VisualWorks 1.0). To get it ftp the file
"/pub/st80_vw/TreeLW1.1" from st.cs.uiuc.edu.

IPL Ltd. (in the UK) has a testing tool called Cantata which allows for
testing C++, but as far as I am able to determine, it has no special
features for C++ testing.  From the product literature:
	Cantata allows testing to be performed in an intuitive way
	making the tool exceptionally easy to use and productive in
	operation. Cantata is suitable for testing software written in
	either C or C++.

	Cantata provides comprehensive facilities for all forms of
	dynamic testing, including: functional testing, structural
	testing, unit testing and integration testing. Cantata has been
	specifically designed to operate in both host and target
	systems and so allow full portability of tests between these
	environments.
For more information contact IPL:
	IPL Ltd.
	Eveleigh House, Grove Street, 
	Bath  BA1 5LR
	UK
	(0225) 444888
	(0225) 444400 (FAX)
	email: shaun@iplbath.demon.co.uk

TestCenter from CenterLine will do coverage testing of C++ (and C)
code.  Also does some memory debugging (similar to Purify) and regression
testing.  Highlights from CenterLine literature:
  *Automatic run-time error-checking on executables to enhance quality 
  *Automatic memory leak detection on executables to optimize memory use
  *Graphical test coverage to highlight any code not executed during test runs
  *Intuitive GUI for easy test analysis 
  *Programmatic interface to output files and cumulative code coverage 
   to support batch-mode and regression testing
  *No recompilation needed, resulting in quick turnaround
  *Complete C and C++ language support
  *Integration with leading programming tools for maximum productivity gains

MicroTech Pacific Research (mpr.ca) has a C++ class testing tool called
ACE (Automated Class Exerciser) which is available under non-disclosure
agreement.  It is not currently for sale.  If you are interested,
contact Paul Townsend, townsend@mprgate.mpr.ca.

Software Research Inc. (625 Third St, San Francisco, CA 94107-1997,
voice: 1-415-957-1441, email: info@soft.com) has a coverage tool for C++
that is called tcat++.  It is an extension of SRI's tcat program.

Quality Assured Software Engineering (938 Willowleaf Dr., Suite 2806,
San Jose, CA 95128, voice: 1-408-298-3824 ) has a coverage tool for
C and C++ called MetaC.  It also dones some syntax checking and memory
allocation checking.

A group of volunteers is building a C++ test harness for the automated
testing of C++, C and Perl programs.  The system is called ETET (Extended
Test Environment Toolkit).  To join the group of volunteers, send email to
	etet_support@uel.co.uk
The software is available via anonymous FTP from bright.ecs.soton.ac.uk
(152.78.64.201) as "/pub/etet/etet1.10.1.tar.Z".  They are looking for
other FTP sites - sned email to the above address if you can provide
one.  This is a beta release and _should_ compile on any POSIX.1 system.
As much of this work is being done by SunSoft, my guess is that the
software will have the fewest problems on SunOS or Solaris releases.

> ACKs

Thanks to the following for helping assemble this list:
	Benjamin C. Cohen, bcohen@scdt.intel.com
	Brian Marick, marick@hal.cs.uiuc.edu
	Bruce Samuleson, bruce@utafll.uta.edu
	Daniel M. Hoffman, dhoffman@uvunix.uvic.ca
	Edward Klimas, ac690@cleveland.freenet.edu
	John Graham, J.Graham@axion.bt.co.uk
	Jim Youlio, jim@bse.com
	Jeffery Brown, jeffrey.brown@medtronic.com
	Lars Jonsson, konlajo@etna.ericsson.se
	Manfred Scheifert, ch_schie@rcvie.co.at
	Mark Swanson, mswanson@mechmail.cv.com
	Mary L. Schweizer, mary@gdwest.gd.com
	Michael Einkauf, Michael_Einkauf@iegate.mitre.org
	Paul Townsend, townsend@mprgate.mpr.ca
	Phyllis G. Frankl, pfrankl@polyof.poly.edu
	Rachel Harrison, rh@ecs.soton.ac.uk
	Risto Hakli, rkh@tko.vtt.fi
	Russ Hopler, russ@bse.com
	Stephane Barbey, barbey@di.epfl.ch
	Tony Reis, tonyr@hpsadln.sr.hp.com
	Yawar Ali, yali@bnr.ca


3.12) What Distributed Systems Are Available?
---------------------------------------------

The following post helps to provide some answers with at least a partial list.
See also Appendix E.

From: rmarcus@bcsaic.boeing.com (Bob Marcus)
Newsgroups: comp.object,comp.client-server
Subject: Distributed Computing Products Overview
Date: 17 Sep 93 00:02:40 GMT
Organization: Boeing Computer Services
           
             DISTRIBUTED COMPUTING PRODUCTS OVERVIEW

  There was a recent posting concerning the relationship between OMG's CORBA
 and Distributed Transaction Processing Monitors. In general, there is a lot of
 uncertainty as to how the various distributed computing tools, products and
 environments might work together.  Below is the outline of an eight-page
 posting to the Corporate Facilitators of  Object-Oriented Technology (CFOOT)
 mailing list addressing these issues. Let me know if you would like a copy
 of the posting and/or to be added to the CFOOT mailing list. 
     
                                          Bob Marcus 
                                          rmarcus@atc.boeing.com
 -----------------------------------------------------------------------
 SOME GENERAL REFERENCES FOR ADDITIONAL INFORMATION 
 -----------------------------------------------------------------------
 MULTIPROTOCOL NETWORK TRANSPORTS

  Peer Logic (PIPES)
  ATT (Transport Layer Interface) 
 -----------------------------------------------------------------------
 MICROKERNELS

  OSF(Mach)
  Chorus Systems (Chorus)
  Microsoft (NT)
 -----------------------------------------------------------------------
 REMOTE PROCEDURE CALLS

  NobleNet (EZ-RPC)
  Netwise (Netwise-RPC) 
  ATT/Sun (TI-RPC)
  OSF (DCE/RPC)
 -----------------------------------------------------------------------
 CONVERSATIONAL PROGRAMMING

  IBM(Common Programming Interface-Communications)
 -----------------------------------------------------------------------
 MESSAGING PRODUCTS

  System Strategies/IBM (MQ Series)
  Horizon Strategies (Message Express) 
  Covia Systems(Communications Integrator)
  Momentum Software(X-IPC)
  Creative System Interface (AAI)
  Digital (DECmessageQ)
  HP (Sockets)(BMS)
  IBM (DataTrade)(DAE)
  Suite Software (SuiteTalk)
  Symbiotics (Networks)
 -----------------------------------------------------------------------
 PUBLISH AND SUBSCRIBE MESSAGING 
 
  Sun(Tooltalk)
  Teknekron (Teknekron Information Bus)
  ISIS(Distributed News)
  Expert Database Systems (Rnet)
 ----------------------------------------------------------------------
 DISTRIBUTED COMPUTING ENVIRONMENTS

  OSF/DCE
  ISIS(Distributed Toolkit)
 -----------------------------------------------------------------------
 TRANSACTION PROCESSING MANAGERS 

  Unix Systems Lab (Tuxedo) 
  Information Management Company (Open TransPort) 
  NCR (TopEnd)
  Transarc (Encina)
  IBM/HP/Transarc (Open CICS)
 -----------------------------------------------------------------------
 DISTRIBUTED WORKSTATION EXECUTION SYSTEMS

  Aggregate Systems (NetShare)
  Platform Computing(Utopia)
  ISIS(Resource Manager)
 -----------------------------------------------------------------------
 OBJECT REQUEST BROKERS 

  Hyperdesk (Distributed Object Manager)
  IBM Distributed System Object Model(DSOM)
  Microsoft (Distributed OLE)
  Iona Technologies Ltd. (Orbix) 
  BBN (Cronus)
  ISIS (RDOM)
  Qualix (NetClasses)
  Symbiotics (Networks!)
  Digital(ACA Services) 
  Suite Software (SuiteDOME)
 -----------------------------------------------------------------------
 SYSTEM MANAGEMENT  

  OSF (Distributed Management Environment)
  Legent
  Digital Analysis (HyperManagement)
 -----------------------------------------------------------------------
 DISTRIBUTED DEVELOPMENT/EXECUTION PRODUCTS   

  Texas Instruments (Information Engineering Facility)
  HP (SoftBench)
  Digital (COHESIONworX) 
 -----------------------------------------------------------------------
 DISTRIBUTED DEVELOPMENT/EXECUTION PRODUCTS   

  Independence Technologies (iTRAN)
  Intellicorp(Kappa) 
  ISIS Distributed Systems (RDOM) 
  Early, Cloud & Company (Message Driven processor)
  Expersoft(XShell)
  Cooperative Solutions(Ellipse)
 -----------------------------------------------------------------------


3.13) What Is The MVC Framework?
--------------------------------

MVC stands for Model-View-Controller.  This framework was originally adopted
in Smalltalk to support Graphical User Interfaces.  Views support graphical
interfacing, controllers handle interaction, and models are the application
objects.  More details and references will be included in future FAQs.

"A Cookbook for Using the Model-View-Controller User Interface Paradigm in
Smalltalk-80".  G. E. Krasner and S. T. Pope.  JOOP, vol 1, no 3, August/
September, 1988, pp 26-49,


3.14) What is Real-Time?
------------------------

Real-time is our linear extrapolation/perception of imaginary time.

[This section is YTBI]


SECTION 4:  COMMONLY ASKED LANGUAGE SPECIFIC QUESTIONS
======================================================

4.1)  What is Downcasting?
--------------------------

Downcasting is the term used in C++ for casting a pointer or reference to
a base class to a derived class.  This should usually be checked with an
embedded dynamic typing scheme if such a scheme is not present in the
language, such as with a typecase (Modula-3) or inspect (Simula) construct.
In C++, it is even possible to use conversion functions to perform some
checks, although the proposed RTTI will perform checked downcasting as
its primary ability.


4.2)  What are Virtual Functions?
---------------------------------

Look under "Dynamic Binding" and "Polymorphism".


4.3)  Can I Use Multiple-Polymorphism Or Multi-Methods In C++?
---------------------------------------------------------------

Yes, but you'll need to embed a dynamic typing scheme to do it.  With dynamic
types in place, an overriding method in a derived class can explicitly check
argument types in a switch statement and invoke the desired method emulating
multiple-polymorphism [See Coplien 92].  

For true CLOS multi-methods, the above technique implemented as a base function
(CLOS defgeneric), switching to specialized functions (CLOS methods, made
friends of all arguments) will provide the functional calling syntax, multiple-
polymorphism and access to parameters found in CLOS.  This can require some
complex switching, which is somewhat mitigated when multiple-polymorphism
is implemented with virtual functions.

Future FAQs should contain more detail.


4.4)  Can I Use Dynamic Inheritance In C++?
-------------------------------------------

Yes, [Coplien 92] describes a scheme where a class can contain a pointer to
a base class that can switch between its derived classes, providing a limited
form.  Earlier chapters contain entries on bypassing C++'s message system and
even bypassing static linking.

Future FAQs should contain more detail.



ANNOTATED BIBLIOGRAPHY
======================

[Agrawal 91]  R. Agrawal et al.  "Static Type Checking of Multi-Methods".
 OOPSLA 91.  Object-Oriented Programming Systems, Languages, and Applications.  
 ACM Press.  Addison Wesley.

  Compile-time checking and optimizations for multi-methods.

[Aho 86] Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman.  Compilers:
 Principles, Techniques, and Tools. Reading, MA: Addison-Wesley, 1986.

  Authoritative, classic book on compilers and optimizations.  Type chapter
  contains section on type inferencing (using ML as an example).

[Berard 93]  Edward V. Berard.  Essays on Object-Oriented Software
  Engineering.  Prentice Hall.

  Many topics on OOSE, includes coverage of OO domain and requirements
  analysis.

[Black 86] A. Black et al.  Object-Structure in the Emerald System.  OOPSLA
 '86 Conference Proceedings, SIGPLAN Notices (Special Issue), Vol. 21, n0. 11,
 pp 78-86.    [I believe there is a more recent article, YTBI]

  The original article on Emerald.  OO language without inheritance but with
  abstract types and static subtype polymorphism.  Also designed for
  distributed programming and reuse.  See article for references: Jade on
  reuse [Raj 89]) and Distr. Prog.

[Black 87] A. Black, N. Hutchinson, E. Jul, H. Levyand L. Carter.  Distribution
 and Abstract Types in Emerald, IEEE Transactions on Software Engineering, Vol.
 SE13, no. 1 Jam., pp 65-76.
 
  Subtype polymorphism for distributed programming in Emerald [Black 86].

[Blair 89] "Genericity vs Inheritance vs Delegation vs Conformance vs ..."
 Gordon Blair, John Gallagher and Javad Malik, Journal of Object Oriented
 Programming, Sept/Oct 1989, pp11-17.

  Recommended by a reader, but the Author has yet to review this article.

[Boehm 86] B.W. Boehm. A Spiral Model of Software Development and Enhancement.
 Software Engineering Notes, Aug., vol. 11 (4), p 22.

 Presents an alternative evolutionary approach to the strict waterfall software
 engineering life-cycle.  Now a classic, most OO methodologies now emphasize
 the iterative or evolutionary approach to software development.

[Booch 87] Grady Booch.  Software Engineering with Ada.  2nd Ed.  Benjamin
 Cummings.

  Booch in his early years.  Mostly object-based programming with Ada.

[Booch 87b] Grady Booch.  Software Components With Ada, Structures, Tools,
 and Subsystems.  Benjamin Cummings.

  A taxonomy and collection of object-based components in Ada (includes code).
  Has many examples with generics.

[Booch 91] Booch, Grady. Object-Oriented Design With Applications.  Benjamin
  Cummings.

  The often referred to book on OOD.  Offers design notation and methodology.
  Brief coverage of OOA and elaborate OOD/P coverage in the applications.
  Good on basic principles and has case studies in Smalltalk, Object Pascal, 
  C++, CLOS and Ada.

  Also contains an *elaborate* classified bibliography on many areas of OO.

[Booch 94]  Grady Booch.  Object-Oriented Analysis And Design With
 Applications, 2nd Ed. Benjamin Cummings.  ISBN 0-8053-5340-2.

  The next FAQ should be updated to the second edition.  All examples are now
  in C++.  Booch incorporates several other major methodologies including
  Wirf-Brock's CRC (Class-Responsibility-Collaboration) and Jacobson's Use-
  Cases.

[Cardelli 85]  L. Cardelli and P. Wegner.  On Understanding Types, Data
 Abstraction, and Polymorphism.  ACM Computing Surveys vol. 17 (4).

 Long, classic article on Object-Oriented Types, Data Abstraction and
 Polymorphism.  Formal coverage with a type system analysis model as well.

[Chambers 92]  Craig Chambers.  The Design and Implementation of the SELF
 Compiler, an Optimizing Compiler for Object-Oriented Programming Languages.
 Dept of Computer Science, Stanford University, March 1992.

  Covers type optimizations for OO compilers.  See Appendix E, PAPERS.

[Chambers 93]  Craig Chambers.  Predicate Classes.  Proceedings ECOOP '93
  O. Nierstrasz, LNCS 707. Springer-Verlag, Kaiserslautern, Germany
  July 1993 pp 268-296

   "... an object is automatically an instance of a predicate class whenever
   it satisfies a predicate expression associated with the predicate class.
   The predicate expression can test the value or state of the object, thus
   supporting a form of implicit property-based classification that augments
   the explicit type-based classification provided by normal classes.  By
   associating methods with predicate classes, method lookup can depend not
   only on the dynamic class of an argument but also on its dynamic value or
   state. [...] A version of predicate classes has been designed and
   implemented in the context of the Cecil language.

  See Appendix E, PAPERS.

[de Champeaux 93] Dennis de Champeaux, Doug Lea, Penelope Faure.
 Object-Oriented System Development.  Addison-Wesley, ISBN 0-201-56355-X.

  Covers an integrated treatment of OOA and OOD.  Takes serious the
  computational model of one thread per object.  Gives more than usual
  attention to the OOA&D micro process.  Presents a unique OOD language.

[Coad 91]  Peter Coad and Edward Yourdon. Object-Oriented Analysis, 2nd ed.
 Englewood Cliffs, NJ. Prentice Hall.

  Coad and Yourdon's OO analysis method.

[Coad 91b]  Peter Coad and Edward Yourdon. Object-Oriented Design.  Englewood
 Cliffs, NJ. Prentice Hall.

  Coad and Yourdon's OO design method.

[Coleman 94] Derek Coleman, et. al.  Object-Oriented Development - The Fusion
 Method.  Prentice-Hall Object-Oriented Series. ISBN 0-13-338823-9

  Fusion is considered to be a second generation OOAD method in that it builds
  on successful components of a number of first generation methods (OMT, Booch,
  CRC, Objectory, etc).  However, this has been done with the requirements of
  industrial software developers in mind. And so issues of traceability,
  management etc. have been taken into consideration and the Method provides
  full coverage from requirements through to code.

[Coplien 92] James O. Coplien.  Advanced C++ Programming Styles and Idioms.
  Addison Wesley.

  Covers advanced C++ programming and performing other more advanced and
  dynamic styles of OO in C++.

[Colbert 89]  E. Colbert.  The Object-Oriented Software Development Method: a
 practical aproach to object-oriented development.  Tri-Ada Proc., New York.

  Presents the Object-Oriented Software development method.  Has emphasis on
  objects.

[Cox 86,91] Cox, Brad J.  Object-Oriented Programming, An Evolutionary
 Approach.  Addison Wesley.

  The original book on Objective-C.  Coverage on object-oriented design and
  programming.  Also covers Objective-C implementation, even into object code.
  
  Objective-C... '91 AW by Pinson and Wiener provide another good text.

[Embley 92]  D.W. Embley, B.D. Kurtz, S.N. Woodfield.  Object-Oriented Systems
 Analysis, A Model-Driven Approach. Yourdon Press/Prentice Hall, Englewood
 Cliffs, NJ.

  Presents the Embley and Kurtz OO methodology.

[Garfinkel 93]  Simson L. Garfinkel and Michael K. Mahoney.  NeXTSTEP
 PROGRAMMING  STEP ONE: Object-Oriented Applications.  Springer-Verlag.

  Introduction to the NextStep environment and applications development.
 
[Goldberg 83] Adele Goldberg and David Robson. Smalltalk-80 The Language and
 Its Implementation.  Addison Wesley.

  The original book on Smalltalk.  Covers implementation.  Also known as "the
  Blue Book".  Out of print.  Superceded by [Goldberg ??].

[Goldberg ??] Adele Goldberg and David Robson. Smalltalk-80: The Language.
 Addison-Wesley. 

  The "Purple Book".  Omits the obsolete abstract virtual machine description
  from the Blue Book.

[Harmon 93] Paul Harmon.  Objects In Action: Commercial Applications Of Object-
 Oriented Technologies.  Jan, 1993.  A-W ISBN 0-201-63336-1.

  Sponsored by the OMG to summarize the use of OO technology in industry and
  business, contains a brief history and summary of OO and many case studies.

[HOOD 89] HOOD Working Group.  HOOD Reference Manual Issue 3.0.  WME/89-173/JB.
 Hood User Manual Issue 3.0. WME/89-353/JB.  European Space Agency.

  Presnets the HOOD (Hierarchical Object-Oriented Design) OOSE methodology.
  From the European Space Agency.  Based on Ada and object-based.

[Hudak 92] Paul Hudak and Simon Peyton Jones.  Haskell Report. SIGPLAN Notices.
 1992, vol 27, no 5.

  Haskell reference.

[Humphrey 89]  Watts Humphrey.  Managing the Software Process.  Addison Wesley.

  Sponsored by the Software Engineering Institute (SEI), the presented project
  management model is inspired by the work of Boehm, Brooks, Demming and Juran
  and represents a strong step in the direction of achieving 6 sigma defect
  rate prevention and optimizing the software development process for quality,
  productivity, and reliability.

[IBM 90,91]  Various Documents from the IBM International Technical Centers:
 GG24-3647-00, GG24-3641-00, GG24-3566-00, GG24-3580-00.

  Present IBM's OOSE methodology.

[Jacobson 92]  Ivar Jacobson, et al.  Object-Oriented Software Engineering - A
 Use Case Driven Approach. ACM Press/Addison Wesley.

  Presents Jacobson's new OOSE methodology based on use cases.

[Jones 92]  Rick Jones. Extended type checking in Eiffel. Journal of Object-
 Oriented Programming, May 1992 issue, pp.59-62.

  Presents subtype polymorphic extension to Eiffel (static typing only).

[Jurik 92] John A. Jurik, Roger S. Schemenaur, "Experiences in Object Oriented
 Development," ACM 0-89791-529-1/92/0011-0189.

  Presents the EVB OOSE methodology.  Also: Barbara McAllister, Business
  Development, EVB Software Engineering, Inc., (301)695-6960, barb@evb.com.

[Kiczales 92] Gregor Kiczales, Jim des Rivieres, Daniel G. Bobrow.  The Art
 of the Metaobject Protocol.  The MIT Press.

  Reflection and Metaobject Protocols (MOPs).  Uses a CLOS subset, clossette,
  as a foundation.

[Kim 89]  Won Kim and Frederick Lochovsky Editors.  Object-Oriented Concepts,
 Applications, and Databases.

  Collection of articles on advanced OO and research systems.

[Lakoff 87] George Lakoff.  Women, Fire, and Dangerous Things: What Categories
  Reveal About The Mind.  UOC Press.

  An almost formal view of classification/categorization by the noted cognitive
  scientist, George Lakoff.  His view blasts objectivism and contends to
  replace it with a subjectivist view, based on a study of humans, natural
  language, and concept formation.

[LaLonde 90]  Wilf R. LaLonde and John R. Pugh.  Inside Smalltalk: Volume 1.
 Prentice Hall.

  Good introduction to Smalltalk.

[LaLonde 90b]  Wilf R. LaLonde and John R. Pugh.  Inside Smalltalk: Volume 2.
 Prentice Hall.

  Excellent coverage of MVC. However, it's based on ParcPlace Smalltalk-80,
  version 2.5, which is obsolete.

[Liskov 93] Barbara Liskov and Jeannette M. Wing.  Specifications and Their use
 in Defining Subtypes.  OOPSLA 93, pp 16-28.  ASM SIGPLAN Notices, V 28, No 10,
 Oct. 1993.  A-W ISBN 0-201-58895-1.

  Specifications on Subtype hierarchies.  Helps to insure the semantic
  integrity of a separate subtype system.  See section 2.7.

[Madsen 93] Ole Lehrmann  Madsen, Birger Moller-Pedersen, Kristen Nygaard:
 Object-oriented programming in the BETA programming language.  Addison-Wesley,
 June 1993. ISBN 0 201 62430 3

  The new and authoritative book on Beta, by the original designers.  They
  are some of the same designers of the Simula languages, originating OO.
  Also just announced:
	Object-Oriented Environments: The Mjolner Approach
	Editors: Jorgen Lindskov Knudsen, Mats Lofgren, Ole Lehrmann Madsen,
		 Boris Magnusson
	Prentice Hall: The Object-Oriented Series
	ISBN: 0-13-009291-6 (hbk)

[Martin 92] James Martin and James J. Odell. Object-Oriented Analysis and
 Design, Prentice-Hall, Englewood Cliffs, NJ.  

  Its primary purpose is to indicate how information engineering (IE) can be 
  evolved to accommodate OO.  The analysis portion (starting at Chapter 15) 
  attempts to go back to 'first principles' and is based on a formal foundation.
  Therefore, the IE aspect is not required.  Emphasis is more on analysis than 
  design.

[Meyer 88] Bertrand Meyer. Object-Oriented Software Construction.  Prentice
 Hall.  [Is there a new edition out?]

  The original book on Eiffel.  Coverage on object-oriented design and
  programming.  Also:
  Bertrand Meyer. Eiffel: The Language. PH. Englewood Cliffs, NJ. 1991(?)

[Mugridge 91] Warwick B. Mugridge et al.  Multi-Methods in a Statically-Typed
 Programming Language. Proc. ECOOP.

  Efficient implementation of Multi-Methods.

[Murray 93] Robert B. Murray.  C++ Strategies and Tactics.  Addison Wesley.

  C++, has template examples.

[Nerson 92] Jean-Marc Nerson.  Applying Object-Oriented Analysis and Design.
 CACM, 9/92.

  Demonstrates the basics of the BON method/notation.  Nerson: marc@eiffel.fr

[Raj 89] R.K. Raj and H.M. Levy.  A Compositional Model for Software Reuse.
 The Computer Journal, Vol 32, No. 4, 1989. 

  A novel approach aading reuse to Emerald [Black 86] without inheritance.

[Reenskaug 91] T. Reenskaug, et al.  OORASS: seamless support for the creation
 and maintenance of object-oriented systems. Journal of Object-Oriented
 Programming, 5(6).

  Presents the Object-Oriented Role Analysis, synthesis, and Structuring
  OOSE methodology.

[Royce 70] W. W. Royce. Managing the Development of Large Software Systems.
 Proceedings of IEEE WESCON, August 1970.

 Introduces the Waterfall Process Model.

[Rumbaugh 91] Rumbaugh James, et al.  Object-Oriented Modeling and Design.
 Prentice Hall.

  The often referred to book on OOA/OOD.  Introduces the Object Modeling
  Technique (OMT) OOA/D notation and methodology.  Has case studies.

[Sciore 89] Edward Sciore.  Object Specialization. ACM Transactions on
 Information Systems, Vol. 7, No. 2, April 1989, p 103.

  A hybrid approach between delegation and classical OO.

[Shlaer 88] Sally Shlaer and Stephen J. Mellor.  Object-Oriented Systems
 Analysis: Modeling the World in Data.

  Credited as the first book proposing an OOA method.

[Shlaer 92] Sally Shlaer and Stephen J. Mellor.  Object Lifecycles: Modeling
  the World in States.

  An addition to [Shlaer 88], provides dynamic modeling with a state-
  transition driven approach.

[Strachey 67]  C. Strachey.  Fundamental Concepts in programming languages.
 Lecture Notes for International Summer School in Computer Programming,
 Copenhagen, Aug.

  Contains original, classical definition of polymorphism.

[Stroustrup 90] Ellis, M.A., Stroustrup. The Annotated C++ Reference Manual.
 Addison Wesley.

  The ARM; the original and definitive book on C++.  Serves as the ANSI
  base document for C++.  Also covers C++ implementation.  It is meant as 
  a reference (including for compiler writers), not as a tutorial for
  beginners.  Perhaps a better ref is [Stroustrup 91].

[Stroustrup 91] Stroustrup, B.  The C++ Programming Language (2nd edition).

  Has the ARM, better reference for the use of C++ (recommended by bs).
  Contains sections on object-oriented software engineering.

[Tasker 93]  Dan Tasker.  The Problem Space, Practical Techniques for
  Gathering & Specifying Requirements. ISBN: 0-646-12524-9.  Avail only from
  author, dant@swdev.research.otc.com.au.

  Object-oriented requirements definition.  Hypertext.  Uses Rumbaugh's OMT as
  a base.  See also APPENDIX D.

[Ungar 87] D. Ungar and R.B. Smith.  The Self Papers. [Entry To Be Completed]

  The documents on Self; a delegation/prototyping language.  Also covers Self
  implementation and optimization.  See also APPENDIX E, PAPERS section.

[Wasserman 90] A.I. Wasserman et al. The Object-Oriented Software Design
 Notation for Software Design Representation. IEEE Computer, 23(3).

  Presents the Object-Oriented Structured Design (OOSD) OOSE methodology.
  Traditional structured techniques to OO, hybrid containing structured
  design and Booch.

[Wegner 87] Peter Wegner. "Dimensions of Object-Based Language Design",
  Proceedings of OOPSLA '87, October 4-8 1987, SIGPLAN Notices
  (Special Issue), V22, No 12, pp168-182, 1987.

[Wikstrom 87] Ake Wikstrom.  Functional Programming Using Standard ML.
 Prentice Hall, ISBN 0-13-331661-0, 1987.

  ML reference.

[Wilkie 93] George Wilkie. Object-Oriented Software Engineering - The
 Professional Developer's Guide. Addison Wesley.

  Covers OOSE, 11 popular analysis and design methodologies with examples,
  comparisons, and analysis, information systems (OODB), and case studies.

[Winter Partners]  Winter Partners 

  A proprietary toolset (OSMOSYS) for OOA and OOD.
  Winter Partners
    London Office:                 Zurich Office:
      West Wing, The Hop Exchange
      24a Southwark Street           Florastrasse 44
      London SE1 1TY                 CH-8008 Zurich
      England                        Switzerland
      Tel. +44-(0)71-357-7292        Tel. +41-(0)1-386-95 11
      Fax. +44-(0)71-357-6650        Fax. +41-(0)1-386-95 00

[Wirfs-Brock 90] Rebecca Wirfs-Brock, Brian Wilkerson, Lauren Wiener.
 Designing Object Oriented Software, Englewood Cliffs, NJ. Prentice Hall.

  Presents a "Responsibility Driven Design" (RDD) with "Class, Responsibility,
  Collaboration" (CRC) technique, a modern and new OOA/OOD methodology.

[Yaoqing 93]  Gao Yaoqing and Yuen Chung Kwong.  A Survey of Implementations
 of Parallel, Concurrent, and Distributed Smalltalk.  ACM SIGPLAN Notices.
 Vol 28, No. 9, Sept 93.

  Covers implementations of Parallel, Concurrent, and Distributed Smalltalk.

[Yourdon 92]  Edward Yourdon.  Decline and Fall of the American Programmer.
 YPCS.

  Excellent coverage of modern software engineering practice and world-class
  software development organizations.



APPENDICES
==========


APPENDIX A  VIPS
================

These are individuals whose names appear in comp.object most often. 
Please send recommendations for *major* VIPS often cited or referenced.

Booch, Grady <egb@rational.com>
-------------------------------

Grady Booch has been an object-oriented Ada advocate for some time.  He's
written books such as Software Engineering with Ada, Software Components
with Ada, and OOD with Applications.  The first two are Object-Based and
the second is primarily Object-Oriented and all use OB and OO notations and
methodologies.  His last notations are often referred to as simply the
"Booch" method or notation and his company, Rational, provides automated
support with a tool named "Rose".  See also APPENDIX D.


Cox, Brad
---------

Founder of Objective-C, which grafts the Smalltalk facilities of an
Object id and a messaging mechanism onto C.  Author of [Cox 87].


Goldberg, Adele  (Alan Kay, Dan Ingalls)
----------------------------------------

One of the founders of Smalltalk (with Alan Kay and Dan Ingalls).  Coauthor
of [Goldberg 83, ??], "Smalltalk-80 The Language and its Implementation".
Smalltalk was invented by a group at Xerox PARC; and a spinoff, ParcPlace, is
now marketing Smalltalk environments (see APPENDIX C).


Meyer, Bertrand <bertrand@eiffel.com>
-------------------------------------

Founder of Eiffel, author of [Meyer 88].  Often posts to comp.lang.eiffel
and comp.object [what a FAQ writer notices].  His company, Interactive
Software Engineering, has a case tool called EiffelCase (see APPENDIX D).


Nygaard, Krysten (and Dahl, Ole-Johan)
--------------------------------------

Inventor of Simula, the first object-oriented programming language.  Also
inventor of object oriented design, for which Simula-67 was considered an
implementation technique.  Now B.B. Kristensen, O.L. Madsen, B. Moller-
Pedersen, and K. Nygaard are working on Beta, their successor to Simula.


Rumbaugh, James
---------------

Part of Rumbaugh, Blaha, Premerlani, Eddy and Lorenson, the authors of
[Rumbaugh 91].  They all work for GE Corporate Research and Development Center
in Schenectady New York and have an OOA/OOD notation/methodology called the
"Object Modeling Technique".  It is a rather formal and complete method often
discussed in comp.object.  OMTool is the name of the CASE system provided by
GE which supports OMT.  See APPENDIX D.


Shlaer, Sally (and Mellor, Stephen J.)
--------------------------------------

>Sally Shlaer            sally@projtech.com
>Project Technology      Training and Consulting using Shlaer-Mellor OOA/RD
>Berkeley, CA            (510) 845 1484

Cofounder of the Shlaer/Mellor OOA/RD method, president of Project Technology.
As shown above, occasionally posts to comp.object [what a FAQ writer notices].


Stroustrup, Bjarne (bs@alice.att.com)
-------------------------------------

Inventor of C++, a C superset, which has probably gained the most widespread
use of any object-oriented language today.  Often found in comp.lang.c++ and
comp.object.



APPENDIX B  OBJECT-ORIENTED DATABASES AND VENDORS
=================================================

This is a list of available Object-Oriented databases.  Thanks go to Stewart
Clamen, who's survey on schema evolution provided a good start.  Additional
short entries are encouraged; please send additions to the author of the FAQ
(and/or to Stewart).

The most recent copy of Stewart Clamen's summary on available databases
support for schema evolution will be available indefinitely via anonymous
FTP from BYRON.SP.CS.CMU.EDU:/usr/anon/OODBMS/evolution-summary.

[Kim 89] covers a few of the research systems below in depth.

Starred entries also have an entry in "APPENDIX E  ANONYMOUS FTP SITES".


TABLE OF CONTENTS

Extended Relational Database Model
 Research Systems
  POSTGRES*     [marketed by Montage]
  Starburst     [IBM almaden, entry NYI]
 Commercial Systems
  Montage       [Research System POSTGRES]

Object-Oriented Data Model
 Research Systems
  AVANCE
  CLOSQL
  ConceptBase*
  COOL/COCOON
  Encore*
  Exodus*
  Machiavelli
  MOOD4-PC*
  OBST/STONE*
  Ode*
  Oggetto
  Orion [marketed as ITASCA, see Entry]
  OTGen
  VODAK
 Commercial Systems
  ArtBASE
  EasyDB (Objective Systems, Sweden)
  GemStone/GeODE
  ITASCA
  Matisse
  NeoAccess
  O2
  Objectivity/DB
  ObjectStore
  Ontos [formerly VBase]
  OpenODB (HP)
  Poet
  Statice
  UniSQL
  Versant

Other Models
 Research Systems  
  GRAS*
  IRIS
 Commercial Systems  
  IDL
  Kala
  Pick

Interfaces
 Research Systems
  Penguin
 Commercial Systems
  Persistence
  Subtlware


EXTENDED RELATIONAL DB MODEL
----------------------------

Research Systems
________________


> POSTGRES (Berkeley)

POSTGRES is an extended-relational database manager that supports
inheritance, user-defined types, functions, and operators, ad-hoc
queries, time travel, a rules system, tertiary storage devices,
and very large typed objects, among other things.  POSTGRES speaks
postquel, a derivative of the quel query language originally
designed at berkeley for the ingres database system.  User functions
may be written in C or in postquel.  C functions will be dynamically
loaded into the database server on demand, and either kind of function
may be executed from the query language.

POSTGRES and the papers that describe it are available free of charge
from toe.CS.Berkeley.EDU (128.32.149.117) in directory pub/postgres.
The code is stored in a directory named after the latest release; at
the time of this writing, that directory is postgres-v4r1.  The list
of officially-supported ports is short (decstations running ultrix 4.x
and sparcstations).  Unofficially, many more are supported -- people
elsewhere have done the ports and distribute their versions of the
code.  The list of unofficial ports is available in pub/postgres as
file UNOFFICIAL-PORT-LIST.

On Type Evolution:
You ask explicitly about type evolution.  We support schema
modification on all classes, including user classes.  This means that
you can add attributes (instance slots) and methods at any time.
Further, since postgres is a shared database system, such changes are
instantly visible to any other user of the class.

The language syntax supports attribute deletion, but the system won't
do it yet.  Since all data is persistent, removing attributes from a
class requires some work -- you need to either get rid of or ignore
all the values you've already stored.

Contact:
Paul Aoki <aoki@cs.berkeley.edu>

The postgres code from uc berkeley is being commercialized by
Miro Systems, Inc.        [This seems to have been updated to Montage]

Contact:
  paula hawthorn (paula@miro.com) 
  dave segleau (dave@miro.com)


Commercial Systems
------------------

> Montage (ORDBMS) [Research System POSTGRES]

From: markh@montage.com (Mark Helfen)
Subject: Montage Database - brief product announcement
Followup-To: sales@montage.com 
Organization: Montage Software, Inc.
Date: Wed, 10 Nov 1993 23:05:03 GMT

The Montage object-relational database management system 
(ORDBMS) is now available from Montage Software, Inc. 

The Montage object-relational database management system 
includes the Montage Server(tm) database engine, the Montage 
Viewer(tm) -- a new visualization tool that simplifies queries of 
complex data -- and Montage DataBlades(tm), specialized modules 
that extend the capabilities of the database for specific applications.  
Montage represents the commercialization of the seven-year 
POSTGRES research project.   

The Montage Server extends the relational database model through 
its ability to handle complex information, and the inclusion of object-
oriented facilities and capabilities.  It uses the familiar relational row-
column metaphor for all data, so that text, numbers and complex data 
are all viewed, managed, manipulated and queried the same way.   
The relational metaphor is extended to allow data of any size and 
complexity to be stored and accessed in the way that is most 
effective.   SQL, used to access and manage data, is extended with 
SQL3-based capabilities to allow the definition of user data types and 
functions.

The Montage Viewer uses visualization technology to organize 
information in visual terms -- by location, shape, color and intensity, 
for example.  Similar to a "flight simulator," the Montage Viewer allows 
the user to visually navigate through data, refining each step by 
"panning" and "zooming" with a mouse.  

A DataBlade is a combination of data types and functions that are 
designed to support a specific application.   Text, Spatial, and Image 
are the first of many DataBlades that will comprise a full-range of 
industry-specific products created by Montage, third parties and 
users based upon their own expertise.    

o     The Text DataBlade expands the database's functionality by 
adding new data types and functions that manage text and document 
libraries, as well as a providing a new access method (Doc-Tree) 
which provides exceptional search performance for text.  

o     The Image DataBlade supports image conversion, storage, 
manipulation, enhancement and management of more than 50 image 
formats, and performs automatic conversion of formats at the user's 
discretion.  

o     Points, lines, polygons and their spatial relationships are now 
supported in the relational model with the Spatial DataBlade.  The 
DataBlade defines nine basic spatial types and makes over 200 SQL 
functions available for use on spatial data, as well as supports the 
R-Tree access method for high speed navigation of spatial data.    

Montage Software was co-founded by Gary Morgenthaler of 
Morgenthaler Ventures and Dr. Michael Stonebraker of the University 
of California, Berkeley, .  Morgenthaler is Montage Software's 
chairman of the board and Stonebraker serves as the company's 
chief technology officer.    Morgenthaler and Stonebraker co-
founded Ingres Corporation (then called Relational Technology, 
Inc.), in 1980.    

FOR ADDITIONAL INFORMATION:

Montage Software Inc. can be contacted at:

email:                        sales@montage.com
phone:                        (510) 652-8000
fax:                          (510) 652-9688

Mailing Address:

Montage Software, Inc.
2000 Powell Street, Suite 1405
Emeryville, CA  94608

OO DATA MODEL
-------------

Research Systems
________________

> AVANCE (SYSLAB)

An object-oriented, distributed database programming language.  Its
most interesting feature is the presence of system-level version
control, which is used to support schema evolution, system-level
versioning (as a way of improving concurrency), and objects with their
own notion of history.  System consists of programming language (PAL)
and distributed persistent object manager. 

REFERENCES: 
        Anders Bjornerstedt and Stefan Britts. "AVANCE: An
        Object Management System".  Proceedings of OOPSLA88.



> CLOSQL (University of Lancaster)

Status:-
CLOSQL is a research prototype OODB designed primarily for prototyping 
various schema evolution and view mechanisms based on class versioning.
The system is built using CommonLISP. It would really only be of interest
to other parties as a research tool.

Requirements:-
Common LISP including CLOS standard. The Graphical user interface requires
the Harlequin LispWorks Tool-kit. The system was built on a Sun4 and
has not been tested on any other platform.

Features:-
As a prototype, CLOSQL is not robust enough to sell. The system is single
user and does not properly support persistence - that is, the data has to
be loaded and saved explicitly. The query language is quite good 
making good use of the functional nature of the environment. 
Methods (LISP and query language only), class versioning and
multiple inheritance are all supported in the data model. Type checking
information is held in the database, but is NOT enforced at present. The
GUI is notable for its support for schema evolution, but otherwise rather
ordinary.

Availability:-
Probably freely available, but as the project was part funded by an
industrial partner, some consultation with them would be necessary before
the system could be released.

References:-
[1]  Monk, S. R. and I. Sommerville, "A Model for Versioning of Classes 
in Object-Oriented Databases", Proceedings of BNCOD 10, Aberdeen. 
pp.42-58. 1992.

[2]  Monk, S. "The CLOSQL Query Language". Technical report No. SE-91-15. 
Computing Dept, Lancaster University, Lancaster, LA1 4YR, UK. 1991.

[3]  Monk, S., "A Model For Schema Evolution In Object-Oriented Database 
Systems", PhD thesis, Dept of Computing, Lancaster University, Lancaster
LA1 4YR, UK. 1992.

On Schema evolution (from original survey):
CLOSQL implements a class versioning scheme (like ENCORE), but employs a
conversion adaptation strategy.  Instances are converted when there is a
version conflict, but unlike ORION and GemStone, CLOSQL can convert instances
to older versions of the class if necessary.

        Aberdeen, Scotland. July, 1992.

Contacts;
Simon Monk:      srm@computing.lancaster.ac.uk
Ian Sommerville: is@computing.lancaster.ac.uk 


> ConceptBase
                                 Version 3.1

The ConceptBase System

ConceptBase is a deductive object management system intended for
conceptual modeling and the coordination of design environments.  It
integrates techniques from deductive and object-oriented databases in
the logical framework of the language Telos.

Key features are

*  hybrid representation with frame-like objects, semantic nets and
   logical specifications

*  extensibility by metaclass hierarchies

*  declarative object-centered query language

*  persistent object management with roll-back capability

ConceptBase follows a client-server architecture.  Client programs can
connect to the ConceptBase server and exchange data via interprocess
communication.  The ConceptBase programming interface allows the users
to create their own client programs in C or Prolog.

The X11-based ConceptBase usage environment offers an extensible
palette of graphical, tabular and textual tools for editing and
browsing the knowledge base.  It includes the CoAuthor tool which
supports multiple author production of hypermedia documents.

ConceptBase Applications

ConceptBase has been developed with partial support from the ESPRIT
projects DAIDA and Compulog.  It serves as a central knowledge manager
in the DAIDA environment for data-intensive information systems.
Further applications range from configuration management, co-authoring
to requirements engineering, reverse engineering, business modeling,
and quality assurance systems.  ConceptBase is used by several research
institutions in Europe and North America for experimental purposes.

Availability

ConceptBase is available for research purposes in a Prolog version
(running under ProLog by BIM 3.1) or as a runtime system.  The
graphical usage environment of ConceptBase is based on the Andrew
toolkit release 5.1.

Version 3.2 (only available as runtime system) will be released in 
August 1993.

A four week test-version of ConceptBase V3.1 is available 
on the FTP server ftp.informatik.rwth-aachen.de in the 
directory pub/CB.  For running the ftp version you must ask for a 
key by email.


Technical Requirements

Machine:  SUN4/Sparc
Main memory:    at least 8 MB
Free swap space:        at least 30 MB
Free space on disk:     at least 18 MB
Operating System:       SUN OS 4.1.1
Environment:            X11 Release 5

Contact

Rene Soiron
RWTH Aachen --- Informatik V
Ahornstr. 55, D-52056 Aachen
Tel/Fax: +49 +241 80 21 501 / 80 21 529
email: CB@picasso.informatik.rwth-aachen.de


Also:
We have developed a deductive object-oriented database called
ConceptBase where everything (tokens, classes, meta-classes
,meta-meta-classes ,attributes, instantiations, specializations) is
treated as an object. That means that you may update the "schema"
(classes) at any time just as any other ordinary object.

The systems has (user-defined and builtin) integrity constraints that
prevent inconsistency (e.g. violation of ref.integrity).  Integrity
constraints in ConceptBase are (as in most other systems) static,
i.e., they are conditions that each database "state" must satisfy.

The data model we use does not distinguish schema level information
(i.e. classes) from instance level information. If you change for
example some classes and this change violates some integrity
constraints, e.g.  some instances now don't have the right attribute
types anymore, then you have the choice either to reject the update or
to change the existing DB. Currently, ConceptBase simply rejects such
updates.  We are thinking of exploiting abduction (see VLDB'90 article
of Kakas&Mancarella) to make more clever reactions in the sense of
"reformatting" instances.

[Manfred Jeusfeld <jeusfeld@forwiss.uni-passau.de>]


> COOL/COCOON (Ulm Universitaet)

The COCOON project was intended to extend the concepts and the
architecture of relational database management systems (DBMSs) beyond
nested relational to object-oriented ones. Based upon the nested
relational DBMS kernel DASDBS, we have built a prototype implementation
of the COCOON model. Key characteristics of COCOON are: generic,
set-oriented query and update operators similar to relational algebra
and SQL updates, respectively; object-preserving semantics of query
operators, which allows for the definition of updatable views; a
separation of the two aspects of programming language "classes": type
vs. collection; predicative description of collections, similar to
"defined concepts" in KL-One--like knowledge representation
languages; automatic classification of objects and views (positioning
in the class hierarchy); physical clustering of subobjects via the use
of nested relations as the internal storage structures; support for the
optimization of both, the physical DB design and query transformation,
by corresponding optimizers.

Project goals are:

- to develop a general formal framework for investigations of all
  kinds of schema changes in object-oriented database systems
  (including schema design, schema modification, schema tailoring, and
  schema integration);
- to find implementation techniques for evolving database schemas,
  such that changes on the logical level propagate automatically to
  adaptations of the physical level (without the need to modify all
  instances, if possible).

In their current paper [see below], schema evolution is used as
example of a general framework for change in OODBs, supporting change
on three levels of database objects: data objects, schema objects, and
meta-schema objects.

Contact: Markus Tresch <tresch@informatik.uni-ulm.de>


REFERENCES:
        M. Tresch and M.H. Scholl. "Meta Object Management
        and its Application to Database Evolution."  In
        _Proceedings of the Eleventh International
        Conference on the Entity-Relationship Approach",
        Karlsruhe, Germany, Oct 1992.  Springer Verlag (to
        appear).


> Encore (Brown University)
email:bpe@browncs.brown.edu

Encore is an object-oriented database system targeted at large scale
software engineering applications which are involved in data modeling.
It was developed at Brown University in the late 1980s.  It is notable
for its special support for long-lived (ie. cooperative) transactions,
popular in design applications, and its support for class versioning.
Objects are never converted, rather, classes are versioned, and the
user can specify filters to make old-style instances appear as new
instances to new applications (and vice versa).


References/Additional Information:

 [] Mary F. Fernandez. OBSERVER: A storage system
    object-oriented applications. Technical Report CS-90-27,
    Brown University, Providence, RI, 1990.

 [] Mark F. Hornick and Stanley B. Zdonik. A shared, segmented
    memory system for an object-oriented database. ACM
    Transactions on Office Information Systems, 5(1):70--95,
    January 1987.

 [] Andrea H. Skarra and Stanley B. Zdonik. Type evolution in an
    object-oriented database. In Research Directions in
    Object-Oriented Programming, MIT Press Series in Computer
    Systems, pages 393--415. MIT Press, Cambridge, MA, 1987. An
    early version of this paper appears in the OOPSLA '86
    proceedings.

 [] Andrea H. Skarra and Stanley B. Zdonik. Concurrency control
    for cooperating transactions in an object-oriented database.
    In Won. Kim and Frederick H. Lochovsky, editors,
    Object-Oriented Concepts, Databases and Applications.
    Addison-Wesley, Reading, MA, 1989.

FTP: Complete source can be found in wilma.cs.brown.edu/pub/encore.tar.Z
See also APPENDIX E.


> Exodus (University of Wisconsin)

EXODUS is a DBMS from the University of Wisconsin.  An overview,
excerpted from the abstract of [CDG+90] reads:

    EXODUS,   an   extensible database    system  project that is
    addressing  data management problems  posed  by  a variety of
    challenging new applications.  The  goal of the project is to
    facilitate   the   fast    development of   high-performance,
    application-specific  database  systems.     EXODUS  provides
    certain  kernel facilities,   including  a versatile  storage
    manager.  In addition, it provides an architectural framework
    for building  application-specific database systems; powerful
    tools   to  help  automate the  generation   of such systems,
    including  a   rule-based query optimizer generator    and  a
    persistent  programming  language;  and libraries  of generic
    software components (e.g., access methods) that are likely to
    be useful for many application domains.

The programming language is called E, an extension of C++. [RC89]

REFERENCES:
(see "ftp.cs.wisc.edu:exodus/bibliography" for a complete list)

[CDG+90] Michael J. Carey, David J. DeWitt, Goetz Graefe,
         David M. Haight, Joel E. Richardson, Daniel T. Schuh,
         Eugene J. Skekita, and Scott L. Vandenberg. The EXODUS
         extensible DBMS project:  An overview. In Stanley B.
         Zdonik and David Maier, editors, Readings in
         Object-Oriented Database Systems, Data Management
         Series. Morgan Kaufmann, San Mateo, CA, 1990. Also
         available as WISC-CS-TR 808.

[CDRS89] Michael J. Carey, David J. DeWitt, Joel E. Richardson,
         and Eugene J. Skekita. Storage management for objects
         in EXODUS. In Won. Kim and Frederick H. Lochovsky,
         editors, Object-Oriented Concepts, Databases and
         Applications, chapter 14. Addison-Wesley, Reading, MA,
         1989. After Carey et al. Object and File Management in
         the EXODUS Database System, Proceedings of the Twelveth
         International Conference on Very Large Data Bases,
         1986.

[GD87]   G. Graefe and D. DeWitt. The EXODUS optimizer
         generator. In U. Dayal and I. Traiger, editors,
         Proceedings of the SIGMOD International Conference on
         Management of Data, San Francisco, CA, May 1987.

[RC89]   Joel E. Richardson and Michael J. Carey. Persistence in
         the E language:  Issues and implementation. Software --
         Practice and Experience, 19(12):1115--1150, December
         1989.


FTP: source code, documentation and a complete bibliography can be
     found at ftp.cs.wisc.edu:exodus/

See also APPENDIX E.


On Schema Evolution (from original survey):
No solution for the problem of schema evolution is provided.
Emulation is rejected by the authors, who claim that the addition of a
layer between the EXODUS Storage Manager and the E program would
seriously reduce efficiency.  Automatic conversion, whether lazy or
eager, is also rejected, as it does not mesh well with the C++ data
layout.  To implement immediate references to other classes and
structures, C++ embeds class and structure instances within its
referent.  The resulting change in the size of the object might
invalidate remote pointer references.

        Joel E.  Richardson and Michael J.  Carey.  "Persistence
        in the E language: Issues and Implementation."  Appeared
        in "Software -- Practice and Experience",
        19(12):1115-1150, December 1989.


> Machiavelli (University of Pennsylvania)

Machiavelli is a statically-typed programming language developed
at the University of Pennsylvania. Its most outstanding innovation 
is the use of conditional typing scheme in its type inference system. 
It does not address type evolution.

[communication with limsoon@saul.cis.upenn.edu]

[Note: Machiavelli is included in this summary because it
       previously incorporated persistence in its data model.]



> MOOD4-PC: Material's/Miniature Object-Oriented Database Prototype for
             NEC/IBM-PC

is an object-oriented database system(OODBS) program developed in the
course of our research project MOOD. The aim of the project MOOD is to
develop a material database system to handle raw material data which
are produced and accumulated in materials research and referred to by
material experts when they face scientific or engineering problems
where the expected behavior of particular materials in particular
environments are crucial importance. We all know that the conventional
database systems do not fulfill this requirement, though they serves
well for bibliographic databases or fact databases which deals with
the standard properties of standard materials.

MOOD4-PC is written in Arity/Prolog and available in source and
executable form via anonymous ftp from:

   ~/pub/mood/mood4
   at mood.mech.tohoku.ac.jp [130.34.88.61]
   
    ~/pub/database/mood
    at ftp.uu.net [192.48.96.9]

    ~/pub/computing/databases/mood
    at src.doc.ic.ac.uk [146.169.2.1]

Although it is true enough to say that MOOD4 is a general purpose
OODBS, it may be appropriate to point out that MOOD4 is significantly
different from what is generally meant by the term, the
Object-Oriented Database System.

That is, OODBSs, in general, consist of two parts:

   (1) Disk storage manager
   (2) Database language to define and manipulate data objects to
       be stored to and retrieved from the disk.

The database language of OODBS is akin to the object-oriented
programming language such as Smalltalk or C++. You can enjoy the full
versatility of these general purpose programming language in writing
application programs with the database language.

As apparent from these, OODBSs, in general, are for programmers who
write application programs which serve end users' needs. MOOD, on the
other hands, is not; it is for end users. It is provided with a user
interface named the object editor or OE in short. With OE, we can;

  (1) Edit class definition objects and save them. This replaces the
      data definition language.

  (2) Edit data objects and save them.

  (3) Create query objects, let the system select data objects which
      match the queries, and browse them.

In the other words, we can do everything necessary to manage and use
database with OE. MOOD, therefore, needs no programming language and,
in fact, has none. In this regard, MOOD may better be categorized to
the OODBS application.

The architecture of MOOD as such is the consequence of the nature of
information to be dealt with in material database. If we describe the
nature with a single word, "variety" will be the one most appropriate. 
No fixed data structure can handle a handful of material data because
their contents differ from one to another. The feature of OODBS
relevant here is not the intimacy with programming languages but the
flexibility of data structure which allows us to construct data
objects with a variety of structures which match the variety in the
information to be dealt with. Upon inputting and retrieving data
objects, end users are forced to face this variety in data structure
since significant information is born in the structures of individual
representations.

Yet, we say that MOOD is a general purpose OODBS. This is not in the
sense that we can develop application programs on it, but in the
sense that it generally supports the essential capabilities of OODBS;

  (1) The abstract data type.

  (2) The nesting of structured data objects.

  (3) The class hierarchy.

  (4) The inheritance of attributes along the hierarchy.

  (5) Matching between objects along their structures with the
      knowledge of the class hierarchy.

For additional features of MOOD4, please consult its manual available
with the program. Although they are biased to the processing of
material data (or, more generally, scientific and technical data),
MOOD with these capabilities can be used in any application domain at
least by the stage where you are to examine how well the pieces of
information of interest are represented in OODBS and how well specific
items of interest are discriminated out from the database as such.

Questions and suggestions on this software which are ever welcome
indeed may be addressed to;
 
     Noboru Ono                                             
     Dept. of Machine Intelligence and Systems Engineering, 
     Faculty of Engineering, Tohoku University.            
     Tel:++22-216-8111,
     Fax:++22-216-8156,
     E-mail:ono@mood.mech.tohoku.ac.jp




> OBST/STONE (Forschungszentrum Informatik [FZI], Karlsruhe, Germany)

The OBject System of Stone --- OBST

The persistent object management system OBST was developed by
Forschungszentrum Informatik (FZI) as a contribution to the STONE
project. This project (supported by grant no. ITS8902A7 from the
BMFT, i.e. the German Ministry for Research) aims at the development
of a software engineering environment for education purposes and is
carried out as a joint project of nine german universities and
research institutions.

An essential feature of STONE is that the object oriented paradigm 
is pursued consequently as a key concept. OBST is the common persistent
object store for all tools within the STONE environment. 


 Data Model
 ---------

The OBST data model can be characterized by the following properties:

 * Schema definition language syntactically similar to C++
 * Support of multiple inheritance
 * Generic classes
 * Abstract classes and methods
 * Distinction between public, protected, and private methods
 * Redefinition of methods
 * Overloading of methods

 Schemas and Containers
 ----------------------

Schemas are compiled by the OBST schema compiler. The compilation
results are instances of classes of the meta schema. From these
instances in a next step interfaces to different programming languages
can be generated. At present the C++ language binding is implemented,
interfaces to Lisp and other languages are planned.

Objects are stored in so-called containers. The container an object
belongs to is determined at the time of object creation and fixed
throughout the object's lifetime. Containers are the units of 
clustering, synchronization, and recovery. Objects can be referenced
by other objects across container boundaries.

 Incremental Loading
 -------------------

OBST provides a mechanism to incrementally load methods. This enables
programs to deal with objects whose type is defined after the program 
itself has been developed. This is useful in systems that provide for 
inheritance and it supports schema evolution. We used it e.g. for
programs that interpret the object base and call methods of the
found objects (for example the below mentioned browser).

 Prototype
 ---------

Since end 1990 the first prototype of OBST is available and is shipped
to interested universities and research institutions. The current
version is publicly available via FTP (see below) since March '92.
Our current mailing list (see below) comprises about 150 persons.

The system comes with the schema compiler, a library of predefined
classes (like Set<Entity>, List<Entity>, String, ...), a graphical
object browser (more a shell than a browser), the structurer and
flattener (STF), tclOBST, and all manuals. For STF and
tclOBST see below.

 Structurer and Flattener
 ------------------------

This is a tool to build objects from bytestrings and flatten objects
down to bytestrings. It is intended to be used when coupling UNIX
tools to the object management system. The user defines a grammar that
describes her objects. Afterwards, the structurer parses an ascii 
text according to the given grammar and creates an OBST object
structure that represents the corresponding parse tree.
The flattener does the inverse transformation, that means it generates
an ascii text from a given OBST object structure according to the given
grammar.

 tclOBST
 -------

tclOBST is a library which provides an embedding of OBST into the
interactive tool command language tcl, developed by John Ousterhout
at the University of Berkeley.
Based on the standard tcl shells, which are also comprised in the
tclOBST distribution, tclOBST offers interactive access to the complete
functionality modeled by OBST schemata.


 System Requirements
 -------------------

For the prototype's installation a C++ compiler (GNU g++ 1.37 or 
later 1.4* or 2.3.3 or AT&T 2.0/2.1/3.01) and the X-Windows system 
(currently X11R4 or X11R5) for the graphical tools are required. 
Installation is well-tried on SUN 4/* systems and should be no problem 
on other UNIX machines, too.

 --------------------------------------------------------------------

For more information please mail to:

                Forschungszentrum Informatik (FZI)
                       STONE Projekt
                 Haid-und-Neu-Strasse 10-14
                     D-76131 Karlsruhe
                          Germany

or email to:  stone@fzi.de

Phone:        ++49-721-9654-601
Fax:          ++49-721-9654-609
Teletex:      721 190 fziKA

The OBST system is available via anonymous FTP from ftp.fzi.de
[141.21.4.3]. The system can be found in the directory /pub/OBST/OBST3-3.3

Sites interested in getting information about new OBST developments
are welcome to register in our mailing list. This can be done
by sending an email with subject "obst-mailing-list" and contents
"SUBSCRIBE <firstname> <surname> <email-adr>" to stone@fzi.de.
If the subscription was successful you will receive a confirmation.

Bug reports should contain a small example program with which the
bug can be reproduced, or at least a detailed description of the
observed phenomenon. 

Besides bug reports we are strongly interested in all experiences
our users make with OBST (e.g. sufficiency of data model, performance,
...) and in our users' application areas and the applications as
well. So, please don't hesitate to send us a short note.

Best regards and happy OBST programming.

   The OBST Team


 ---

BTW "Obst" is the German word for "fruit",
    so have a fruitful time with OBST!


> Ode

                                 Ode 2.0
                       An Object-Oriented Database

       C++ Compatible, Fast Queries, Complex Application Modeling,
       Multimedia Support, and more

See APPENDIX E, Databases, for description.


> Oggetto, University of Lancaster, UK.

Developed at the University of Lancaster, UK.  Summary NYI.

"Oggetto: An Object Oriented Database Layered on a Triple Store",
J.A. Mariani, The Computer Journal, V35, No 2, pp108-118, April 1992.


> ORION (Now marketed as ITASCA)

ORION was a prototype OODBMS developed at MCC, an American consortium by Won
Kim and his group.  Won Kim has left MCC and formed a new company, UniSQL, in
Austin, with a new product of the same name.

See also entry under "ITASCA".

REFERENCES:

I have found nearly a dozen papers published by the ORION folks.
Overviews at various stages in its development and commercialization
can be found in:

[KBGW91] Won Kim, N. Ballou, J.F. Garza, and D.; Woelk. A
         distributed object-oriented database system supporting
         shared and private databases. ACM Transactions on
         Information Systems, 9(1):31--51, January 1991.

[KGBW90] W. Kim, J.F. Garza, N. Ballou, and D. Woelk.
         Architecture of the orion next-generation database
         system. IEEE Transactions on Knowledge and Data
         Engineering, 2(1):109--24, March 1990.

[KBCG89] Won Kim, Nat Ballou, Hong-Tai Chou, and Darrell Garza,
         Jorge F. Woelk. Features of the ORION object-oriented
         database system. In Won. Kim and Frederick H.
         Lochovsky, editors, Object-Oriented Concepts, Databases
         and Applications, chapter 11. Addison-Wesley, Reading,
         MA, 1989.

[KBC+88] Won Kim, N. Ballou, Hong-Tai Chou, J.F. Garza,
         D. Woelk, and J. Banerjee. Integrating an
         object-oriented programming system with a database
         system. In Proceedings of the ACM Conference on
         Objected-Oriented Programming:  Systems, Languages and
         Applications (OOPSLA), pages 142--152, San Diego, CA,
         September 1988. Published as ACM SIGPLAN Notices
         23(11).
         [Pointers to the previous papers documenting each of the
          advanced features listed above are cited therein.]


The paper most relevant to the issue of schema evolution is the
following:

[BKKK87] J. Banerjee, W. Kim, H-J. Kim, and H.F. Korth.
         Semantics and implementation of schema evolution in
         object-oriented databases. In U. Dayal and I. Traiger,
         editors, Proceedings of the SIGMOD International
         Conference on Management of Data, San Francisco, CA,
         May 1987.


You might also like to look at Kim's book, which provides a good
introduction to OODBMS, while focusing on the ORION work:

[Kim90]  Won Kim. Introduction to Object-Oriented Databases.
         Computer Systems. MIT Press, Cambridge, MA, 1990.


> OTGen (Carnegie Mellon University/UMass Amherst)

OTGen is a design for a system to support schema evolution in
object-oriented databases.  The chief contribution of OTGen is support
for programmer extensibility of transformation functions to allow a
system to support a wide range of schema changes, not just those that
can be easily automated.  While OTGen was never implemented, it is
based on the implementation of TransformGen, a system to support the
evolution of the specialized databases used by Gandalf programming
environments.  For more information on OTGen and TransformGen, please
see: 

Barbara Staudt Lerner and A. Nico Habermann, "Beyond Schema Evolution
    to Database Reorganization", in Proceedings of the Joint ACM 
    OOPSLA/ECOOP '90 Conference on Object-Oriented Programming:
    Systems, Languages, and Applications, Ottawa, Canada, October
    1990, 67-76. 

Barbara Staudt, Charles Krueger, and David Garlan, TransformGen:
    Automating the Maintenance of Structure-Oriented Environments, 
    Computer Science Department Carnegie-Mellon University, Technical 
    Report CMU-CS-88-186, November 1988.

David Garlan, Charles W. Krueger, and Barbara J. Staudt, "A Structural
    Approach to the Maintenance of Structure-Oriented Environments",
    in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering
    Symposium on Practical Software Development Environments, Palo
    Alto, California, December 1986, 160-170.

Contact:
Barbara Lerner
blerner@cs.umass.edu


> VODAK

Research in the framework of VODAK focuses on an extensible data
model and database programming language, an advanced transaction
model, object-oriented query language, and support for multimedia data.

The VODAK Data Model Language VML

Usually database models lack mechanisms for extending them with
additional modeling primitives. This limitation does not allow the
adaptation of the models for specific application needs, e.g. database
integration, multimedia document handling, hypertext modeling, etc.

The VODAK Model Language VML  homogeneously integrates the concept of
metaclasses and the separation of types and classes with other
object-oriented concepts such as properties, methods, inheritance, and
object identity. Complex nested data structures can be defined using
the set, array, tuple, and dictionary type constructors. VML supports
its own programming language for implementing methods, specifying
transactions and an ad hoc query language.

In VML classes are used to organize a set of objects corresponding to
real world entities and relationships between them. Object types define
the structure of objects and the operations defined on these
structures.  They are associated with classes in order to determine the
structure and behavior of the class' instances. Metaclasses are first
class objects whose instances are classes. Metaclasses are associated
with three object types: an (optional) own-type extending their own
behavior, an instance-type specifying the behavior of their instances
(which are classes), and an  instance-instance-type specifying the
behavior of the instances of their instances.  Metaclasses can be
organized in an instantiation hierarchy of arbitrary depth.

This approach leads to an open, adaptable data model which provides for
the specification of additional modeling primitives at a meta layer of
the database schema. The concept of metaclasses and the separation of
classes and types allow to determine the structure and behavior of
objects and the individual inheritance behavior via semantic
relationships between arbitrary objects already at the meta layer
independently from the specifications given at the application layer
for the application specific classes.


The VODAK Transaction Model

In VODAK, we focus on two specific problems of transaction management.

1. Operations to read and edit (hyper)documents are typically complex,
interactive and of long duration. A high degree of concurrency is
required to reduce the number and length of times a transaction is
blocked.

2. A publication environment has to handle existing database systems
for using and modifying remote information and documents.  Transaction
managers of existing systems, i.e. concurrency control and recovery,
have to be integrated in a transparent way utilizing the functionality
of existing managers.

Our transaction model is based on open nested transactions. Compared to
conventional flat transactions, nested transactions allow more
concurrency and are more flexible for recovery.  A nested transaction
is a tree-like structure, dynamically built up by the call of
subtransactions until a bottom implementation level is encountered.

We extended the open nested model from a fixed calling hierarchy of
operations in a layered system (multi-level transactions) to an
arbitrary calling hierarchy of operations in an object-oriented system.
Commutativity of operations is applied to system defined VODAK methods,
and to methods of user defined object types.  For the second type of
operations, we developed a framework to specify commutativity and
inverse operations in VML.

Query Processing

Although nearly all object-oriented data models proposed so far include
behavioral aspects, most object-oriented query languages, algebras and
query optimization strategies simply adapt relational concepts since
they focus on the complex structures of objects and neglect the
behavior. We claim that this approach is not sufficient since it does
not reflect the much richer semantics methods can carry which have to
be taken into account for really efficient query processing. The quite
straightforward approach we consider is to integrate methods in an
algebraic framework for query processing and to make there partial
knowledge about methods available in the form of equivalences. We
integrate algebraic set operators with methods defined in database
schemas within an object-oriented data model. We investigate the impact
on the architecture of the query processor when the algebra becomes an
extendible component in query processing.

Multimedia Support

The V3 Video Server was built as a demonstration showing a multimedia
application developed on top of the VODAK database management system.
The V3 Video Server allows a user to interactively store, retrieve,
manipulate, and present analog and short digital video clips. A video
clip consists of a sequence of pictures and corresponding sound.
Several attributes like author, title, and a set of keywords are
annotated.

In the future, the VODAK DBMS will be enhanced with new built-in
functionality for multimedia datatypes. Therefore, existing components
of VODAK must be changed and new ones must be added to support time
dependencies, high data volumes, and user interaction.

Query Processing

Although nearly all object-oriented data models proposed so far include
behavioral aspects, most object-oriented query languages, algebras and
query optimization strategies simply adapt relational concepts since
they focus on the complex structures of objects and neglect the
behavior. We claim that this approach is not sufficient since it does
not reflect the much richer semantics methods can carry which have to
be taken into account for really efficient query processing. The quite
straightforward approach we consider is to integrate methods in an
algebraic framework for query processing and to make there partial
knowledge about methods available in the form of equivalences. We
integrate algebraic set operators with methods defined in database
schemas within an object-oriented data model. We investigate the impact
on the architecture of the query processor when the algebra becomes an
extendible component in query processing.

The VODAK Prototype

The system architecture consists of a central database environment and
several external database environments to which the user wants to have
integrated access. Each of these environments consists of an object
manager, a message handler, a transaction manager, and a communication
manager. In addition to these components an external database
environment includes a database interface module which realizes the
access to an external database system.

The DBMS components are currently built on top of DAMOKLES and will be
in the near future on top of ObjectStore.

A first version of a C++ based prototype of VODAK is available for Sun
Sparc Stations under certain conditions.  It implements all the
features specified in including e.g. metaclasses, transactions, and
remote message execution.

References

P. Muth, T. Rakow, W. Klas, E. Neuhold:  A Transaction Model for an
Open Publication Environment.  A. K. Elmagarmid (Ed.): Database
Transaction Models for Advanced Applications. Morgan Kaufmann
Publishers, San Mateo, Calif., 1992.

Wolfgang Klas, Karl Aberer, Erich Neuhold Object-Oriented Modeling for
Hypermedia Systems using the VODAK Modeling Language (VML) to appear
in: Object-Oriented Database Management  Systems, NATO ASI Series,
Springer Verlag Berlin Heidelberg, August 1993.

Karl Aberer, Gisela Fischer Object-Oriented Query Processing: The
Impact of Methods on Language, Architecture and Optimization
Arbeitspapiere der GMD No. 763, Sankt Augustin, July 1993.

T.C. Rakow, P. Muth The V3 Video Server: Managing Analog and Digital
Video Clips, Sigmod 93, Washington, DC.

For further information contact

{aberer,muth,rakow,klas}@darmstadt.gmd.de

  GMD-IPSI                                             
  Dolivostr. 15                                                           
  D-64293 Darmstadt
  GERMANY    
                                    
  FAX: +49-6151-869 966   


Commercial Systems
__________________

> ArtBASE  (Object-Oriented Data Model)

by:     ArtInAppleS Ltd.
        Kremelska 13
        845 03 Bratislava
        SLOVAKIA
        Phone: x42-7-362-889
        fax:   x42-7-777 779
        EMail: artbase.support@artinapples.cs

Distributor for Germany:
        ARS NOVA Software GmbH
        Stettener Strasse 32/3
        73732 Esslingen a.N.
        Germany
        Phone: x49-711 3704001
        Fax:   x49-711 3704001
        EMail: info@arsnova.stgt.sub.org

Languages: Objectworks\Smalltalk by ParcPlace Systems, Inc.

Platforms: Unix, PC Windows, Macintosh

Features:
- Fully implemented in Objectworks\Smalltalk
  (ArtBASE is delivered with source code)

- ArtBASE extents Smalltalk of persistency. Persistent objects are handled the
  same way as transient objects.

- Optimistic and pessimistic concurrency control.

- Transactions, including long lived transactions

- User concept with access restrictions

- storing of classes and methods in the database - entire applications 
  may be stored in an ArtBASE database, including the data AND the 
  application classes

- Currently, a single user version is available. The Distributed Multi User Server Version
  will be presented at the OOPSLA'93 at Washington D.C. in September 1993 for Unix
  environments and PCs.

- Existing applications can be turned to database applications very easily using ArtBASE


> EasyDB (Objective Systems, Sweden)

EasyDB features a (programming language independent) Data Definition
Language (DDL) for the definition of schemas.  It relies on the
Entity-Attribute-Relationship model.  Data Manipulation Languages
(DML) include a Navigational Query language (NQL) embedded in a host
language (C available now, Ada in January '93), and a generic C++
class library.

On Schema Evolution (from original survey):
The schema may be freely extended with new items (types, domains,
attributes, entities, relationships etc.). Deletion of items is not
allowed.

Data created with an older schema may co-exist with newer data. Old
applications need not be recompiled when the schema is updated.
Attempts by newer applications to access `older' data in an
inconsistent way are detected and reported via an exception handling
system.

[Tomas Lundstrom <tomas@os.se>]

Objective Systems SF AB (Ericsson)
Box 1128
S-164 22 Kista, Sweden
tel : +46-8-703-4591
fax : +46-8-750-8056
contact: Jaan Habma, jaan@os.se


> GemStone (Servio Logic)

First introduced in 1987, Servio's GemStone is the oldest commercial ODBMS
available today. GemStone is particularly well suited for use in complex
multi-user, multi-platform client/server applications. It supports
concurrent access from multiple external languages, including Smalltalk-80,
Smalltalk/V, C++ and C. GemStone also provides a dialect of Smalltalk as an
internal DML, which can execute methods or entire applications in the
database.

Servio also offers GeODE (GemStone Object Development Environment), an
object database application development environment which allows developers
to build complete object applications visually, without writing code. With
GeODE's visual programming tools, programming an application is a matter of
wiring together graphical representations of encapsulated code blocks. A
simple extension mechanism promotes the re-use of code, thereby increasing
the speed of program development. Also, association of application user
interface elements with database objects is established through simple
graphical tools. GeODE applications are stored and run in the GemStone
database, and so are both self-porting and network-aware, and can be
accessed externally from any of the GemStone language interfaces. Because
of GemStone's network architecture, Geode applications can operate easily
in a client/server environment.


 ==============================================================================

GEMSTONE

GemStone is a highly scalable client-multiserver database for commercial
applications. GemStone's features include:

o  Active Database -- GemStone allows database application developers to
   write methods which are stored and executed directly in the database.
   These methods can be accessed either internally, or from external client
   applications. This can significantly reduce network traffic and allow
   applications to take advantage of the superior compute power of the
   server. This also eliminates the need to rebuild and re-deploy
   applications whenever application or business processing rules change.
   This in turn allows for centralized code development and management,
   architecture-independent code that ports itself to new platforms,
   reduced network usage, and true client/server applications that share
   compute load between client and server machines.

o  Concurrent Support for Multiple Languages -- GemStone provides
   concurrent support for applications developed in Smalltalk, C++, C or
   GeODE. All applications, regardless of language, can have simultaneous
   access to the same database objects.

o  Flexible multi-user transaction control -- Multiple users can
   operate in the database simultaneously, with a variety of transaction
   control modes available.

o  Object-level security -- Authorization control can be applied to any
   object in the database, allowing for fine tuning of object security.

o  Dynamic schema and object evolution -- GemStone supports schema
   modification through class versioning and allows full migration of
   objects between versions of their classes with a simple message send.
   Migration is fully customizable and is undoable.

o  Production Services -- GemStone delivers the full suite of features
   required in any production-ready networked database including online
   backup, rapid recovery, referential integrity, sophisticated concurrency
   control, and event signals and notifiers.

o  Scalability -- In a recent independent benchmark, GemStone scaled to
   support more than 1,000 simultaneous log-ins and 100 concurrent active
   users on a mid-sized SMP server.

o  Legacy Gateways -- GemStone incorporates gateways or data bridges
   that allow object applications to integrate legacy data, whether in SQL,
   IMS, VASM or other formats. The level of integration between GemStone
   and legacy data and applications can range from simple query access to
   extensive read-write interoperability.


 ==============================================================================

GEODE

GeODE is a comprehensive environment for rapidly designing, building and
deploying production-quality commercial object applications. Its design
promotes code reuse in a team programming environment for increased
productivity. GeODE consists of six main elements:

o  Visual Application Manager -- Provides centralized management
   of each application and its component parts, and a namespace for
   addressing known objects.

o  Visual Schema Designer -- Allows the development of database schema
   visually, making the process more interactive and intuitive than with
   object-oriented programming languages. It also provides analysis tools
   for examining an existing schema.

o  Visual Forms Designer -- The Forms Designer reads GemStone class
   definitions and an associated data dictionary to automatically create
   default forms suitable for simple data entry. These forms can be rapidly
   customized, using a wide selection of user interface components and
   field types, which include image and sound support, and a large set of
   form design aids. The list of field types can be extended interactively.

o  Visual Program Designer -- The Visual Program Designer allows developers
   to visually create and modify the behavior of an application without
   having to write code. Programs are created by connecting visual program
   blocks to field blocks drawn from the forms created in the Forms
   Designer. A large collection of predefined program blocks is provided
   with GeODE, and users can extend the catalog in any of a number of
   simple ways. Code-based programming can be integrated routinely.

o  Developer Class Library - GeODE comes standard with more than 480
   classes and thousands of methods, and is easily extended for handling
   specialized applications. In a team environment, some programmers can
   develop visual applications while others write new methods that are
   encapsulated into visual program blocks for easy reuse.

o  Developer Tools -- GeODE includes tools for debugging, browsing and
   inspecting applications. Included in this set of tools are several
   debuggers, browsers, inspectors, an object clipboard, an image editor,
   and a code profiler for performance analysis.


 ==============================================================================

PLATFORMS

GemStone release 3.2 and GeODE 2.0 and all language interfaces are
available for UNIX workstations and servers from SUN, HP, IBM, Sequent, and
DEC. Client-only support is available in a number of languages for Windows
3.1, OS/2 and Macintosh. Servio is an active member in the Object
Management Group and the ANSI Smalltalk standardization committee. Servio
supports SUN ODMG, ANSI C++ and intends to comply fully with the emerging
standards.

 ==============================================================================

REFERENCES

  [Maier, et al. 84] D. Maier, J. Stein, A. Otis, A. Purdy, ``Development
  of an object-oriented DBMS'' Report CS/E-86-005, Oregon Graduate Center,
  April 86 - ACM 0-89791-204-7/86/0900-0472

  R.G.G. Cattell: Object Data Management - Object-Oriented and Extended
  Relational Database Systems; Addison-Wesley. ISBN 0-201-53092-9

  Robert Bretl, David Maier, Allan Otis, Jason Penney, Bruce Schuchardt,
  Jacob Stein, E. Harold Williams, Monty Williams. "The GemStone Data
  Management System." Chapter 12 of "Object-Oriented Concepts, Databases
  and Applications", by Kim and Lochovsky.


 ==============================================================================

CONTACTS

 === Headquarters - San Jose ====

Servio Corporation
2085 Hamilton Avenue
Suite 200
San Jose  CA  95125

Tel: 800-243-9369
Tel: 408-879-6200
Fax: 408-369-0422

 === Chicago ====

Servio Corporation
8410 Bryn Mawr
Suite 400
Chicago  IL  60631

Tel: 312-380-1310
Fax: 312-380-1308

 ===  New York ====

Servio Corporation
1120 Avenue of the Americas
4th Floor
New York  NY  10036

Tel: 212-626-6680
Fax: 212-626-6684

 === Dallas ====

Servio Corporation
14875 Preston Road
Suite 550
Dallas  TX  75240

Tel: 214-980-7073
Fax: 214-980-2949

 === Europe/UK ====

Servio UK
Criterion House
Beauchamp Court, Victors Way
Barnet  EN5 5TZ  England

Tel: +44 81 447-0800
Fax: +44 81 447-0577

 === Japan ====

Servio Corporation
Daito-Eiwa Building, 7F
5-11 Nihonbashi-Hakozakicho
Chuo-ku  Tokyo 103  Japan

Tel: +81 3 3660-1910
Fax: +81 3 3663-3287

 =====================
 === Distributors ====
 =====================

 === Germany, Austria, Switzerland ====

ObjectOriented System Technologies
Baroper Str. 337
Dortmund  50  W-4600
Germany

Tel: +49 231 975 990
Fax: +49 231 975 99-20

 === Japan ====

Japan Information Processing Co., Ltd.
6-7 Kabutocho, Nihonbashi
Chuo-ku  Tokyo 103  Japan

Tel: +81 3 3668-6170
Fax: +81 3 3668-1428

 ---

Nexus Technology K.K.
Suite 901
Botan 3-11-1
Koto-ku  Tokyo 135  Japan

Tel: +81 3 3660-1910
Fax: +81 3 3663-3287

 === Taiwan ====

Anco Technologies
11-1F, 76 Tun Hwa S. Road, Sec. 2
Taipei
Taiwan, R.O.C.

 === Italy ====

Etnoteam S.P.A.
Via Adelaide Bono Cairoli 34
Milano  20127  Italy

Tel: +39 2 261 621
Fax: +39 2 261 10755

 === England ====

AI International Ltd.
1 Parkview Road
Berkhamsted
Herts  HP4 2EY  England

Tel: +44 442 876 722
Fax: +44 442 877 997

 ==== Mexico ====

TEIX, Sistemas de Informacion
Estrategica S.A. de C.V.
Antonio M. Anza No. 43
Col Roma  Mexico D.F.  06700

Tel: +52 5 564-7146


> ITASCA
                       ITASCA ODBMS V2.2

                      Itasca Systems, Inc.
                       7850 Metro Parkway
                      Minneapolis, MN 55425
                        sales@itasca.com
                         (612) 851-3155

                          Sandy Miezwa
                         (612) 851-3169

Introduction

Itasca Systems develops, markets, and supports ITASCA, a distributed 
active object database management system and related tools. The initial 
research work for ITASCA occurred in the Object-Oriented and Distributed 
Systems Lab at the Microelectronics and Computer Technology 
Corporation (MCC) in Austin, Texas. The research was known as the 
ORION prototypes. 

The ITASCA Distributed ODBMS is a language neutral, full-featured, active 
object database that supports data access from various object
languages. ITASCA allows clients to transparently access data that is
distributed among multiple servers.  ITASCA supports full dynamic schema
modification that can be performed during any phase of the software
lifecycle.  Applications written in dissimilar and incompatible languages,
such as C++ and CLOS, share objects through ITASCA. ITASCA stores methods
inside the database, promoting reusability and maintainability.  The only
commercial ODBMS based upon the MCC Orion technology, ITASCA is considered
by many to be the most feature-rich ODBMS on the market today.

This overview describes release 2.2 of the ITASCA Distributed Object 
Database Management System. It describes how ITASCA functions, 
outlines its implementation features, and explains some of the system 
benefits. 


History of ITASCA

ITASCA is based on a series of object database research prototypes. Work 
on these prototypes began in 1985 at the Microelectronics and Computer 
Technology Corporation (MCC) Object-Oriented and Distributed Systems 
Laboratory. MCC released the first prototype, ORION-1, in May, 1987, as 
a single-user system. MCC extended ORION-1 to the ORION-1SX 
prototype system and released it to the shareholder companies in April, 
1988. ORION-1SX was a multi-user system with a multi-client, single 
server architecture. The third prototype, ORION-2, introduced a distributed, 
object-oriented architecture for a multi-user environment. MCC released 
the third prototype to shareholder companies in July, 1989. ORION-2 has a 
multi-client, multi-server architecture. Having met its objectives, MCC 
stopped all work on ORION at that time. Over five million dollars was spent
for the three generations of prototypes.

The ITASCA product is an extension and commercialization of the ORION-2
prototype from MCC. Itasca Systems has added major enhancements and
features, improved the performance, and strengthened the code. It now runs
on UNIX systems from multiple vendors. ITASCA is an industrial-strength,
documented product, fully supported by Itasca Systems, Inc. Itasca Systems
continues to develop tools and other products to work with ITASCA.


Overview

ITASCA employs a distributed architecture with private and shared objects 
spread across UNIX-based computers on a local-area network. The 
ITASCA model follows the object-oriented view that uniformly models any 
real-world entity as an object. Each object has a unique identifier along with 
a state and behavior. Attributes represent the state of an object. Methods 
(code) define the behavior of an object. A class object collects objects that 
share the same set of attributes and methods. Subclasses derive from 
existing classes. The resulting schema, or database definition, is a class 
hierarchy. Each subclass inherits all the attributes and methods of its 
superclasses. ITASCA supports multiple inheritance. A subclass may derive 
from more than one superclass. 

One of the breakthroughs of object-oriented technology is the reusability of 
code. ITASCA allows for the active management of both reusable code and 
data in an integrated system. Developers may write applications in C++,
CLOS, C or Common Lisp. This means ITASCA is language neutral. Objects 
stored using one programming language can be accessed by other 
programming languages. It also means an application program need not be
written in an object-oriented language. 

The ITASCA database management system has features belonging to most any 
database system. This includes persistent storage for data and schema, 
concurrency control and locking, transaction management, multiple 
security levels, and logging and recovery for both CPU and disk media 
failure. Additional features of ITASCA include dynamic schema 
modification, long-duration transactions, shared and private databases, 
distributed version control, distributed transaction management, distributed 
query management, distributed change notification, object migration, and 
an extensible architecture.

Shared and private databases exist in a distributed environment in ITASCA. 
The shared database is distributed across workstations (sites) in a network. 
An ITASCA server controls the partition of the shared database at each site. 
ITASCA clients provide transparent access to the various partitions of the 
shared database. The architecture allows any number of private databases at 
each distributed database site. Data can move between private and shared 
databases. Private databases allow private data that is not shared with other 
users of the database.

ITASCA stores the schema redundantly at each site to improve 
performance. The schema storage also includes code in the form of 
methods. Management of schema updates is automatic for all sites. This 
includes sites that were off-line during any changes. Automatic distribution 
of schema changes, including method code changes, simplifies database 
administration.

ITASCA stores each instance of data in one site. The system or a user may 
move the data from one site to another to improve data locality. Access to 
moved data remains transparent. There is no need for a user or application 
to know the specificlocation of data in the ITASCA distributed database. 
ITASCA will automatically find the location of the data. This simplifies 
distributed application development. The developer can rely on ITASCA 
finding data in the distributed database.

No single site acts as a master site, thus ITASCA's architecture has no 
single point of failure. ITASCA has neither a central data server nor a 
central name server. This is important for maintaining a database system 
with high availability in a networked workstation environment.

ITASCA supports dynamic schema modification to create a flexible 
environment for changing or customizing a database system. Authorized 
users can add and remove attributes or change the subclass/superclass 
relationship at any time. Authorized users can also add or remove partitions 
of the shared database at any time. All this can be done interactively without 
affecting other parts of the ITASCA database at the time changes occur to 
the schema. There is no need to "bring the system down" or off-load/reload 
data to restructure the database. Dynamic schema modification can 
significantly reduce maintenance costs. It also is useful in environments 
where change to data definitions are normal or relatively frequent.

ITASCA has a sophisticated security authorization technique tied to the 
class hierarchy. It supports both positive and negative authorizations at any 
level in the class hierarchy. For example, granting access to all objects but 
one requires only two authorizations: a global grant followed by a specific 
denial. Authorization extends to classes, instances of classes, attributes, 
and methods. Also, inheritance of authorization reduces the work of database 
administration. 

Long-duration transactions allow users to check objects out of the shared, 
distributed database into their private databases. Users can then change the 
objects in the private databases without affecting the shared database or 
other users. These changes can be committed to the private database. Then, 
at any later time, the user can check the updated object or objects back into 
the shared database.

ITASCA supports version control of objects. A new version of an object 
promotes the original or parent object to restrict further changes to the 
parent. ITASCA also supports alternate versions such that multiple versions 
can have the same parent. Promoting an object version to a released status 
restricts any deletion of the object. ITASCA uses generic versions to 
dynamically reference the most recent or default version of an object 
without any intervention by a user or application.

Change notification in ITASCA is either flag-based or message-based. 
Flag-based notification will identify an updated object upon querying the 
object for such information. It is a passive notification scheme. Message-
based notification, on the other hand, is an active notification scheme. It 
will execute a method (or code) upon an update or other change to an object. 
Such methods can send mail messages or invoke other methods or 
programs. 

Memory management in ITASCA uses both page and object buffers. 
ITASCA has a traditional database page buffer scheme that contains pages 
with multiple objects. Desired objects move from the page buffer to an 
object buffer. The object buffer then provides ITASCA with enhanced in-
memory performance because it contains only frequently-referenced 
objects. 


> Matisse

OODBMS FEATURES LIST:

An Industrial Strength Open Semantic Object Database

Performance
-       Symmetric, Fine Grain, Multi-Threaded Architecture
-       Parallel and Asynchronous Disk I/O
-       Automatic Disk Optimization through Dynamic Clustering
-       High Speed OLTP Environment
Reliability
-       24 Hour - Mission Critical Operation
-       Media Fault Tolerant (Object Replication)
-       Transparent On-line Recovery
Database Administration
-       Full On-line Administration (No Down Time)
-       On-line Incremental or Full Back-Up
-       Dynamically Increase Database Size -   On-line
-       Full On-line Monitoring
Data Management and Consistency
-       Dynamic Schema Evolution
-       Consistent Database Reads without Locking
-       Historical Versioning, both Schema and Data Objects
-       Built-in Enforced Referential Integrity
-       Object Level Implicit or Explicit Locking
Scalability
-       Hundreds of Concurrent On-line Users
-       Hundreds of Gigabytes Per Database
-       From Few Bytes to Four Gigabytes for Each Object
-       Up to Four Giga-objects Per Database
Object Model
-       Full Object Oriented Model
-       User Extensible Object Meta-Schema
-       Support for Complex, Highly Dynamic, Variable Sized Objects
-       Multiple Inheritance
Intelligent Objects
-       Triggers at Object, Attribute, or at Relationship Level
-       Consistency Rules at Object, Attribute, or at Relationship Level
-       Customizable Intelligent Object Indexing
-       Automatic Inverse Relationships
Open Systems
-       Open C, C++ API
-       Supports Any Commercial Development Tool and Language
-       No Proprietary Tool Required
-       Heterogeneous Cross Platform Client/Server Architecture

For Information on MATISSE, Contact one of the following offices:

USA:
ODB, an Intellitic International Company
238 Broadway
Cambridge, MA  02139
Phone:(617) 354-4220
Fax: (617) 547-5420
email:  info@odb.com

EUROPE:
INTELLITIC INTERNATIONAL
12-14 rue du Fort de Saint-Cyr
Montigny-le-Bretonneux
78182 Saint Quentin en Yvelines Cedex France
Phone:   33(1) 30.14.54.30
Fax:    33 (1) 30.14.54.40

JAPAN:
SGN CO. LTD.
Urban Toranomon Building
16-4 Toranomon
Minato-Ku Tokyo 105 Japan
Phone:   81 (3) 3593.34.31
Fax:   81 (3) 3593.34.32


> NeoAccess

A cross-platform object-oriented database engine based on C++. It allows
developers to embed the power of a fully-functional object-oriented database
system into their applications. All of the data contained in the database,
including indices, can be in a single file, so users can treat a database
file as they would a standard document file. The programming model is
designed to keep visible complexity to a minimum while providing a
feature-rich foundation on which to build and enhance applications.

NeoAccess has taken a different approach toward the issues surrounding object
persistence than have other solutions that have been offered. We believe that
objects should be viewed as having a set of properties with a pliable state.
With NeoAccess persistent objects are provided with persistence and sharing
properties. These properties allow objects to maintain an association with a
file. This association, which can be built and broken freely, allowing
objects to migrate freely between disk and memory. The API to these
properties address issues such as adding or deleting the object from a file,
sorting and indexing, locating and later freeing the object in memory, object
sharing, and maintaining relationships between objects.

NeoAcces
s with has been fully integrated into standard application frameworks such as
Borland's ObjectWindows and MacApp 3.0 and the THINK Class Library on the
Macintosh. A single source tree can be used to build the engine in all
development environments. Database files are binary-compatible across
platforms so users on different types of machines can share data without
conversion.

Contact:
Bob Krause
NeoLogic Systems
1373 Third Avenue
San Francisco, CA 94122
(415) 566-9207


> O2 (INRIA/O2 Technology)

This is an entry on schema evolution.  General papers on O2 are included.

We have implemented in O2 schema updates in our first release but
without NO IMPACT on the database (we have a design to implement
deferred update, but it is a paper design). However, users manage to
convert their instances by hand, using their O2 programs written
themselves, and with the aid of the following tools:

1- There is a set of predefined classes whose instances contain
   objects representing a schema (i.e., a Meta-schema). These classes
   may be used in a conversion program, they may even be extended by
   the programmer.

2- There is a save-restore program that allows to take an O2 database,
   save it on a file or a tape in a logical way (i.e., independent of
   the physical format of objects on disk), and restore it again on a
   (perhaps new release) of the system, in an empty database.
   Currently, when saving a database its schema is also saved. The
   next extension to this save/restore program will be to save the
   database without saving its schema, and then restore the database
   on a new version of that schema. The restore program will be able
   to perform automatically some conversions like "add attribute" or
   "delete attribute".


Schema updates with impact on the database will be implemented in future 
releases.

[Fernando Velez <fernando@o2tech.fr>]


For more information on O2, consult the following REFERENCES:

        Francois Bancilhon, Claude Delobel, Paris
        Kanellakis.  "Building an Object-Oriented Database
        System: The Story of O2".  Morgan Kaufmann Series
        in Data Management Systems, San Mateo, Calif., 1992.
        
        F. Bancilhon, G. Barbette, V. Benzaken, C. Delobel,
        S. Gamerman, C. Lecluse, P. Pfeffer, P. Richard,
        and F. Velez.  "The Design and Implementation of
        O2, and Object-Oriented Database System".
        Advances in Object-Oriented Database Systems,
        Springer Verlag. (Lecture Notes in Computer Science
        series, Number 334.)

        C. Lecluse, P. Richard, and F. Velez. "O2, an
        Object-Oriented Data Model".  Proceedings of
        SIGMOD88.  Also appears in Zdonik and Maier,
        "Readings in Object-Oriented Database Systems",
        Morgan Kaufmann, 1990.

 ==== Corporate headquarters:
O2 Technology
7 Rue du Parc de clagny
78035 Versailles Cedex
France
tel : 33 1 30 84 77 77
fax : 33 1 30 84 77 90

[They have many other contacts worldwide]


> Objectivity/DB (Objectivity)

Introduction:

Objectivity/DB has a fully distributed client/server architecture that
transparently manages objects distributed across heterogeneous environments and
multiple databases.  It provides an application interface that uses transparent
indirection to ensure integrity and provides a single logical view of all
information, with all operations working transparently on any database on the
network, with scalable performance as users and objects increase.  A
higher-level Object Definition Language (ODL) is available as well as a C
functional interface, integrated C++ interface, and SQL++.


Objectivity/DB

Objectivity/DB [Reference:  Technical Overview, Objectivity, 1993], a product
of Objectivity, Inc. of Menlo Park, CA, provides an integrated C++ programming
interface with an emphasis on the DBMS engine for robustness and scalability
from workgroups to enterprise-wide production applications.  In production use
today with more than 50,000 end users licensed, it supports a fully
distributed, rather than central-server, architecture, with all operations
working transparently over a mixture of multiple databases, schemas, users, and
computers, and over heterogeneous hardware, operating systems, and networks. 
The language interface includes a C++ class library interface, soon to be ODMG;
a C function library; and SQL++, supporting query predicates with either SQL or
C++ syntax, interactively or programmatically.  Over forty administrative and
GUI tools provide both an interactive and programmatic interface, and a
messaging backplane allows third party tools integration at four different
levels, with a list of partners at all levels.

One of the key architectural concepts of Objectivity/DB is an object reference
mechanism that ensures data integrity.  Unlike traditional ODBMSs that use
direct pointers, which become invalid after commit and hence lead to crashes
and corrupt databases, Objectivity/DB uses an indirection to guarantee safe
reference.  Transparent to the user, this indirection requires an extra test
and pointer dereference, or a couple of cycles, which is not measurable in most
applications.  However, it ensures integrity of all references, even across
transaction boundaries, resulting in production quality robustness.  Also, it
provides object level granularity for the object manager, allowing it to move,
cluster, and swap objects as necessary, one of the keys required for
scalability in objects and users.  Finally, it allows object-level granularity
for current features, such as heterogeneity and versioning, and future
extensions, such as object-level security.

A higher-level Object Definition Language (ODL) is provided that allows
declaration of modeling concepts such as bi-directional associations, behavior
of associations between objects as they version (move, copy drop), and
propagation of methods across associations.  These then result in automatically
generated methods and declarations for both C++ and C.  The standard C++ API
allows application programmers to work with any standard compilers and
debuggers, with no extra pre-processors, providing ODBMS capabilities via
overloading C++ operators (new, ->, etc.), and declarations via provided
classes (for references, etc.).

Workgroup through enterprise-wide and cross-enterprise computing is supported
via a distributed client/server architecture that provides a single logical
view over multiple databases on heterogeneous machines.  The user sees a
logical view of objects connected to objects and need not worry that one object
is in a database on a Sun workstation, while another may be in a database under
Windows or VMS.  All operations work transparently across this environment,
including atomic transactions with two-phase commit, propagating methods, and
versioning.  Objects may be moved between databases and platforms without
affecting working applications or requiring changes to the applications. 
Multiple schemas may be created, without affecting other users or databases,
and may be used simultaneously with shared schemas, allowing local groups to
define their own models but still connect to other groups.  Databases may be
detached from this shared environment (federated database) and used on portable
devices, reconnected or moved to different (compatible) environment, or
distributed as parts or image libraries.  Gateways to RDBMSs are provided via
third-party integration with Persistence Software, and more generally to any
foreign data store, as long as the user installs the appropriate access
methods, extending the single-logical-view to include read/write access to
arbitrary foreign data stores.  Together, these allow delegation of
responsibilities to the appropriate users, integration with existing systems,
and gradual migration toward full enterprise-wide sharing.

The on-demand object manager directly and automatically manages object access
and buffering, rather than relying on system facilities such as virtual memory
or user manual get/put calls.  Mechanisms used include multiple buffer pools
locally and remotely, b-trees, hashing, scoped names, keys, and iterators, with
distributed catalogues for schemas and databases.  A direct connection is
established between the user and the objects used, so that users do not
conflict unless and until they are competing for the same objects, thus
avoiding the traditional central-server bottleneck.  Short transactions are
based on traditional (transient) locks, owned by the process, and group
together an arbitrary set of operations.  Long transactions are based on
persistent locks, owned by the user, and provide the same arbitrary grouping. 
Default concurrency is two-phase locking and serialization, but extensions
available include MROW, or multiple-readers concurrent with one-writer, and
allow users to lock with or without wait or with timed waits, to implement more
sophisticated mechanisms.

Objects may be modeled using C++ structures augmented by classes provided such
as strings, dictionaries, and relationship management, as well as some
particular domain libraries.  A simple object is a C++ class (or C structure)
with associated access methods.  A complex object may include multiple varrays,
each being a dynamically varying sized array of arbitrary structure.  A
composite object is any network of related objects that acts as a single
object, both structurally and behaviorally, via propagation of behaviors to
component objects.  Any number of composite objects may be contained in
composite objects, and a single object may participate in any number of
composites.  The relationship mechanism supports uni- and bi-directional
relationships, one-to-one, one-to-many, and many-to-many.  Versioning is
supported at object granularity, may be turned on or off at any time for each
object, may be restricted to linear or allow branching with multiple writers. 
References to versioned objects may be to a specific version or to the default
version, which may be separately specified by a method and may allow multiple
defaults.  Schema and object evolution are supported via versioning of the
type-defining objects.  Each time a type definition is changed, its defining
object is versioned, allowing arbitrary changes.  Objects may then be instances
of the old or new type version.  Object evolution or upgrading to the new type
version is supported  by the user writing conversion methods which are
installed and invoked by the system.

ANSI SQL query is supported in the SQL++ product.  Predicate syntax may be
either C++ or SQL.  The ODBC and SQL Access Group (SAG) protocols are
supported.  Queries may be invoked programatically or interactively, with ad
hoc support.  Access to object features is available via methods and traversal
of relationships.

Over forty administrative and developer tools are provided, each with both an
interactive and programmatic interface.  These include GUI object and type
browsers, query browsers, report generator, tools to examine and force short
and long locks, to move objects and databases, etc.  On-line incremental backup
provides a consistent network-wide snapshot, including referential integrity
across all databases, and runs incremental and full database backups with no
need to acquiesce the databases and no interference with active applications. 
All tools are built around a messaging backplane, which supports four levels of
integration with user and third-party tools.  Integrated products include HP
SoftBench (full operational level), CenterLine's ObjectCenter (tool level), 
Persistence RDBMS gateway, PTech and ProtoSoft Design and Analysis (language
level), and XVT and UIM/X (compatibility level).

Objectivity/DB is resold by Digital Equipment Corporation as DEC Object/DB,
providing a multi-billion-dollar second source vendor.  Over 50,000 end users
are licensed in production use, with applications including real-time
telecommunications, aerospace, defense, case, CAD/CAM, CIM, manufacturing, oil
& gas, process control, transportation, multi-media, case, document management,
financial analysis, and corporate information management.  Platform support
includes all Sun, all DEC (including VMS, alpha, OSF-1), HP/9000 series (both
68xxx and PA-RISC), IBM RS/6000, NCR 3300, SGI, Windows 3.1, and Windows NT.

On Schema Evolution (from original survey):
In the just-released Version 2.0 (shipping Oct 92), schema evolution
is supported via dynamic versioning of type-defining objects [ie.
class versions -- SMC], and via a step-by-step approach that allows
conversion of instance data via user-provided conversion methods.
Also, a full dynamic type manager interface is available for doing
fancier things.

Contact:

Drew Wade
Objectivity, Inc.
800 El Camino Real
Menlo Park, CA  94025 USA
drew@objy.com
1(415)688-8000 voice
1(415)325-0939 fax
admin ass't:  Vickie Clements (vickie@objy.com)
information:  info@objy.com


> ObjectStore (Object Design)

Entry on Schema Evolution only:

ObjectStore does not provide schema evolution as yet but it has
promised to provide schema evolution in the next release.
[h.subramanian@trl.OZ.AU]

ObjectStore is an ODBMS produced by Object Design, Inc.  Release 2,
which is in beta test now, supports schema evolution.  The kinds of
evolution supported include change of a data member's type, addition
and removal of data members, and change in inheritance structure.
There are default transformations built in, (e.g. from int to float),
and user-defined transformations may be run also.

Approximately $5-8K

[Ian Schmidt, Object Design, Inc. <schmidt@odi.com>]

        
> Ontos [formerly VBase] (Ontologic)

Entry on schema evolution only:

*Ontos provides schema evolution. It allows any class to be modified.
*The major drawback is that data does not migrate ie., instances are
*not modified to adopt to the new class definition. So schema changes
*can be done only on classes that do not contain instances and do not
*have sub classes that contain instances.
*[h.subramanian@trl.OZ.AU]

*As a system for experiments, we are currently using ONTOS from
*Ontologic Inc.  Unfortunately, there is no transparent concept of
*schema evolution for populated database. Thus, we still investigate
*how it works.

ONTOS has a version of ONTOS for OS/2.  Approximately $11K. Others I don't know


> OpenODB (Hewlett-Packard)

OpenODB is an advanced object-oriented database management system
(ODBMS) from Hewlett-Packard for your complex commercial application
needs.  With OpenODB, you can take advantage of new object-oriented
features combined with a robust database management system.  This
combination of capabilities is unique in the industry.

OpenODB's object-oriented features will help to reduce your development
and maintenance costs by more intuitively representing your business
problems. Also, OpenODB stores code as well as data.  This means that
your application will be simpler and code as well as data can be shared
between multiple users and applications.

OpenODB's database management features ensure the integrity, security
and availability of your stored code and data.  At the same time,
OpenODB protects your existing data, applications and training
investment by allowing you to access existing data and applications
using the object-oriented structured query language (OSQL).

Hewlett-Packard's OpenODB product uses a client/server architecture, 
enabling you to efficiently utilize your available computing power.  
OpenODB's clients use the programmatic interface to access information on 
the server.

OpenODB is composed of the following client and server components:

OpenODB Clients

o        Interactive Object-Oriented SQL (IOSQL)
         This interface allows you to interactively enter all object-
         oriented SQL (OSQL) statements, facilitating rapid prototyping
         and testing.  IOSQL provides basic query, administration and
         editing capabilities.

o        Graphical Browser
         The Graphical Browser is a tool that allows you to graphically
         explore your database schema and contents.  This tool is
         designed to increase the speed of application development by
         making it easier for you to find reusable code stored in
         OpenODB.

o        Programmatic Interface
         You can write OpenODB applications using any programming
         language that can be linked with C (C++, COBOL, FORTRAN,
         Pascal).  The programmatic interface uses OSQL statements
         passed as parameters and does not require preprocessors.

o        User Applications and Tools
         These are the OpenODB clients you will develop using IOSQL,
         the Graphical Browser and the Programmatic Interface.

OpenODB Server Components

o        Object Manager
         The Object Manager executes OSQL calls made by the OpenODB
         clients.  The Object Manager processes requests and accesses
         data and code from the internal data storage manager
         (Relational Storage Manager) or passes the request to a
         subsystem outside of OpenODB (External Functions).

o        Relational Storage Manager
         OpenODB uses a relational database as its storage manager for
         internally stored data and code.  The relational database
         performs the physical file management and database functions
         such as multiuser concurrency, transaction management, and
         recovery.  Relational database tools are available to help you
         perform online backup and recovery, manage physical
         distribution of files, maximize availability and change
         database parameters.

o        External Functions

         External functions allow you to access data and code stored
         outside of OpenODB, regardless of data format or location.
         They are implemented by you as subroutines written in general-
         purpose programming languages and compiled outside of OpenODB.
         With external functions, you can encapsulate existing
         applications.  External functions can be called by any OSQL
         statement, allowing you to use this remote data and
         application code like any other object.

OpenODB Object Model

In OpenODB, the object-oriented model is based upon three components:
objects, types and functions.  These terms are defined as follows in
OpenODB:

     Objects are a combination of data and stored code that operate on
     the data.

     Types allow you to classify similar objects.

     Functions operate on data in the database and also define the
     behavior of that data in the database.  OpenODB supports the
     following three  types of user-defined functions:

  *      Stored functions define attributes and relationships that are
         stored in the database.

  *      OSQL-based functions define attributes and relationships that
         are  retrieved or calculated with OSQL statements.

  *      External functions are a reference to code or data stored
         outside of OpenODB.

OpenODB Language

You create and manipulate objects, types and functions using OpenODB's
object-oriented structured query language (OSQL).  OSQL is a functional
language that is a semantic superset of SQL, the structured query
language used for relational databases.  OSQL is a complete language
with statements that allow you to define and manipulate your OpenODB
database, specify authorization by individuals or groups, define
transactions, embed program logic within functions, and administer your
database.

Using OSQL, you can create the following schema:

                           +---------------+
Type                       |   Employee    | Name, Salary, Picture,
                           +---------------+ SalaryDeduction, WorksFor,
                  +----------------|----------------+ DisplayPicture
         +----------------+               +-----------------+
Subtype  |    Manager     | Manages       |    Programmer   | Languages
         +----------------+               +-----------------+

                         OpenODB Schema Diagram

Creating Types and Functions

The first step is to create basic types and functions using the CREATE
TYPE statement, and to create additional functions using the CREATE
FUNCTION statement.  Next, using the simple OSQL statements shown in
Table 2, you can create specific objects.

   Create a user-defined type called Employee with three stored
   functions:

        CREATE TYPE Employee
          FUNCTIONS (Name CHAR,
                     Salary FLOAT,
                     Picture BINARY);

   Create type Programmer, a subtype of Employee. Also define the
   stored function Languages on Programmer:

        CREATE TYPE Programmer SUBTYPE OF Employee
          FUNCTIONS (Languages SETTYPE(CHAR));

   Create type Manager, a subtype of Employee.  Also define the stored
   function Manages on Manager:

        CREATE TYPE Manager SUBTYPE OF Employee
          FUNCTIONS (Manages SETTYPE(Employee));

   Create an OSQL-based function SalaryDeduction on Employee:

        CREATE FUNCTION SalaryDeduction (Employee e) -> FLOAT AS OSQL
           SELECT (0.3 * Salary (e));

   Create an OSQL-based function WorksFor on Employee to define the
   relationship with Manager:

        CREATE FUNCTION WorksFor (Employee e) -> Manager AS OSQL
           SELECT mgr
            FOR EACH Manager mgr
            WHERE e IN Manages(mgr);

   Create an external function on Employee to display the employee's
   picture:

        CREATE FUNCTION DisplayPicture (CHAR Name) -> CHAR AS EXTERNAL
          SIMPLEEXTFUN('DisplayPicture $Name');

Creating Objects

  Put data into three stored functions defined on the Programmer type:

        CREATE OBJECT AS Programmer
         FUNCTIONS (Name, Salary, Languages)
         :bob ('Bob Cox', 55000, SET('PL/1', 'C')),
         :sue ('Sue Smith', 65000, SET('COBOL'));

  Put data into three stored functions defined on the Manager type:
        CREATE OBJECT AS Manager
         FUNCTIONS (Name, Salary, Manages)
         :al ('Al Ott', 70000, SET(:bob,:sue)),
         :jim ('Jim Hill', 100000, SET());

  Put data into three stored functions using a reference to another
  object:

        CREATE OBJECT AS Manager
         FUNCTIONS (Name, Salary, Manages)
         :chris ('Chris Jones', 80000, SET(:al,:jim));

SQL-like Queries

  Select Bob's salary:

        SELECT Salary (:bob);
          Result: 55000

  Select the names of the employees that Al manages:

        SELECT Name(Manages(:al));
          Results: 'Bob Cox'
                   'Sue Smith'

  Select the names of all managers:

        SELECT Name (m)
         FOR EACH Manager m;
            Results: 'Al Ott'
                     'Jim Hill'
                     'Chris Jones'

NOTE:  The ":" denotes a temporary variable (e.g. :bob) defined in your
application to store a reference to your OpenODB object.

Development of New Applications Faster Using OpenODB, you can directly
model your business information in an intuitive way.  You can also
reuse code stored in OpenODB to reduce your application backlog and
improve your productivity.  To help you develop new applications
faster, OpenODB provides the following features:

Object Identity Each object stored in OpenODB has a system-provided,
unique handle called an object identifier (OID).  OIDs reduce
duplication of information and relieve you from creating unique keys to
identify stored information in the database.

Complex Objects With OpenODB you can construct complex objects from
simpler objects.  Complex objects relieve your application code from
managing the relationships between simple objects.

Referential Integrity Since OpenODB has knowledge of the relationships
between objects, it can manage referential integrity on your behalf.
That is, if objects referenced by other objects are deleted, the system
removes all dependencies.  You can specify whether or not to "cascade"
changes or to just delete the immediate dependency.  For instance, if
you delete the Employee 'Bob Cox', the function call
(Name(Manages(:al))) will return just 'Sue Smith'.  The result is a
simplified database schema and simplified application code that can be
developed more quickly since you do not need to manage referential
integrity explicitly.

User-defined Data Types In addition to the primitive data types you can
construct user-defined data types in OpenODB rather than in your
application code.  User-defined types give you more flexibility and
lead to more manageable, clearer code.

Type Hierarchy Types can be organized in a hierarchy.  This hierarchy
of types and related functions allows you to minimize the translation
from your business model to your OpenODB schema.  The hierarchy also
enables a type to inherit functions defined on "parents", eliminating
duplication of functions.  You will be able to more quickly move from
application design to implementation.

Multiple Inheritance Functions defined on a type can be inherited by
one or more subtypes.  By inheriting rather than redefining functions,
you can easily extend the functionality of your application.

Overloaded Functions Multiple functions can have the same name with
different implementations.  In your application, all you need to do is
call a function (e.g. Salary). OpenODB will determine which code
(Salary for Employee or Salary for Manager) to execute based upon the
parameter passed at run-time.  As a result, your application code is
simplified since the logic for determining which function to execute is
now in OpenODB.

Late Binding OpenODB supports functions that are resolved at run-time.
Late binding allows you more flexibility in application development and
gives you the full power of overloaded functions as described above.
Late binding also shields your applications from changes to functions
since these changes can be made online and the new function definition
resolved at run-time.

Reduced Maintenance Costs OpenODB allows you to add new functionality
and make schema changes to your OpenODB database at run-time, often
without changing your application code or even stopping the database
system.  The following OpenODB features will help reduce your
maintenance costs:

Dynamic Schema Modification You can create new functions and types in
OpenODB at runtime.  You can also change the implementation of
functions without having to recompile your applications.

Dynamic Typing You can dynamically change the type of an object without
having to destroy and recreate the object.  This is possible because an
object can belong to more that one type.

Encapsulation OpenODB supports the combination of data and user-defined
functions.  Since OpenODB only allows access to your data through these
functions, your application is protected from changes to the function
implementation and you have control over how users access information
in OpenODB.  Encapsulation allows you to modify the function body
without changing your application code.

Procedural Language OSQL includes programming flow statements,
including IF/THEN/ELSE, FOR and WHILE.  The procedural language allows
OpenODB functions to be quite complex, simplifying your application
code.  By moving application code into the database, you can now share
the code and get all of the benefits of sharing data, such as
consistency, security and integrity.

For example...

Create a Procedure

  Convert all managers to programmers that have less than a specified
  number of employees:

   CREATE FUNCTION MgrToEng (INTEGER minemps) -> BOOLEAN
     AS OSQL
        BEGIN
          FOR m IN Manager DO
             IF (COUNT(Manager (m)) < minemps)
             THEN
                BEGIN
                  ADD TYPE Programmer TO m;
                  REMOVE TYPE Manager FROM m;
                END
             ENDIF;
         END;

Executing a Procedure

Applications are simplified since the implementation of functions can
now be stored in OpenODB.  Simply call a function, passing a parameter:

  CALL MgrToEng(3);

Protection of Existing Investments OpenODB coexists with your current
data and applications, allowing you to build upon existing
functionality.  Also, OpenODB's object-oriented SQL (OSQL) is easy to
learn if you already know Structured Query Language (SQL).

External Functions Using external functions, you can access distributed
data and code stored outside of OpenODB, regardless of data format or
location.  This simplified view of your enterprise allows you to more
easily develop complex applications that integrate your existing data
and applications.  For instance, you can develop an OpenODB application
that accesses data stored in other databases (e.g. ALLBASE/SQL,
TurboImage or DB2) as well as in flat files.  OpenODB acts as an
integrator so that your application just needs to know OSQL.  OSQL
statements may actually call functions that access data and encapsulate
code stored outside of OpenODB.

OSQL If you already know SQL, you can quickly be productive using
OpenODB's OSQL. OSQL uses syntax that is similar to SQL, the semantics
are a superset of SQL, and both query languages are set-based, that is
they retrieve sets of information based upon queries, as shown in
earlier examples.

Optimize Performance and Availability OpenODB, with the help of the
underlying relational storage manager, gives you flexibility in
managing the performance of your system and maximizing the availability
of information for your users.

High Availability
OpenODB maximizes the availability of your information by providing:
* dual logging, to ensure the integrity of your log file
* switch log, to automatically switch to a second log file if the
  original log file is damaged or becomes full
* dynamic file expansion, to automatically expand the size of your
  system file if it becomes full
* online backup of the database, to backup the database while it is
  being accessed OpenODB will also take advantage of available system
  features such as disc mirroring.

Multiuser Concurrency Control OpenODB is designed to support hundreds
of users accessing the same information while guaranteeing the
integrity of that information.

Compiled Functions To improve runtime performance, functions are
compiled and can be cached.

Access Methods on Stored Data Indexes are automatically defined on
object identifiers (OIDs) for you when you create types and functions.
These indexes help provide quick access to information stored in your
OpenODB ODBMS.  You can also define your own indexes.

Clustering Related functions can be stored close to each other in order
to improve performance.

Additional Features

Authorization You can control access to OpenODB at the database and
function levels based on individuals or a group of users. Authorization
statements provide you a flexible way to control access to types and
functions in OpenODB.

Client/Server Architecture Clients communicate with the OpenODB server
over a network.  The interface between the clients and the server is
transparent to you as a user.  The clients and server can also reside
on the same machine.

Multimedia OpenODB allows you to store large, unformatted data in
binary format.  Some examples include graphics, images or voice.  You
can also define functions in OpenODB to manipulate this multimedia
information.  For example, you can store a picture as well as the
function to display the picture.

Native Language Support You can store 8-bit and 16-bit character data
in OpenODB.

Persistent Data and Code OpenODB allows you to save data as well as
code between application sessions.

Primitive Data Types OpenODB supports a number of primitive data types,
shown in the OpenODB Feature Summary below.  You can also create your
own user-defined data types.

Recovery OpenODB has a robust logging and recovery facility.  In case
of a failure, OpenODB can handle rollback or rollforward recovery to a
particular time, using your log file to recreate saved work.

Transaction Management OpenODB ensures the logical and physical
integrity of your database by giving you complete control over the unit
of work to be performed within a single transaction.  With this
control, you can save or rollback a transaction (throw away temporary
work) at your discretion.  Savepoints are supported so that you can
rollback parts of a transaction.

System Environment The OpenODB server and all clients are available on
HP-UX 8.0 or later versions for the HP9000 Series 300/400/700/800
systems and for MPE XL 4.0 or later versions for the HP3000 Series 900
systems.  Client software will also be supported using X terminals.
You will need 16 Mbytes of main memory (32 Mbytes recommended), at
least 15 Mbytes disc space for installation and approximately 10 Mbytes
DISC space for each new OpenODB database.

Software Requirements To use OpenODB, you need to have a TCP/IP
transport and ARPA Berkeley Services.  To use the OpenODB Graphical
Browser, you need to have X-Window X11.

Ordering Information The software includes:  OpenODB clients (IOSQL,
Graphical Browser, Programmatic Interface) and the 1-8 user license for
the OpenODB server (Object Manager, Runtime ALLBASE/SQL and External
Functions).  You must specify a media option for the HP9000 systems.

         Product Number  Product Description
         B2466A          OpenODB Developer Release for HP9000 S300/S400
         B2468A          OpenODB Developer Release for HP9000 S700
         B2470A          OpenODB Developer Release for HP9000 S800
         B2472A          OpenODB Developer Release for HP3000 S900

Documentation, Online Support, Training and Consulting The OpenODB
Developer Release includes documentation for all systems.  The OpenODB
Developer Release also includes online support, training and
consulting.   These services will be arranged when you place an order
for the product.

OBJECT-ORIENTED FEATURES                 CLIENT INTERFACES
Complex Objects                          Interactive OSQL
Dynamic Schema Modification              Graphical Browser
Dynamic Typing                           Programmatic Interfaces: C
Encapsulation                            linkable languages (C++,
External Functions                       COBOL, FORTRAN, Pascal)
Functions (Stored Code or Methods)
Late Binding                             OSQL STATEMENTS
Multiple Inheritance                     Add/Remove Type To/From Object
Object Identity (OID)                    Add/Remove User
Overloaded Functions                     Call Function
Type (Class) Hierarchy                   Change Password
User-defined Data Types                  Create/Delete Function
                                         Create/Delete Object
DBMS FEATURES                            Create/Delete Type
Access Methods on Stored Data            Create/Delete User/Group
Authorization (Security)                 Grant/Revoke
Client/Server                            If/Then/Else, While, For
Clustering                               Implement Function
Compiled Function                        Open/Fetch/Close Cursor
Declarative Query Language (OSQL)        Select
High Availability                        Update
Multimedia
Multiuser Concurrency Control            PRIMITIVE DATA TYPES
Native Language Support                  Binary
Persistence                              Boolean
Primitive Data Types                     Character
Procedural Language                      Date
Recovery                                 Datetime
Referential Integrity                    Decimal
Transaction Management                   Floating Point
                                         Integer
                                         Interval
                                         Long Binary (Large)
                                         Small Integer
                                         Time

                            OpenODB Feature Summary 



HP OpenODB Price Guide

SUMMARY:

   Description                        U.S. List Price

1. Developer's Bundle                         $105,000
2. Evaluator's Bundle                           $5,000
3. Learning Version                            $10,000
4. Training Course                       $2,500/person
5. Consulting                      $3,500/day or Quote
6. Reference Manual                               $250

DETAILED DESCRIPTION:

1. Developer's Bundle

Contents:
A) OpenODB software (1-64 User License for 1 Server Platform)
B) OpenODB documentation
C) 5 passes to the OpenODB Training Course
D) 5 days of on-site consulting
E) Phone and software update support for 6 months

U.S. List Price: $105,000/bundle

Product Numbers:
B2472A (for HP 3000 Series 900 with MPE/iX)

B2468A (for HP 9000 Series 700 with HP-UX)

B2470A (for HP 9000 Series 800 with HP-UX)

Notes:
A) OpenODB documentation includes the OpenODB Reference Manual, ALLBASE/SQL
   Handbook of DBA Tasks, and Up and Running with ALLBASE/SQL.
B) The OpenODB Training Course is delivered in Cupertino, California and takes
   4 days.
C) Consulting is provided at the customer's site with a maximum of two trips.
D) Phone support is provided directly from the HP OpenODB factory consulting
   team in Cupertino, California.  Phone and software update support can be
   purchased at the end of the first 6 months at the rate of $6,900 per year.
E) Volume End User (VEU) and Educational discounts apply to the entire list
   price.
F) The Developer's Bundle is available on HP 3000 Series 900 or HP 9000 Series
   700 and 800 computers.


2. Evaluator's Bundle

Contents:
A) 3 months use of OpenODB software (1-64 User License for 1 Server Platform)
B) OpenODB documentation
C) 1 pass to the OpenODB Training Course
D) Phone support for 3 months

U.S. List Price:  $5,000/bundle

Product Numbers:
B3178A (for HP 9000 Series 700 with HP-UX)

B3179A (for HP 9000 Series 800 with HP-UX)

Notes:
A) The OpenODB software is shipped when the product is ordered.  The OpenODB
   software will stop running 3 months after it is installed.
B) OpenODB documentation includes the OpenODB Reference Manual, ALLBASE/SQL
   Handbook of DBA Tasks, and Up and Running with ALLBASE/SQL.
C) The OpenODB Training Course is delivered in Cupertino, California and takes
   4 days.
D) Phone support is provided directly from the HP OpenODB factory consulting
   team in Cupertino, California.
E) Volume End User and Educational discounts apply to the entire list price.
F) The Evaluator's Bundle is only available on HP 9000 Series 700 or 800
   computers.

3. Learning Version

Contents:
A) OpenODB learning version software (Single User License for 1 Platform)
B) OpenODB documentation

U.S. List Price:  $10,000/license

Product Numbers:
B3181A (for HP 9000 Series 700 with HP-UX)

B3182A (for HP 9000 Series 800 with HP-UX)

Notes:
A) This special single user version is intended for students, researchers, and
   technical evaluators who wish to learn about the Object-oriented SQL (OSQL)
   interface language and OpenODB product.  The learning version software runs
   on one computer for one user application (i.e. no client/server mode).
B) OpenODB documentation includes the OpenODB Reference Manual, ALLBASE/SQL
   Handbook of DBA Tasks, and Up and Running with ALLBASE/SQL.
C) Volume End User and Educational discounts apply to the list price.
D) The Learning Version is available on HP 9000 Series 700 and 800 computers.
E) Phone and software update support for the Learning Version can be
   purchased at the rate of $1,500 per year.


4. OpenODB Training Course

Contents:
A) 1 pass to the OpenODB Training Course
B) OpenODB documentation
C) Class notes and OSQL case study examples

U.S. List Price:  $2,500/person

Product Number:
B3184A

Notes:
A) The OpenODB Training Course is delivered in Cupertino, California and takes
   4 days.
B) OpenODB documentation includes the OpenODB Reference Manual, ALLBASE/SQL
   Handbook of DBA Tasks, and Up and Running with ALLBASE/SQL.
C) The OpenODB Training Course includes hands on experience with the OpenODB
   software through a case study approach.
D) No standard discounts apply.


5. OpenODB Consulting

Contents:
A) 1 person on the customer's site for technical consulting

U.S. List Price:  $3,500/day + zone charge/trip

Product Number:
B3186A

Notes:
A) For details about this consulting, see the OpenODB Consulting Fact Sheet.
B) The zone charges per trip are: $1000 in North America, $2000 in Europe,
   and $3000 in the Far East and South America.

   Consulting that does not require travel will not have a zone charge.
C) Special quotes are available for projects longer than one week.
D) No standard discounts apply.


6. OpenODB Reference Manual

Contents:
A) OpenODB Reference Manual
B) The right to make up to 5 additional copies of the OpenODB Reference Manual
   for internal use only.

U.S. List Price:  $250/manual & right to copy

Product Number:    B3185A

Notes:
A) No standard discounts apply

Mark Boronkay
OpenODB Consultant
boronkay@cup.hp.com



> POET <Persistent Objects and Extended Database Technology>  (BKS Software)

C++ Language Support

o    tight semantic integration with C++
o    any C++ object or structure can be made persistent by adding the 
     persistent keyword
o    storing and reading a C++ object does not change its state or behavior
o    full support for C++ encapsulation, object identity,  inheritance, and 
     polymorphy
o    C++ pointers and references are automatically converted to database 
     references when storing objects
o    database references are automatically converted to C++ pointers and 
     references when reading objects
o    all database definition is done through a small extension to C++ 
     declaration syntax

Database Functionality
navigation, queries, sorting, indexes, single-user operation, multi-user
operation using client/server architecture, flexible locking for objects
and sets, nested transactions, watch & notify for objects and sets,
event handling, database size limited only by hard disk size

C++ Language Extensions
persistence, indexes, transient data elements in persistent classes, sets,
dependent objects

PTXX-Precompiler
automatically converts extended C++ class declarations into ANSI 2.0 code,
registers classes in the class dictionary, provides class versioning

Predefined C++ Classes
date, time, strings, and BLOBS (binary large objects)

Portability
all platforms are source-code compatible, any POET database may be read by
any computer full support for heterogeneous networks

Platforms
Available for MS-DOS / MS-Windows (Borland C++, Microsoft), 
OS/2 (Borland C++), Novell, Macintosh MPW, and various Unix 
systems, including NeXT (NeXTStep) and Sun OS (Sun C++).

How to Contact Us:
BKS has offices in Santa Clara, Hamburg, and Berlin.  Silicon 
River, Limited, is responsible for POET in the United Kingdom.  

Santa Clara:    (North America, Australia, Asia)

BKS Software
4633 Old Ironsides Drive  Suite 110
Santa Clara, CA 95054
Phone:  408 / 748 - 3403
Fax:    408 / 748 - 9060

Contact Person: jrobie@netmbx.netmbx.de (Jonathan Robie)


> Statice (Symbolics)

From: fischerm@darmstadt.gmd.de (Markus Fischer)
Newsgroups: comp.databases.object,comp.lang.lisp
Subject: Statice now runs on Unix
Date: 15 Jun 93 14:55:48 GMT

Hi there,

since I've never seen 'Symbolics' or 'Statice' in
comp.database.object, this might be interesting:

A few days ago, Symbolics announced the availability of a beta-
release of their ODBMS 'Statice' on Unix platforms. It is quite
powerful and tightly integrated within Common Lisp.
Currently, Symbolics and LUCID are supported.
People (like me) used to Symbolics' Genera development environment 
can continue to use Statice there (where it has been already
successfully employed in 'real world' applications)
and now also use it on Unix Workstations.  (Those are the cheaper
boxes, I guess). Both kinds of platforms can be freely intermixed
in a network.

Statice is based on standards of Lisp: CLOS and CLIM 
(Common Lisp Object System, resp. Common Lisp Interface Manager)

Here's the address of Symbolics in Germany; they're mostly 
responsible for Statice on Unix:

Symbolics Systemhaus GmbH
Mergenthalerallee 77
6236 Eschborn (til June 31)
65760 Eschborn (from July 1)
Tel. (49) 6196-47220, Fax (49) 6196-481116

Contact person is Dr. Thomas Neumann (TN@symbolics.de).

Also:

"Update Database Schema" brings an existing database into conformance
with a modified schema.  Changes are classified as either compatible
(lossless, i.e., completely information-preserving) or incompatible
(i.e., potentially information-losing in the current implementation).
Basically, any change is compatible except for the following:

    -- If an attribute's type changes, all such attributes extant
    are re-initialized (nulled out).  Note that Statice permits
    an attribute to be of type T, the universal type.  Such an
    attribute can then take on any value without schema
    modification or information loss.

    -- If a type's inheritance (list of parents) changes, the
    type must be deleted and re-created, losing all extant
    instances of that type. This is Statice's most serious
    current limitation.  The simplest workaround is to employ a
    database dumper/loader (either the one supplied by Symbolics
    or a customized one) to save the information elements and
    then reload them into the modified schema.

[Lawrence G Mayka <lgm@IExist.ATT.COM>]


> UniSQL

UniSQL offers a state-of-the-art suite of integrated object-oriented database
systems and application development products which can be used separately or
together to support complex development projects which use object-oriented
development techniques, integrate sophisticated multimedia data, and require
true multidatabase access to relational and object-oriented databases. The
UniSQL product suite includes:

        UniSQL/X Database Management System;
        UniSQL/M Multidatabase System; and
        UniSQL/4GE Application Development Environment
        User interfaces include: C++, C, Object SQL, SmallTalk, and ODBC
        Database interfaces include: Ingres, Oracle, Sybase, UniSQL/X, and EDA/SQL

UniSQL offers:

- A wide selection of user interfaces including C++, SmallTalk, C, Microsoft's
  ODBC, both embedded (static and dynamic) and interactive Object SQL, and UniSQL
  and 3rd-party development tools.

- Mission-critical database features such as a high-level query language
  (SQL/X), cost-based query optimization, automatic transaction management,
  automatic concurrency control, dynamic schema evolution, dynamic authorization,
  physical disk structuring options, and installation tuning parameters.

- The UniSQL Multimedia Framework which provides natural and uniform database
  system support for all types of large unstructured data objects. The Multimedia
  Framework also provides for seamless integration of multimedia devices such as
  fax machines, CD jukeboxes, satellite feeds, image compression boards, etc.

- The UniSQL/M Multidatabase System enables developers to manage a collection
  of multi-vendor databases -- Ingres, Oracle, Sybase, DB2, UniSQL/X, and others
  -- as a single federated database system with full object-oriented
  capabilities.

UniSQL has well over 150 customers around the world, the majority of which are
using UniSQL database products for mission-critical applications which require
object-oriented, multimedia, post-relational, and heterogeneous database
capabilities.

A typical UniSQL customer is a Fortune 500 company, a commercial software
developer, or government organization that is using UniSQL database products
to:

- support mission-critical application development projects which are being
  developed using object-oriented programming languages and development
  techniques,

- support applications which must integrate many different types of corporate
  data -- text and documents, tabular data, images and audio, engineering
  drawings, GIS data, procedural data (programs), etc. -- into a single
  application context.

- support the full object-oriented development paradigm using existing
  relational database systems such as Ingres, Oracle, Sybase, and DB2.

- logically integrate one or more relational and object-oriented databases to
  form a single, homogenized database server which supports both relational and
  object-oriented facilities.

In September 1992, UniSQL was selected by the Petrotechnical Open Software
Corporation (POSC) -- over more than 25 other industry vendors -- to provide
database technology which is being used by POSC in their development of a new
data management specification for the oil & gas industry. Also during 1992,
because of its powerful multimedia capabilities, UniSQL was selected by the MIT
AthenaMuse Consortium on multimedia as the consortium's multimedia database
system.

During the DB/EXPO '93 Conference and Exhibition, UniSQL was chosen in
competition with major industry database vendors as a finalist in the
``RealWare Awards''.  The ``RealWare Awards'' honor companies that have
had a major impact in the user community.

UniSQL was founded in May 1990 by Dr. Won Kim, President and CEO, delivering
the UniSQL/X DBMS in March of 1992. With its world-class database research and
architectural team, UniSQL has perfected what the database industry has sought
since the mid-1980s: a fully object-oriented data model that is a natural
conceptual outgrowth of the popular relational model. Both the UniSQL/X DBMS
and the UniSQL/M Multidatabase System represent the first of a powerful new
generation of client-server database systems that support the full
object-oriented paradigm yet retain all of the strengths and capabilities of
relational database systems including support for ANSI-standard SQL.

UniSQL currently has 45 employees and is privately owned and managed by Dr.
Kim. The company has secured long-term funding from NTT Data Communications
Systems Corp. (NTT Data), a $2 billion company, which is Japan's foremost
systems integrator and UniSQL's exclusive distributor in Japan.

For more information, contact:

        UniSQL, Inc.
        9390 Research Blvd., II-200
        Austin, Texas 78759-6544
        Tel.: 512/343-7297
        Tollfree: 800/451-DBMS
        Fax.: 512/343-7383

And:
From: jonh@unisql.UUCP (Jon Higby)
Newsgroups: comp.databases,comp.databases.theory,comp.databases.object,comp.object
Subject: Re: SQL3, Itasca, & UniSQL/X
Message-ID: <6143@unisql.UUCP>
Date: 10 Sep 93 14:26:04 GMT
References: <CD1Ln5.9G3@dcs.glasgow.ac.uk>
Organization: UniSQL, Inc., Austin, Texas, USA

>>...
For UniSQL/X, feel free to contact me (email, snail-mail or phone).

UniSQL/X is a SQL compliant database with Object Oriented extensions
(classes, inheritance, methods, etc).  We have an information packet
available which includes a white-paper on our OORDMS approach.

Jon Higby
Technical Services Consultant

UniSQL, Inc.
9390 Research II, Suite 200
Austin, Texas  78759-6544
(512) 343-7297

*****************************************************************************
Standard disclaimer ... All opinions expressed are my own and not of my 
                        employer.......................................
*****************************************************************************



> Versant (Versant Object Technology)

Versant is a client/server object database management system (ODBMS) targeted at
distributed, multi-user applications.  Versant runs on UNIX and PC platforms, 
including Sun, IBM, HP, DEC, SGI, Sequent, OS/2, with support for Windows NT is 
planned during 1993.

Versant provides transparent language interfaces from object-oriented 
programming languages such as C++ and Smalltalk.  Versant also supports a C API.

Versant is built with an object-level architecture, which means that operations 
are generally performed on the object (or group thereof) level.  Key Versant 
features include:

 Performance
 -----------

*  Object-level locking for fine granularity concurrency control
*  Server-based query processing to reduce network I/O
*  Dual caching to speed warm traversals
*  Dynamic space reclamation and reuse

 Distribution
 ------------

*  Immutable, logical object identifiers for data integrity
*  Object migration (transparent relocation across nodes)
*  Transparent cross-node references (distributed db)
*  Automatic two-phase commit

 Other
 -----

*  Schema evolution (online via lazy updates)
*  Standard workgroup features (e.g., versioning, checkin/out)
*  Detachable, personal databases
*  DBA utilities


Additional information available from

info@versant.com  (General information)
davek@versant.com (Dave Kellogg)

Versant Object Technology 
1380 Willow Road
Menlo Park, California  94025

415-329-7500 phone.
415-325-2380 fax.


On Schema Evolution (from original survey):
We support run-time schema evolution.  It uses a lazy scheme, so
schema operations are very fast.  Objects on disk may have an older
`storage class' and they will be updated to the new schema when they
are used.

In older releases schema evolution was allowed only on leaf classes
(those with no subclasses).  In our new release 2 (going to beta test
soon) you can do schema evolution on any class.

In the future we're working on more general view mechanisms so you can
see a subset of the attributes in memory, or some more complicated
transformation.  This goes together with support for multiple
compilers and multiple languages.

[Joe Keane <osc!jgk@amd.com>]

Also: 1-800-Versant




Other Models
------------

Research Systems
________________

> GRAS

--------------------------------------------------------------
GRAS - A Graph-Oriented Database System for SE Applications
Copyright (C) 1987-1993  Lehrstuhl Informatik III, RWTH Aachen
--------------------------------------------------------------

See the GNU Library General Public License for copyright details.

Contact Adresses:

    Dr. Andy Schuerr 
    Lehrstuhl fuer Informatik III,
    University of Technology Aachen (RWTH Aachen),
    Ahornstr. 55,
    D-5100 Aachen

Email to

    andy@i3.informatik.rwth-aachen.de

GRAS is a database system which has been designed according
to the requirements resulting from software engineering
applications. Software development environments are composed
of tools which operate on complex, highly structured data.
In order to model such data in a natural way, we have selected
attributed graphs as GRAS' underlying data model.

A first prototype of the GRAS (GRAph Storage) system - described
in /BL 85/ - was already realized in 1985. Since this time
gradually improving versions of the system have been used at
different sites within the software engineering projects
IPSEN /Na 90/, Rigi /MK 88/, MERLIN /DG 90/, and CADDY /EHH 89/.
Based on these experiences, almost all parts of the original
prototype have been redesigned and reimplemented.

Thus, nowadays a stable and efficiently working single-process
version of the system GRAS with interfaces for the programming
languages Modula-2 and C is available as free software for Sun
workstations (the GRAS system itself is implemented in Modula-2
and consists of many layers which might be reusable for the
implementation of other systems):

  Via anonymous ftp from ftp.informatik.rwth-aachen.de
  in directory /pub/unix/GRAS in file gras.<version-no>.tar.Z.

  There are several files containing documentation, sources, binaries,
  application examples, and libraries. All binaries are for Sun/4
  machines. Sun/3 binaries are shipped only if explicitly requested.

  You have to use the following sequence of operations for installing
  the GRAS system at your site:

  1) 'ftp ftp.informatik.rwth-aachen.de' (with login name "anonymous"
     and password equal to your mail address).
  2) 'cd pub/unix/GRAS' (for changing the current directory).
  3) 'binary' (command for changing ftp mode).
  4) 'get gras.<version-no.>' (use 'ls' for finding the currently used
      GRAS version nr.).
  5) 'bye' (for exiting ftp).
  6) 'uncompress gras.<version-no>.tar'.
  7) 'tar xvf gras.<version-no>.tar' (creates a subdirectory GRAS_2 for
     the Modula-2 implementation of GRAS including its C-interface).
  8) Follow the instructions in file GRAS_2/README.


The current version has programming interfaces for Modula-2 and C
and supports:

  - the manipulation of persistent attributed, directed node- and
    edge-labeled graphs (including the creation of very long
    attributes and of attribute indexes).

  - the manipulation of temporary/volatile generic sets/relations/lists,

  - the coordination of graph accesses by different GRAS applications
    (multiple-read/single-write access with graphs as lock units),

  - error recovery based on shadow pages and forward logs,

  - nested transactions and linear undo/redo of arbitrarily long
    sequences of already committed graph modifying operations based
    on forward and backward logs,

  - event-handling (with certain kinds of graph-modifications
    as events and graph-modifying transactions as event-handlers),

  - primitives for version control comprising the capability
    for efficiently storing graphs as forward/backward deltas to
    other graphs,

  - and primitives for declaring graph schemes and for incremental
    evaluation of derived attributes.

Furthermore, tools for (un-)compressing graphs and a X11R5-based
graph browser are part of this release.

A multi-process version of the system GRAS supporting the inter-
action of multiple client and multiple server processes within
one local area network is nearby completion (version 6.0/0).

Thus, the GRAS system may be considered to be the core of a graph
oriented DBMS environment. The development of such an environment
based on a very high-level specifications language named PROGRES
is under way (the underlying calculus of this specifcation language
are so-called PROgrammed GRaph REwriting Systems).

This environment will comprise the following tools (a prerelease
of this environment might be made available upon request):

  - a syntax-directed editor for graph schemes, graph rewrite rules,
    and sequences of graph rewrite rules,

  - an incrementally working consistency checker,

  - an incrementally working compiler&interpreter translating
    PROGRES specifications into sequences of GRAS procedure
    calls (for C as well as for Modula-2),

  - and an "enhanced" graph (scheme) browser.


References
----------

Refer to the following publications for further info about GRAS, PROGRES,
and related topics:

/BL85/          Brandes, Lewerentz: A Non-Standard Data Base System within
                a Software Development Environment. In Proc. of the Workshop
                on Software Engineering Environments for Programming-in-the-
                Large, pp 113-121, Cape Cod, June 1985

/DHKPRS90/      Dewal, Hormann, Kelter, Platz, Roschewski, Schoepe: Evaluation
                of Object Management Systems. Memorandum 44, University
                Dortmund, March 1990

/Feye92/	Feye A.: Compilation of Path Expressions (in German), Diploma
		Thesis, RWTH Aachen (1992)

/Hoefer92/	Hoefer F.: Incremental Attribute Evaluation for Graphs (in
		German), Diploma Thesis, RWTH Aachen (1992)

/HPRS90/        Hormann, Platz, Roschweski, Schoepe: The Hypermodel Benchmark,
                Description, Execution and Results. Memorandum 53, University
                Dortmund, September 1990

/KSW92/ *       Kiesel, Schuerr, Westfechtel: GRAS, A Graph-Oriented Database
                System for (Software) Engineering Applications. Proc. CASE 93,
		Lee, Reid, Jarzabek (eds.): Proc. CASE '93, 6th Int. Conf. on
		Computer-Aided Software Engineering, IEEE Computer Society
		Press (1993), pp 272-286
		Also:  Technical Report AIB 92-44, 

/Klein92/	Klein P.: The PROGRES Graph Code Machine (in German), Diploma
		Thesis, RWTH Aachen (1992)

/Kossing92/	Kossing P.: Modelling of Abstract Syntax Graphs for normalized
		EBNFs (in German), Diploma Thesis, RWTH Aachen (1992)

/LS88/          Lewerentz, Schuerr: GRAS, a Management System for Graph-
                Like Documents. In Proceedings of the Third International
                Conference on Data and Knowledge Bases, Morgan Kaufmann
                Publ. Inc. (1988), pp 19-31

/Nagl89/        Nagl (ed.): Proc. WG'89 Workshop on Graphtheoretic Concepts
                in Computer Science, LNCS 411, Springer-Verlag (1989)

/NS91/          Nagl, Schuerr: A Specification Environment for Graph Grammars,
                in Proc. 4th Int. Workshop on Graph-Grammars and Their
                Application to Computer Science, LNCS 532, Springer-
                Verlag 1991, pp 599-609

/Schuerr89/     Schuerr: Introduction to PROGRES, an Attribute Graph Grammar
                Based Specification Language, in: /Nagl89/, pp 151-165

/Schuerr91a/ *  Schuerr: PROGRES: A VHL-Language Based on Graph Grammars,
                in Proc. 4th Int. Workshop on Graph-Grammars and Their
                Application to Computer Science, LNCS 532, Springer-
                Verlag 1991, pp 641-659
		Also:  Technical Report AIB 90-16

/Schuerr91b/	Schuerr: Operational Specifications with Programmed Graph
		Rewriting Systems: Theory, Tools, and Applications, 
		Dissertation, Deutscher Universitaetsverlag (1991) (in German)

/SZ91/ *        Schuerr, Zuendorf: Nondeterministic Control Structures for
                Graph Rewriting Systems, in Proc. WG'91 Workshop in Graph-
                theoretic Concepts in Computer Science, LNCS 570, Springer-
                Verlag 1992, pp 48-62
		Also: Technical Report AIB 91-17

/Westfe89/      Westfechtel: Extension of a Graph Storage for Software
                Documents with Primitives for Undo/Redo and Revision Control.
                Technical Report AIB Nr. 89-8, Aachen University of Technology,
                1989

/Westfe91/      Westfechtel: Revisionskontrolle in einer integrierten Soft-
                wareentwicklungsumgebung, Dissertation, RWTH Aachen, 1991

/Zuendorf89/    Zuendorf: Kontrollstrukturen fuer die Spezifikationssprache
                PROGRES, Diplomarbeit, RWTH Aachen, 1989

/Zuendorf92/ *  Zuendorf A.: Implementation of the Imperative/Rule Based
                Language PROGRES, Technical Report AIB 92-38, RWTH Aachen,
                Germany (1992)

/Zuendorf93/ *  Zuendorf A.: A Heuristic Solution for the (Sub-) Graph
                Isomorphism Problem in Executing PROGRES, Technical
                Report AIB 93-5, RWTH Aachen, Germany (1993)
 
* : All reports marked with an asterisk are available via anonymous ftp from
    ftp.informatik.rwth-aachen.de in directory /pub/reports/... .
 
See also PROGRES documentation.

[See also APPENDIX E]


> IRIS (HP Labs)

[Iris is a system out of HP Labs that began as a prototype and eventually
became a commercial product.  I believe it was eventually incorporated into
the new HP product, OpenODB. - clamen]

Long and short system summaries can be found in:

[FISH89] D.H. Fishman et. al. Overview of the Iris DBMS. In Won.
         Kim and Frederick H. Lochovsky, editors,
         Object-Oriented Concepts, Databases and Applications,
         chapter 10, pages 219--250. Addison-Wesley, Reading,
         MA, 1989.

[FBC+87] D.H. Fishman, D. Beech, H.P. Cate, E.C. Chow,
         T. Connors, J.W. Davis, N. Derrett, C.G. Hock, W. Kent,
         P. Lyngbaek, B. Mahbod, M.A. Neimat, T.A. Tyan, and
         M.C. Shan. Iris:  An object-oriented database
         management system. ACM Transactions on Office
         Information Systems, 5(1):48--69, January 1987.

The abstract of the latter (written early in the project) follows:

   The Iris database management system is a research prototype of
   a next-generation database management system intended  to meet
   the needs of new and emerging database applications, including
   office    automation and knowledge-based systems,  engineering
   test and measurement, and hardware  and software design.  Iris
   is exploring a rich set of  new database capabilities required
   by    these   applications,   including  rich    data-modeling
   constructs, direct  database support for inference,  novel and
   extensible data types, for example to  support graphic images,
   voice,    text,   vectors,  and  matrices,    support for long
   transactions   spanning  minutes  to  many  days, and multiple
   versions of data.  These capabilities are, in addition  to the
   usual support for  permanence   of data, controlled   sharing,
   backup and recovery.

   The   Iris   DBMS consists   of  (1) a  query   processor that
   implements  the   Iris object-oriented  data    model, (2)   a
   Relational Storage Subsystem (RSS) -like  storage manager that
   provides  access paths and  concurrency  control, backup   and
   recovery, and (3) a collection of programmatic and interactive
   interfaces.  The data   model supports  high-level  structural
   abstractions,  such  as  classification, generalization,   and
   aggregation, as  well  as behavioral    abstractions.      The
   interfaces to  Iris  include an  object-oriented extension  to
   SQL.


On Schema Evolution (from original survey):
Objects in the Iris system may acquire or lose types dynamically.
Thus, if an object no longer matches a changed definition, the user
can choose to remove the type from the object instead of modifying the
object to match the type.  In general, Iris tends to restrict class
modifications so that object modifications are not necessary.  For
example, a class cannot be removed unless it has no instances and new
supertype-subtype relationships cannot be established.


Commercial Systems
__________________


> IDL (Persistent Data Systems)

IDL is a schema definition language. Schema modifications are defined
in IDL, requiring ad-hoc offline transformations of the database, in
general.  A simple class of transformations can be handled by
IDL->ASCII and ASCII->IDL translators (i.e., integer format changes,
list->array, attribute addition).

[conversation with Ellen Borison of Persistent Data Systems]


ADDITIONAL REFERENCES:
        John R. Nestor. "IDL: The Language and Its
        Implementation". Prentice Hall. Englewood Cliffs,
        NJ., 1989.



> Kala
                         Kala Technical Brief

Summary

Kala(tm) is a Persistent Data Server managing distributed, shared,
arbitrarily complex and evolving persistent data. Kala is highly
efficient and secure. Kala manages the visibility of persistent data
elements to its clients, thus supporting any types of transactions,
versions, access control, security, configurations. Kala does not
restrict you to any particular model. Kala provides the mechanism, but
imposes no policy. Usable as either a link library communicating to a
server or as a standalone, Kala is compact and simple.

Kala is used for applications such as: kernel of DBMS products,
substrate for extended file systems, implementation of language
persistence, data manager for groupware applications as well as
applications which deal with large, complex, and changing volumes of
data (text databases, financial distributed transaction systems). Our
current customers use Kala in applications ranging from CASE
repositories to CAD systems, from document management for financial
institutions to OODBMS platforms, from real-time applications to
database research.  Kala is a component of broad reuse.


Motivation

The simplest persistent data storage available to you is the file
system on your disk drive. File systems have some attractive
characteristics; their performance is good, they can hold any data,
they're easy to use, and, of course, the price is right. Conversely,
files are unreliable.  They provide no mechanism for in maintaining
data consistency and only primitive data sharing facilities. Few file
systems offer version control and all require that you transform data
between "internal" and "external" forms all the time.

Unlike a file system, a true database management system provides
mechanisms for sharing data and for ensuring the integrity of the
data.  It supports transactions and version control, although the
specifics of these functions may not be exactly what your application
needs. Finally, a database system is scalable, and much more robust
than a file when your hardware or software fails.

The downside to a database system is that, compared to a file system,
it is slower by an order of magnitude or more. Also, a database system
generally confines you to dealing only with the kind of data that it
can handle. In addition, a database is usually very complicated,
difficult to learn and use, and expensive, both in terms of your cost
of operation and in the amount of system resources they consume.

Whether you choose a file system or a database manager, then, you
have to sacrifice either economy or performance. Is there a happy
medium?  Something with the speed and flexibility of files, the
reliability, shareability and robustness of databases, and at a cost
that won't break your wallet or the available hardware? Sure there is!
Kala is a first in a new breed of products, persistent data servers,
aimed squarely at the yawning gap between DBMSs and file systems.


Overview

Kala is *not* a DBMS. Instead, you use Kala whenever the few canned
combinations of DBMS features do not meet the needs of your
application. A DBMS product constrains you to accept *its* choice of
an end-user graphical interface, a query language binding, a specific
high level data or object model, a particular transaction model, a
single versioning scheme, etc. This either compromises your
application's functionality, or forces your to spend substantial
development effort and money to bridge the impedance mismatch to the
application.  Instead, Kala allows *you* to develop no more and no
less than the functionality you need. You build your domain specific
functionality our of a small set of primitives with very little code.
Your gains in productivity, efficiency, and flexibility are
substantial.

To sustain this level of flexibility and reuse, Kala manages any data
that you can represent in machine memory out of bits and references.
Examples include records, dynamically linked graphs and lists,
executable code, and object encapsulations.

Kala can handle data as small as one bit, and as large as the virtual
memory and more, while being totally unaware of the data's semantics.
Its stores and retrieves data efficiently, and compactly over a
distributed and dynamically reconfigurable set of Stores. Upon
retrieval, Kala dynamically relocates embedded references to retain
the original topological structure of the data, thus preserving
referential integrity. Kala also supports active data, physical store
management, and automatic archiving.

Kala repackages the fundamentals and universals of data management in
one reusable data server, separating them from the application domain
specific models and policies. Kala defines a low level interoperabi-
lity point for the data storage domain, just as X does for the display
domain and Postscript does for the printing domain.

Kala has matured through four successive versions to its present
industrial strength implementation and stable API. Kala is lean,
compact, and portable. Kala is a high performance, low overhead
system. We call it a Reduced Instruction Set Engine (RISE). Unlike
large, complex, and typically bulky DBMS products, Kala is small,
simple, and suitable for managing anywhere from a single diskette to
terabytes of distributed data.


Benefits

* For those who need functionality traditionally associated with
  databases, but cannot tolerate the overhead and complications DBMS
  products introduce, Kala offers a flexible, compact, performant,
  elegant, and simple alternative.

* For those whose application domain requires data models where the
  mapping to those offered by today's DBMS products is cumbersome,
  introduces development and execution overhead, and is not portable
  across multiple linguistic and environmental platforms, Kala offers
  a data model independent interface against any data model
  expressible in terms of bits and pointers can be easily built.

* For those who need DBMS functionality or qualities that no single
  DBMS product now has, Kala offers the opportunity to build that
  functionality now with little effort out of a simple set of
  primitives, and not wait for one vendor or another to deliver
  it later.

* For those who have determined that the only viable option for their
  application's persistent data needs is the file system, and have
  resined to the idea that they will have to build everything else
  they need from scratch, Kala offers an off-the-shelf implementation
  without loss of any of files' advantages.

* For those who need performance, size, portability, storage
  compactness, and industrial strength that no single DBMS product can
  now satisfy, Kala offers all of the above now.

* For those who realize that while object-level interoperability is a
  strong desideratum, the likelihood of a single, universal such model
  in the foreseeable future is quite low, Kala offers a solid, long
  term alternative. Data store interoperability that brings us beyond
  file systems is the best practical bet. Kala is the basis for data
  store interoperability now.

* Finally, for all of you who are concerned about the economics of
  software, and take the view that there are many elements that
  could contribute negatively to the soundness of your business, such
  as operational costs, software maintenance costs, software licensing
  costs, software development and learning costs, etc., you will find
  Kala an economically sound, sensible, and practical product.


Features

- The execution architecture is that of multiple (communicating)
  servers and multiple clients. Kala can also be configured in a
  standalone (single process) mode. Kala's IPC is built for maximum
  performance, portable to any given datagram protocol.

- The managed data elements are made out of uninterpreted bits and
  references. Data elements (named `monads') are universally uniquely
  identified. Bits are stored with no overhead. References,
  represented in memory as native machine pointers, are stored
  very compactly, introducing an average of 2.5 bytes overhead.

- Kala is a fully recoverable system, short of media damage. Recovery
  from hardware failures can be supported by the layer beneath Kala.

- The Kala primitives support arbitrary transaction models, including
  classic short transactions, long (persistent) transactions, nested
  transactions, shared transactions, pessimistic and optimistic
  policies, etc. Concurrency control is achieved through two locking
  mechanisms (short-term and long-term (persistent, shared) locking),
  with full support for atomicity of operations and two-phase commit.

- The Kala primitives support arbitrary versioning models, allowing
  versions to co-exist in split/rejoined networks, various version
  organization strategies (single-thread, tree, DAG, etc.). Kala
  primitives provide mechanisms for arbitrary access and update
  triggers, such as notifications, security checks upon access/update,
  etc. __ with no limitations on what the trigger code does. Kala
  provides protection measures against virus and other intruding
  executions.

- The Kala primitives support a wide range of access control, security
  and protection models, including revocable access rights, access
  control without the overhead of ACL management, arbitrary access
  validation routines, etc. Kala does not introduce any more security
  holes than the operating environment already has.

- Kala has primitives for physical store allocation and de-allocation
  management, for a wide spectrum of store administrative tasks, as
  well as licensing administration. The latter includes application-
  sensitive time-limited client-connect-based licensing, as well as
  metered (connect/load/store) usage. Kala can be set up to do
  automatic archiving and backup of its physical store.

- Kala provides a wide spectrum of licensing schemes, usable by
  platforms and applications built upon Kala to their customer base.
  Kala provides renewable licenses, perpetual licenses, full
  protection against duplication without hardware (hostid) support,
  metered (pay-by-use) usage, etc.

- And more ... not fitting on this page-long Technical Brief.


Availability

o Kala is available now on Sun platforms (SunOS / 68K & SPARC), as
  well as on 80x86/MS-DOS (both Microsoft and Borland compilers &
  runtimes supported) platforms. If you are interested in a port to
  your favorite platform, call us to discuss our Development and
  Porting Partnership Programme.

o Kala's interface is ANSI C, also callable from C++. If you are
  interested in an interface or a binding to your favorite programming
  language, please call us to discuss out Development Partnership
  Programme.

o For pricing and other information, please contact us by phone, fax
  or via e-mail at Info@Kala.com


 _     _     ____   _         ____ tm ____________________________________
 \\   /     |    \   \       |    \       \\\\ 
  \\ /__     \ __ \   \       \ __ \       \\\\ 
   \\    \    \    \   \       \    \       \\\\  
    \\    \    \    \   \       \    \       \\\\  No more than you need !!!
     \\'   \'   \'   \'  '____'  \'   \'      \\\\  No less than you want !!!
      ........................................................................
      Penobscot Development Corporation                 email: Info@Kala.com
       One Kendall Square Building 200 Suite 2200 Cambridge MA 02139-1564 USA
        voice +1-617-267-KALA fax +1-617-859-9597 tech support +1-201-539-7739
         ...............(5252) fax +1-617-577-1209.............................



     +---------------------------------------------------------------+
     |   Copyright (c) 1992-93, Penobscot Development Corporation.   |
     |   Kala is a Trademark of Penobscot Development Corporation.   |
     +---------------------------------------------------------------+

On Schema Evolution (from original survey):

Kala manages an untyped persistent store, implementing the semantics
of robust, distributed, secure, changing, and shareable persistent
data.  Layers built upon the Kala platform can implement the semantics
of objects with the same properties.

As it operates below the schema layer, Kala does not address schema
evolution directly. However, It supports the building of schema'ed
layers above it and below the application, and those layers can
provide for schema evolution conveniently using Kala primitives.
This parts-box approach requires extra work on the part of the developer
compared to out-of-the-box solutions, but provides power and
flexibility sufficient for relatively low cost solutions in
difficult environments (e.g. graph-structured data, dynamic classing) 
where no out-of-the-box solution is available.


Contacts:
Sergiu Simmel           sss@kala.com
Ivan Godard             ig@kala.com
general information     info@kala.com
subscription to moderated newsletter    forum-request@kala.com


REFERENCES:
        Segui S. Simmel and Ivan Godard. "The Kala Basket: A
        Semantic Primitive Unifying Object Transactions,
        Access Control, Versions, annd Configurations


> Pick

With Pick and its variants you only have problems if you want to
redefine an existing field.  Because of the way the data are stored
and the separation of the data and the dictionary you can define
additional fields in the dictionary without having to do anything to
the data - a facility which we have found very useful in a number of
systems.

There is no general facility to redefine an existing field - you just
make whatever changes are required in the dictionary then write an
Info Basic program to change the data.  We have seldom needed to do
this, but it has not been complicated to do.

If a field in the database is no longer used, it is often easiest
simply to delete the reference to that field in the dictionary, and
accept the storage overhead of the unused data.  In such cases, while
the data cannot be accessed through the query language, (Pick)Basic
programs can still access them.

[Geoff Miller <ghm@ccadfa.cc.adfa.oz.au>]



Interfaces
----------


Research Systems
________________


> Penguin (Stanford)

Penguin is an object-oriented interface to relational databases.
Penguin has its own simple language-independent object model with
inheritance for composite objects defined as views (called
view-objects) of a relational database.  These view-objects represent
data according to application requirements in such a way that multiple
applications can share overlapping, but different, sets of data.
Multiple applications may share data by having overlapping schemata
with differing composite objects and differing inheritance mappings.
We have a C++ binding, which supports multiple inheritance.  The
result is a framework for collaboration among multiple users, each
with differing perspectives about the system and its data.

For additional information, please contact ark@db.stanford.edu

References:

``A C++ Binding for Penguin: a System for Data Sharing among
Heterogeneous Object Models,'' Arthur M. Keller, Catherine Hamon,
Foundations on Data Organization (FODO) 93, October 1993, Chicago.

``Querying Heterogeneous Object Views of a Relational Database,''
Tetsuya Takahashi and Arthur M. Keller, Int. Symp. on Next Generation
Database Systems and their applications, Fukuoka, Japan, September
1993, to appear.

``Updating Relational Databases through Object-Based Views,'' by
Thierry Barsalou, Niki Siambela, Arthur M. Keller, and Gio Wiederhold,
ACM SIGMOD, Denver, CO, May 1991.

``Unifying Database and Programming Language Concepts Using the Object
Model'' (extended abstract), Arthur M. Keller, Int. Workshop on
Object-Oriented Database Systems, IEEE Computer Society, Pacific
Grove, CA, September 1986.


Commercial Systems
__________________
  
> Persistence

                PERSISTENCE(TM): BRIDGING THE GAP BETWEEN OBJECT 
                    ORIENTED DEVELOPMENT AND RELATIONAL DATA

Persistence is an application development tool which provides object
oriented access to existing relational data.  Persistence uses an
automatic code generator to convert object models into C++ classes
which know how to read and write themselves to a relational database.

Leverage existing data

Persistence enables object oriented access to existing relational
databases. Applications built with Persistence can work side by side
with legacy systems.

Automate database access

By generating the methods to convert relational data into objects,
Persistence saves the developer from having to write literally hundreds
of lines of code per class.

Speed application development

With Persistence, major changes to the application object model can be
completed in minutes, not weeks.

Quality

Persistence generates tested, bug-free code. Using Persistence helps
ensure the reliability and reusability of your applications.

Performance

At Runtime, Persistence manages an object cache to enhance performance
while ensuring data integrity. The Persistence object cache can provide
a factor of ten performance improvement for data intensive
applications.

Portability

Code generated by Persistence is database independent. You can choose
which database to work with at link step, increasing application
portability.

                        TECHNICAL SPECIFICATIONS

The Persistence Database Interface Generator converts object schemas
into C++ classes.

                                                Custom
                                                Code
                                                   |
                                                   v

Object schema    --->   Persistence    ---->    Generated
                        Generator               Classes
                                                   ^
                                                   |
                                                   v
                                                Persistence
                                                Object Cache
                                                   ^
                                                   |
                                                   v
                                                Legacy Data


Encapsulation

Each class generated by Persistence maps to a table or view in the database.
- Query using ANSI SQL or attribute values
- Add custom code to generated classes
- Preserve custom code when model changes

Inheritance

Persistence supports inheritance of attributes, methods and relationships.
- Propagate superclass queries to subclasses
- Use virtual methods for polymorphism

Associations

Persistence maps associations to foreign keys in the database. Each class has methods to access related classes.
- Ensure referential integrity between classes
- Specify delete constraints for associations

Object Caching

The Persistence Runtime Object Management System caches objects during
transactions and ensures data integrity. In the object cache,
Persistence "swizzles" foreign key attributes into in-memory pointers,
speeding object traversal.

Transactions

When a transaction is committed, Persistence walks through the object
cache and writes out changes to the database.

Environment

Platforms/Operating systems
Persistence will support all major Unix and Intel platforms
- Sun/SunOS 4.x, Solaris 2.x
- HP/HP-UX 8.0, 9.0
- IBM/AIX (planned 11/93)
- Intel/NT (planned 3/94)

Development Tools

Persistence supports all major C++ compilers and integrates with GE's
OMTool, allowing developers to go straight from an object model to a
running C++ application.
- Cfront 2.1: ObjectCenter 1.0, SPARCompiler, ObjectWorks
- Cfront 3.0: ObjectCenter 2.0, SPARCompiler, Softbench C++
- GE's OMTool

Databases

Persistence provides database independence. With our Objectivity
integration, we also provide a clear migration path to object
databases.
- Oracle V6, V7
- Sybase 4.x
- Ingres 6.x
- Objectivity ODBMS
- Informix (planned 9/93)
- ODBC (planned 3/94)

                            CUSTOMER QUOTES

"We wanted to use object technology while continuing to support our
legacy systems. Persistence made this feasible by automating over 30
percent of our development cycle." Steve Hunter, Sterling Software

"Persistence cut our development time by approximately 40%, because we
would have had to do all the mapping functions ourselves." Jim
Adamczyk, Partner, Andersen Consulting

"I'm convinced we'll save weeks or months of time because of
Persistence." Mike Kubicar, SunSoft Defect Tracking Team

"The good thing is that you can change your object model and just
re-generate the database interface classes at the press of a button."
Richard Browett, Product manager, K2 Software Developments, Ltd.

"The Persistence package saved at least 25 to 50 percent of the
development time, and seemed extremely robust. Support has been nothing
short of phenomenal." Stew Schiffman, DuPont Research and Development

                        FOR MORE INFORMATION

For more information on Persistence, please contact Carl White, VP Sales:
- By phone: (415) 341-1280
- By fax: (415) 341-8432 
- By email: information@persistence.com

Persistent Data Systems
PO Box 38415
Pittsburgh, PA  15238-9925


> Subtlware

From: subtle@world.std.com (Ted p Kyriakakis)
Subject: Re: OOP access to relational databases?
Summary: C++ to SQL RDBMS Mapping Tool and Literature
Date: Mon, 25 Oct 1993 06:51:48 GMT

koch@eis.cs.tu-bs.de (Andreas Koch) writes:
>I am interested in approaches and examples of transparent access to
>relational databases within OOPLs such as C++ and Smalltalk. Of interest
>are pointers to literature and articles as well as ftp'able sample code.
>Any hints are appreciated.

There is a book out from MIS Press by Al Stevens called "C++ Database
Development" which addresses this topic in detail for C++ OO development.  The
book does a good job of describing issues with object persistence and the
implications of using a RDBMS as an object database.

There is also a C++ to SQL mapping product, Subtlware for C++/SQL, that
provides a tool and framework which addresses many of the issues mentioned in
the book. The tool automates the production of the code necessary to map C++
objects to a SQL RDBMS using C++ header files as input.  

If you want more information, you can contact me at:

          subtle@world.std.com

or you can contact Subtle Software at:

	(508) 663-5584 



APPENDIX C  OBJECT-ORIENTED LANGUAGES AND VENDORS
=================================================

See also APPENDIX D.

FORMAT:
    tool name, 
    description and methods
    operating systems
    Vendor name, 
    city/state, phone (if known)

ACTOR ($495)
------------
*Prototyping & Code generation (ACTOR, access to C, Pascal)
*IBM PS/2, PC AT/XT
The Whitewater Group Inc.
600 Davis, Evanston, IL 60201

Allegro CL
----------
*Advanced Object Oriented Development System based on CLOS.  Incremental
 compiler; automatic memory management; integrated editor, debugger class
 browsers, and profilers; multiple inheritance, method combination, multiple
 argument discrimination, meta-object protocol.
*Unix workstations (Sun/Sparc, IBM RS/6000, HP, Silicon Graphics)
 PCs with Microsoft Windows
Franz Inc.
1995 University Avenue
Berkeley, CA 94704
(510) 548-3600, FAX (510) 548-8253
Email info@franz.com

Bootcon
-------
*DOS
Modular Software System

CaseVision
----------
*Browser, Static Analysis, no compiler (yet), Editor Debugger, Profiler, ... 
Silicon Graphics

Classic-Ada
-----------
*Object-Oriented Ada Environment (to Ada translator)
Software Productivity Solutions
(407) 984-3370.

Comeau C++ 3.0.1 With Templates
-------------------------------
* compiler
* many OS's (MS-DOS, AmigaDOS, UNIX (SVR4, SPARC, UNIX 386, etc), etc)
Comeau Computing
91-34 120th Street
Richmond Hill, NY 11418-3214
718-945-0009, comeau@csanta.attmail.com

Distributed Smalltalk (HP)
--------------------------
*ParcPlace's VisualWorks Extension, world's first complete implementation of
*the OMG CORBA 1.1.
European Knowledge Systems Centre (HP's European software tools specialists)
ph:    44 272 228794
email: wjb@hplb.hpl.hp.com

Energize (5 $16250, single $4250, lcc 1500)
-------------------------------------------
*Debugger, Class Language Calltree Error Project Browsers
*SunOS 4.1
Lucid
707 Laurel St.
Menlo Park, CA 95025
(415) 329-8400

Frameworks 3.1 ($495.)
----------------------
*IDE, Browser, Debugger, Compiler, ...
*DOS, Windows
Borland International
1800 Greenhills Road
Scotts Valley, CA  95067
800-331-0877

FUSE ($1560 C++, $1944 FUSE)
----------------------------
*Distr Builds, Editor, Debugger, Profiler, Call Graphs, Call Tree Animation,
 Browser, ...
*Ultrix RISC, OSF/1 AXP  (planned to alpha NT)
DEC
14475 Northeast 24th St.
Bellvue, WA 98007

GNU GCC (g++)
-------------
*C++ compiler, (non-graphical) debugger.
*Unix
prep.ai.mit.edu:/pub/gnu/gcc-2.4.5.tar.gz

GNU GCC (g++)
-------------
*C++ compiler, (non-graphical) debugger.
MS-DOS
grape.ecs.clarkson.edu:/pub/msdos/djgpp/djgpp.zip 

Hamilton C-Shell
----------------
*A shell
*OS/2, Windows
Hamilton Labs

HighC/C++ (basic $795, w/Phar Lap $995)
---------------------------------------
*Editor, Debugger, Windows ADK, Unix Utilities, Speedkit
*Unix
MetaWare Inc.
2161 Deleware Ave.
Santa Cruz, CA  95060
(408) 429-6382

Iconix Power Tools
------------------
*Multiuser, OO development toolset
*Macintosh
Iconix Software Engineering
Santa Monica, Ca.

MetaC
-----
*testing tool, code coverage, lint-style chking, C, C++, tests mem alloc errors
 QASE (Quality Assured Software Engineering)
938 Willowleaf Dr.
Suite 2806
San Jose, CA 95128
(408) 298-3824 ext. 5

MKS Toolkit
-----------
*Make, ...
*PC (Unix-Like)
MKS

NEXPERT
-------
*GUI-type builder, rule based, objects, classes, subclasses, rule inheritance,
 embedded, but you can call external routines. 
Neuron Data Elements 
From: jrp@accint.com (Jason R. Pascucci)  (abstract from a post)

NextStep
--------
*Application, DB, Windows, Indexing, 3D Graphics Kits, Project and Interface
 Builder, Viewers, Modelers, Compilers/Debuggers, Performance, PostScript, ...
*Next, 486, ???
Next Computer, Inc.
900 Chesapeake Drive
Redwood City, CA 94063
800-TRY-NEXT

ObjectCenter
------------
*C++ programming environment, high quality graphics, browser, debugger,
 interpreter.
*Sun, ???
CenterLine
(kendall@)centerline.com

ObjectIQ
--------
*OO devel environ. Objects, rules, debugger, browser, GUI builder, more.
*RAD and intelligent decision support applications.
European Knowledge Systems Centre (HP's European software tools specialists)
ph:    44 272 228794
email: wjb@hplb.hpl.hp.com

ObjectWorks, VisualWorks
------------------------
*Smalltalk programming environment from the Smalltalk people.
ParcPlace Systems, Inc.
999 E. Arques Avenue
Sunnyvale, CA 94086
email:	info@parcplace.com
fax:	1-408-481-9095
voice:	1-800-759-PARC

OpenTalk
--------
*Smalltalk to C++ and C Translator.
TNI Industries (Techniques Nouvelles d'Informatique)
ZI du Vernis
29200 Brest
France
tel 98 05 24 85, fax 98 49 45 33

OST/Look
--------
*C++ program animator.
*Suns, PCs, others coming.
Admiral Software
193-199 London Road
Camberley
Surrey
UK
Tel: (44) (276) 692269
Fax: (44) (276) 677533

Prograph
--------
*OO visual programming environment
*Macintosh
TGS Systems
Halifax, Nova Scotia
902-455-4446

SDE WorkBench/6000 ($918 - $7350)
---------------------------------
*Editor (syntax Highlighting), Browser, Flow Grapher, Make, Test Coverage
 Analysis, Debugger, Profiler, ...
*HP Apollo 9000, Sparcstations
IBM, Canada
PRGS Toronto Laboratory
895 Don Mills Road
North, York
Ontario, Canada, M3C 1W3
800-IBM-CALL

SNAP
----
*Template based devel. environment for building distributed OO applications
Template Software Inc.
13100 Worldgate Drive, Suite 340
Herndon, VA  22070-4382
(703) 318-1000

SNiFF+
------
*C/C++ development environment with fuzzy parser, Emacs integration and code
 browsers, free to universities.  See APPENDIX E, TOOLS AND CASE
*SunOS 4.x, Solaris 2.x, AIX 3.2, HP/UX 8.0/9.0
takeFive Software
Jakob-Haringer-Strasse 8
5020 Salzburg, AUSTRIA
phone: +43 662 457 915
fax:   +43 662 457 915 6
email: sniff@takefive.co.at

SparkWorks ($1995, $995 C++)
----------------------------
*Debugger, Profiler, Source Browser, File Merge, MakeTool
*Suns
SunPro
2550 Garcia Ave.
Mountain View, CA 94043
(800) 926-6620

Zortech C++ v. 3.1 ($499)
-------------------------
*Debugger, Workbench, Resource Workshop
*PCs?
Symantec Corp
10201 Torre Ave.
Cupertino, CA 95014
(408) 253-9600



APPENDIX D  OBJECT-ORIENTED CASE (OOA/D/P TOOLS) AND VENDORS
============================================================

See also APPENDIX C.

Below is a list of available OO CASE environments.  Thanks go to Ron Schultz
<ron@bse.com> for a list posted to comp.object on 9/13/92.  Many additional
entries have been added and additional entries are encouraged; please send
additions to the author of the FAQ (and/or to Ron).

Second is a collection of articles, products, and papers on CASE systems.
These appeared as posts to comp.object.

Available CASE Systems
----------------------

FORMAT:
    tool name, 
    description and methods
    operating systems
    Vendor name, 
    city/state, phone (if known)

AdaVantage ($1095--$1780)
-------------------------
*analysis, design (Ada) Generators:  production code, Ada compiler and tool set
 reusable components library
*PC AT/XT, Mac, Unix Workstations
Meridian Software Systems, Inc.
23141 Verdugo Dr., Ste 105, Laguna Hills CA 92653

ATRIOM
------
*Object-oriented analysis and design
*?? platforms supported unknown ??
Semaphore
North Andover, Ma.
508-794-3366 or
800-937-8080

Bachman Data Analyst
--------------------
*Data Modeling and analysis with OO support
*PC-DOS, OS/2
Bachman Information Systems
Burlington, Ma.
800-222-4626

BOCS
----
*Semantic Nets, Object-Message Diagrams, State Transition Diagrams, Petri-Nets,
 Graphical models
Berard Software Engineering
Gaithersburg, Maryland
301-417-9884
Ron Shultz
US $595.00 per single copy. 
Volume and educational discounts are available.

EasyCASE
--------
*parts of Shlaer/Mellor method plus lts of other non-OO notations
*Windows, DOS ($795 to $1,295)
Evergreen CASE Tools, Inc
8622 154th Ave NE
Redmond, WA  98052
(206) 881-5149
(206) 883-7070 (fax)

EiffelCase
----------
*Supports ISE's BON (Better Object Notation)
*Generates Eiffel class templates
*Unix, Windows NT ($1,995)
Interactive Software Engineering, Inc
270 Storke Road, Suite 7
Goleta, CA  93117
(805) 685-1006
(805) 685-6869 (fax)

Excelerator II
--------------
*supports Odell/Martin, Rumbaugh, and Wirf-Brock notation
*LAN, customizable graphics and rules
*OS/2 ($9,500)
Intersolv, Inc
3200 Tower Oaks Blvd
Rockville, MD  20852
(301) 230-3200
(301) 231-7813(fax)

Foundation
----------
*Object-based full life-cycle tools
*MVS, PC-DOS, OS/2, VAX/VMS, GCOS
Andersen Consulting
Chicago, Il.

GraphTalk
---------
*supports many methods (IE, NIAM, HOOD, Merise, SADT)
 configurable meta-CASE tool
 executable code generation of C (via enhanced pseudo code) and GQL
*Sun, DEC, RS6000, UNIX, Motif, PS/2, PC 386, OS/2
Rank Xerox
AI & CASE Division
7, rue Touzet Gaillard
93586 Saint-Ouen Cedex
France
+33 (1) 494 85085
+33 (1) 494 84350 (fax)

???
---------------------
Hamilton Technologies
Cambridge, Ma.

HOOD Toolset
------------
*supports HOOD notation
*Unix, DOS
CASET Corporation
33751 Connemara Dr
San Juan Cap., CA  92693
(714) 496-8670

IE\O  (Information Engineering)
-------------------------------
*OO version of IEF, allows existing entity models to evolve into OO models
 non-OO models can coexist with OO generates relational or OO database, as
 well as conventional file design to generate traditional or OO code
*OS/2 (delivery mid-1994?)
Texas Instruments
P.O. Box 2909   
Austin, TX  78769
(800) 527-3500

IEF  (and IEW)
--------------
*Object-oriented information engineering
*?? platforms supported unknown ??
Texas Instruments, Inc.
800-527-3500

ILOG KADS Tool
--------------
*supports knowledge-based system (KBS) approach named KADS, part is OO to
 capture knowledge, part involves rules that capture decision-making logic,
 generates C++
*Unix, DEC VMS
ILOG
2, ave Gallieni, BP 85
94523 Gentilly Cedex
France
+33 1 4663-6666
+33 1 4663-1582 (fax)

Intelligent OOA
---------------
*Developed with IPSYS ToolBuilder meta-CASE tool
 Supports Shlaer-Mellor, others?
Kennedy-Carter

KnowledgePro
------------
*OO Development environment with C++ code generation
*Windows
Knowledge Garden, Inc.
Nassau, N.Y.

MacAnalyst and MacDesigner
--------------------------
*Object-oriented analysis
*Macintosh
Excel Software
Marshalltown, Ia.
515-752-5359

MetaEdit
--------
*Analysis and design tool that supports most available structured
 and OO analysis and design methods, and can be easily be customized. 
 OO methods supported: Booch, Coad/Yourdon, Demeter, Rumbaugh, OSA and MOSESA.  
*MetaEdit is available for MS-Windows 3.1 (499$ - 1500$).
MetaCase Consulting OY
P.O. Box 449
FIN-40101  JYVASKYLA
Finland
tel. & fax. +358-41-650 400

[The shareware version can be found from Simtel, Cica, and their mirrors. The
 version 1.0 is shareware but the latest version 1.1 is fully commercial.]

Model 5w 
--------
*prototype, free with purchase of OOA text "The Problem Space".
 GUI front end for integrated repository supporting OO requirements
 analysis, including events, rules, participants, and locations.
*Windows 3.X under DOS or OS/2
Dan Tasker Consulting
Sydney, Australia
Phone/Fax +61 2 909-8961
dant@swdev.research.otc.com.au

OBJECT-DESIGNER
---------------
*Graphical object-oriented design tool
*?? platforms supported unknown ??
Chen & Associates, Inc.
Baton Rouge, La.
514-928-5765

Objecteering
-------------
*supports Softeam's "Class Relation" approach notation, analysis, design, and
 programming, generates C++ ("up to 60%"), open with multiple, concurrent user
*Sun, DEC, HP, RS6000, Unix, X Windows/Motif($9,500)
Softeam
One Kendall Square, #2200
-Cambridge, MA  02139
(617) 621-7091
(617) 577-1209 (fax)
-12, Avenue de Pres
78181 Montigny-le-Bretonneux
+33 (1) 30 43 86 06

ObjecTime CASE Toolset 
----------------------
*The ROOM methodology (Real-Time Object-Oriented Modeling), full support,
 executable specs.
ObjecTime Limited
340 March Road, Suite 200
Kanata, Ontario, Canada
K2K 2E4
Support: (613) 591-3400
Fax:     (613) 591-3784
sales@objectime.on.ca
support@objectime.on.ca
contact: ian@objectime.on.ca

ObjectMaker
-----------
*Berard, Booch, Coad/Yourdon, Colbert, Rumbaugh, and others
 Object-oriented analysis and design.  Meta-Case support.
*Windows, Unix, Macinstosh
Mark V Software
Encino, Ca.
818-995-7671

Objectory SE
------------
*Jacobson's OO Use-Case Approach
 4 configurations, $5000.00 - $10000.00 (USD)
Objective Systems
Kista Sweden
Torshamnsgatan 39, 
Mail Box 1128, S-164 ss
KISTA Sweden
support@os.se

Object System/Designer
----------------------
*Booch, Object-oriented design
*Windows
Palladio Software, Inc.
Brookfield, Wi.
1-800-437-0019 or
414-789-5253

ObjectTeam (also Teamwork)
--------------------------
*Shlaer/Mellor, Rumbaugh(a "special edition" of Paradigm Plus/Cadre)
*VAX/VMS, Unix, Windows, OS/2, PC-DOS
Cadre Technologies, Inc
Providence, R.I.
401-351-CASE
401-351-5950

Object Vision ($399, other)
---------------------------
*IBM PS/2, PC
*analysis, design, coding, proprietary methods, C++, Pascal, doc report gen.
Object Vision, Inc.

OEW (Object Engineering Workbench)  
----------------------------------
*supports Martin/Odell object diagrams, generates C++ code (templates unless
 supplemented with C++ coded methods) reverse engineers C++ code,
*Sun OS, PC Windows 3.x ($99-$2190)
Innovative Software GmbH
Niddastr. 66-68
6000 Frankfurt/M 1
Germany
+49 60 236 929
+49 69 236930 (fax)

OMTool
------
*Rumbaugh, Object-oriented analysis and design
*?? platforms supported unknown ??
Martin Marietta
Advanced Concepts Center
640 Freedom Business Center
P.O. Box 1561
King of Prussia, PA 19406
215-992-6200 or
800-438-7246

OMW (Object Management Workbench)
---------------------------------
*executes from Martin/Odell diagrams, produces fully executable ANSI C
 environment, UI construction facilities, "object engine" for managing
 objects, "rule engine" for managing rules interfaces with multiple databases
*UNIX; executable: any ANSI C environment ($5,000-25,000) 
IntelliCorp
1975 El Camino Real West Mountain View, CA  94025 
(415) 965-5500
(415) 965-5647

OOATool, OODTool
----------------
*Coad/Yourdon, Object-oriented analysis
*Macintosh, Windows, OS/2
Object International, Inc.
9430 Research Blvd IV-400
Austin, Tx  78759-6535
512-795-0202 or
800-926-9306
alternate numbers:
512-343-4549
FAX: 512-343-4569

OO-Other 
--------
*Coad/Yourdon, OO Documentation Tool, Shareware (CICA)
*Windows
Roman Zielinski Metod & SystemUtveckling
Norsborg, Sweden

OSMOSYS
-------
*OOA and OOD for OSMOSYS
Winter Partners
London Office:                 Zurich Office:
  West Wing, The Hop Exchange
  24a Southwark Street           Florastrasse 44
  London SE1 1TY                 CH-8008 Zurich
  England                        Switzerland
  Tel. +44-(0)71-357-7292        Tel. +41-(0)1-386-95 11
  Fax. +44-(0)71-357-6650        Fax. +41-(0)1-386-95 00

Paradigm Plus
-------------
*CASE toolset supporting Booch, Coad/Yourdon, EVB, and others
*Windows, Unix, OS/2
Protosoft
17629 El Camino Real 202
Houston TX 77058
Houston, Tx.
713 480 3233, Fax 713 480 6606

Ptech
-----
*supports Martin/Odell notation, "data model is the database", C++ and Ontos
 or Objectivity code generation (fully executable code), formal foundation
*Unix ($5,000 to $25,000)
Associative Design Technology
200 Friberg Parkway
Westborough, MA 01581  USA
(508) 366-9166

Rose
----
*Booch, Object-oriented analysis and design
*Unix, AIX
*C++ Booch Components 1-800-767-3237 ext. 23
*PC, MAC $495 PC; SPARC, HP 9000 RS/6000 $695; server license $2500
Rational
3320 Scott Blvd.
Santa Clara, Ca.  95054
408-496-3700
408-496-3600
e-mail : info@rational.com

SES Objectbench
---------------
*Shlaer/Mellor notation, supports GUI and database links editors, browsers,
 test utilities, and statistical analysis for simulation development.
 Emphasizes importance of model animation to functionally verify the analysis.
*UNIX ($4,900 to $24,300)
Software & Engineering Software (SES)
4301 Westbank Dr., Bldg A
Austin, TX 78746
(512) 328-5544
(512) 327-6646 (fax)

SoftBench ($1785 C++, $4500 Softbench)
--------------------------------------
*C++ class constructor, CASE (graphically modify C++), Browser, Analyzer,
 Editor, Builder, Debugger, ...
HP
3404 E. Harmony Rd. MS 81
Fort Collins, CO 80525
800-845-0070
or
Cupertino, Ca.
800-752-0900 ext. 2707
or 303-229-2255

Software Through Pictures
-------------------------
*Rumbaugh
 Not sure about: Wasserman's OOSD, OO SD with multi-user OO, data dictionary
*VAX/VMS, Unix
Interactive Development Environments
San Francisco, Ca.

Stood
-----
*HOOD (version 3.1) notation, supports Ada, C, C++
*Unix, RISC, X windows
Techniques Nouvells d'Informatique
Technopole Brest-Iroise
ZI du Vernis, Case postale 1
29608 Brest Cedex
France
+33 9 8052744
+33 9 849-4533 (fax)

System Architect
----------------
*Object-oriented design, Shlaer-Mellor, others?
*Windows, OS/2
Popkin Software
N.Y., N.Y.
212-571-3434

TASKON/OOram
------------
*A tool supporting the OOram (formerly named OORASS)
 methodology [Reenskaug 91].  Powerful support for types and roles.
*Windows and Unix versions available
Taskon
Gaustadalleen 21
N-0371-Oslo
Norway
Tel: +47-22 95 86 31
Fax: +47-22 60 44 27
ooram-info@taskon.no

Toolbuilder
-----------
*supports many methods (IE, HOOD, SSADM, Shlaer-Mellor)
 configurable meta-CASE tool, executable code generation of C, C++, Cobol,
 ADA (via enhanced design-level action diagrams) and Motif and Open Look
 interfaces via ANSI SQL to Sybase, Oracle, Informix
*Sun Sparc, Apollo, HP 9000, DECstation, RS6000 ($17,000)
IPSYS Software
28 Green Street
Newbury, MA 01951
(508) 463-0006
IPSYS Software plc
Marlborough Court
Pickford Street
Macclefield, Cheshire 
SK11 6JD  U. K.
+44 (625) 616722

TurboCase
---------
*Object-oriented analysis, structured design
*Macintosh
StructSoft
Bellevue, Wa.
206-644-9834

VIEWS-SF
--------
*supports VSF's extensive approach (including rules) some of which are based  
  on other popular notations, C++ template generation, reverse engineerings 
*OS/2, Unix ($8,000-$23,500)
Virual Software Factory, Inc
13873 Park Center Rd, #218
Herndon, VA  22071
(703) 318-1180
(703) 318-1190 (fax)


ARTICLES, PRODUCTS, AND PAPERS ON CASE SYSTEMS
----------------------------------------------

> "CASE Products 1990: A survey of CASE Products from US Vendors",
  Arbeitspapiere der GMD 518, March, 1991.  Heinz W. Schmidt,

Ovum Ltd
1 Mortimer Street
London W1N 7RH
England
Tel: +44 71 255 2670
Fax: +44 71 255 1995

From: oil@idt.unit.no (Odd Ivar Lindland)
Subject: Re: CASE Survey
Organization: Norwegian Institute of Technology, University of Trondheim
Date: Fri, 9 Jul 93 06:57:25 GMT
>...
A comprehensive survey of 35 commercial CASE tools is given in 
"Ovum evaluates: CASE products". It is from 1993 and is continuously updated. 
It has all the information you asked for. The bad thing is that it is very
expensive ($1995 !!!). You should get a 40 % academic discount, however.
Moreover, recently they had a "quick-answer discount" making the full price
(before academic discount) $1295. Anyway, I believe it is good investment if you
quickly want to have comprehensive information about the current CASE market.
Particularly valuable is the comparative evaluation of the 35 products.


> Proceedings of the Workshop on the Next Generation of CASE Tools (NGCT)

From: sjbr@cs.utwente.nl (Sjaak Brinkkemper)
Subject: 
Organization: University of Twente, Dept. of Computer Science
Date: Fri, 9 Jul 1993 11:05:51 GMT

The proceedings of the Fourth Workshop on the Next Generation of
CASE Tools (NGCT'93) are available as a technical report from the
Center for Telematics and Information Technology, University of
Twente.

Price: Nfl 45, US$ 25 (including shipping and money transfer)

Order by sending a message including a POSTAL ADDRESS to:
Sjaak Brinkkemper
CTIT
E-mail: sjbr@cs.utwente.nl

*******************************************************
*      Proceedings of the Fourth Workshop on the      *
*           Next Generation of CASE Tools             *
*     Universite Paris 1 Sorbonne - 7/8 June 1993     *
*******************************************************

Editors: S. Brinkkemper and F. Harmsen
Center for Telematics and Information Technology
University of Twente
the Netherlands
174 pages

Abstract

The Workshop on the Next Generation of CASE Tools (NGCT) is an
annual event, bringing together leading researchers on Computer
Aided Software Engineering (CASE). NGCT workshop is a pre-conference
workshop of the annual Conference on Advanced Information Systems
Engineering (CAiSE). The goal of this year's workshop, held in
Paris, is to conduct an in-depth discussion of research approaches
in the area of Computer Aided Software Engineering. Three main
themes have been identified: 
*       CASE architectures
*       Development process support
*       Advanced requirements engineering
The workshop committee accepted fourteen papers, which are grouped
in the proceedings according to these three themes. Among the topics
of the papers are: multiparadigm specification for interoperable
information systems, capturing design decisions, automated user
interface derivation, deductive repositories, human error analysis,
and business modeling.



APPENDIX E  ANONYMOUS FTP SITES
===============================

These are anonymous ftp sites of interest to the OO community.  Thanks go to
Mike DeVaney (dm_devaney@pnl.gov gen ftp site list) and to Bill Kinnersley
(billk@hawk.cs.ukans.edu, anon ftp programming languages list), whose initial
lists helped to get things going.  Additional short entries are encouraged;
please send additions to the author of the FAQ (and/or to Mike and Bill).

Entries will be standardized and summarized in future (non-draft) FAQs and are
not limited to one category.

Starred entries have a summary below and can be found as ">#" followed by the
description.  These entries will eventually be cleaned up.

PROGRAMMING LANGUAGES
---------------------

ajpo.sei.cmu.edu:/public/ada9x                  Ada-9x info, ARM
cs.nyu.edu:pub/gnat/...                        *Ada-9x (compiler, GNU,50)
ftp.inria.fr:lang/alcool                       *Alcool-90 (dyn ML,1)
arjuna.ncl.ac.uk:/pub/Arjuna                   *Arjuna (Distr Prog System,2)
munnari.oz.au:pub/bebop.tar.Z                  *BeBOP(seq,par,LP,OO,meta,46) 
sales@mjolner.dk                                BETA (Mjolner Informatics Demo)
monch.edrc.cmu.edu:/usr0/snl/archive/bos-1.2   *BOS (prototyping,3)
grape.ecs.clarkson.edu:/pub/msdos/djgpp/djgpp.zip C++ (for MS-DOS)
prep.ai.mit.edu:/pub/gnu/gcc-2.4.5.tar.gz       C++ (for Unix, & Objective-C)
omnigate.clarkson.edu:/pub/msdos/djgpp         *G++ for DOS (Many sites,4)
tsbgw.isl.rdc.toshiba.co.jp:
  pub/toshiba/cooc-beta.1.1.tar.Z              *cooC (Concurrent, OO C ext.,5)
parcftp.xerox.com:pcl                           CLOS
pion.lcs.mit.edu                                CLU (Sun, VAX)
ftp.cs.cornell.edu:/pub/CML-0.9.tar.Z           CML
arisia.xerox.com                                Pcl (Portable CommonLoops)
xcf.berkeley.edu:src/local/fmpl                *FMPL (prototyping,6)
nebula.cs.yale.edu                              Glasgow Haskell
piggy.cs.chalmers.se                            Chalmers Haskell (hbc)
software.watson.ibm.com                         Hermes (Unix)
cs.arizona.edu                                  Icon
sun.soe.clarkson.edu                            ISETL (DOS, Mac, Unix, VMS,src)
cs.orst.edu                                     Little Smalltalk (C src)
ftp.ircam.fr:/pub/IRCAM/programs               *MAX (visual OO,7)
128.59.24.6 (MeldC@cs.columbia.edu)             MeldC (Rflctv, prllel, OO lang)
gatekeeper.dec.com                              Modula-3
cs.uni-sb.de:/pub/osmall/machine               *O'small (OO lang for teaching,8)
obj3dist@csl.sri.com (license or request)      *OBJ3 (OO lang,9)
gate.fzi.de:/pub/OBST                          *OBST (lang, perst, OODB,10)
prep.ai.mit.edu:/pub/gnu/gcc-2.4.5.tar.gz       Objective-C (for Unix, & C++)
128.100.1.192:/pub/ootDistrib                  *OOT (OO Turing demo,11)
neptune.inf.ethz.ch                             Oberon (MacII, SPARC, DECstn)
wuarchive.wustl.edu:/mirrors/msdos/pgmutl/oberon11.zip Oberon (MS-DOS)
ux1.cso.uiuc.edu:pub/amiga/fish/ff380           Oberon (Amiga)
watserv1.waterloo.edu                           occam (VAX sim, Tahoe)
wuarchive.wustl.edu:/mirrors/unix-c/languages/ops5 OPS5 (interpreter)
wuarchive.wustl.edu:/mirrors/msdos/pli/runpli1a.arc PL/I (interpreter)
watserv1.waterloo.edu                           Russell
parcftp.xerox.com:pub/russell                   Russell
ftp.icsi.berkeley.edu:pub/sather               *Sather (simple Eiffel,12)
altdorf.ai.mit.edu: scm                         Scheme (small, portable)
gatekeeper.dec.com: elk                         Scheme (for Suns)
acorn.cs.brandeis.edu: gambit                   Scheme (for 68K's)
otis.stanford.edu                              *Self (13)
self.stanford.edu                               Self
cs.nyu.edu                                      SETL2 (DOS, OS/2, Mac, Unix)
rascal.ics.utexas.edu                           SIMULA 67 (Mac)
prep.ai.mit.edu:pub/gnu                         Smalltalk-80 (GNU v1.1)
st.cs.uiuc.edu                                 *Smalltalk V (38)
cs.yale.edu:pub/ml                              SML/NJ
research.att.com:dist/ml                        SML (Version 0.75)
sbcs.sunysb.edu                                 SML (lazy)
gatekeeper.dec.com                              Modula-3 (SRC)
ucbvax.berkeley.edu                             tcl
ftp.cs.umu.se:/pub/umlexe01.zoo                 uML

csd4.csd.uwm.edu:/pub/compilers/list            Free Compilers/Interp's list
primost.cs.wisc.edu: pub/comp.compilers/LanguageList*  Bill Kinnersley's list
idiom.berkeley.ca.us: pub/compilers-list/LanguageList*
See also Knowledge Media cd-rom collection on Languages, entry 47.


COMPILER TOOLS
--------------

prep.ai.mit.edu:pub/gnu/bison-1.14.tar.Z        Yacc
ftp.th-darmstadt.de:/pub/programming/languages/C++ *C++ gram, etc.,14
  [See also Free Compilers and Kinnersley's List above!]


DATABASES (See also APPENDIX B)
-------------------------------

ftp.informatik.rwth-aachen.de:pub/CB            *ConceptBase (OODB, reqkey,15)
pippin.cs.monash.edu.au:pub/export/diamond-0.1.2.tar.Z  *C++ OODB (16)
wilma.cs.brown.edu/pub/encore.tar.Z              Encore of Brown Univ
ftp.cs.wisc.edu:exodus                          *Exodus (Storage Man, perst,17)
ftp.informatik.rwth-aachen.de:/pub/unix/GRAS522_3 *GRAS (18)
mood.mech.tohoku.ac.jp                          *MOOD   (OODB, lim arch,19)
src.doc.ic.ac.uk:/computing/databases            MOOD/Postgres/OBST copies
gate.fzi.de:/pub/obst                           *OBST/STONE(schema,prst obj,10)
research.att.com                                *Ode    (C++ OODB,20)
postgres.berkeley.edu:pub                       *POSTGRES (Ext. Rel. DBMS,21)
toe.CS.Berkeley.EDU:pub/postgres                *POSTGRES,21
cs.utexas.edu:pub/garbage/{swizz,texaspstore}.ps *The Texas Persistent Store,41

See also idiom.berkeley.ca.us:pub/free-databases, object-oriented databases.


TOOLS AND CASE
--------------

ftp.th-darmstadt.de:/pub/programming/languages/C++ *Cls bwsr,tmplates,GC,etc,14
siam.unibe.ch:C++/Sniff1.6/                     *Sniff (C++ devel environ,22)
self.stanford.edu:/pub/sniff                    *Sniff,22
ftp.centerline.com:/pub/tags-1.0.tar.Z          *C++ tags, 23
interviews.stanford.edu:/pub/3.1.tar.Z           InterViews 3.1 (C/C++ browser)
wsmr-simtel20.army.mil(192.88.110.20)            OOTool (win31 directory?)
ftp.informatik.uni-stuttgart.de:/pub/eiffel     *Eiffel archive, 24
ftp.informatik.uni-stuttgart.de:/pub/eiffel/eiffel-3/sig *short tool, 24
ftp.cs.purdue.edu:/pub/gb/*                     *C++ Signatures (subtyping),40


LIBRARIES AND INTERFACES
------------------------

arjuna.ncl.ac.uk                             *C++SIM (Simula-like Sim Pkg,38)
csc.ti.com:pub/COOL.tar.Z                    *COOL(C++, orig from TI,25)
cs.utexas.edu:pub/COOL/GE_COOL2.1.tar.Z      *COOL(C++, Cfront 2.1, from GE,25)
omg.org:pub/NEC_DII/93-1-2...                 CORBA (DII)
claude.ifi.unizh.ch:under pub/standards/spec  CORBA Spec
omg.org:pub/OMG_IDL_CFE_1.2/bin              *idl.SunOS4.x, idl.Solaris2.x,26
ftp.cica.indiana.edu:/pub/pc/win3/programr   *MindFrame for Windows,54
ftp.th-darmstadt.de:pub/programming/languages/C++ *NIHCL COOL OATH ET++,etc,14
straylight.acs.ncsu.edu:/pub/ose             *OSE C++lib,42
watmsg.UWaterloo.ca:pub/uSystem              *u++(C++ Trans. and Concry RTS,48)


DOCUMENTATION AND INFO SERVERS
------------------------------

ftp.ncsa.uiuc.edu:Web/xmosaic or info.cern.ch:pub/www  *Browser for OO info,27
ftp.th-darmstadt.de:/pub/programming/languages/C++ *C++ docs, code, net sums,14
ftp.cm.cf.ac.uk:pub/Eiffel                     Eiffel FAQ
zaphod.uchicago.edu:/pub/faq.8-25[.Z]          OO FAQ (this document)
http://cui_www.unige.ch/OSG/FAQ/OO-FAQ/       *OO FAQ(hypertext version),WWW,27
http://cui_www.unige.ch/OSG/OOinfo/           *OO Information sources on WWW,27
byron.sp.cs.cmu.edu:/usr/anon/OODBMS/evolution-summary OODB Schema Evol Summary
byron.sp.cs.cmu.edu:/usr/anon/OODBMS/Manifesto.{PS,txt}.Z OODB Manifesto


PAPERS
------

scslwide.sony.co.jp:pub/CSL-Papers                  *Apertos (MO Distr OS,28)
sail.stanford.edu:pub/MT/93actors.ps.Z              *Actors Paper (UIUC,29)
biobio.cs.uiuc.edu:directory pub/papers             *Actors Papers,29
euagate.eua.ericsson.se:ftp/pub/eua/c++/rules.ps.Z  *C++ coding standard,44
self.stanford.edu:pub/papers/chambers-thesis        *Chambers' Thesis,30
http://cui_www.unige.ch/Chloe/Oscar/home.html        Concurrency Papers,WWW,27
ftp.gte.com:pub/dom                                 *Distrib Reports GTE,52
ftp.ifi.unizh.ch: pub/techreports/electra.ps.Z       Electra ORB, sec 3.8.6
cs.utexas.edu:pub/garbage/gcsurvey.ps                Garbage Collection,sec 3.9
wilma.cs.brown.edu:/pub/gdbiblio.{tex,ps}.Z         *graph drawing,31
world.std.com:/pub/kala/TechDocs/Overview_Sun.ps,*  *Kala Archive,45
ftp.ccs.neu.edu:pub/demeter/documents               *Law of Demeter,32
ftp.cs.ualberta.ca:pub/oolog/state.ps.Z              MUTABLE STATE OOPL SURVEY
mushroom.cs.man.ac.uk:/pub/mushroom/papers          *OO Dyn Grping, memory,33
st.cs.uiuc.edu:/pub/papers                           OO Frameworks, R. Johnson
cs.washington.edu:/pub/chambers/predicate-classes.ps.Z *Pred Classes (Cecil,34)
ginger.cs.berkeley.edu/pub/raidPapers                RAID Papers  (Berkeley) 
sprite.(cs.)berkeley.edu:~ftp/pub/RAID-II            RAID configs (Berkeley) 
ius4.ius.cs.cmu.edu:/usr/chimera/public/CMU_RI_TR_93_11.ps.Z *Real Time,49
self.stanford.edu:pub/papers/                        Self Papers
vega.dur.ac.uk:/pub/papers/foot.dvi                  Testing OO (sect 3.11)
townsend@mprgate.mpr.ca                              Testing OO (sect 3.11)
ftp.parc.xerox.com:/pub/mops/traces.ps              *Traces,kiczales,MOP,DI,43
neptune.inf.ethz.ch: pub/issac93.ps.Z                Types, Comp alg (Santas)
cui.unige.ch:OO-articles                             U. Geneva OO Group papers
research.microsoft.com:/pub/mernst/vdg.ps           *Value Dependence Graphs,57

The Postgres, OBST and Exodus sites also contain a good selection of papers. 


GENERAL
-------

ics.uci.edu:gnu/C++_wrappers.tar.Z    *ACE Lib, C++ Networking,55
scslwide.sony.co.jp:pub/CSL-Papers    *Apertos(Meta-Obj Distr OS, research,28)
euagate.eua.ericsson.se:ftp/pub/      *Archive site,C++,Coplien,papers,etc,44
research.att.com:dist/drawdag/*.Z     *Graph service,37
netcom.com:/pub/softia/keobj.zip      *KEOBJ, OO DSP micro-kernel,53
ftp.th-darmstadt.de:/pub/programming/languages/C++ *lots for C++,14
st.cs.uiuc.edu                        *Manchester Archive and some,35
ftp.odi.com:/pub/oo7/results.ps       *Object Design's OO7 Results,36
wuarchive.wustl.edu:languages/ada/crsware *Teaching OO Course Slides,51
cs.orst.edu:pub/budd/oopintro/slides/* *Teaching Intro to OO Slides, T. Budd,56


OTHER
-----

Computer Select Database              *commercial on cd-rom,39
Knowledge Media                       *Big col. on cd-roms, lots of freeware,47
godot.uvic.ca:/pub/oopsla-93          *OOPSLA-93 Info


DESCRIPTIONS
------------

>1  Alcool-90 (dyn ML)

What: Alcool-90 Release 0.40.3
From: rouaix@inria.fr (Francois Rouaix)
Date: 18 May 92 09:36:22 GMT

Alcool-90 is an experimental extension of ML with run-time overloading and
a type-based notion of modules, functors and inheritance.

New constructs have been added:
        * Overloaded symbols (overload).
        * Local definition of abstract values (overload in).
        * Implementations and parametric functors (pack to). 
        * Extension functors (overload with).
        * Class-based Dynamics (dynamic).

This version of Alcool is based on the CAML Light implementation (release
0.4) of the ML language, but this release is autonomous.

Alcool-90 is available by anonymous FTP from ftp.inria.fr:

    host:      ftp.inria.fr  (128.93.1.26)
    directory: lang/alcool
    files:
     README                 Copyright information.
     alcool270492.tar.Z     Sources for Un*x machines (Apr 27 1992 Release).
     alcooldoc.dvi.tar.Z    DVI for the Alcool-90 report draft.

For questions, comments, bug reports, please e-mail to Francois.Rouaix@inria.fr


>2  Arjuna (Distr Prog System)

What: Release 2 of Arjuna Distributed Programming System
From: arjuna@newcastle.ac.uk (Arjuna Project)
Date: Mon, 17 May 1993 12:37:34 GMT

        We are pleased to announce the  availability  of a new  version 
of Arjuna:  a programming system for  reliable  distributed  computing, 
and the Arjuna mailing list.

        The software  and the manual  for  the  Arjuna  system  can  be 
obtained by anonymous ftp: arjuna.ncl.ac.uk (128.240.150.1)

Arjuna System

        This beta release of  ArjunaPR2.0  fixes all known bugs present 
in ArjunaPR1.2B that have  been  reported to us or  that we have found, 
and contains only minimal information about how to use the new features 
provided.   This  release  should  be  compilable  with  the  following 
compilers:

        AT&T Cfront Release 2.1, on SunOS 4.1.x,
            (using Sun supplied lex and yacc).
        AT&T Cfront Release 3.0.1, on SunOS 4.1.x and Solaris 2.1,
            (using Sun supplied lex and yacc).
        GCC versions 2.1, 2.2.2, on SunOS 4.1.x,
            (using flex(v2.3.x) and bison).
        Patched GCC version 2.3.3 on SunOS 4.1.x and Solaris 2.1,
            (using flex(v2.3.x) and bison).
        Sun C++ 2.1, on SunOs 4.1.x,
            (using Sun's lex++ and yacc++).
        HP  C++ (B2402 A.02.34), HP-UX 8.07,
            (using HP supplied lex and yacc or lex++ and yacc++).

The major new features are:

        - Faster object store.
        - Support for replicated objects.
        - Memory resident object store.
        - Support for ANSAware (not available via ftp)

        Arjuna supports nested atomic actions (atomic transactions) for 
controlling operations on objects (instances of C++ classes), which can 
potentially be persistent. Arjuna has been implemented in C++ to run on 
stock  platforms  (Unix  on  SUNs,  HPs  etc).  The  software available 
includes  a C++  stub generator  which hides  much  of the  details  of 
client-server  based  programming,  plus  a system  programmer's manual 
containing  details of  how  to  install  Arjuna and  use it  to  build 
fault-tolerant  distributed  applications.  The software and the manual 
can be obtained by anonymous ftp: arjuna.ncl.ac.uk (128.240.150.1)

        Several  enhancements   and   ports  on   various   distributed 
computing platforms are in progress.  We would be pleased  to hear from 
researchers and teachers  interested in using Arjuna.  The programmer's 
manual  contains the  e-mail  addresses for sending  your  comments and 
problem reports.

ANSAware version of Arjuna

The ANSAware version of Arjuna is available from:

Architecture Projects Management Limited
Poseidon House
Castle Park                                  Phone    +44 223 323010
Cambridge                                    Fax      +44 223 359779
CB3 0RD                                      Internet apm@ansa.co.uk
United Kingdom                               UUCP     ...uknet!ansa!apm

Arjuna Mailing List

To enable us to  help people using Arjuna,  an electronic mail list has 
been setup. You can join  the Arjuna mailing list  by sending an e-mail 
message to "mailbase@mailbase.ac.uk" containing:

join arjuna <Your Name>

For example : join arjuna John Smith

Mail  messages  can  then   be  sent  to  "arjuna@mailbase.ac.uk",  for 
distribution.


Arjuna Project Team
The Department of Computing Science,
The University,
Newcastle upon Tyne.
NE1 7RU, UK.

Fax:           +44 91 222 8232
e-mail:        arjuna@newcastle.ac.uk
anonymous ftp: arjuna.ncl.ac.uk (128.240.150.1)

EMAIL = arjuna@newcastle.ac.uk
POST  = Computing Laboratory, The University, Newcastle upon Tyne, UK NE1 7RU
VOICE = +44 91 222 8067         FAX = +44-91-222-8232

Subject: Arjuna papers announcement
Date: Tue, 8 Jun 1993 16:47:02 GMT

This is to announce the availability of most Arjuna related papers and
theses via anonymous ftp from arjuna.ncl.ac.uk. These papers are
available in both US Letter and European A4 standards in postscript and
should now print on systems. Any problems in printing should be directed to
arjuna@newcastle.ac.uk.

Since there are too many papers to describe in one posting there is an index
available in /pub/Arjuna/Index which contains the abstracts from all of
the papers/theses and their locations within the ftp hierarchy.


>3  BOS (prototyping)

What: BOS
From: Sean.Levy@cs.cmu.edu
Date: 23 Apr 92 18:07:32 GMT

[For readers of comp.object and self-interest, BOS is a prototype-based
object system that I have, er, prototyped in Tcl. It is available via anon
FTP to monch.edrc.cmu.edu under /usr0/snl/archive/bos-1.2.tar.Z (you have to
cd to /usr0/snl/archive first and then get the file, due to CMU security hacks
in ftpd). I thought that this would be of interest to comp.object and
self-interest, so I'm cross-posting/mailing --S]

Note: I play very fast and loose with the terminology of OOP to get my
point across. I apologize if I offend any sensibilities, and will clarify what
I say if it is obfuscated by my use of terms.


>4  G++ for DOS (Many sites)

:From: DJ Delorie <dj@ctron.com>
:Newsgroups: gnu.announce,gnu.misc.discuss

:               DJGPP 1.10 is now available!
                         :
                         :
:               --- DJGPP - G++ for MSDOS/386 ---

:djgpp is normally uploaded to:
:  omnigate.clarkson.edu                 128.153.4.2     pub/msdos/djgpp
:  math.utexas.edu                       128.83.133.215  pub/msdos/djgpp(*)
:  ftp.uni-koeln.de                      134.95.128.208
:                                                       msdos/gnuprogs/djgpp (*)
:  ftp.eb.ele.tue.nl                     131.155.40.15
:                                                       pub/pc/gnu/gcc-pl* & gcc-newst
:  wowbagger.pc-labor.uni-bremen.de      134.102.228.9   pub/msdos/djgpp
:  src.doc.ic.ac.uk                      146.169.2.1     ibmpc/djgpp
:  ftp.mcc.ac.uk                         130.88.200.7    pub/djgpp
:  UK.AC.MCC.FTPJ (JANET)                user<guest>     <PUB>djgpp

:(*) Please do not access during working hours (7am - 6pm their local time)


>5  cooC (Concurrent, OO C ext.)

From: maeda@isl.rdc.toshiba.co.jp (Ken-ichi Maeda)
Subject: cooC FTP release (2nd posting)
Date: 2 Jul 93 15:13:11
Organization: TOSHIBA R & D Center, Kawasaki, JAPAN.

        We are pleased to announce the release of new object oriented
language based on C.  The language has support for concurrent object
execution with synchronous or asynchronous message pssaing and wait when
necessary reply handling.  The language known as cooC (concurrent object
oriented C) is available by anonymous FTP for research purposes.

        FTP Site:  tsbgw.isl.rdc.toshiba.co.jp (133.196.1.11)
        File: pub/toshiba/cooc-beta.1.1.tar.Z

        The released version of cooC employs SunOS(TM) LWP (light weight
process), to obtain concurrent execution.  The release consists of the
language translator (cooC->C), a runtime library (SunOS(TM)), a
concurrent object based debbuger, an example groupware application
(SharedDraw) and some technical papers.

BECAUSE THE SYSTEM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR
ANY PART OF THE SYSTEM.

        TOSHIBA Corporation while making cooC free for research, retains
copyright.

        For further detail, please refer to COPYRIGHT notice in the
package.

        Any questions and/or comments are welcome at the following
e-mail address.

        cooc@isl.rdc.toshiba.co.jp

--
--------------------------------------------------------------------
Ken-ichi Maeda <maeda@isl.rdc.toshiba.co.jp>
Communication and Information Systems Research Lab. II
TOSHIBA Research & Development Center
1, Komukai Toshiba-cho, Saiwai-ku, Kawasaki 210, JAPAN
TEL. (+81- or 0)44-549-2237  FAX. (+81- or 0)44-520-1841
--------------------------------------------------------------------


>6  FMPL (prototyping)

What: Interpreter for FMPL of Accardi, Release 1
From: blojo@xcf.berkeley.edu (Jon Blow)
Date: 2 Jun 92 08:42:26 GMT

An interpreter for FMPL of Accardi, Release 1 is now available for ftp at 
xcf.berkeley.edu:src/local/fmpl/.

*FMPL is a prototype-based object-oriented programming language.
*FMPL possesses lambda-calculus based constructs.
*FMPL is an event-driven language; the events it responds to are mainly
based on the behavior of input/output streams, not only within the unix domain
but across the internet as well.
*FMPL supports "pretty"-printing of internally-represented code back into
readable form.
*FMPL is an experimental language developed at the Experimental Computing 
Facility of the University of California, Berkeley.  This release is something
of a beta test since the language has not been widely used outside Berkeley.
It is hoped that this release will draw useful comments and suggestions from
the world at large that will help in improving future versions of FMPL.


>7  MAX (visual OO)

From: fingerhu@ircam.fr (Michel Fingerhut)
Subject: IRCAM DSP software for DEC/ALPHA and DEC/MIPS
Organization: Inst. de Recherche et Coordination Acoustique/Musique, Paris
Date: Fri, 13 Aug 93 11:25:23 GMT

ftp.ircam.fr:/pub/IRCAM/programs contains some of the IRCAM-developed
software packages (in demo version; see further down for availability
of the fully functional versions), including runnable binaries for
both the DEC/ALPHA (osf1) and DEC/MIPS (ultrix) architectures, and soon
available on other platforms (SGI and Macintosh).

MAX

MAX is a visual, object-oriented, programming language, initially
designed for interactive musical performance, but which is suitable for
digital signal processing as well as real-time control.  It allows
interconnecting of oscillators and filters, building custom controller
modules and simulation units all from a core collection of signal
processing objects.

First developed by Miller Puckette at IRCAM in late 1986 to control
the IRCAM 4X, it was later implemented on the Apple Macintosh as a
graphical programming environment for MIDI applications.  This version
has been extended by the Opcode company in Palo Alto, CA (USA), and is
available through them.

The Alpha version (and its demo-only subset) is based on the NeXT
version, where it is used to control the IRCAM-designed ISPW board.
This card, based on two Intel i860 microprocessors, handles
numerically-intensive real-time operations.

To date, it has been extensively used in live performance of
full-length musical compositions (see some references in the MAX/doc
directory), as well as in scientific and experimental applications
requiring real-time control.

SVP

SVP (``Super Vocodeur de Phase'') is a signal processing tool which was
designed and developed at IRCAM by Gilles Poirot and Philippe
Depalle.  It is a full system for the analysis and synthesis of sound,
whose core is a phase vocoder, and which comprises several modules for
analysis (FFT, LPC..), filtering (band modes, surface modes...), time-
scaling, mixing, spectral combination, cross-synthesis and
amplification, which can be combined in multiple ways.

UDI

UDI is a library of C routines which provides a coherent software
approach for developing and maintaining digital signal processing
algorithms on stand-alone workstations or on host/array processor
configuration.  Initially designed for sound signal analysis and
synthesis, it can be used by any application which does vector math
calculation.

It provides functions ranging from elementary vector and matrix
operations to more specific DSP operations, such as, but not limited
to, FFT, least-square, linear prediction coding, discrete cepstrum and
pitch detection.

UDI was actually used in implementing SVP.

HOW TO RETRIEVE

The following example contains underlined text.  If it does not print
nicely, use your favorite editor in order to remove all occurrences of
"^H_" (control-H followed by underscore).

Connect via ftp to ftp.ircam.fr.  Engage into the following dialog (the
underlined text is the reply you should provide

        220 ftp FTP server (Version 6.17 Thu Mar 11 08:30:51 MET 1993) ready.
        Name (ftp:host): f_t_p_            (or: a_n_o_n_y_m_o_u_s_)
        Passwd: l_o_g_i_n_@_y_o_u_r_m_a_c_h_i_n_e_       (see NOTE further down)
        230-...
        230-(informational messages, please read!)
        230-...
        ftp> c_d_ _p_u_b_/_I_R_C_A_M_/_p_r_o_g_r_a_m_s_
        250 CWD command successful.
        ftp> g_e_t_ _R_E_A_D_M_E_
        200 PORT command successful.
        150 Opening ASCII mode data connection for README (nnn bytes).
        226 Transfer complete.
        local: README remote: README
        nnn bytes received in mmm seconds (xxx Kbytes/s)
        ftp> b_i_n_
        200 Type set to I.
        ftp> g_e_t_ _s_v_p_._t_a_r_._g_z_             (or u_d_i_._t_a_r_._g_z_ or m_a_x_._t_a_r_._g_z_)
        ...
        ftp> q_u_i_t_

NOTE

The ftp server requires you to give as password something of the form
        l_o_g_i_n_@_h_o_s_t_
where l_o_g_i_n_ is your login name (or account name, or user information)
and h_o_s_t_ is the fully-qualified name of the machine you are currently calling
from, which is not necessarily the one on which you get your mail.  If you
mistype it, the ftp server will advise you with an informative error message.

AVAILABILITY

For information on availability of these and other IRCAM tools with
full functionality and documentation, and/or licensing of source code,
as well as IRCAM publications (technical/scientific reports) please contact
(in french or english, preferably):

        Mr. Vincent Puig
        Directeur de la Valorisation
        IRCAM
        31, rue Saint-Merri
        F-75004 Paris, France

        email:  puig@ircam.fr
        FAX:    +33 1 42 77 29 47

Additional info can be found in the README file in the above directory.

REPORTING PROBLEMS AND GETTING HELP

... in retrieving the software and/or in running it: please send email to

        manager@ircam.fr



>8  O'small (OO lang for teaching)

From: hense@sol.cs.uni-sb.de (Andreas Hense)
Subject: *** NEW O'small compiler available by ftp !!! ***
Date: 25 Jun 1993 13:54:35 GMT
Organization: Universitaet des Saarlandes,Rechenzentrum

             O'small - THE object-oriented language for teaching
             ---------------------------------------------------
                       (Announcement of a new compiler)

*** An object-oriented language for teaching?

Depending on which aspects of object-orientation you want to convey you
may choose your teaching language. If you want to teach the aspect of
software reuse and nice graphical user interfaces, you should choose
Smalltalk. If you want to show students how to program in a best
selling language you should choose C++.


*** In which case should I choose O'small?

You should consider O'small if you believe that computer languages
should have a GOOD FORMAL SEMANTICS. Everyone will agree that a
language needs a formal semantics. Otherwise, your program will yield
different results on different implementations. A good formal
semantics does not only serve the purpose of precisely defining what
the results of your programs are, it also gives insights about the
nature of the language. 

You should consider O'small if you do not want to waste time on
unnecessary details. O'small is CONCISE. Its syntax and semantics
takes no more than one page (if you choose the right font). Its syntax
is similar to more traditional languages. O'small has been used in a
lecture showing the differences between wrapper semantics
(denotational) and method lookup semantics (operational). 

O'small is FREE! Up to now, there has only been an O'small interpreter
written in Miranda [Hen91b]. This interpreter is directly based on the
denotational semantics of O'small [Hen91d]. The interpreter itself is
available by ftp. However, you need Miranda in order to run it. Now,
there is a NEW IMPLEMENTATION of O'small based entirely on EASILY
AVAILABLE SOFTWARE. This software is not free but it does not cost
anything. The new implementation is based on an abstract machine [Boe93].

You can MODIFY the language and have your students make experiments
with it. The source code of the abstract machine and the
specifications for the parser and scanner generators are available.
Using these generators you can make experiments for your own research
in statical analysis of object-oriented languages.


*** I would like to TRY O'small

You get the implementation by anonymous internet ftp.
The following table gives the ftp connection information.

Host:                   Net Address:      Directory:
-------------------------------------------------------------
cs.uni-sb.de            134.96.7.254      /pub/osmall/machine

The directory /pub/osmall/machine contains the files
        README 
        ANNOUNCE                this file
        HowToGetML 
        oma.1.00.tar.Z          compressed tar-file


***************************************************************************
NOTE: Ftp should be put into binary mode before transferring the compressed
tar file.
***************************************************************************

Here is a sample dialog:

   ftp
   ftp> open cs.uni-sb.de
   Name: anonymous
   Password: <your name>
   ftp> binary
   ftp> cd /pub/osmall/machine
   ftp> get README
   ftp> get ANNOUNCE
(  ftp> get HowToGetML  )
   ftp> get oma.1.00.tar.Z
   ftp> close
   ftp> quit

If you have a Sun 4 or a SPARC you can use the existing executable files.
Otherwise, you need 'sml-yacc', 'sml-lex' and 'sml-noshare'. Read
'HowToGetML' to obtain them.

Instructions on using the machine are contained in the file README.

References

[Boe93]  Christoph Boeschen.  Christmas - An abstract machine for
         O'small.  Master's thesis, Universit"at des Saarlandes, 
         Fachbereich 14, June 1993.

[Hen91b] Andreas V. Hense.  An O'small interpreter based on denotational
         semantics.  Technical Report A 07/91, Universit"at des Saarlandes,
         Fachbereich 14, November 1991.

[Hen91c] Andreas V. Hense. Type inference for O'small. Technical Report A
         06/91, Universit"at des Saarlandes, Fachbereich 14, October 1991.

[Hen91d] Andreas V. Hense.  Wrapper semantics of an object-oriented pro-
         gramming language with state. In T. Ito and A. R. Meyer, editors,
         Theoretical Aspects of Computer Software, volume 526 of Lecture No-
         tes in Computer Science, pages 548-568. Springer-Verlag, September
         1991.

[Hen93]  Andreas V. Hense.  Denotational semantics of an object-oriented
         programming language with explicit wrappers.  Formal Aspects of
         Computing, 5(3), 1993. to appear.

[HS92]   Andreas V. Hense and Gert Smolka.  A verification of extensible
         record types.  In Zhongzhi Shi, editor, Proceedings of the IFIP
         TC12/WG12.3 International Workshop on Automated Reasoning,
         pages 137-164, Beijing, P.R. China, 13-16 July 1992. Internatio-
         nal Federation for Information Processing, Elsevier, North-Holland,
         Excerpta Medica.

[HS93]   Andreas V. Hense and Gert Smolka.  Principal types for object-
         oriented languages. Technical Report A 02/93, Universit"at des Saar-
         landes, Fachbereich 14, June 1993.


>9  OBJ3 (OO lang)

What: Release 2.0 of OBJ3 (needed for FOOPS and OOZE, concurrent OOP)
Date: Thu, 4 Jun 92 15:07:26 BST
From: Paulo.Borba@prg.oxford.ac.uk

OBJ is available from SRI, see the message below; prototypes implementations of
FOOPS (without the concurrent extension) and OOZE are due to the end of the
year, but for both you also need OBJ. 

Unfortunately, I don't have any document about the FOOPS extension now, but
probably by the end of the year. I will send it to you as soon as possible.


What: Release 2.0 of OBJ3 is now available
From: winkler@csl.sri.com (Timothy Winkler)
Date: 6 Apr 92 08:35:40 GMT

Release 2.0 of OBJ3 is now available!

Improvements in this version include some language extensions and additional 
theorem proving features.  In addition, an effort has been made to speed up
the implementation; rewriting is often twice as fast as in the original
implementation.  We are including the AKCL patches from the University of
Texas at Austin in the distribution, which are necessary for maintaining the
portability of OBJ3 and also improve its efficiency.  In addition, we are
distributing a SPARC version of OBJ3.

OBJ3 has pattern matching modulo associativity, commutativity, and identity.
New: the system automatically computes conditions for rules involving matching
modulo identity that are used to prevent obvious non-termination problems.

Also new to this version of OBJ3 is a facility for controlled rewriting. This
provides substantially increased support for the use of the system for
equational theorem proving.

To receive the OBJ3 distribution tape or an OBJ3 license, send a request
to:

           Judith Burgess (OBJ3)
           Computer Science Laboratory
           SRI International
           333 Ravenswood Ave.
           Menlo Park, CA 94025-3493, USA

        Telephone: (415) 859-5924
        Fax: (415) 859-2844
            email: obj3dist@csl.sri.com

Be sure to give us your postal mailing address.  Then we will send you the
OBJ3 Information Form, and License Agreement, with instructions on how to
fill them out.  (A KCL license form will also be included.)  When you return
them to us, appropriately filled out and signed, we will send you the tape,
somedocumentation, and, in case you are requesting a tape, an invoice for
$150.00 plus any required taxes.

If you already have an OBJ3 license, then you don't need to get a new license,
but, if you are requesting a tape from SRI, you are asked to pay the above
distribution fee.

It is also possible to get a license for OBJ3 at no charge from SRI and then
get the OBJ3 distribution itself from some third party also having a license.

Jose Meseguer, Timothy Winkler, and Patrick Lincoln
Computer Science Laboratory
SRI International
333 Ravenswood Avenue
Menlo Park, California 94025, USA

Joseph Goguen
Programming Research Group
Computing Laboratory
Oxford University
11 Keble Road
Oxford OX1 3QD, United Kingdom


>10  OBST (lang, perst, OODB)

What: OBST (Version: OBST3-2)
From: stone@fzi.de
Date: 19/3/92

[ Formerly, we used the acronym SOS, which led to a conflict
  with an object oriented operating system of the same name.
  Therefore we changed the name to OBST ("Obst" is the German 
  word for "fruit"). As many people already use SOS (OBST) we 
  did not change internal things like class names, environment 
  variables and so on. ]

The persistent object management system OBST was developed by
Forschungszentrum Informatik (FZI) as a contribution to the STONE
project. This project (supported by grant no. ITS8902A7 from the
BMFT, i.e. the German Ministry for Research) aims at the development
of a software engineering environment for education purposes and is
carried out as a joint project of nine german universities and
research institutions.

An essential feature of STONE is that the object oriented paradigm 
is pursued consequently as a key concept. OBST is the common persistent
object store for all tools within the STONE environment. 

The OBST data model can be characterized by the following properties:

 * Schema definition language syntactically similar to C++
 * Support of multiple inheritance
 * Generic classes
 * Distinction between public, protected, and private methods
 * Redefinition of methods
 * Overloading of methods

Schemas are compiled by the OBST schema compiler. The compilation
results are instances of classes of the meta schema. From these
instances in a next step interfaces to different programming languages
can be generated. At present the C++ language binding is implemented,
interfaces to Lisp and other languages are planned.

Objects are stored in so-called containers. The container an object
belongs to is determined at the time of object creation and fixed
throughout the object's lifetime. Containers are the units of 
clustering, synchronization, and recovery. Objects can be referenced
by other objects across container boundaries.

OBST provides a mechanism to incrementally load methods. This enables
programs to deal with objects whose type is defined after the program 
itself has been developed. This is useful in systems that provide for 
inheritance and it supports schema evolution.

Since end 1990 the first prototype of OBST is available and is shipped
to interested universities and research institutions. 

The system comes with the schema compiler, a library of predefined
classes, a graphical object browser, the structurer and flattener and the
OShell, and all 
manuals. 

Structurer and Flattener is a tool to build objects from bytestrings and
flatten objects down to bytestrings. It is intended to be used when coupling
UNIX tools to the object management system. The user defines a grammar
that describes her objects. Afterwards, the structurer parses an ascii 
text according to the given grammar and creates an OBST object structure that
represents the corresponding parse tree.  The flattener does the inverse
transformation, that means it generates an ascii text from a given OBST object
structure according to the given grammar.

OShell is a tool which provides interactive access to the OBST object base.
There is a language called OSL which is based on the lambda calculus and
defines the interface to the OShell tool.

For the prototype's installation a C++ compiler (GNU g++ 1.37 or later or AT&T
2.0/2.1) and the X-Windows system (currently X11R4) for the graphical tools
are required. Installation is well-tried on SUN 3/* and SUN 4/* systems and
should be no problem on other UNIX machines, too.

--------------------------------------------------------------------
For more information please mail to:
                Forschungszentrum Informatik (FZI)
                       STONE Projekt
                 Haid-und-Neu-Strasse 10-14
                     D-7500 Karlsruhe 1
                          Germany
or email to:  stone@fzi.de

Phone:        ++49-721-9654-601
Fax:          ++49-721-9654-609
Teletex:      721 190 fziKA

The OBST system is available via anonymous FTP from gate.fzi.de
[141.21.4.3]. The system can be found in the directory /pub/OBST.

Sites interested in getting information about new OBST developments
are welcome to register in our mailing list by sending an email with
subject "obst-mailing-list" to stone@fzi.de.


>11  OOT (OO Turing demo)

What: OOT
From: holt@turing.toronto.edu (Ric Holt)
Date: 26 Apr 93 20:14:43 GMT

OBJECT ORIENTED TURING: DEMO AVAILABLE VIA FTP

OOT (Object Oriented Turing) is a programming language that has been 
developed at the University of Toronto.  An OOT demo, which includes the 
fully implemented language, is available for Sun/4's running X windows.  
See below for instructions to copy the demo to your site.

OOT supports the standard OOPL features of information hiding, classes,
polymorphism and generics, as well as the usual features in C and Pascal 
style languages.  It also supports concurrency, exception handling 
and system programming (pointer arithmetic, bit manipulation, etc).  

The OOT environment is designed for teaching Computer Science.
It is being used in introductory programming courses, courses
on OO concepts, compiler courses, OS courses, etc.

The OOT environment is fully integrated, with multi-window editing, turbo 
speed compiler, integrated color graphics, GUI user interface, implicit MAKE, 
on-line manual, integrated demos, etc.  The system includes an experimental
CASE tool with an interface browser and a visual system browser.


>12  Sather (simple Eiffel)

What: SATHER

Sather is under development at the International Computer Science Institute.
Sather has clean and simple syntax, parameterized classes, object-oriented
dispatch, multiple inheritance, strong typing, and garbage collection. The
compiler generates efficient and portable C code which is easily integrated
with existing code.

The initial beta test release of the language was in May, 1991. The compiler,
debugger, Emacs development environment, documentation, and library classes
are available by anonymous ftp from "icsi-ftp.berkeley.edu".
"sather@icsi.berkeley.edu" is a mailing list for discussing aspects of Sather
and "sather-admin@icsi.berkeley.edu" should be used for bug reports and
requests to be added or deleted from the mailing list.

Sather is based on Eiffel but is more concerned with efficiency and less with
some of the formal and theoretical issues addressed by Eiffel. The language is
much smaller than the current Eiffel, it eliminates over 40 keywords and
simplifies the syntax and inheritance rules. 

Like Eiffel, Sather code is compiled into portable C and efficiently links
with existing C code. The Sather compiler is written in Sather and has been
operational for almost a year, though it is still being improved. Preliminary
benchmarks show a performance improvement over Eiffel of between a factor of 4
and 50 on basic dispatching and function calls. On the benchmarks used at
Stanford to test Self (including 8 queens, towers of hanoi, bubblesort, etc),
Sather is even slightly faster than C++.

The Sather compiler and libraries are publicly available under a very
unrestrictive license aimed at encouraging contribution to the public library
without precluding the use of Sather for proprietary projects.  The goal is to
establish a repository for efficient, reusable, well written, publicly
available, classes for most of the important algorithms in computer science.
There are currently about 120 classes in the library. The libraries are
growing quickly and will collect together classes from many authors under the
same unrestrictive license. 

A GNU emacs development environment for Sather is available. A debugger based
on gdb from the Free Software Foundation is also available. A parallel version
of Sather for shared memory machines called "Psather" is also under
development.

From the Sather FAQ, August 16, 1993 (See Section 1.24):

Q 1: What is Sather?
     ~~~~~~~~~~~~~~ 
Sather is an object oriented language which aims to be simple,
efficient, interactive, safe, and non-proprietary. It aims to meet the
needs of modern research groups and to foster the development of a
large, freely available, high-quality library of efficient
well-written classes for a wide variety of computational tasks. It was
originally based on Eiffel but now incorporates ideas and approaches
from several languages. One way of placing it in the "space of
languages" is to say that it attempts to be as efficient as C, C++, or
Fortran, as elegant and safe as Eiffel or CLU, and to support
interactive programming and higher-order functions as well as Common
Lisp, Scheme, or Smalltalk.

Sather has garbage collection, statically-checked strong typing,
multiple inheritance, separate implementation and type inheritance,
parameterized classes, dynamic dispatch, iteration abstraction,
higher-order routines and iters, exception handling, assertions,
preconditions, postconditions, and class invariants. The development
environment integrates an interpreter, a debugger, and a
compiler. Sather code can be compiled into C code and can efficiently
link with C object files.


>13  Self

What: Self 2.0 Release
From: hoelzle@Xenon.Stanford.EDU (Urs Hoelzle)
Date: 10 Aug 92 21:08:25 GMT

Announcing Self Release 2.0

The Self Group at Sun Microsystems Laboratories, Inc., and Stanford University
is pleased to announce Release 2.0 of the experimental object-oriented
exploratory programming language Self.

Release 2.0 introduces full source-level debugging of optimized code, adaptive 
optimization to shorten compile pauses, lightweight threads within Self,
support for dynamically linking foreign functions, changing programs within
Self, and the ability to run the experimental Self graphical browser under
OpenWindows.

Designed for expressive power and malleability, Self combines a pure,
prototype-based object model with uniform access to state and behavior. Unlike
other languages, Self allows objects to inherit state and to change their
patterns of inheritance dynamically. Self's customizing compiler can generate
very efficient code compared to other dynamically-typed object-oriented
languages.

Self Release 2.0 runs on Sun-3's and Sun-4's, but no longer has an optimizing
compiler for the Sun-3 (and therefore runs slower on the Sun-3 than previous
releases).

This release is available free of charge and can be obtained via anonymous ftp
from self.stanford.edu. Unlike previous releases, Release 2.0 includes all
source code and is legally unencumbered (see the LICENSE file for legal
information.)  Also available for ftp are a number of papers published about
Self.

Finally, there is a mail group for those interested in random ramblings about
Self, self-interest@self.stanford.edu. Send mail to
self-request@self.stanford.edu to be added to it (please do not send such
requests to the mailing list itself!).

The Self Group  at Sun Microsystems Laboratories, Inc. and Stanford University


>14  C++ gram, etc.

What: ftp site for C++ material
From: schrod@iti.informatik.th-darmstadt.de (Joachim Schrod)
Date: 27 May 92 22:32:35 GMT

There were a lot of questions about C++ material in the last time and some 
announcements which involved our ftp server.
        ftp.th-darmstadt.de [130.83.55.75]
        /pub/programming/languages/C++
At the moment we have:
 -- documentation and assorted stuff
        C++ products list as announced by Saumen K Dutta (in a subdirectory!)
        C++ YACC grammar, ET++ tutorial, summaries from the Net,
        sources from James Coplien's book (idioms...), etc.
 -- class libraries
        NIHCL (original, persistent for ObjectStore, with g++ 1.4x changes)
        COOL, OATH, RogueWave vector, ET++,
        RPC package, a package for sockets, awe (thread package)
 -- tools
        class browser (for GNU Emacs), indent++, yacc+, template
        processor of Brad Cox[sp?], DEC garbage collector

More stuff is always welcome.  (Btw, Interviews and Motif C++ wrapper
classes are to be found in the /pub/X11 subtree.)


>15  ConceptBase (OODB, reqkey)

What: ConceptBase

See APPENDIX B.

A four week test-version of ConceptBase V3.1 is available 
on the FTP server ftp.informatik.rwth-aachen.de in the 
directory pub/CB.  For running the ftp version you must ask for a 
key by email.


>16  C++ OODB
Exodus (Storage Man, perst)

From: darrenp@dibbler.cs.monash.edu.au (Daz)
Subject: Re: Class libraries for accessing RDBs ?
Organization: Monash University, Melb., Australia.
Date: Thu, 17 Jun 1993 23:53:22 GMT

shekar@gizmo.CS.MsState.Edu (Chandrashekar Ramanathan) writes:

>Hello,
>       Are there any shareware/ftp'able C++ class libraries that
>provide Relational Database access? I would also appreciate any
>pointers (ideas/articles/journals) to the various issues that one has
>to consider in designing such library. 
Ok, I'm not sure if it's exactly what you want, but it's a database, it's
fully written in c++ with classes etc, and it's out for beta testing.

Check out pippin.cs.monash.edu.au:pub/export/diamond-0.1.2.tar.Z
and please mail darrenp@dibbler.cs.monash.edu.au if you decide to play with
it.

Daz.
--
Darren Platt, Department of Computer Science
darrenp@dibbler.cs.monash.edu.au
Monash University, Clayton Melbourne, Victoria, Australia


>17  Exodus (Storage Man, perst)

What: Exodus project software (Storage Manager & GNU E)
From: zwilling@caseus.cs.wisc.edu (Mike Zwilling)
Date: 16 Jul 92 04:53:19 GMT

In the past there have been discussions in comp.object and comp.databases
about persistent storage for object-oriented databases and programming
languages.  As you may know, the EXODUS Database Toolkit project at the
University of Wisconsin has researched these issues and others for a number of
years.  The purpose of this note is to inform you that the software from the
EXODUS project is freely available via anonymous ftp.  The EXODUS software
includes the EXODUS Storage Manager and the compiler for the E persistent
programming language.  Also included is documentation, and a suite of test
programs for both components.  This note briefly describes the software and
explains how to obtain it.  We currently support DECstation 3100s/5000s and
SPARC based workstations.  Others have ported the code to HP700s and IBM
RS6000s.

The EXODUS Storage Manager is a client-server object storage system which
provides "storage objects" for storing data, versions of objects, "files"
for grouping related storage objects, and indexes for supporting efficient
object access.  A storage object is an uninterpreted container of bytes which
can range in size from a few bytes to hundreds of megabytes.  The Storage
Manager provides routines to read, overwrite, and efficiently grow and shrink
objects.  In addition, the Storage Manager provides transactions, lock-based
concurrency control, and log-based recovery.

GNU E is a persistent, object-oriented programming language developed as part
of the Exodus project.  GNU E extends C++ with the notion of persistent data,
program level data objects that can be transparently used across multiple
executions of a program, or multiple programs, without explicit input and
output operations.

GNU E's form of persistence is based on extensions to the C++ type system to 
distinguish potentially persistent data objects from objects that are always
memory resident.  An object is made persistent either by its declaration (via
a new "persistent" storage class qualifier) or by its method of allocation
(via persistent dynamic allocation using a special overloading of the new
operator).  The underlying object storage system is the Exodus storage manager,
which provides concurrency control and recovery in addition to storage for
persistent data.

The current release of GNU E is based on gcc/g++ version 2.2.2, and is upward 
compatible with C++ as implemented by that compiler.

A bibliography of EXODUS related papers can be obtained from the ftp site
described below.

To obtain the software, simply ftp to ftp.cs.wisc.edu (128.105.8.18), login
as anonymous with your email address as a password, "cd" to the "exodus"
directory, and follow the directions (directions will be given as you "cd").
See the README for the latest information about the software and an indication
of our future plans.  If you decide to use the software, please contact us at
exodus@cs.wisc.edu so that we can notify you of changes.


>18  GRAS

GRAS - A Graph-Oriented Database System for SE Applications
Copyright (C) 1987-1992  Lehrstuhl Informatik III, RWTH Aachen
This library is free software under the terms of the GNU Library 
General Public License.

Lehrstuhl f"ur Informatik III --> GRAS
University of Technology Aachen (RWTH Aachen),
Ahornstr. 55,
D-5100 Aachen
Contact : Dr. Andy Sch"urr (or Richard Breuer),
andy@rwthi3.informatik.rwth-aachen.de
ricki@rwthi3.informatik.rwth-aachen.de (for technical support)

The system GRAS with interfaces for the programming languages Modula-2
and C is available as public domain software for Sun3/Sun4 workstations
(the GRAS system itself is implemented in Modula-2 and consists of many
layers which might be reusable for the implementation of other systems): 

  Via anonymous ftp from tupac-amaru.informatik.rwth-aachen.de
  (137.226.112.31) in the directory /pub/unix/GRAS522_3

  There are several files contain documentation, sources, binaries,
  and libraries. All binaries are for Sun/4 machines. Sun/3 binaries
  are shipped only if explicitly requested.

[See APPENDIX B]


>19  MOOD   (OODB, lim arch)

What: MOOD/P3 Ver.2.00 OODBS {Miniature,Materials}OODBS.
From: ono@mood.mech.tohoku.ac.jp (Noboru Ono)
Date: 18 May 92 10:28:42 GMT

The following program/sample database package is available through anonymous
FTP at mood.mech.tohoku.ac.jp (130.34.88.61). Sorry it is not the sources and
operates only in NEC-PC9801/MS-DOS environment.  Sorry again documents are all
in Japanese. We will tell you later when English documents has become ready.

      MOOD/P3 Ver.2.00
      Material's Object-Oriented Database, Prototype 3

This program, as you may guess,

      1) is an Object-Oriented database system program,
      2) operates on PC-9801 series personal computer, and
      3) is accompanied by sample material database schema.

Although this program has been developed and being used in the experiments
on material data processing in which we are now involved, it is a general
purpose OODBS. 

Noboru Ono
Dept. of Machine Intelligence and Systems Engineering,
Faculty of Engineering, Tohoku University.
Tel:++22-222-1800
Fax:++22-268-3688
E-mail:ono@mood.mech.tohoku.ac.jp


>20  Ode    (C++ OODB)

What: Ode Release 1.1
From: nhg@research.att.com

Ode is an object-oriented database based on the C++ database model. The
primary interface to Ode is the database programming language O++ which is
based on C++.

Ode 1.1 is now available to Universities.  This is a beta release.  The
current version of Ode runs on Sun (Sparc) workstations and users must have
C++ release 2.0 or a later release.  If you are interested in using Ode and
giving us feedback on your experience with Ode, please send me mail with the
appropriate information.

Narain Gehani
AT&T Bell Labs 3D-414
600 Mountain Ave
Murray Hill, NJ 07974


From: thssamj@iitmax.iit.edu (Aditya M. Jani)
Subject: *Announcement* UserGroup for ODE (OODBMS from AT&T)
Organization: Illinois Institute of Technology, Chicago
Date: Fri, 25 Jun 93 17:27:53 GMT

                    Ode Object database v2.0
                    ------------------------
Ode 2.0 is available via ftp from research.att.com.
Here is a sample session showing how to retrieve Ode 2.0
which is kept in the directory

    dist/ode2.0

as a compressed tar file named

2.0.oppbin.tar.Z

First create the directory on the local machine
where ode is to be installed, e.g.,

mkdir ode
cd ode

Retrieve the compressed tar Ode file using ftp into
as illustrated below.
Then uncompress it

uncompress 2.0.oppbin.tar.Z

and unbundle it

tar xvf 2.0.oppbin.tar

Next see file README, fix install file, and run install

./install
 



Sample ftp session
--------------
$ ftp research.att.com
Connected to tcp!192.20.225.2!1390.
220 inet FTP server (Version 4.271 Fri Apr 9 10:11:04 EDT 1993) ready.
Name (research.att.com:smith): anonymous
331 Guest login ok, send ident as password.
Password: smith@hostname
230 Guest login ok, access restrictions apply.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> cd dist
250 CWD command successful.
ftp> cd ode2.0
250 CWD command successful.
ftp> get 2.0.oppbin.tar.Z
200 PORT command successful.
150 Opening BINARY mode data connection for 2.0.oppbin.tar.Z (2762525
bytes).
226 Transfer complete.
2762525 bytes received in 1.6e+02 seconds (16 Kbytes/s)
ftp> quit 
221 Goodbye.

-------------------------------------------------------------------------------

                              Available Now!




                                 Ode 2.0
                       An Object-Oriented Database

       C++ Compatible, Fast Queries, Complex Application Modeling,
       Multimedia Support, and more




       Ode 2.0 is now available to Universities.  Users who currently
       have Ode 1.1 will be automatically sent a tape with Ode 2.0.
       There is no charge for Ode.  However, AT&T requires the signing
       of a non-disclosure agreement.



       Details
       -------

       ODE OBJECT-ORIENTED DATABASE

       The Ode object database is based on the C++ object paradigm.
       Ode  uses  one  integrated data model (C++ classes) for both
       database and general purpose manipulation.  The Ode database
       is   defined,   queried  and  manipulated  in  the  database
       programming language O++, which provides simple and  elegant
       facilities for manipulating the database.

       O++  is  an  upward-compatible  extension  of  C++.   A  few
       facilities have been added to C++ to make it into a database
       programming language.  C++ programmers can learn  O++  in  a
       very short time.

       O++ programs can be compiled with C++ programs thus allowing
       the use of existing C++ code.

       THE ODE MODEL OF PERSISTENCE

       Ode offers a simple and elegant notion of persistence  which
       is   modeled  on  the  ``heap''.   Specifically,  memory  is
       partitioned into volatile and persistent.  Volatile  objects
       are   allocated   in   volatile   memory  (stack  or  heap).
       Persistent objects are allocated  in  persistent  store  and
       they  continue  to exist after the program that created them
       has terminated.

       An Ode database is a collection of persistent objects.  Each
       object  is  identified  by  a  unique  object  id  (i.e.,  a
       persistent pointer,  or  to  be  precise,  a  pointer  to  a
       persistent object).

       The database programming language  O++  provides  facilities
       for   creating  and  manipulating  the  Ode  database.   For
       example,   O++   provides    facilities    for    specifying
       transactions,  creating and manipulating persistent objects,
       querying the database, creating and manipulating versions.

       WHAT IS AN OBJECT-ORIENTED DATABASE

       Some  important  characteristics   of   an   object-oriented
       database are:

          + data is stored as objects,

          + data  can  be  interpreted  (using  methods)  only   as
            specified by the class designer,

          + relationship  between  similar  objects  is   preserved
            (inheritance), and

          + references between objects are preserved.

       ADVANTAGES OF OBJECT-ORIENTED DATABASES

          + Speed: Queries can  be  faster  because  joins  (as  in
            relational  databases)  are  often not needed.  This is
            because an object can be retrieved directly  without  a
            search, by following object ids.

          + No impedance mismatch: The same data model is  used  by
            both   the   database   programming  language  and  the
            database;  it  is  not  necessary  to  do  any   format
            conversions  when  reading  the data from disk and when
            storing the data on disk.

          + Programmers  need  to  learn   only   one   programming
            language:  The  same  programming  language is used for
            both data definition and data manipulation.

          + Complex applications: The full power  of  the  database
            programming language's type system can be used to model
            the data structures of a complex  application  and  the
            relationship between the different data items.

          + Multimedia  applications:  The   semantic   information
            stored  in  the  database  (class  methods) facilitates
            correct  interpretation  of  the  data.   This  reduces
            application complexity since applications do no have to
            be responsible for the correct interpretation of data.

          + Versions: Object-oriented databases  typically  provide
            better support for versioning.  An object can viewed as
            the set of all its versions.  Also, object versions can
            be treated as full fledged objects.

          + Triggers  and  constraints:  Object-oriented  databases
            provide systematic support for triggers and constraints
            which are the basis of active databases.

       Finally, most, if not all, object-oriented applications that
       have  database  needs  will  benefit  from  using an object-
       oriented database.  Specifically, C++ applications that have
       database needs will benefit from using Ode.

       FEATURES OF ODE

         1.  Ode is C++ based and compatible with C++.

         2.  The  Ode  object   database   provides   four   object
             compatible  mechanisms  for  manipulating and querying
             the database: O++, OdeView, OdeFS, and CQL++:

                + O++ is a database programming language  based  on
                  C++.   O++  is  upward compatible with C++ and it
                  makes minimal  changes  to  C++.   O++  offers  a
                  simple and elegant notion of persistence which is
                  modeled on the ``heap''.  O++ provides facilities
                  for querying the database, and a variant of other
                  facilities.

                + OdeView is a graphical X-based interface  to  the
                  Ode database.

                + OdeFS is a  file  system  interface  to  the  Ode
                  object  database.   OdeFS  allows  objects  to be
                  treated and  manipulated  like  files.   Standard
                  commands  such as rm, cp and mv and tools such as
                  vi and grep can be used to manipulate objects  in
                  the database.

                + CQL++ is a C++ variant  of  SQL  for  easing  the
                  transition  from  relational databases to object-
                  oriented databases such as Ode.

             Currently, only O++ is shipped with Ode 2.0.  A  beta-
             test version of OdeFS is available upon request.

         3.  Ode supports large objects  (these  are  critical  for
             multi-media    applications).    Ode   provides   both
             transparent access for large objects and a  file  like
             interface  for  large objects.  The latter can be used
             to efficiently access and  update  parts  of  a  large
             object.

         4.  Users can create versions of objects.  Ode will  track
             the   relationship   between   versions  and  provides
             facilities for accessing the different versions.

         5.  Transactions  can  be  specified  as  read-only;  such
             transactions  are  faster  because they are not logged
             and they are less likely to deadlock.

         6.  Users   can   run    ``hypothetical''    transactions.
             Hypothetical  transaction  allow users to pose ``what-
             if'' scenarios (as often  done  with  spread  sheets).
             User  can  change  data  and  see  the impact of these
             changes without changing the database.

         7.  EOS, the storage engine of Ode, is based on a  client-
             server architecture.  Some features of EOS:

               a.  Efficient  and  transparent  handling  of  large
                   objects.  A file-like interface is also provided
                   for very large objects.

               b.  Concurrency is based on  multi-granularity  two-
                   version   two-phase   locking;  it  allows  many
                   readers and one writer to access the  same  item
                   simultaneously.

               c.  Log  records  contain  only  after   images   of
                   updates,  thus making logs small.  Recovery from
                   system failures requires one scan over  the  log
                   resulting in fast restarts.

       USE MODES

       Ode supports two modes of use:

         1.  Client-server (allows multiple  users  to  access  the
             database concurrently).

         2.  Single user (improved performance  compared  to  using
             the client-server mode).

       USERS

       Ode 2.0 is currently being used as the multi-media  database
       engine  for  AT&T's  Interactive TV project.  Ode 1.1 (older
       version of Ode with  limited  capabilities)  has  also  been
       distributed to 30+ sites within AT&T and 135+ universities.


>21  POSTGRES (Ext. Rel. DBMS)

What: Version 4.0 of the POSTGRES DBMS
From: mer@gaia.CS.Berkeley.EDU (Jeff Meredith)
Date: 16 Jul 92 04:53:17 GMT

Version 4.0 of the POSTGRES DBMS is now available for distribution. Version 4.0 
provides significant advances in functionality over 3.1.  General improvements
in the code and some key multi-user bug fixes have resulted in a much more
reliable system than we have ever previously released.

Major new features include:
 o  Complete support for language (POSTQUEL) functions.
 o  Handling of nested dot expressions.
 o  Optimization of predicates with expensive functions.
 o  Binary portals
 o  Initial support of sets
 o  Indices on system catalogs.

Postgres runs on Sparc I, Sparc II, Sun 4 running SunOs, and DECstations
running ULTRIX >= 4.0, as well as Sequent Symmetry machines.  Postgres
consists of about 250,000 lines of C.

If you would like to get Postgres 4.0, you can get it in one of two ways:

(1)  Anonymous FTP from postgres.berkeley.edu

cd pub
get postgres-setup.me
binary
get postgres-v4r0.tar.Z
quit 

Or, if you do not have net.access, you can order a Postgres distribution
tape by sending a check payable to the Regents of the University of California
for $150.00 to:
         Postgres Project
         571 Evans Hall
         University of California
         Berkeley, CA 94720.

Indicate in your accompanying letter whether you want the system on a 9-track
tape at 1600 BPI, at 6250 BPI, on a cartridge tape for SUN shoeboxes (QIC 24 
format), or on a TK50 DEC cartridge tape.


>22  Sniff (C++ devel environ)

[See also APPENDIX C, SNiFF+, for the commercial version]

What: SNIFF (Sniff 1.1b (C++ Development Environment))
From: shite@sinkhole.unf.edu (Stephen Hite)
Date: 23 Aug 92 18:14:00 GMT

Sniff 1.1b is available from iamsun.unibe.ch in the C++ hierarchy.  It's a
development environment for C++ (minus the C++ compiler or interpreter).
It's freely available and you're gonna need OpenWindows 3.0 if you want
to play with it immediately.  I just downloaded it and haven't had a 
chance to look into whether the XView 3.0 package will be able to handle
everything Sniff requires of the OpenLook part.

And:

From: sniff@takeFive.co.at (Mr. Sniff)
Newsgroups: comp.lang.c++,comp.unix,comp.unix.osf.osf1,comp.unix.solaris,comp.object
Subject: SNiFF+ takeFive Starts Free University Distribution of Commercial C/C++ Programming Environment
Date: 22 Sep 1993 15:51:26 GMT
Organization: EUnet EDV-Dienstleistungsgesellschaft m.b.H
Keywords: programming environments, browsing, C++

SNiFF+: takeFive Starts Free University Distribution of Commercial C/C++
Programming Environment

1. Introduction
 ===============
Since the beginning of 1993 takeFive has taken over development and support 
for SNiFF+, a leading edge C/C++ programming environment.  With SNiFF+ 
rapidly gaining commercial acceptance takeFive has decided to offer the 
product free to educational establishments. There are several reasons for 
this step.

...

6. How to Obtain SNiFF+
 =======================
6.1 FTP
 -------
Sniff can be downloaded from anonymous FTP sites in USA and Europe.
You can get all details from info@takeFive.co.at.

And:

From: hueni@iam.unibe.ch (Hermann Hueni)
Subject: Re: Browsers
Date: Fri, 11 Jun 1993 12:37:28 GMT

Sniff is a commercial product.
Send mail to info@takeFive.co.at
AN early version is available as a SUN SPARC binary only from
siam.unibe.ch:C++/Sniff1.6/     (THIS site is in EUROPE)


>23  C++ tags
Eiffel archive,24
short tool, 24

What: ctags/etags for C and C++
From: kendall@centerline.com (Sam Kendall)
Date: 10 Jun 92 09:31:27 GMT

A lot of people have requested this software!  You can now get Tags for
C/C++ version 1.0 via anonymous ftp at:

        ftp.centerline.com:/pub/tags-1.0.tar.Z

ftp.centerline.com is 140.239.2.29.  Anonymous ftp means login as "ftp" and
give your email address as the password.

If you don't have ftp access to the internet, you may want to wait for this
stuff to come out in comp.sources.unix.  Or, if you plan to use it right away,
send me a letter that says "I can't use ftp; please send by email" and I will
do so.


>24  short tool

From: neil@aldur.demon.co.uk (Neil Wilson)
Subject: New version of 'short' available
Date: Sat, 7 Aug 1993 09:38:25 +0000

A new beta release (1.2) of 'short' is available from the Stuttgart
Eiffel archive (ftp.informatik.uni-stuttgart.de) in directory
/pub/eiffel/eiffel-3/sig

Command line processing is now included in the short system. Short can
now cope with multiple input files, the standard input and deal with
most file errors.

Short now depends on the argument cluster which is available from
the same archive and directory.

Short supports the following options:

        -V, +version, -h, +help
                Displays the 'short' version information and gives the
                usage help message for the command.

        -e, +abstract, +eiffel
                Produces a fully deferred version of the input class(es)
                which will compile just like any other class (hopefully :-)

        -l <class_name>, +view <class_name>
                Produces the output from the point of view of the class
                <class_name> - the "short form for <class_name>".
                Special handling for ANY and NONE of course. By default
                short outputs the "short form for ANY".

        -f, +full
                Produces the short form including all the feature
                blocks.  (Implemented as the "short form for NONE".)

        -p, +parents
                Retains the inheritance clause in the output. The default is
                to drop it.

        -b <number>, +blank <number>
                Indent levels by <number> characters. 

        -c <number>, +column <number>
                Width of the output is <number> characters. Should be
                greater than 20.

Obsolete features are not retained. Obsolete classes retain no features.

The output of the tool now conforms to the layout rules in Appendix A of
ETL and should look like the 'short' examples in the book. As much as is
possible the output and command line options conform to ISE's 2.3
version of 'short'.

This release of short has been tested on all the v1.21 Eiffel/S
libraries, itself and the argument clusters, plus any other class
fragments I had lying around at the time.

My biggest debt is of course to David Morgan. This version is only
really a tiny modification of his work. His ELEXER Eiffel 3 parser
remains the core of the tool.  I though am responsible for any remaining
deficiencies or problems with this release.

Problems, suggestions, comments, criticisms to me please. All gratefully
received - I can't improve my Eiffel if somebody doesn't tell me where I
blew it.


>25  COOL(C++, Cfront 2.1, from GE)

COOL is a C++ class library developed at Texas Instruments.

Features are:
1. Rich set of containers like Vector, List, Hash_Table, Matrix, etc...
2. Hierarchy is shallow with no common base class, rather than deep like NIHCL.
3. Functionality close to Common Lisp data structures, like GNU libg++.
4. Template syntax very close to Cfront3.x, g++2.x.
5. Free, with good documentation, and extensive test cases.

Light version of COOL from General Electric:
1. Hairy macros, run-time type, exceptions removed for mainstream C++
   compatibility
2. Free of memory leaks and bound violations. Leaks and bounds are checked
   with Purify.
3. Has memory management and efficient copy in expressions like:
  Set c = a+b+c;    
  Pointers are shared with Handle and Reference count. Deep copy in
  expressions are replaced by shallow copy.
4. Compatible with Cfront2.1, and is being converted to Cfront3.0. You can
  build both static and shared library on SunOS 4.1.x

1. original version from Texas Instruments:
   at csc.ti.com, get pub/COOL.tar.Z
2. Cfront2.1 version modified by General Electric:
   at cs.utexas.edu, get pub/COOL/GE_COOL2.1.tar.Z

I am working on Cfront3.0 version of COOL, using the Beta 3.0 from Sun. I am
experiencing problems with instantiation and specialization of templates.  So
Cfront3.0 version of COOL won't be available until Sun's Cfront 3.0 is
released with bugs fixed.

Van-Duc Nguyen
General Electric 
Research & Development Ctr
1 River Road, Room K1-5C39.
Schenectady, NY 12301.
Phone: (518) 387-5659
Fax:   (518) 387-6845
nguyen@crd.ge.com


>26  idl.SunOS4.x, idl.Solaris2.x

Subject: Binaries for OMG IDL CFE placed on omg.org
Date: 11 Jun 93 00:13:11 GMT
Reply-To: jyl@toss.eng.sun.com


SunSoft has made available statically linked binaries for the OMG IDL CFE,
for both Solaris 1.x and Solaris 2.x. Because they are statically linked,
these binaries can be used on systems which do not have the SparcWorks (TM)
compilers installed.

It is expected that people who only want an IDL parser will prefer to
obtain these binaries instead of compiling the program on their host.
People who want to build a complete compiler, by programming their own
back-end, will continue to obtain the sources which are also provided at
the same location.

The binaries can be obtained by anonymous FTP to omg.org. They are
installed in the directory pub/OMG_IDL_CFE_1.2/bin, in idl.SunOS4.x and
idl.Solaris2.x. Uuencoded versions are also available, in the same
directory.

Please send email to idl-cfe@sun.com if you obtain these files.

The attached copyright applies to the provided binaries and to the source
files provided on the omg.org file server.


Copyright:
Copyright 1992 Sun Microsystems, Inc.  Printed in the United States of
America.  All Rights Reserved.

This product is protected by copyright and distributed under the following
license restricting its use.

The Interface Definition Language Compiler Front End (CFE) is made
available for your use provided that you include this license and copyright
notice on all media and documentation and the software program in which
this product is incorporated in whole or part. You may copy and extend
functionality (but may not remove functionality) of the Interface
Definition Language CFE without charge, but you are not authorized to
license or distribute it to anyone else except as part of a product or
program developed by you or with the express written consent of Sun
Microsystems, Inc. ("Sun").

The names of Sun Microsystems, Inc. and any of its subsidiaries or
affiliates may not be used in advertising or publicity pertaining to
distribution of Interface Definition Language CFE as permitted herein.

This license is effective until terminated by Sun for failure to comply
with this license.  Upon termination, you shall destroy or return all code
and documentation for the Interface Definition Language CFE.

[...] etc. on copyright stuff [...]

SunSoft, Inc.  
2550 Garcia Avenue 
Mountain View, California  94043


>27  Browser for OO info

From: oscar@cui.unige.ch (Oscar Nierstrasz)
Subject: CUI & Object Oriented Information Sources on the World Wide Web
Reply-To: oscar@cui.unige.ch
Organization: University of Geneva, Switzerland
Date: Fri, 25 Jun 1993 12:18:38 GMT

An HTTP server has been installed at the Centre Universitaire d'Informatique
of the University of Geneva.  Information about various research groups at
the CUI is available, as well as a number of other experimental services.

The Object Systems group at CUI is providing a number of pointers to
Object-Oriented Information Sources available on the World Wide Web.
The page containing these sources is accessible from the CUI home page.
The URL is: http://cui_www.unige.ch/home.html

You must have a WWW browser to access the information.  If you do not have
a browser, you should obtain, for example, the xmosaic browser from:
ftp.ncsa.uiuc.edu:Web/xmosaic or info.cern.ch:pub/www.

The material available from CUI is in an early stage of development.
Suggestions for additional OO references to include (or whatever) are welcome!

Oscar Nierstrasz

----------------------------------------------------------------------------
        Dr. O.M. Nierstrasz, Centre Universitaire d'Informatique
University of Geneva, 24, rue General-Dufour, CH-1211 Geneva 4, Switzerland
        Tel: +41 22 705.7664    Secr: 705.7770    Fax: 320.2927
            E-mail: oscar@cui.unige.ch  Home: 733.9568
----------------------------------------------------------------------------


>28  Apertos(Meta-Obj Distr OS, research)

The Apertos (formerly MUSE) project at Sony Research
is a meta-object based distributed OS for turning portable wireless
hand-held computers into fully-connected Dynabook-like
terminals.  It's very very wizzy.  The papers are on: 
        scslwide.sony.co.jp:pub/CSL-Papers

The source is available for research; I think you have to
sign something first.


>29  Actors Paper (UIUC)

From: agha@cs.uiuc.edu (Gul Agha)
Subject: Actor Theory Paper available
Organization: University of Illinois, Dept. of Comp. Sci., Urbana, IL
Date: Wed, 4 Aug 1993 15:41:02 GMT

A new paper providing a definitive and detailed development of the
semantics of actor systems is available via anonymous ftp.  Comments
are especially welcome.  


Title:          A Foundation for Actor Computation

Authors:        Gul Agha, Univerity of Illinois at Urbana-Champaign
                Ian Mason, Stanford University
                Scott Smith, John Hopkins University
                Carolyn Talcott, Stanford University

Abstract:

        We present an actor language which is
        an extension of a simple functional language, and provide a precise
        operational semantics for this extension.  Actor configurations are
        open distributed systems, meaning we explicitly take into account the
        interface with external components in the specification of an actor
        system.  We define and study various notions of equivalence on actor
        expressions and configurations.

to ftp the compressed postscript file:
        ftp sail.stanford.edu  (or 36.28.0.130)
        login: anonymous
        send ident as password.
        cd pub/MT
the file is called:  
        93actors.ps.Z

Note: the paper is 76pp long.  It subsumes work reported in our paper
in CONCUR '92.  

(A number of other recent papers on actor languages and their
implementation may be obtained by anonymous ftp from
biobio.cs.uiuc.edu in the directory pub/papers).


>30  Chambers' Thesis

What: SELF optimizing compiler and Thesis
From: chambers@cs.washington.edu (Craig Chambers)
Date: 9 May 92 22:00:53 GMT

My Ph.D. thesis, entitled "The Design and Implementation of the Self Compiler,
an Optimizing Compiler for Object-Oriented Programming Languages," is now
available as Stanford technical report number STAN-CS-92-1420.  Copies may be
ordered from Stanford.  Stanford requires $20 (plus tax for orders from within
California), in advance, for each copy.

The dissertation also is available in compressed postscript form.  The
electronic version may be copied via anonymous ftp from self.stanford.edu in
the directory pub/papers/chambers-thesis.  This version is free.  Note however
that the thesis is about 250 pages long.


>31  graph drawing

From: rt@cs.brown.edu (Roberto Tamassia)
Subject: annotated bibliography on graph drawing algorithms
Organization: Brown University Department of Computer Science
Date: Wed, 30 Jun 1993 06:45:48 GMT

A new revised version of the annotated bibliography on graph drawing
algorithms by Giuseppe Di Battista, Peter Eades, Roberto Tamassia, and
Ioannis Tollis is now available via anonymous ftp from
wilma.cs.brown.edu (128.148.33.66).  The files are /pub/gdbiblio.tex.Z
and /pub/gdbiblio.ps.Z.


>32  Law of Demeter

From: lieber@ccs.neu.edu (Karl Lieberherr)
Subject: Law of Demeter/Adaptive Software
Organization: College of CS, Northeastern University
Date: Fri, 4 Jun 1993 20:41:49 GMT

 >...
 Yes, the Law of Demeter paper is available in electronic form on the
 net. Indeed, many of the Demeter project papers are available from
 the ftp server at Northeastern University (see instructions below).

 The Law of Demeter idea has been automated in the Demeter Tools/C++
 as an adaptive software tool which automatically makes much of your C++ code
 compliant with the Law of Demeter. The tool is an add-on tool to
 your favorite C++ development environment and is commercially available
 from Demeter International. The Demeter Tools/C++ lift
 object-oriented programming to a higher level of abstraction
 by allowing the user to focus on the essential and
 stable classes. A paper on ADAPTIVE SOFTWARE will appear in 
 the Communications of the ACM and is also available from the
 ftp server.

 For more information, use the ftp instructions below or call

Demeter International
56 Bennett Road
Marblehead, MA 01945

 phone: (617) 639 1544
 fax: (617) 373 5121

or send e-mail to demeter@ccs.neu.edu 

-- Karl Lieberherr

FTP instructions:

Some of our papers are available in one package by anonymous ftp from

ftp.ccs.neu.edu (129.10.10.51)

in directory pub/demeter/documents

Use the following command sequence to copy the Demeter papers:

% ftp ftp.ccs.neu.edu or 129.10.10.51)
Name ( ... ): ftp
Password: your-email-address
ftp> cd pub/demeter/documents
ftp> ls
ftp> binary
ftp> get papers.tar.Z
ftp> quit
% uncompress papers.tar.Z
% tar xf papers.tar

If you want to copy individual papers and not all at once, go to 
directory pub/demeter/documents/papers and retrieve them
individually.

Law of Demeter paper:
  LH89-law-of-demeter.ps
Adaptive Software papers:
  LSLX93-adaptive-programming.ps
  L92a-component-enhancement.ps
  LHSLX92-pp-experience.ps


>33  OO Dyn Grping, memory

From: mario@cs.man.ac.uk (Mario Wolczko)
Subject: Re: OOPLs and Locality of Reference
Keywords: locality of reference
Date: 5 Jul 93 14:39:13 GMT
Organization: Dept Computer Science, University of Manchester, U.K.

[...]
The measurements done as part of the work here on the Mushroom project
show that temporal locality within Smalltalk objects is great (and
hence even conventional caches work reasonably well [unless the GC
scheme trashes the cache]), whereas spatial locality on a scale much
larger than the average object (which is 40 bytes) is much harder to
come by.

More details can be found in these papers (all available by ftp from
mushroom.cs.man.ac.uk in /pub/mushroom/papers):

  dgvm1.ps.Z
    "Dynamic Grouping in an Object Oriented Virtual Memory Hierarchy"
    Ifor Williams, Mario Wolczko, Trevor Hopkins, Proc. ECOOP 87,
    Springer-Verlag LNCS 276, pp.79-88.

  dgvm2.ps.Z
    "Realization of a Dynamically Grouped Object-Oriented Virtual
     Memory Hierarchy", Proceedings of the Workshop on Persistent Object
     Systems: Their Design, Implementation and Use, available as
     Persistent Programming Research Report PPRR-44-87, Universities
     of Glasgow and St. Andrews, Aug. 1987, pp.298--308.

  obma.ps.Z
    "An Object-Based Memory Architecture"
    Ifor Williams and Mario Wolczko, in Implementing Persistent Object
    Bases: Proc. Fourth International Workshop on Persistent Object Systems,
    Morgan Kaufmann, 1991, pp.114-130.
    The first three figures are in obma-fig[123].ps.Z.

Mario Wolczko

   ______      Dept. of Computer Science   Internet:      mario@cs.man.ac.uk
 /~      ~\    The University              uucp:    mcsun!uknet!man.cs!mario
(    __    )   Manchester M13 9PL          JANET:         mario@uk.ac.man.cs
 `-':  :`-'    U.K.                        Tel: +44-61-275 6146  (FAX: 6236)
____;  ;_____________the mushroom project___________________________________


>34  Pred Classes (Cecil)

What: "Predicate Classes" paper
From: chambers@klamath.cs.washington.edu (Craig Chambers)
Date: Fri, 30 Apr 93 01:25:02 GMT

"Predicate classes are a new linguistic construct designed to
complement normal classes in object-oriented languages. Like a normal
class, a predicate class has a set of superclasses, methods, and
instance variables. However, unlike a normal class, an object is
automatically an instance of a predicate class whenever it satisfies a
predicate expression associated with the predicate class. The
predicate expression can test the value or state of the object, thus
supporting a form of implicit property-based classification that
augments the explicit type-based classification provided by normal
classes. By associating methods with predicate classes, method lookup
can depend not only on the dynamic class of an argument but also on
its dynamic value or state. If an object is modified, the
property-based classification of an object can change over time,
implementing shifts in major behavior modes of the object. A version
of predicate classes has been designed and implemented in the context
of the Cecil language."

Comments on the ideas in the paper are appreciated.

-- Craig Chambers


>35  Manchester Archive and some

What: Manchester Archive, SmallTalk-V
From: johnson@m.cs.uiuc.edu (Ralph Johnson)
Date: 18 Dec 91 19:41:38 GMT

We have a complete copy of everything in the Manchester archive, and you
can either access it by e-mail like the Manchester archive or by anonymous
ftp.  Our archive is on st.cs.uiuc.edu, and you can get information about the
e-mail server by sending to archive-server@st.cs.uiuc.edu, and putting the
line help in your message. We actually have a little more than is in the
Manchester archive.  We have the Smalltalk-V code from the defunct
International Smalltalk Association, and a few other odds and ends.


>36  Object Design's OO7 Results

What: Object Design's Results on the OO7 Benchmarks
From: dudek@odi.com (Glen Dudek)
Date: Thu, 29 Apr 93 17:17:11 GMT

OBJECT DESIGN'S RESULTS ON THE OO7 BENCHMARKS
April 26, 1993

We have made a copy of our results available to the Internet community. You
can access this information through anonymous ftp from ftp.odi.com in the
file /pub/oo7/results.ps.

The report includes the "official" tests done for ObjectStore by the
University of Wisconsin, and our internal execution of all the tests using
ObjectStore Release 2.0.1, the current production version.  As the report
shows, our internal execution carefully followed the agreed-upon procedures
for running OO7, and we believe the numbers that were produced accurately
represent ObjectStore's performance.

        For further information contact oo7info@odi.com.


>37  Graph service

From: north@ulysses.att.com (Stephen C. North)
Subject: free samples of directed graph layouts by mail
Keywords: graph layout, DAG, embedder
Date: 25 Jun 93 18:28:29 GMT
Organization: AT&T Bell Laboratories, Murray Hill

I have created an experimental service for remote users to try some of
our graph layout programs through Internet mail, for research or
educational purposes.  I'm looking for a few friendly users to try this
service.  The programs are:

    dag (directed graphs, old, program, works with some USL C++ utilities.
                This may have unintentionally sparked the apparently misdirected 
                discussion of "DAG classes" in one newsgroup recently.)
    dot (directed graphs, newer algorithms, better layouts, more features)
    neato (undirected graphs, compatible with dot, Kamada-Kawai spring embedder)

You can ftp PostScript files of documentation from dist/drawdag/*.Z on
research.att.com

To draw graphs, send a graph file to drawdag@toucan.research.att.com
and give the command line in the Subject header.  For example,

    From cs.Princeton.EDU!north Thu Jun 24 11:45:28 0400 1993 remote from toucan
    Date: Thu, 24 Jun 1993 11:45:28 -0400
    From: Stephen North <north@cs.Princeton.EDU>
    To: drawdag@toucan.research.att.com
    Subject: dot -Tps 

    digraph G { a -> b }

File arguments are disabled for obvious reasons.  Please let me know if
you hit any snags.  There is a reasonable limit on graph size and probably
number of invocations from a given site/account. (If you use it that much,
AT&T's Intellectual Property Division sells binary executables; their number
is 800-462-8146).

Stephen North, AT&T Bell Laboratories, Murray Hill NJ, (908) 582 7392
Parturiunt montes, nascetur ridiculus mus!


>38  C++SIM (Simula-like Sim Pkg)

From: M.C.Little@newcastle.ac.uk (Mark Little)
Subject: C++SIM Release 1.0 Announcement
Organization: Computing Laboratory, U of Newcastle upon Tyne, UK NE17RU
Keywords: C++, SIMULA, simulation, object-oriented
Date: Mon, 14 Jun 1993 15:02:33 GMT

C++SIM 1.0 Release Announcement.

This is to announce the release of version 1.0 of C++SIM, a simulation
package written in C++. C++SIM provides discrete process based
simulation similar to that provided by the simulation class and
libraries of SIMULA. The linked list manipulation facilities provided
by SIMSET are also included in the package.

Inheritance was used throughout the design to an even greater extent
than is already provided by SIMULA. This has allowed us to add new
functionality without affecting the overall system structure, and hence
provides for a more flexible and expandable simulation package.

A paper is included which describes the design and implementation of
C++SIM and includes a worked example of how to use the package. The
paper describes the class hierarchy which we have created, and
indicates how it can be used to further refine the simulation package.

The simulation package requires the use of a threads package and
currently only works with Sun's lightweight process library or the Gnu
thread package (which *is* included in the distribution). The package has
been used on Sun workstations, and, with the exception of the thread
library requirement, contains no system specific code which should make
porting to other systems relatively easy. The code has been compiled
with Cfront 2.1 and Cfront 3.0.1 and g++ 2.3.3

If you find any bugs or make modifications (e.g., ports to other thread
packages) or port it to other systems, then please let me know so I can
keep the sources up-to-date for other users.

The package is available via anonymous ftp from arjuna.ncl.ac.uk


>39  commercial on cd-rom

From: jimad@microsoft.com (Jim Adcock)
Subject: Re: Non-defense Ada applications - answering several requests
Date: 11 Jun 93 18:56:55 GMT
Organization: Microsoft Corporation

 >...

1) Get a copy of the Computer Select Database.  [I notice the company
is offering free trial copies [the database is CD-ROM based]]

2) Select "Section: Software Product Specifications"

3) Select "Find: C++"

Behold!  A list of 734 commercially available software packages written
in C++, including some of the best known names in the software industry.


>40  C++ Signatures (subtyping)

From: gb@cs.purdue.edu (Gerald Baumgartner)
Newsgroups: comp.object,comp.lang.c++
Subject: signature implementation for G++ 2.5.2 and tech report available
Date: 4 Nov 1993 12:03:00 -0500
Organization: Department of Computer Sciences, Purdue University

Announcing the paper

	Signatures: A C++ Extension for
	Type Abstraction and Subtype Polymorphism

	by Gerald Baumgartner and Vincent F. Russo.
	Tech report CSD-TR-93-059, Dept. of Computer
	Sciences, Purdue University, September 1993.
	Submitted to Software Practice & Experience.

and a beta release of our implementation of

	signatures for GCC 2.5.2.


 How to Get that Stuff?
 ----------------------

You can get both the paper and the implementation by ftp from

	host:		ftp.cs.purdue.edu	(128.10.2.1)

	login:		anonymous

	password:	your e-mail address

	directory:	pub/gb

	files:		COPYING			Copyright notice.

			README			This file.

			Signatures.{dvi,ps}.gz	DVI and Postscript versions
						of the paper.

			gcc-2.5.2.sig.diff.gz	Patch to upgrade GCC 2.5.2.

			test.tar.gz		Test files and script to run
						the tests.

To make GCC 2.5.2 understand signatures, just copy the context diff
file into the GCC source directory, type

	gunzip gcc-2.5.2.sig.diff.gz
	patch < gcc-2.5.2.sig.diff

and rebuild and install `gcc,' `cc1plus,' the man pages, and the manual.

For compiling C++ code containing signatures, you need to use the
command line option

	-fhandle-signatures

We tested our extension on Sun 4 only, but since there are no changes
to the compiler backend, it is expected work on other architectures as
well.  To test whether it works on your architecture, unpack the file
`test.tar.gz' and run the shell script

	Test

It compiles the test programs and runs them.  If everything works
correctly, all the test programs (all 40 of them) should print

	Hello World.


 What are Signatures anyway?
 ---------------------------

Roughly, signatures are type abstractions or interfaces of classes.
They are related to ML's signatures, categories in Axiom, definition
modules in Modula-2, interface modules in Modula-3, and types in
POOL-I.

The main language constructs added are signatures and signature pointers.
For example, the signature declaration

	signature S
	{
	  int foo (void);
	  int bar (int);
	};

defines a new abstract type `S' with member functions `int foo (void)'
and `int bar (int).'  Signature types cannot be instantiated since they
don't provide any implementation.  Only signature pointers and signature
references can be defined.  For example,

	C obj;
	S * p = &obj;

defines a signature pointer `p' and initializes it to point to an object
of class type `C,' where `C' is required to contain the public member
functions `int foo (void)' and `int bar (int).'  The member function call

	int i = p->foo ();

executes then `obj.foo ().'

Class `C' is called an implementation of the abstract type `S.'  In
this example, we could have made `S' an abstract virtual class and `C' a
subclass of `S,' and we would have had the same effect.  The advantages
of signatures over abstract virtual classes are

	- you can build a type hierarchy separate from the class inheritance
	  (implementation) hierarchy,
	- subtyping becomes decoupled from inheritance, and
	- signatures can be used with compiled classes, while you cannot
	  retrofit an abstract virtual class on top of compiled class
	  hierarchies.

For more information, please, see the paper.


 What's Implemented and what's not?
 ----------------------------------

Signature declarations and signature pointers are implemented and
working.  For examples of what's working and how to use them you can
have a look at the test files.

The following bugs are known:

      - The destructor of objects cannot be called though signature pointers.
      - A signature pointer cannot point to an object of a class defined
	by multiple inheritance.
      - The signature conformance check does not work if the signature
	contains other signature declarations or class declarations.
      - Operator and conversion operator member functions of signatures
	can only be called with function call syntax, such as
	`p->operator+(17),' but not with operator or conversion syntax.

The following language constructs and features are not yet implemented:

      - constants in signatures,
      - signature references,
      - signature inheritance,
      - the `sigof' (signature of a class) construct,
      - views (not even the parsing is done),
      - signature templates, and
      - exception specifications in signature member function declarations.

The following optimization is not implemented:

      - Looking up a virtual class member function through a signature
	pointer/reference requires double indirection.  This can be optimized
	by memoizing, so that only the first lookup of a member function
	requires double indirection and further lookups require only single
	indirection.

The items above are roughly in the order in which they will be implemented.

Besides bug fixes, the main features that have been implemented since the
last release are default implementations of signature member functions
and opaque types.


 Feedback
 --------

Please, send your questions, comments, suggestions, and complaints to

	gb@cs.purdue.edu

--
Gerald Baumgartner
Dept. of Computer Sciences, Purdue University,  W. Lafayette, IN 47907
Internet: gb@cs.purdue.edu, UUCP: ...!{decwrl,gatech,ucbvax}!purdue!gb


>41 The Texas Persistent Store

  The Texas Persistent Store, version 0.1

Texas is a simple, portable, high-performance and (best of all) FREE
persistent store for C++ using "pointer swizzling at page fault time"
to translate persistent addresses to hardware-supported virtual addresses.

Texas is built on top of a normal virtual memory, and relies on the
underlying virtual memory system for caching.  It uses user-level virtual
memory protections to control the faulting of data from a persistent storage
file into virtual memory.

All addresses in a page are translated from a persistent format to
actual virtual addresses when the page is brought into virtual memory,
and subsequent memory references (including pointer traversals) are
just as fast as for non-persistent data.

Texas is easy to use, and is implemented as a UNIX library.  It is small
and can be linked into applications.  It requires no special operating 
system privileges, and persistence is orthogonal to type---objects may be 
allocated on either a conventional transient heap, or on the persistent
heap, as desired.

Texas supports simple checkpointing of heap data.  A log-structured storage
module is under development, and will provide fast checkpointing of small
transactions.

Texas is beta software, and the current prerelease version supports only
simple single-machine operation.  Future releases will support client-server
operation, a flexible access control scheme, and transaction support.

Texas currently runs under SunOS and ULTRIX, using Sun CC or GNU C++.
Porting to other modern systems (e.g., OS/2, WNT, Mach) should be easy---it
requires only mprotect(), signal(), and sbrk() calls (or their equivalent)
to control virtual memory protection setting and trap handling.

Papers about the pointer swizzling scheme and Texas itself (referenced
below) are available via anonymous ftp from cs.utexas.edu (IP address
128.83.139.9), as postscript files swizz.ps and texaspstore.ps in the
directory pub/garbage.

The source code for Texas is also available, in the directory
pub/garbage/texas.

References:

Paul R. Wilson and Sheetal V. Kakkad, "Pointer Swizzling at Page Fault
Time: Efficiently and Compatibly Supporting Huge Address Spaces on Standard
Hardware," Proc. Second Int'l. Workshop on Object Orientation in Operating
Systems, Sept. 1992, Dourdan, France, pp. 364--377.

Vivek Singhal, Sheetal V. Kakkad, and Paul R. Wilson, "Texas: an Efficient,
Portable Persistent Store", Proc. Fifth Int'l. Workshop on Persistent Object
Systems, Sept. 1992, San Miniato, Italy, pp. 11-33.


>42 OSE C++lib

From: grahamd@research.otc.com.au (Graham Dumpleton)
Date: Tue, 16 Nov 1993 11:34:42 +1100 (EST)
Organisation: Telstra International
Phone: +61-2-287-3119

  WHAT:

    OSE consists of three C++ class libraries, a build environment based on
    GNU make, programs for documentation extraction and other miscellaneous
    tools.

    The C++ libraries include generic classes and some UNIX specific classes.
    Collection classes use templates compatable with AT&T C++ 3.0. If you
    have a C++ compiler which does not support templates, a template
    preprocessor supplied with OSE can be used.

    OSE uses a GNU style configure script, making it relatively easy to
    install, even on platforms for which it may not yet have been compiled.
    For DOS users, a script is provided to create a copy of the C++
    libraries suitable for compilation on that platform.


  WHERE:

    OSE can be obtained via anonymous ftp from:

      Europe:

	ftp.th-darmstadt.de [130.83.55.75]
	directory pub/programming/languages/C++/class-libraries/OSE

      United States

	straylight.acs.ncsu.edu [152.1.65.11]
	directory /pub/ose

      Australia:

	csis.dit.csiro.au [192.41.146.1]
	directory pub/otc


  HELP:

    To get further information about OSE, without actually fetching the
    complete package, either fetch the file "ANNOUNCE" from one of the
    ftp sites, or send mail to:

      ose@research.otc.com.au


>43 Traces,kiczales,MOP,DI

From: gregor@parc.xerox.com (Gregor Kiczales)
Subject: Re: Dynamic Objects
In-Reply-To: rjh@geodesic.com's message of 25 Aug 93 21:52:56 GMT
Message-ID: <GREGOR.93Sep3093506@calvin.parc.xerox.com>
Organization: Xerox Palo Alto Research Center
References: <16C357BF0.MFARMER@utcvm.utc.edu> <1993Aug25.215256.8031@midway.uchicago.edu>
Date: 3 Sep 93 09:35:06

Earlier in this series of messages, Craig Chambers and others mentioned
his ECOOP'93 paper on predicate classes, which provide a powerful handle
on some of the problems that have been mentioned in this series of
messages, specifically, how dynamic changes to an object or its context
can be harnessed to reliably effect the object's (message receipt)
behavior.  As I see it, predicate classes are a key step towards solving
one of the most frustrating problems of OO programming: the struggle
over whether to encode some difference among objects in the value of a
slot (that is one of its parts) or in the object's `method table' (class
or that which it is one-of).

A closely related problem, that has also come up in this series of
messages, is how so-called factory objects can dynamically select the
behavior of the objects they create.  We have developed a new OO
language concept called Traces, that can be used to make much more
powerful factory objects, as well as handle some of the things predicate
classes do.  The two ideas are similar in that they both make behavior
selection a much more dynamic phenomena.

My ISOTAS'93 paper presents the concept of Traces and shows it
application to some problems.  This paper is available for anonymous FTP
from ftp.parc.xerox.com, in the /pub/mops directory.  The file is
traces.ps.

Gregor

Following is the abstract from the paper:
  
Object-oriented techniques are a powerful tool for making a system
end-programmer specializable.  But, in cases where the system not only
accepts objects as input, but also creates objects internally,
specialization has been more difficult.  This has been referred to as
the ``make isn't generic problem.''  We present a new \oo{} language
concept, called traces, that we have used successfully to support
specialization in cases that were previously cumbersome.
  
The concept of traces makes a fundamental separation between two kinds
of inheritance in \oo{} languages: inheritance of default implementation
-- an aspect of code sharing; and inheritance of specialization, a
sometimes static, sometimes dynamic phenomenon.


>44 C++ coding standard

From: metz@iam.unibe.ch (Igor Metz)
Subject: Re: C++ coding standard
Organization: Dept. of CS, University of Berne, Switzerland
Date: Tue, 7 Sep 1993 07:08:21 GMT

euagate.eua.ericsson.se   (Internet Address: 134.138.134.16)
~ftp/pub/eua/c++/rules.ps.Z

[Also an archive site.  E.g. Coplien includes a dir of C++ examples]


>45 Kala Archive

From: sss@world.std.com (Sergiu S Simmel)
Subject: Kala White Paper now available via anonymous ftp
Message-ID: <CD4MyB.Hsn@world.std.com>
Organization: Penobscot Development Corporation, Cambridge MA
Date: Fri, 10 Sep 1993 07:18:11 GMT

An 8-page paper providing an overview of what Kala is and what Kala is
for is now available, in PostScript format, in the Kala Archive. The
file is accessible, via anonymous FTP, at the following location:

          anonymous@world.std.com:/pub/kala/TechDocs/Overview.ps

The outline is the following

        1 What is Kala For?
        2 Software Infrastructure
                Persistent Data and Persistent Stores
        3 Data Transfer
        4 Data Visibility
                Changing Visibility
                Sharing Visibility
                Transactions
                Versions
        5 Runtime and Architectural Models
        6 Relationship to Other Technologies

This paper is targeted towards those who don't know anything about
Kala and would like to find out a bit in 10 pages or less.

Enjoy!

P.S. For those of you who do not have FTP access and would like to
     obtain this file, please send a brief e-mail message to
     info@Kala.com, requesting that the file be e-mailed to you.
     Beware that the file is approximately 425Kbytes long (the paper
     contains 13 illustrations!).


>46 BeBOP(seq,par,LP,OO,meta)

From: ad@munta.cs.mu.OZ.AU (Andrew Davison)
Subject: BeBOP v.1.0 Available
Message-ID: <9325614.15552@mulga.cs.mu.OZ.AU>
Organization: Department of Computer Sci, University of Melbourne
Follow-Up: comp.parallel
Date: Mon, 13 Sep 1993 04:08:41 GMT

 BeBOP and bp Version 1.0 now available
 ======================================

 What is BeBOP?
 ==============
The language BeBOP is a unique combination of sequential 
and parallel Logic Programming (LP), object oriented 
programming and meta-level programming. 

The LP component offers both don't know non-determinism
and stream AND-parallelism, a combination not possible 
with concurrent LP languages. 

BeBOP's object oriented features include object IDs, 
encapsulation, message passing, state updating, and 
object behaviour modification. 

The meta-level capabilities are based on the treatment 
of Prolog theories as first order entities, which 
enables them to be updated easily, and for fragments 
to be passed between objects in messages.

BeBOP is implemented by translation down to NU-Prolog,
and its parallel extension, PNU-Prolog. An unusual
aspect of this is the way that object IDs are utilized 
as a communication mechanism between objects.

 What is bp?
 ===========
The bp interactive interpreter supports BeBOP programming 
by allowing the flexible invocation of objects, and 
offering the means for setting up communication links 
between objects at any time. An incidental benefit is 
the ability to use `global' variables in queries. Since 
bp is an augmentation of the NU-Prolog np system, objects 
and Prolog goals can be combined, and a by-product is 
that the floundering of Prolog queries is avoided.


 Where are they?
 ===============
The BeBOP system (BeBOP and bp), and the PNU-Prolog 
preprocessor pnp, can be found at the anonymous ftp 
site munnari.oz.au (128.250.1.21), in the directory 
pub as the file bebop.tar.Z. Remember to use binary 
mode when copying it.

The release comes with a user manual, several papers 
(in Postscript format), sample programs, and source code.


 System requirements
 ===================
The BeBOP system requires the following:

* The NU-Prolog system, compiler and interpreter
* The pnp preprocessor 
  (this is included as part of the BeBOP system release)
* GCC or similar compiler
* Yacc (or Bison) and Lex


 For more details, contact:
 ==========================
        Andrew Davison
        Dept. of Computer Science
        University of Melbourne
        Parkville, Victoria 3052
        Australia

Email:  ad@cs.mu.oz.au
Fax:    +61 3 348 1184
Phone:  +61 3 287 9172 / 9101
Telex:  AA 35185


>47 Knowledge Media, Massive cd-rom, lots of freeware

A "Resource Library" of cd-rom discs .  CDs for language/OS, graphics, multi-
media, mega-media (3), and audio.  "Gathered from the resources of the
Internet, CompuServe, Genie, BIX, and other BBS's".  Some shareware.  Should be
available at your local software store.

From the back of the Languages CD:

  'Over 100 Languages'
        ...

This is the largest collection of compilers, interpreters, libraries, and
source code for standard and experimental computer languages and operating
systems ever assembled.  A must for anyone interested in computer programming,
this disc is just right for everyone, whether he or she is a researcher,
student, or an interested hobbist.

Knowledge Media Inc.
Paradise, CA  95969 USA


>48 u++, C++ Trans. and Concry RTS

From: nat@nataa.frmug.fr.net (Nat Makarevitch)
Subject: Re: 'Concurrent Objects' - Suggestions needed
Date: 10 Oct 1993 02:41:15 GMT
Organization: LIVIA

       u++ - uC++ Translator and Concurrency Runtime System

DESCRIPTION
The u++ command introduces  a  translator  pass  over  the
specified source files after the C preprocessor and before
the actual C++ compilation.  The translator converts  sev-
eral  new  uC++  constructs  into C++ statements.  The u++
command also provides  the  runtime  concurrency library,
which must be linked with each uC++ application.

                                                                 
REFERENCES                                                       
uC++:  Concurrency in the Object-Oriented Language C++, by      
P.A.  Buhr,  G.  Ditchfield,  R.A.   Stroobosscher,   B.M.
Younger, C.R.  Zarnke;   Software-Practise and Experience,
22(2):137--172, February 1992.  This paper describes  uC++
v2.0, which has been significantly extended.

The  uC++  system is available via anonymous FTP
from watmsg.UWaterloo.ca:pub/uSystem.  A license agreement
is required to use uC++.


>49 Real Time

From: dstewart+@cs.cmu.edu (David B Stewart)
Subject: Re: Object-Oriented Systems and Realtime
Organization: The Robotics Institute, Carnegie Mellon University
Date: Mon, 11 Oct 1993 16:51:19 GMT

In article <1993Oct11.082519.23058@cs.tcd.ie>,
Chris Zimmermann <czimmerm@cs.tcd.ie> wrote:
>Hi community:
>
>What is the state of the art concerning real time in 
>object-oriented systems (if any)? By this, I mean the
>marriage of more or less traditional real time systems
>(including systems concerned with "soft" real time aspects
>like multimedia) with the OO paradigm.
>[...]

We've done significant work in that area.  Check out the following tech
report:

D. B. Stewart, R. A. Volpe, and P. K. Khosla, "Design of Dynamically
    Reconfigurable Real-Time Software using Port-Based Objects," 
    Carnegie Mellon University Tech Report #CMU-RI-TR-93-11, July 1993.

	Abstract: The current development of applications for sensor-based
	robotic and automation (R&A) systems is typically a `one-of-a-kind'
	process, where most software is developed from scratch, even though
	much of the code is similar to code written for other applications.
	The cost of these systems can be drastically reduced and the capability
	of these systems improved by providing a suitable software framework
	for all R&A sys tems. We describe a novel software framework, based on
	the notion of dynamically reconfigurable software for sensor-based
	control systems. Tools to support the implementation of this framework
	have been built into the Chimera 3.0 Real-Time Operating System. The
	framework provides for the systematic development and predictable
	execution of flexible R&A applications while maintaining the ability to
	reuse code from previous applications. It combines object-oriented
	design of software with port-automaton design of digital control
	systems. A control module is an instance of a class of port-based
	objects. A task set is formed by integrating objects from a module
	library to form a specific configuration. An implementation using
	global state variables for the automatic integration of port-based
	objects is presented. A control subsystem is a collection of jobs
	which are executed one at a time, and can be programmed by a user.
	Multiple control subsystems can execute in parallel, and operate
	either independently or cooperatively. One of the fundamental concepts
	of reconfigurable software design is that modules are developed
	independent of the target hardware. Our framework defines classes of
	reconfigurable device driver objects for proving hardware independence
	to I/O devices, sensors, actuators, and special purpose processors.
	Hardware independent real-time communication mechanisms for
	inter-subsystem communication are also described. Along with providing
	a foundation for design of dynamically reconfigurable real-time
	software, we are also developing many modules for the control module,
	device driver, and subroutine libraries. As the libraries continue to
	grow, they will form the basis of code that can eventually be used by
	future R&A applications. There will no longer be a need for developing
	software from scratch for new applications, since many required modules
	will already be available in one of the libraries.  

This report is available via anonymous FTP as follows:

	% ftp IUS4.IUS.CS.CMU.EDU	(128.2.209.143)
	Name:       anonymous
	Password:   yourname@yourmachine
	ftp> binary
	ftp> cd /usr/chimera/public
	ftp> get CMU_RI_TR_93_11.ps.Z
	ftp> quit
	% uncompress CMU_RI_TR_93_11.ps.Z
	% lpr CMU_RI_TR_93_11.ps	(must be a postscript printer)

For more information, 'finger chimera@cmu.edu'.

>50 Ada-9x (compiler, GNU)

From: stt@spock.camb.inmet.com (Tucker Taft)
Subject: Re: which language to use ...?
Organization: Intermetrics, Inc.
Date: Mon, 1 Nov 1993 23:22:42 GMT

 >[...]

Also, there is a preliminary release of a GNU-GCC-based Ada 9X
compiler available from NYU on cs.nyu.edu in pub/gnat/...
The front end is written in Ada itself; the back end
is the usual GCC back end (enhanced as appropriate).

S. Tucker Taft  stt@inmet.com
Intermetrics, Inc.
Cambridge, MA  02138


>51 OO Course Slides

From: wellerd@ajpo.sei.cmu.edu (David Weller)
Subject: Re: Slides on OOP or OMT wanted
Organization: Sigma Software Engineering, Inc.
Date: Fri, 5 Nov 1993 11:01:44 EST

In article <2bdot7$3nr@news-rocq.inria.fr> ziane@lolita.inria.fr (Mikal Ziane (Univ. Paris 5 and INRIA) ) writes:
>
>Hello netters,
>
>Is anybody aware of public domain slides available on an ftp site ?
>I'd like slides on OO programming or OO design methods (esp. OMT).
>I know I am crazy to ask for that but someone told me he saw
>a very good C++ course on some ftp site ! (he does not remember which one 
>unfortunatemy)
>

It's true!  On WUArchive (wuarchive.wustl.edu) there is a series of
slides developed in Microsoft's PowerPoint.  The course material
includes lesson plans, tests, and workbooks, along with full notes
accompanying each slide.

There's one _little_ catch -- it's in the Public Ada Library.  Now,
the OOP course (there's three courses, one on OOD, OOP, and Software
Engineering) covers both C++ and Ada.  It was designed to let the
students work in both languages to get an objective opinion of the
pluses and minuses of each language (gee, what a concept!).

The OOD slides do NOT cover OMT.  Some material is used from Booch's
OOD book, but not the notation.  From looking at the slides, it appears
very easy to insert your own notation.  The important part for students
is communicating the concepts, which (for the price) these slides do
a DAMN good job of. <- (Safire's Violation #45: "A perposition is a 
bad thing to end a sentence with." :-)

Ah, but WHERE on WUArchive are they?  If you look under 
languages/ada/crsware, I believe you'll find them.  Good luck!

dgw
-- 
type My_Disclaimer is new Standard.Disclaimer with record
	AJPO, SEI : Cognizance := Disavow_All_Knowledge;
end record;--)


>52 GTE Distrib Reports

From: em02@gte.com (Emon)
Subject: Reports Available From The Distributed Object Computing Department
Date: 5 Nov 93 18:10:15 GMT
Organization: GTE Laboratories, Inc.

                        REPORTS AVAILABLE FROM
             THE DISTRIBUTED OBJECT COMPUTING DEPARTMENT
                     GTE LABORATORIES INCORPORATED
                        40 Sylvan Road, M/S 62
                     Waltham, Massachusetts 02254


For over six years, the primary focus of the Distributed Object Computing
Department within GTE Laboratories has been the Distributed Object
Management (DOM) project. The DOM project conducts research into
object-oriented technology for integrating heterogeneous, autonomous,
distributed (HAD) computer systems/resources. Major research areas include:
interoperable object models; interoperable, distributed object
architectures; heterogeneous, extended transaction models; and information
requests in HAD environments. We are experimenting in these areas using our
prototype DOM system which we have developed over the past five years. This
technology is based on ideas from a number of technical areas including
distributed, object-oriented, databases, multi-database systems, operating
systems, and programming languages.

Permission is granted at this time for the operations and uses listed
below. However, this permission is non-transferable and is subject to
revocation on a report-by-report basis, due to possible copyright transfers
that are normal in the publication process. Any additional copyright
restrictions are noted in the reports themselves. Default permissions are
for anonymous ftp, electronic viewing, and single-copy printing.
Permissible uses are research and browsing. Specifically prohibited are
SALES of any copy, whether electronic or hardcopy, of any of these reports
for any purpose. Also prohibited is copying, excerpting or extensive
quoting of any report in another work without the written permission of one
of the report's authors.

Reports marked with a "*" can be retrieved in postscript(ascii) form via
anonymous ftp from ftp.gte.com (132.197.8.2) in the "pub/dom" subdirectory.
 
 >>>>>>>>> 1994

[GEOR94a]*   Georgakopoulos, D., M. Rusinkiewicz, and W. Litwin,
"Chronological Scheduling of Transactions with Temporal Dependencies," to
appear in the VLDB journal, January 1994 (submitted in December 1990). 

[GEOR94b]*   Georgakopoulos, D., M. Hornick, P. Krychniak, and F. Manola,
"Specification and Management of Extended Transactions in a Programmable
Transaction Environment," to appear in the Proceedings of the 10th
International Conference on Data Engineering, Houston, Texas, February
1994. Also published as TC-0207-02-93-165, GTE Laboratories Incorporated,
February 1993.


 >>>>>>>>> 1993

[BROD93a]*   Brodie, M.L., "The Promise of Distributed Computing and the
Challenge of Legacy Information Systems," in Hsiao, D., E.J. Neuhold, and
R. Sacks-Davis (eds), Proc. IFIP TC2/WG2.6 Conference on Semantics of
Interoperable Database Systems, Lorne, Australia, November 1992, Elsevier
North Holland, Amsterdam 1993.

[BROD93b]*   Brodie, M.L. and M. Stonebraker, "DARWIN: On the Incremental
Migration of Legacy Information Systems," DOM Technical Report,
TR-0222-10-92-165, GTE Laboratories Inc., March 1993.

[GEOR93a]*   Georgakopoulos, D., M. Hornick, and P. Krychniak, "An
Environment for Specification and Management of Extended Transactions in
DOMS," to appear in Proceedings of the 3rd International Workshop on
Interoperability in Multidatabase Systems, Vienna, Austria, April 1993.

[GEOR93c]*   Georgakopoulos, D., M. Rusinkiewicz and A. Sheth, "Using
Ticket-based Methods to Enforce the Serializability of Multidatabase
Transactions," to appear in the IEEE Transactions on Data and Knowledge
Engineering December 1993 (submitted in February 1992).

[GEOR93e]*   Georgakopoulos, D., M. Hornick, F. Manola, M. Brodie, S.
Heiler, F. Nayeri, and B. Hurwitz, "An Extended Transaction Environment for
Workflows in Distributed Object Computing," in IEEE Data Engineering, pp.
24-27, vol. 16, no. 2, June 1993.

[MANO93a]   Manola, F., "The Need for Object Model Interoperability,"
Workshop Report, Workshop on Application Integration Architectures, Dallas,
Texas, February 1993

[MANO93c]*   Manola, F. and S. Heiler, "A 'RISC' Object Model for Object
System Interoperation: Concepts and Applications," TR-0231-08-93-165, GTE
Laboratories, Inc., August 1993.

[MITC93a]   Mitchell, G., "Extensible Query Processing in an
Object-Oriented Database," PhD Thesis, Brown University Technical Report
No. CS-93-16, May 1993. Available in hard copy from Brown University,
Computer Science Department, and postscript format via anonymous ftp from
wilma.cs.brown.edu as file techreports/93/cs93-16.ps.Z

[NAYE93c]*   Nayeri, F., and B. Hurwitz, "Experiments with Dispatching in a
Distributed Object System," GTE Laboratories, Inc., TR-0236-09-93-165, July
1993.

[NAYE93d]*   Nayeri, F., "Addressing Component Interoperability in the OMG
Object Model," position paper submitted to ORB Implementors' Workshop, San
Francisco, June 1993.

[NICO93a]   Nicol, J., T. Wilkes, and F. Manola, "Object Orientation in
Heterogeneous Distributed Computing Systems," IEEE Computer, pp. 57-67,
Vol. 26, No.6, June 1993.

[VENT93]*   Ventrone, V. and S. Heiler, "Some Practical Advice for Dealing
with Semantic Heterogeneity in Federated Database Systems," Submitted to
USENIX.


 >>>>>>>>> 1992

[BGR92]*   Batra, R., D. Georgakopoulos, and M. Rusinkiewicz, "A
Decentralized Deadlock-free Concurrency Control Method for Multidatabase
Transactions," in Proceedings of 12th International Conference on
Distributed Computing Systems, Yokohama, Japan, June, 1992.

[BRO92b]*   Brodie, M.L. and J. Mylopoulos , "Artificial Intelligence and
Databases: Dawn, Midday, or Sunset?," Canadian Information Processing
/Informatique Canadienne, July/August 1992.

[BROD92c]*   Brodie, M.L. and S. Ceri, "On Intelligent and Cooperative
Information Systems," in International Journal of Intelligent and
Cooperative Information Systems 1, 2 September 1992. 

[BUCH92]   Buchmann, A.P., M.T. Ozsu, M. Hornick, D. Georgakopoulos, F.A.
Manola, "A Transaction Model for Active Distributed Object Systems," in
Database Transaction Models for Advanced Applications, A.K. Elmagarmid,
(ed.), Morgan Kaufmann, San Mateo, CA, Spring 1992.

[GEOR92]*   Georgakopoulos, D., "A Framework for Dynamic Specification of
Extended Multidatabase Transactions and Interdatabase Dependencies,"
Proceedings of Third Workshop on Heterogeneous Databases and Semantic
Interoperability, Boulder, February, 1992.

[HEIL92]   Heiler, S., S. Haradhvala, B. Blaustein, A. Rosenthal, and S.
Zdonik, "A Flexible Framework for Transaction Management in Engineering
Environments," in Database Transaction Models for Advanced Applications,
A.K. Elmagarmid (ed.), Morgan Kaufmann, San Mateo, CA, Spring 1992.

[MANO92]*   Manola, F., S. Heiler, D. Georgakopoulos, M. Hornick, M.
Brodie, "Distributed Object Management," International Journal of
Intelligent and Cooperative Information Systems 1, 1 March 1992.

[MANO92a]*   Manola, F. and S. Heiler, "An Approach To Interoperable Object
Models," Proceedings of the International Workshop on Distributed Object
Management, Edmonton, Canada, August 1992 (also in Distributed Object
Management, M.T. Ozsu, U. Dayal, and P. Valduriez (eds.), Morgan Kaufmann,
San Mateo, CA, 1993).


 >>>>>>>>> 1991

[BROD91]   Brodie, M., "Distributed Object Management Research,"
Proceedings of the Second Telecommunications Information Networking
Architecture (TINA) Workshop, pp. 297-303, Chantilly, France, March 1991.

[BROD91a]*   Brodie, M. and M. Hornick, "An Interoperability Development
Environment For Intelligent Information Systems," Proceedings of the
International Workshop on the Development of Intelligent Information
Systems, Niagara-on-the-Lake, April 1991.

[BUCH91]*   Buchmann, A.P., M. Tamer Ozsu, and D. Georgakopoulos, "Towards
a Transaction Management System for DOM," TR-0146-06-91-165, GTE
Laboratories Incorporated, June 1991.

[GEOR91a]*   Georgakopoulos, D., M. Rusinkiewicz, and A. Sheth, "On
Serializability of Multidatabase Transactions Through Forced Local
Conflicts," Proceedings of the 7th International Conference on Data
Engineering, Kobe, Japan, April 1991.

[GEOR91b]*   Georgakopoulos, D., "Multidatabase Recoverability and
Recovery," Proceedings of the First International Workshop on
Interoperability in Multidatabase Systems, Kyoto, Japan, April 1991.

[GRL91]   Georgakopoulos, D., M. Rusinkiewicz, and W. Litwin,
"Chronological Scheduling of Transactions with Temporal Dependencies," in
the VLDB journal, available draft also as a Technical Report from the
Department of Computer Science at the University of Houston, UH-CS-91-03,
February, 1991.

[HEIL91]*   Heiler, S., "Extended Data Type Support in Distributed DBMS
Products: A Technology Assessment and Forecast," TR-170-12-91-165. GTE
Laboratories Incorporated, December 1991.

[HORN91]*   Hornick, M.F., J.D. Morrison, and F. Nayeri, "Integrating
Heterogeneous, Autonomous, Distributed Applications Using the DOM
Prototype," TR-0174-12-91-165. GTE Laboratories Incorporated, December
1991.

[MANO91]   Manola, F. and U. Dayal, "An Overview of PDM: An Object-Oriented
Data Model," in K.R. Dittrich, U. Dayal, and A.P. Buchmann (eds.), On
Object-Oriented Database Systems, Springer-Verlag, 1991.

[MANO91a]*   Manola, F., "Object Data Language Facilities for Multimedia
Data Types," TR-0169-12-91-165. GTE Laboratories Incorporated, December
1991.

[MANO91b]   Manola, F., "The Third-Generation/OODBMS Manifesto, Commercial
Version," SIGMOD Record, Vol. 20, No. 4, December 1991.

[RUSI91]   Rusinkiewicz, M. and D. Georgakopoulos, "Multidatabase
Transactions: Impediments and Opportunities," Compcon Spring '91 Digest of
Papers, San Francisco, February 1991.

[VENT91]   Ventrone, V. and S. Heiler, "Semantic Heterogeneity as a Result
of Domain Evaluation," SIGMOD Record Special Issue: Semantic Issues in
Multidatabase Systems, Vol. 20, No. 4, December 1991.


 >>>>>>>>> 1990

[BREI90]   Breitbart, Y., D. Georgakopoulos, and M. Rusinkiewicz, A.
Silberschatz, "Rigorous Scheduling in Multidatabase Systems," Proceedings
of Workshop in Multidatabases and Semantic Interoperability, Tulsa, pp.
658-667, November 1990.

[BROD90]*   Brodie, M.L., F. Bancilhon, C. Harris, M. Kifer, Y. Masunaga,
E.D. Sacerdoti, K. Tanaka, "Next Generation Database Management Systems
Technology," in Deductive and Object-Oriented Databases, W. Kim, J-M
Nicolas, S. Nishio, (eds.), Elsevier Science Publishers, 1990.

[HEIL90]   Heiler, S., F. Manola and S. Zdonik, "An Object-Oriented
Database Approach to Federated Systems," (unpublished paper), 1990.

[MANO90]   Manola, F., "Object-Oriented Knowledge Bases," AI Expert, 5(3),
5(4), March and April 1990.

[MANO90a]*   Manola, F. and A. Buchmann "A Functional/Relational
Object-Oriented Model for Distributed Object Management: Preliminary
Description" TM-0331-11-90-165. GTE Laboratories Incorporated, December
1990.

[MANO90b]*   Manola, F., M. Hornick, and A. Buchmann "Object Data Model
Facilities for Multimedia Data Types" TM-0332-11-90-165, GTE Laboratories
Incorporated, December 1990.

[MYLO90]*   Mylopoulos, J. and M. Brodie, "Knowledge Bases and Databases:
Current Trends and Future Directions," Lecture Notes in Computer Science,
Vol. 474: Information Systems and Artificial Intelligence: Integration
Aspects, D. Karagiannia, (ed.), Springer-Verlag, New York, 1990.

[RUSI90]   Rusinkiewicz, M., D. Georgakopoulos, and R. Thomas, "RDS: A
Primitive for the Maintenance of Replicated Data Objects," Proceedings of
Second IEEE Symposium on Parallel and Distributed Processing, Dallas, pp.
658-667, December 1990.

[SILB90]   Silberschatz, A., M. Stonebraker, and J.D. Ullman (eds.), M.L.
Brodie, P. Buneman, M. Carey, A. Chandra, H. Garcia-Molina, J. Gray, R.
Fagin, D. Lomet, D. Maier, M.A. Niemat, A. Silberschatz, M. Stonebraker, I.
Traiger, J. Ullman, G. Wiederhold, C. Zaniolo, and M. Zemankova, P.A.
Bernstein, W. Kim, H.F. Korth, and A. van Tilborg, (co-authors), "Database
Systems: Achievements and Opportunities," ACM SIGMOD Record, 19, 4,
December 1990; also appeared in Communications of the ACM, Vol. 34, No.10,
pp. 110-120, October 1991.

[STON90]   Stonebraker, M. , L.A. Rowe, B. Lindsay, J. Gray, M. Carey, M.L.
Brodie, P. Bernstein, and D. Beech, "Third-Generation Data Base System
Manifesto," ACM SIGMOD Recored 19, 3, September 1990.

[ZERT90]   Zertuche, D.R. and A.P. Buchmann, "Execution Models for Active
Database Systems: A Comparison," TM-0238-01-90-165, GTE Laboratories
Incorporated, January 1990.


 >>>>>>>>> 1989

[BROD89]   Brodie, M., D. Bobrow, V. Lesser, S. Madnick, D. Tsichritzis,
and C. Hewitt, "Future Artificial Intelligence Requirements for Intelligent
Database Systems" Expert Database Systems: Proceedings From the Second
International Conference, L. Kerschberg (ed.), Benjamin/Cummings, Menlo
Park, CA, 1989.

[BROD89a]   Brodie, M. , J. Mylopoulos, "Future Intelligent Information
Systems: AI and Database Technologies Working Together," in M. Brodie, J.
Mylopoulos, (eds. and contributors), Readings in Artificial Intelligence
and Databases, Morgan Kaufmann, San Mateo, CA, 1989.

[MANO89]*   Manola, F., "Applications of Object-Oriented Database
Technology in Knowledge-Based Integrated Information Systems," GTE
Laboratories Incorporated, April 1989.

[MANO89a]*   Manola, F., "Object Model Capabilities For Distributed Object
Management," TM-0149-06-89-165, GTE Laboratories Incorporated, June 1989.

[MANO89b]*   Manola, F., "An Evaluation of Object-Oriented DBMS
Developments," TR-0066-10-89-165, GTE Laboratories Incorporated, October
1989.

[WELC89]   Welch, J.L. and A.P. Sistla, "Object-Based Concurrency Control
and Recovery Mechanisms," TM-0150-06-89-165, GTE Laboratories Incorporated,
June 1989.


 >>>>>>>>> 1988

[MANO88]*   Manola, F., "Distributed Object Management Technology,"
TM-0014-06-88-165, GTE Laboratories Incorporated, June 1988.


 >>>>>>>>> 1987

[MANO87]   Manola, F., "A Personal View of DBMS Security," Database
Security: Status and Prospects, C.E. Landwehr (ed.), Elsevier Science
Publishers B.V., North Holland, 1988, 23-34; TN CS1.1, GTE Laboratories
Incorporated, December 1987.



_[GEOR94a]* _[GEOR94b]*
_[BROD93a]* _[BROD93b]* _[GEOR93a]* _[GEOR93c]* _[GEOR93e]*
_[MANO93a]  _[MANO93c]* _[NAYE93c]* _[NAYE93d]* _[NICO93a] 
_[VENT93]*
_[BGR92]    _[BRO92b]*  _[BROD92c]* _[BUCH92]   _[GEOR92]*
_[HEIL92]   _[MANO92]*  _[MANO92a]* 
_[BROD91]   _[BROD91a]* _[BUCH91]*  _[GEOR91a]* _[GEOR91b]*
_[GRL91]    _[HEIL91]*  _[HORN91]*  _[MANO91]   _[MANO91a]* 
_[MANO91b]  _[RUSI91]   _[VENT91] 
_[BREI90]   _[BROD90]*  _[HEIL90]   _[MANO90]   _[MANO90a]* 
_[MANO90b]* _[MYLO90]*  _[RUSI90]   _[SILB90]   _[STON90] 
_[ZERT90] 
_[BROD89]   _[BROD89a]  _[MANO89]*  _[MANO89a]* _[MANO89b]*
_[WELC89] 
_[MANO88]* 
_[MANO87]


>53  KEOBJ, OO DSP micro-kernel

From: clb@softia.com (Chris Bidaut)
Subject: Object kernel for DSP & RISC processors
Date: Mon, 15 Nov 1993 22:48:46
Organization: Softia, Inc.

This is an announcement for KEOBJ, an object-oriented micro-kernel for Digital
Signal Processors (DSP) and RISC processors.  This is also a request for 
comments from the Internet community. Feedback on the architecture and 
programming interface will be appreciated and incorporated into the next
release.


1 DESCRIPTION
-------------

KEOBJ is an object-oriented micro-kernel optimized for advanced embedded 
applications, and it particularly targets Digital Signal Processors (DSP) 
and RISC processors in multimedia environments.

Its main features are object-orientation, real-time behavior, signal processing
support, micro-kernel architecture and scalability.

1.1 Object-orientation

The kernel is a collection of system classes exported to the applications
(e.g Process, Thread, Memory, ...).
An object name space provides a way to locate any public object (e.g. IPC, 
memory) using a symbolic path.
The kernel is written in C++ and is easily portable.

1.2 Real-time behavior

The design stresses fast response time and predictability to qualify for the 
real-time label. The kernel is reentrant and preeemptable.

1.3 Signal processing support

Besides providing an architecture appropriate for most general purpose 
applications, the kernel incorporates dedicated features for signal processing
applications. This includes two phases interrupt processing, time-deadline
scheduling, Inter Process Communications, multiple memory pools, awareness of
the constraints due to a single data type (word).

1.4 Micro-kernel architecture

Probably the most important feature of the kernel is the ability to be
extended at run-time with new services such as devices drivers, public
classes (IPC, file systems, windowing systems). Applications and system
services are dynamically loaded by a COFF compatible loader.

The core kernel is customizable at run-time through a personality mechanism 
to emulate other environments (Operating systems) or to tailor the processes
environments. 

1.5 Scalability

The API supports physical and virtual memory organizations with the same 
semantics.

Applications source code will be portable across DSP and RISC processors.

The architecture supports symmetric multiprocessing and distribution (Available
by mid-1994).


2 WHERE TO FIND THE PACKAGE
---------------------------

A set of documentation about KEOBJ is available via anonymous ftp on the 
following Internet server:
		netcom.com (192.100.81.100) in file /pub/softia/keobj.zip


If you do not have access to Internet, contact me for other delivery media at:
Chris Bidaut			clb@softia.com
Telephone (408) 262-6520	Fax (408) 262-7210


>54  MindFrame for Windows

From: gcl@netcom.com (Geoff Lee)
Subject: "MindFrame for Windows" (freeware) application is available for ftp
Date: Tue, 16 Nov 1993 21:07:28 GMT

	MindFrame for Windows 1.0 Release Note
	======================================

mndframe.zip (MindFrame for Windows) is available for anonymous ftp
on ftp.cica.indiana.edu. It is currently in /pub/pc/win3/uploads.

"MindFrame for Windows" is a freeware application developed to
teach an object modeling approach presented in the
book: "Object-Oriented GUI Application Development" Geoff Lee,
Prentice-Hall, 1993, ISBN 0-13-363086-2.

This application is useful in many other areas as well, for
example, in Bible studying (metaphors, parables, prophecies,
types), neural modeling, ecological modeling, and task modeling.
There are 20 sample applications covering these areas. There
are also description of each of the sample application in the
on-line Help. Read "About MindFrame..." help topic for more
information.

This is a copyrighted software, but you can freely redistribute if
you keep the release intact.

The following is the content of mdnframe.txt file in the .zip file:

1. Installation Procedure:
   DOS> mkdir MndFrame
   DOS> cd MndFrame
   DOS> copy b:MndFrame.zip   (or where you kept the mndframe.zip file)
   DOS> unzip -d mndframe.zip  (extract files into subdirectories)
   DOS> copy grid.vbx \windows\systems (your local Windows system directory)

2. Running the application:
   . In Windows, open your "File Manager"
   . Go to \MndFrame directory
   . Find the MndFrame.exe file
   . Drag the MndFrame.exe file icon into a "Program Manager" window
   . Open the MndFrame.exe program

3. Sample applications:
   Once you are in the MindFrame application, open files in the 
   \MndFrame\Samples subdirectories. There are 20 sample files organized
   according to areas of application (e.g., object modeling, neural
   modeling, bible studying). You can also find description of each of
   these samples in the On-Line Help file.

4. On-line help:
   Use the "About MindFrame..." menu item in the "Help" menu to learn more
   about this application. There is an on-line help provided for this
   application. Read through the help topics to learn about using this
   application.

5. Files in this release:
   mndframe.txt: this file.
   mdnframe.exe: the executable file of "MindFrame for Windows" freeware.
   mndframe.hlp: the on-line help file for "MindFrame for Windows".
   biblnote.ps:  the PostScript file of help text on using this application
   	         to study metaphors, parables, types, and prophecies in the
   	         Holy Bible.
   grid.vbx:     the visual basic grid control that is necessary to run this
   	         application. It must be copied into your local "system"
   	         directory for Windows (\windows\system in most cases).
   samples\*:    in this directory, there are 20 samples (*.frm files) in 
   	         the subdirectories for each application area 
   	         (e.g., objmodel, ecology, neural, parable).

New MindFrame anonymous FTP Directory:

It has been moved to a more permanent directory: /pub/pc/win3/programr.

>55  ACE Lib, C++ Networking

From: schmidt@liege.ics.uci.edu (Douglas C. Schmidt)
Subject: Re: C++ and Semaphores
Date: 22 Nov 1993 19:27:00 -0800
Organization: University of California at Irvine: ICS Dept.

       THE "ADAPTIVE COMMUNICATION ENVIRONMENT" (ACE) LIBRARY:

	  A Collection of C++ Network Programming Components
	  --------------------------------------------------

	The ACE library is available for anonymous ftp from the
ics.uci.edu (128.195.1.1) host in the gnu/C++_wrappers.tar.Z file
(approximately .4 meg compressed).  This release contains contains the
source code, documentation, and example test drivers for a number of
C++ wrapper libraries and higher-level network programming foundation
classes developed as part of the ADAPTIVE transport system project at
the University of Calfornia, Irvine.

	. The C++ wrappers encapsulate many of the user-level BSD and
	  System V Release 4 IPC facilities such as sockets, TLI,
	  select and poll, named pipes and STREAM pipes, the mmap
	  family of memory-mapped file commands, System V IPC (i.e.,
	  shared memory, semaphores, message queues), and explicit
	  dynamic linking (e.g., dlopen/dlsym/dlclose) using
	  type-secure, object-oriented interfaces. 

	. The higher-level network programming foundation classes
	  integrate and enhance the lower-level C++ wrappers to
	  support the configuration of concurrent network daemons
	  composed of monolithic and/or stackable services

	Many of the C++ wrappers and higher-level components have been
described in issues of the C++ Report, as well as in the proceedings
of (1) the 2nd Annual C++ World conference held in Dallas, Texas in
October, 1993, (2) the 11th Annual Sun Users Group Conference held in
San Jose, CA in December, 1993, and (3) the 2nd International Workshop
on Configurable Distributed Systems held at CMU in Pittsburgh, PA in
March, 1994.  A relatively complete set of documentation and extensive
examples are included in the release.  A mailing list is available for
discussing bug fixes, enhancements, and porting issues regarding ACE.
Please send mail to ace-users-request@ics.uci.edu if you'd like to
become part of the mailing list.

CONTENTS OF THE RELEASE

	The following subdirectories are included in this release:

	. apps    -- complete applications written using the ACE wrappers
	. bin	  -- utility programs for building this release such as g++dep
	. build	  -- a separate subdirectory that keeps links into the main
		     source tree in order to facilitate multi-platform
		     build-schemes
	. include -- symbolic links to the include files for the release
	. lib	  -- object archive libraries for each C++ wrapper library
	. libsrc  -- the source code for the following C++ wrappers:
			ASX -- higher-level C++ network programming foundation classes
			Get_Opt -- a C++ version of the UNIX getopt utility
			IPC_SAP -- wrapper for BSD sockets
			IPC_SAP_FIFO -- wrapper for FIFOS (named pipes)
			IPC_SAP_SPIPE -- wrapper for SVR4 STREAM pipes and connld 
			Log_Msg -- library API for a local/remote logging facility
			Mem_Map -- wrapper for BSD mmap() memory mapped files 
			Message_Queues -- wrapper for SysV message queues
			Reactor -- wrapper for select() and poll()
			Semaphores -- wrapper for SysV semaphores
			Server_Daemon -- a wrapper for dynamically linking
			Shared_Memory -- wrapper for SysV shared memory
			Shared_Malloc -- wrapper for SysV/BSD shared mallocs
			TLI_SAP -- wrapper for SVR4 TLI 
	. tests -- programs that illustrate how to use the various wrappers

	Please refer to the INSTALL file for information on how to
build and test the ACE wrappers.  The BIBLIOGRAPHY file contains
information on where to obtain articles that describe the ACE wrappers
and the ADAPTIVE system in more detail.

	Also, please note that there is a companion tar file called
C++_wrappers_doc.tar.Z, which is approximately 1.5 Meg compressed.
This file is in the same ftp/gnu directory as the source code
distribution.  In this file is the following:

	. doc	  -- LaTeX documentation (in both latex and .ps format)
	. papers  -- postscript versions of various papers describing ACE

COPYRIGHT INFORMATION

	You are free to do anything you like with this code.  However,
you may not do anything to this code that will prevent it from being
distributed freely in its original form (such as copyrighting it,
etc.).  Moreover, if you have any improvements, suggestions, and or
comments, I'd like to hear about it!  It would be great to see this
distributed evolve into a comprehensive, robust, and well-documented
C++ class library that would be freely available to everyone.
Natually, I am not responsible for any problems caused by using these
C++ wrappers.

	Thanks,
	
		Douglas C. Schmidt
		(schmidt@ics.uci.edu)
		Department of Information and Computer Science
		University of California, Irvine
		Irvine, CA 92717
		Work #: (714) 856-4105
		FAX #: (714) 856-4056

ACKNOWLEDGEMENTS
	
	Special thanks to Paul Stephenson for devising the recursive 
Makefile scheme that underlies this distribution.  Also thanks to Olaf
Kruger for explaining how to instantiate templates for shared
libraries on SunOS 4.
-- 
Douglas C. Schmidt
Department of Information and Computer Science
University of California, Irvine
Irvine, CA 92717. Work #: (714) 856-4105; FAX #: (714) 856-4056


>56  Teaching Intro to OO Slides, T. Budd

From: budd@daimi.aau.dk (Tim Budd)
Subject: Re: Slides on OOP or OMT wanted
Date: 8 Nov 1993 07:46:08 GMT
Organization: DAIMI, Computer Science Dept. at Aarhus University

>...

I also have a series of slides that I have developed for use with my
text ``an introduction to object-oriented programming'' (timothy budd,
addison-wesley publishers).  These can be found at cs.orst.edu
directory pub/budd/oopintro/slides/*, or there is a mail server
called almanac@cs.orst.edu and if you say
	send oopintro slides chapter1
and so on you can get them via e-mail.  Warning, it yields a lot of
e-mail, so do it one at a time.
--tim


>57  Value Dependence Graphs

From: Michael D. Ernst <mernst@research.microsoft.com>
Subject:  Value dependence graphs paper available
Date: Tue, 9 Nov 1993 00:59:36 GMT

The paper "Value Dependence Graphs: Representation Without Taxation",
which describes a new intermediate representation which is particularly
amenable to optimization, is available.  (This version corrects typos and
clarifies a few minor points that may not have been completely clear in
the version which will appear in the POPL 94 proceedings.)  You can get a
copy in three ways:

1.  Via anonymous ftp, obtain file research.microsoft.com:/pub/mernst/vdg.ps
    (or file vdg.ps635 if you have a HP LaserJet 4 printer).
2.  Reply to mernst@research.microsoft.com requesting PostScript by email,
    and I will send you the PostScript file of your choice.  (The files are
    483K and 1018K bytes, respectively.)
3.  Reply to mernst@research.microsoft.com sending me your physical mail
    address, and I will mail you a hardcopy.

The abstract is:

The value dependence graph (VDG) is a sparse dataflow-like representation
that simplifies program analysis and transformation.  It is a functional
representation that represents control flow as data flow and makes
explicit all machine quantities, such as stores and I/O channels.  We are
developing a compiler that builds a VDG representing a program, analyzes
and transforms the VDG, then produces a control flow graph (CFG) [ASU86]
from the optimized VDG.  This framework simplifies transformations and
improves upon several published results.  For example, it enables more
powerful code motion than [CLZ86, FOW87], eliminates as many redundancies
as [AWZ88, RWZ88] (except for redundant loops), and provides important
information to the code scheduler [BR91].  We exhibit a fast, one-pass
method for elimination of partial redundancies that never performs
redundant code motion [KRS92, DS93] and is simpler than the classical
[MR79, Dha91] or SSA [RWZ88] methods.  These results accrue from
eliminating the CFG from the analysis/transformation phases and using
demand dependences in preference to control dependences.

The paper's full citation is:

@InProceedings{WeiseCES94,
  author = 	 "Daniel Weise and Roger F. Crew and Michael Ernst and
		  Bjarne Steensgaard",
  title = 	 "Value Dependence Graphs:  Representation Without Taxation",
  booktitle =	 POPL94,
  OPTpages = 	 "",
  year =	 1994,
  month =	 jan,
  address =	 "Portland, OR"
}



APPENDIX F  MAGAZINES, JOURNALS AND NEWSLETTERS
===============================================


ACM OOPSLA
----------

  Addison-Wesley
  Order Dept.
  Jacob Way
  Reading, MA 01867
  (800) 447-2226

Additional information can be obtained from ACMpubs@acm.org.

ACM
---
ACM OO Messenger
----------------
ACM SigPlan Notices
-------------------

  Publications Office
  ACM, 1515 Broadway
  NY, NY 10056
  (212)869-7440, FAX: (212)869-0481


American Programmer (Yourdon's Newsletter)
------------------------------------------

  American Programmer, Inc.
  Dept. 13
  161 West 86th Street
  New York, NY  10024-3411

  Send for complementary copy.


CASE Trends Magazine
--------------------


The Coad Letter
---------------

  Object International, Inc.
  3202 W. Anderson Lane, Suite 208-724
  Austin, TX  78757-1022
  Tel: 800-926-9306, 512-795-0202
  Fax: 512-795-0332


C++ Report
----------
Journal of Object-Oriented Programming
--------------------------------------
Object Magazine
---------------
The Smalltalk Report (9/year)  (Dept SML)
-----------------------------------------

  Subscriber Services, Dept OOP
  PO 3000
  Denville NJ  07834-9970
  Phone: 212.274.0640
  Fax:   212.274.0646


The Guerilla Programmer
-----------------------

  New, by Ed Yourdon.

  Phone:  800-964-8702 or 617-648-9702
  Fax:    800-888-1816 or 617-648-1950



Object-Oriented Systems (New)
-----------------------------

EMail: journal@chall.mhs.compuserve.com

  USA/Canada:
  Journals Promotion Dept., Chapman & Hall, 29 West 35th
  Street, New York, NY 20001-2299, USA.
  Tel: (212) 244 3336
  Fax: (212) 244 3426
  EMail: 71201.1651@compuserve.com

  EC/RoW:
  Journals Promotions Dept., Chapman & Hall, 2-6 Boundary Row, London
  SE1 8HN, UK.
  Tel: +44 (0)71 865 0066
  Fax: +44 (0)71 522 9623
