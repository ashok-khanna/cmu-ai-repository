#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of shell archive."
# Contents:  gzip-1.2.2 gzip-1.2.2/README gzip-1.2.2/NEWS
#   gzip-1.2.2/INSTALL gzip-1.2.2/Makefile.in gzip-1.2.2/configure.in
#   gzip-1.2.2/configure gzip-1.2.2/COPYING gzip-1.2.2/TODO
#   gzip-1.2.2/THANKS gzip-1.2.2/ChangeLog gzip-1.2.2/gzip.c
#   gzip-1.2.2/zip.c gzip-1.2.2/deflate.c gzip-1.2.2/trees.c
#   gzip-1.2.2/bits.c gzip-1.2.2/unzip.c gzip-1.2.2/inflate.c
#   gzip-1.2.2/util.c gzip-1.2.2/crypt.c gzip-1.2.2/lzw.c
#   gzip-1.2.2/unlzw.c gzip-1.2.2/unpack.c gzip-1.2.2/unlzh.c
#   gzip-1.2.2/getopt.c gzip-1.2.2/alloca.c gzip-1.2.2/match.S
#   gzip-1.2.2/gzip.h gzip-1.2.2/lzw.h gzip-1.2.2/tailor.h
#   gzip-1.2.2/revision.h gzip-1.2.2/crypt.h gzip-1.2.2/getopt.h
#   gzip-1.2.2/zmore.in gzip-1.2.2/znew.in gzip-1.2.2/zdiff.in
#   gzip-1.2.2/zgrep.in gzip-1.2.2/zforce.in gzip-1.2.2/gzexe.in
#   gzip-1.2.2/gzip.1 gzip-1.2.2/zdiff.1 gzip-1.2.2/zgrep.1
#   gzip-1.2.2/zmore.1 gzip-1.2.2/znew.1 gzip-1.2.2/gzexe.1
#   gzip-1.2.2/zforce.1 gzip-1.2.2/gzip.doc gzip-1.2.2/algorithm.doc
#   gzip-1.2.2/gzip.texi gzip-1.2.2/texinfo.tex gzip-1.2.2/gpl.texinfo
#   gzip-1.2.2/gzip.info gzip-1.2.2/sample gzip-1.2.2/sample/makecrc.c
#   gzip-1.2.2/sample/zread.c gzip-1.2.2/sample/add.c
#   gzip-1.2.2/sample/sub.c gzip-1.2.2/sample/ztouch gzip-1.2.2/msdos
#   gzip-1.2.2/msdos/tailor.c gzip-1.2.2/msdos/match.asm
#   gzip-1.2.2/msdos/gzip.prj gzip-1.2.2/msdos/doturboc.bat
#   gzip-1.2.2/msdos/Makefile.msc gzip-1.2.2/msdos/Makefile.bor
#   gzip-1.2.2/msdos/Makefile.djg gzip-1.2.2/os2
#   gzip-1.2.2/os2/Makefile.os2 gzip-1.2.2/os2/gzip.def
#   gzip-1.2.2/os2/gzip16.def gzip-1.2.2/vms
#   gzip-1.2.2/vms/Makefile.vms gzip-1.2.2/vms/Makefile.gcc
#   gzip-1.2.2/vms/makegzip.com gzip-1.2.2/vms/Makefile.mms
#   gzip-1.2.2/vms/vms.c gzip-1.2.2/vms/gzip.hlp gzip-1.2.2/amiga
#   gzip-1.2.2/amiga/Makefile.sasc gzip-1.2.2/amiga/Makefile.gcc
#   gzip-1.2.2/amiga/tailor.c gzip-1.2.2/amiga/utime.h
#   gzip-1.2.2/amiga/match.a gzip-1.2.2/atari
#   gzip-1.2.2/atari/Makefile.st gzip-1.2.2/primos
#   gzip-1.2.2/primos/readme gzip-1.2.2/primos/primos.c
#   gzip-1.2.2/primos/alloca.pma gzip-1.2.2/primos/ci.opts
#   gzip-1.2.2/primos/build.cpl gzip-1.2.2/primos/include
#   gzip-1.2.2/primos/include/errno.h
#   gzip-1.2.2/primos/include/fcntl.h
#   gzip-1.2.2/primos/include/stdlib.h
#   gzip-1.2.2/primos/include/sysStat.h
#   gzip-1.2.2/primos/include/sysTypes.h
# Wrapped by friedman@wookumz.gnu.ai.mit.edu on Thu Jun 17 16:20:59 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test ! -d 'gzip-1.2.2' ; then
    echo shar: Creating directory \"'gzip-1.2.2'\"
    mkdir 'gzip-1.2.2'
fi
if test -f 'gzip-1.2.2/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/README'\"
else
echo shar: Extracting \"'gzip-1.2.2/README'\" \(7680 characters\)
sed "s/^X//" >'gzip-1.2.2/README' <<'END_OF_FILE'
XThis is the file README for the gzip distribution, version 1.2.2.
X
Xgzip (GNU zip) is a compression utility designed to be a replacement
Xfor 'compress'. Its main advantages over compress are much better
Xcompression and freedom from patented algorithms.  The GNU Project
Xuses it as the standard compression program for its system.
X
Xgzip currently uses by default the LZ77 algorithm used in zip 1.9 (the
Xportable pkzip compatible archiver). The gzip format was however
Xdesigned to accommodate several compression algorithms. See below
Xfor a comparison of zip and gzip.
X
Xgunzip can currently decompress files created by gzip, compress or
Xpack. The detection of the input format is automatic.  For the
Xgzip format, gunzip checks a 32 bit CRC. For pack, gunzip checks the
Xuncompressed length.  The 'compress' format was not designed to allow
Xconsistency checks. However gunzip is sometimes able to detect a bad
X.Z file because there is some redundancy in the .Z compression format.
XIf you get an error when uncompressing a .Z file, do not assume that
Xthe .Z file is correct simply because the standard uncompress does not
Xcomplain.  This generally means that the standard uncompress does not
Xcheck its input, and happily generates garbage output.
X
Xgzip produces files with a .gz extension. Previous versions of gzip
Xused the .z extension, which was already used by the 'pack'
XHuffman encoder. gunzip is able to decompress .z files (packed
Xor gzip'ed).
X
XSeveral planned features are not yet supported (see the file TODO).
XSee the file NEWS for a summary of changes since 0.5.  See the file
XINSTALL for installation instructions. Some answers to frequently
Xasked questions are given in the file INSTALL, please read it. (In
Xparticular, please don't ask me once more for an /etc/magic entry.)
X
XWARNINGS about broken optimizers:
X
X- on the NeXT, "cc -finline-functions" is broken.  gzip produces
X  valid .gz files but they are much too large because the string
X  matching code misses most matches. Use "cc -O" instead.
X
X- on the Mips R4000, gcc -O (version 2.3.1) generates bad code, use cc
X  or just gcc -g instead.
X
X- gcc 2.3.3 and 2.4.3 on the SGI Indigo IRIX 4.0.5 also produce bad code.
X  Use instead: make CC='cc -O2' or gcc without -O.
X
X- On Solaris 2.1 for x86, the January 1993 "OEM" compiler release
X  generates bad code. This is fixed in the June 1993 "FCS" release.
X
X- on Sparc with SunOS 4.1.1 and the SC1.0 compiler, the optimizer
X  works up to -O3 but -O4 does not work.
X
X- MSC 5.1 with -Ox and -DDYN_ALLOC generates bad code in inflate.c.
X  The default is static allocation (no DYN_ALLOC) and -Ox works on inflate.c.
X  But -Ox does not work on util.c, so you must use -Oait -Gs.
X
X- On dnix 5.3 2.2 cc version 2.37c is buggy. Version 2.38d works.
X
X- On an Alliant running Concentrix, cc (even without optimization) generates
X  incorrect code. You have to use gcc.
X
XFor all machines, Use "make check" to check that gzip was compiled correctly.
X
XPlease send all comments and bug reports by electronic mail to:
X   Jean-loup Gailly <jloup@chorus.fr>
X
Xor, if this fails, to bug-gnu-utils@prep.ai.mit.edu.
XBug reports should ideally include:
X
X    * The complete output of "gzip -V" (or the contents of revision.h
X      if you can't get gzip to compile)
X    * The hardware and operating system (try "uname -a")
X    * The compiler used to compile (if it is gcc, use "gcc -v")
X    * A description of the bug behavior
X    * The input to gzip, that triggered the bug
X
XIf you send me patches for machines I don't have access to, please test them
Xvery carefully. gzip is used for backups, it must be extremely reliable.
X
XThe package crypt++.el is highly recommended to manipulate gzip'ed
Xfile from emacs. It recognizes automatically encrypted and compressed
Xfiles when they are first visited or written. It is available via
Xanonymous ftp to roebling.poly.edu [128.238.5.31] in /pub/crypt++.el.
XThe same directory contains also patches to dired, ange-ftp and info.
XGNU tar 1.11.2 has a -z option to invoke directly gzip, so you don't have
Xto patch it.
X
XThe znew and gzexe shell scripts provided with gzip benefit from
X(but do not require) the cpmod utility to transfer file attributes.
XIt is available by anonymous ftp on gatekeeper.dec.com in
X/.0/usenet/comp.sources.unix/volume11/cpmod.Z.
X
XThe sample programs zread.c, sub.c and add.c are provided as examples
Xof useful complements to gzip. Read the comments inside each source file.
XThe perl script ztouch is also provided as example (not installed
Xby default since it relies on perl).
X
X
Xgzip is free software, you can redistribute it and/or modify it under
Xthe terms of the GNU General Public License, a copy of which is
Xprovided under the name COPYING. The latest version of gzip are always
Xavailable by ftp in prep.ai.mit.edu:/pub/gnu, or in any of the prep
Xmirror sites:
X
X- sources in gzip-*.tar (or .shar or .tar.gz)
X- Solaris 2 executables in sparc-sun-solaris2/gzip-binaries-*.tar
X- MSDOS lha self-extracting exe in gzip-msdos-*.exe. Once extracted,
X  copy gzip.exe to gunzip.exe and zcat.exe, or use "gzip -d" to decompress.
X  gzip386.exe runs much faster but only on 386 and above; it needs go32.exe,
X  available in omnigate.clarkson.edu:/pub/msdos/djgpp/djdev110.zip
X
XA VMS executable is available in ftp.spc.edu:[.macro32.savesets]gzip-1-*.zip
X(use [.macro32]unzip.exe to extract). A PRIMOS executable is available
Xin ftp.lysator.liu.se:/pub/primos/run/gzip.run.
X
XMany thanks to those who provided me with bug reports and feedback.
XSee the files THANKS and ChangeLog for more details.
X
X
X		Note about zip vs. gzip:
X
XThe name 'gzip' was a very unfortunate choice, because zip and gzip
Xare two really different programs, although the actual compression and
Xdecompression sources were written by the same persons. A different
Xname should have been used for gzip, but it is too late to change now.
X
Xzip is an archiver: it compresses several files into a single archive
Xfile. gzip is a simple compressor: each file is compressed separately.
XBoth share the same compression and decompression code for the
X'deflate' method.  unzip can also decompress old zip archives
X(implode, shrink and reduce methods). gunzip can also decompress files
Xcreated by compress and pack. zip 1.9 and gzip do not support
Xcompression methods other than deflation. (zip 1.0 supports shrink and
Ximplode). Better compression methods may be added in future versions
Xof gzip. zip will always stick to absolute compatibility with pkzip,
Xit is thus constrained by PKWare, which is a commercial company.  The
Xgzip header format is deliberately different from that of pkzip to
Xavoid such a constraint.
X
XOn Unix, gzip is mostly useful in combination with tar. GNU tar
X1.11.2 has a -z option to invoke gzip automatically.  "tar -z"
Xcompresses better than zip, since gzip can then take advantage of
Xredundancy between distinct files. The drawback is that you must
Xscan the whole tar.gz file in order to extract a single file near
Xthe end; unzip can directly seek to the end of the zip file. There
Xis no overhead when you extract the whole archive anyway.
XIf a member of a .zip archive is damaged, other files can still
Xbe recovered. If a .tar.gz file is damaged, files beyond the failure
Xpoint cannot be recovered. (Future versions of gzip will have
Xerror recovery features.)
X
Xgzip and gunzip are distributed as a single program. zip and unzip
Xare, for historical reasons, two separate programs, although the
Xauthors of these two programs work closely together in the info-zip
Xteam. zip and unzip are not associated with the GNU project.
XThe sources are available by ftp in
X
X	 oak.oakland.edu:/pub/misc/unix/zip19p1.zip
X	 oak.oakland.edu:/pub/misc/unix/unz50p1.tar-z
END_OF_FILE
if test 7680 -ne `wc -c <'gzip-1.2.2/README'`; then
    echo shar: \"'gzip-1.2.2/README'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/README'
fi
if test -f 'gzip-1.2.2/NEWS' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/NEWS'\"
else
echo shar: Extracting \"'gzip-1.2.2/NEWS'\" \(8758 characters\)
sed "s/^X//" >'gzip-1.2.2/NEWS' <<'END_OF_FILE'
XCurrent Version: 1.2.2.
XSee the file ChangeLog for the details of all changes.
X
XMajor changes from 1.2 to 1.2.1
X* Fix a compilation error on Sun with cc (worked with gcc).
X
XMajor changes from 1.2 to 1.2.1
X* Let zmore act as more if the data is not gzipped.
X* made gzexe more secure (don't rely on PATH).
X* By default, display output name only when the name was actually truncated.
X
XMajor changes from 1.1.2 to 1.2
X* Added the --list option to display the file characteristics.
X* Added the --no-name option: do not save or restore original filename
X  Save the original name by default.
X* Allow gunzip --suffix "" to attempt decompression on any file
X  regardless of its extension if an original name is present.
X* Add support for the SCO compress -H format.
X* gzip --fast now compresses faster (speed close to that of compress)
X  with degraded compression ratio (but still better than compress).
X  Default level changed to -6 (acts exactly as previous level -5) to
X  be a better indication of its placement in the speed/ratio range.
X* Use smart name truncation: 123456789012.c -> 123456789.c.gz
X   instead of 12345678901.gz
X* With --force, let zcat pass non gzip'ed data unchanged (zcat == cat)
X* Added the zgrep shell script.
X* Made sub.c useful for 16 bit sound, 24 bit images, etc..
X* Supress warnings about suffix for gunzip -r, except with --verbose.
X* On MSDOS, use .gz extension when possible (files without extension)
X* Moved the sample programs to a subdirectory sample.
X* Added a "Special targets" section in INSTALL.
X
XMajor changes from 1.1.1 to 1.1.2.
X* Fix serious bug for VMS (-gz not removed when decompressing).
X* Allow suffix other than .gz in znew.
X* Do not display compression ratio when decompressing stdin.
X* In zmore.in, work around brain damaged stty -g (Ultrix).
X* Display a correct compression ratio for .Z files.
X* Added .z to .gz renaming script in INTALL.
X* Allow setting CFLAGS in configure.
X
XMajor changes from 1.1 to 1.1.1.
X* Fix serious bug in vms.c (affects Vax/VMS only).
X* Added --ascii option.
X* Add workaround in configure.in for Ultrix (quote eval argument)
X
XMajor changes from 1.0.7 to 1.1.
X* Use .gz suffix by default, add --suffix option.
X* Let gunzip accept a "_z" suffix (used by one 'compress' on Vax/VMS).
X* Quit when reading garbage from stdin instead of reporting an error.
X* Added makefile for VAX/MMS and support for wildcards on VMS.
X* Added support for MSC under OS/2.
X* Added support for Prime/PRIMOS.
X* Display compression ratio also when decompressing (with --verbose).
X* Quit after --version (GNU standard)
X* Use --force to bypass isatty() check
X* Continue processing other files in case of recoverable error.
X* Added comparison of zip and gzip in the readme file.
X* Added small sample programs (ztouch, sub, add)
X* Use less memory when compiled with -DSMALL_MEM (for MSDOS).
X* Remove the "off by more than one minute" time stamp kludge
X
XMajor changes from 1.0.6 to 1.0.7.
X* Allow zmore to read from standard input (like more).
X* Support the 68000 (Atari ST) in match.S.
X* Retry partial writes (required on Linux when gzip is suspended in a pipe).
X* Allow full pathnames and renamings in gzexe.
X* Don't let gzexe compress setuid executables or gzip itself.
X* Added vms/Makefile.gcc for gcc on the Vax.
X* Allow installation of binaries and shell scripts in different dirs.
X* Allows complex PAGER variable in zmore (e.g.: PAGER="col -x | more")
X* Allow installation of zcat as gzcat.
X* Several small changes for portability to old or weird systems.
X* Suppress help message and send compressed data to the terminal when
X  gzip is invoked without parameters and without redirection.
X*  Add compile option GNU_STANDARD to respect the GNU coding standards:
X   with -DGNU_STANDARD, behave as gzip even if invoked under the name gunzip.
X(I don't like the last two changes, which were requested by the FSF.)
X
XMajor changes from 1.0.5 to 1.0.6.
X* Let gzexe detect executables that are already gzexe'd.
X* Keep file attributes in znew and gzexe if cpmod is available.
X* Don't try restoring record format on VMS (1.0.5 did not work correctly)
X* Added asm version for 68000 in amiga/match.a.
X  Use asm version for Atari TT and NeXT.
X* For OS/2, assume HPFS by default, add flag OS2FAT if necessary.
X* Fixed some bugs in zdiff and define zcmp as a link to zdiff.
X
X
XMajor changes from 1.0.4 to 1.0.5.
X* For VMS, restore the file type for variable record format, otherwise
X    extract in fixed length format (not perfect, but better than
X    forcing all files to be in stream_LF format).
X* For VMS, use "-z" default suffix and accept a version number in file names.
X* For Unix, allow compression of files with name ending in 'z'. Use only
X  .z, .*-z, .tgz, .taz as valid gzip extensions. In the last two cases,
X  extract to .tar by default.
X* On some versions of MSDOS, files with a 3 character extension could not
X  be compressed.
X* Garbage collect files in /tmp created by gzexe.
X* Fix the 'OS code' byte in the gzip header.
X* For the Amiga, add the missing utime.h and add support for gcc.
X
X
XMajor changes from 1.0.3 to 1.0.4.
X* Added optimized asm version for 68020.
X* Add support for DJGPP.
X	
X* Add support for the Atari ST.
X* Added zforce to rename gzip'ed files with truncated names.
X* Do not install with name uncompress (some systems rely on the
X  absence of any check in the old uncompress).
X* Added missing function (fcfree) in msdos/tailor.c
X* Let gunzip handle .tgz files, and let gzip skip them.
X* Added -d option (decompress) for gzexe and try preserving file permissions.
X* Suppress all warnings with -q.
X* Use GZIP_OPT for VMS to avoid conflict with program name.
X* ... and many other small changes (see ChangeLog)
X
X
XMajor changes from 1.0.2 to 1.0.3
X* Added -K option for znew to keep old .Z files if smaller
X* Added -q option (quiet) to cancel -v in GZIP env variable.
X* Made gzexe safer on systems with filename limitation to 14 chars.
X* Fixed bugs in handling of GZIP env variable and incorrect free with Turbo C.
X
X
XMajor changes from 1.0.1 to 1.0.2
X* Added env variable GZIP for default options. Example:
X   for sh:   GZIP="-8 -v"; export GZIP
X   for csh:  setenv GZIP "-8 -v"
X* Added support for the Amiga.
X* znew now keeps the old .Z if it is smaller than the .z file.
X  This can happen for some large and very redundant files.
X* Do not complain about trailing garbage for record oriented IO (Vax/VMS).
X  This implies however that multi-part gzip files are not supported
X  on such systems.
X* Added gzexe to compress rarely used executables.
X* Reduce memory usage (required for MSDOS and useful on all systems).
X* Preserve time stamp in znew -P (pipe option) if touch -r works.
X
X
XMajor changes from 1.0 to 1.0.1
X* fix trivial errors in the Borland makefile (msdos/Makefile.bor)
X
X
XMajor changes from 0.8.2 to 1.0
X* gzip now runs on Vax/VMS
X* gzip will not not overwrite files without -f when using /bin/sh in
X  background.
X* Support the test option -t for compressed (.Z) files.
X  Allow some data recovery for bad .Z files.
X* Added makefiles for MSDOS (Only tested for MSC, not Borland).
X* still more changes to configure for several systems
X
X
XMajor changes from 0.8.1 to 0.8.2:
X* yet more changes to configure for Linux and other systems
X* Allow zcat on a file with multiple links.
X
X
XMajor changes from 0.8 to 0.8.1:
X* znew has now a pipe option -P to reduce the disk space requirements,
X  but this option does not preserve timestamps.
X* Fixed some #if directives for compilation with TurboC.
X
X
XMajor changes from 0.7 to 0.8:
X* gzip can now extract .z files created by 'pack'.
X* configure should no longer believe that every machine is a 386
X* Fix the entry for /etc/magic in INSTALL.
X* Add patch for GNU tar 1.11.1 and a pointer to crypt++.el
X* Uncompress files with multiple links only with -f.
X* Fix for uncompress of .Z files on 16-bit machines
X* Create a correct output name for file names of exactly N-1 chars when
X  the system has a limit of N chars.
X
X
XMajor changes from 0.6 to 0.7:
X* Use "make check" instead of "make test".
X* Keep time stamp and pass options to gzip in znew.
X* Do not create .z.z files with gzip -r.
X* Allow again gunzip .zip files (was working in 0.5)
X* Allow again compilation with TurboC 2.0 (was working in 0.4)
X
X
XMajor changes form 0.5 to 0.6:
X* gunzip reported an error when extracting certain .z files. The .z files
X  produced by gzip 0.5 are correct and can be read by gunzip 0.6.
X* gunzip now supports multiple compressed members within a single .z file.
X* Fix the check for i386 in configure.
X* Added "make test" to check for compiler bugs. (gcc -finline-functions
X  is broken at least on the NeXT.)
X* Use environment variable PAGER in zmore if it is defined.
X* Accept gzcat in addition to zcat for people having /usr/bin before
X  /usr/local/bin in their path.
END_OF_FILE
if test 8758 -ne `wc -c <'gzip-1.2.2/NEWS'`; then
    echo shar: \"'gzip-1.2.2/NEWS'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/NEWS'
fi
if test -f 'gzip-1.2.2/INSTALL' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/INSTALL'\"
else
echo shar: Extracting \"'gzip-1.2.2/INSTALL'\" \(8260 characters\)
sed "s/^X//" >'gzip-1.2.2/INSTALL' <<'END_OF_FILE'
XThis is a generic INSTALL file for utilities distributions.
XSome features specific to gzip have been added.
X
XTo compile this package:
X
X1.  Configure the package for your system.  In the directory that this
Xfile is in, type `./configure'.  If you're using `csh' on an old
Xversion of System V, you might need to type `sh configure' instead to
Xprevent `csh' from trying to execute `configure' itself.
X
XThe `configure' shell script attempts to guess correct values for
Xvarious system-dependent variables used during compilation, and
Xcreates the Makefile(s) (one in each subdirectory of the source
Xdirectory).  In some packages it creates a C header file containing
Xsystem-dependent definitions.  It also creates a file `config.status'
Xthat you can run in the future to recreate the current configuration.
X
XRunning `configure' takes a minute or two.  While it is running, it
Xprints some messages that tell what it is doing.  If you don't want to
Xsee the messages, run `configure' with its standard output redirected
Xto `/dev/null'; for example, `./configure >/dev/null'.
X
XTo compile the package in a different directory from the one
Xcontaining the source code, you must use a version of `make' that
Xsupports the VPATH variable, such as GNU `make'.  `cd' to the directory
Xwhere you want the object files and executables to go and run
X`configure'.  `configure' automatically checks for the source code in
Xthe directory that `configure' is in and in `..'.  If for some reason
X`configure' is not in the source code directory that you are
Xconfiguring, then it will report that it can't find the source code.
XIn that case, run `configure' with the option `--srcdir=DIR', where
XDIR is the directory that contains the source code.
X
XBy default, `make install' will install the package's files in
X/usr/local/bin, /usr/local/lib, /usr/local/man, etc.  You can specify an
Xinstallation prefix other than /usr/local by giving `configure' the option
X`--prefix=PATH'.  Alternately, you can do so by consistently giving a value
Xfor the `prefix' variable when you run `make', e.g.,
X	make prefix=/usr/gnu
X	make prefix=/usr/gnu install
X
XYou can specify separate installation prefixes for
Xarchitecture-specific files and architecture-independent files.  If
Xyou give `configure' the option `--exec-prefix=PATH' or set the
X`make' variable `exec_prefix' to PATH, the package will use PATH as
Xthe prefix for installing programs and libraries.  Data files and
Xdocumentation will still use the regular prefix.  Normally, all files
Xare installed using the regular prefix.
X
XAnother `configure' option is useful mainly in `Makefile' rules for
Xupdating `config.status' and `Makefile'.  The `--no-create' option
Xfigures out the configuration for your system and records it in
X`config.status', without actually configuring the package (creating
X`Makefile's and perhaps a configuration header file).  Later, you can
Xrun `./config.status' to actually configure the package.  You can also
Xgive `config.status' the `--recheck' option, which makes it re-run
X`configure' with the same arguments you used before.  This option is
Xuseful if you change `configure'.
X
X`configure' ignores any other arguments that you give it.
X
XIf your system requires unusual options for compilation or linking
Xthat `configure' doesn't know about, you can give `configure' initial
Xvalues for some variables by setting them in the environment.  In
XBourne-compatible shells, you can do that on the command line like
Xthis:
X	CC='gcc -traditional' DEFS=-D_POSIX_SOURCE ./configure
X
XFor csh compatible shells, you can do something like this:
X
X	(setenv CC 'gcc -traditional' ; ./configure)
X
XThe `make' variables that you might want to override with environment
Xvariables when running `configure' are:
X
X(For these variables, any value given in the environment overrides the
Xvalue that `configure' would choose:)
XCC		C compiler program.
X		Default is `cc', or `gcc' if `gcc' is in your PATH.
XINSTALL		Program to use to install files.
X		Default is `install' if you have it, `cp' otherwise.
X		If you have an non-standard `install', use INSTALL=cp
X
X(For these variables, any value given in the environment is added to
Xthe value that `configure' chooses:)
XDEFS		Configuration options, in the form `-Dfoo -Dbar ...'
XCFLAGS		Compiler options, such as `-O -g ...'
XLIBS		Libraries to link with, in the form `-lfoo -lbar ...'
X
XIf you need to do unusual things to compile the package, we encourage
Xyou to figure out how `configure' could check whether to do them, and
Xmail diffs or instructions to the address given in the README so we
Xcan include them in the next release.
X
X2.  Type `make' to compile the package.  If you want, you can override
Xthe `make' variables CFLAGS and LDFLAGS like this:
X
X	make CFLAGS=-O2 LDFLAGS=-s
X
X3.  The package comes with self-tests. If you want to run them,
Xtype `make check'.
X
X4.  Type `make install' to install programs, data files, and
Xdocumentation. This creates links between gzip, gunzip and zcat.
XYou can create additional links uncompress, ungzip and gzcat if
Xyou prefer these names. You can also create links to unpack and pcat
Xif your system uses packed files by default and you want to transform
Xthem transparently to gzip'ed files.
X
XIf you wish to use only the name gzcat and not overwrite an existing zcat, use:
X
X	make ZCAT=gzcat install
X
XThe man pages are installed by default with an extension `.1' (one).
XIf you want the extension `.l' (lower case L) use:
X
X	make manext=l install
X
XIf you are using csh or tcsh, you must type `rehash' after `make install'
Xto make sure that the command `gzip' will invoke the new executable.
X
X5.  You can remove the program binaries and object files from the
Xsource directory by typing `make clean'.  To also remove the
XMakefile(s), the header file containing system-dependent definitions
X(if the package uses one), and `config.status' (all the files that
X`configure' created), type `make distclean'.
X
XThe file `configure.in' is used as a template to create `configure' by
Xa program called `autoconf'.  You will only need it if you want to
Xregenerate `configure' using a newer version of `autoconf'.
X
X6.  You  can add the following  lines  to your  /etc/magic file so that
Xfile(1), if  your system supports it,  will recognize files created by
Xgzip:
X
X0	string		\037\213	gzip compressed data
X>2	byte		8		- deflate method
X>3	byte		&0x1		, ascii
X>3	byte		&0x2		, continuation
X>3	byte		&0x4		, extra field
X>3	byte		&0x8		, original file name
X>3	byte		&0x10		, comment
X>3	byte		&0x20		, encrypted
X>8	byte		2		, max compression
X>8	byte		4		, max speed
X
XIf your version of 'file' does not accept octal numbers in strings, replace the
Xfirst line with one of these:
X
X0	short		0x8b1f		gzip compressed data
X0	short		0x1f8b		gzip compressed data
X0	short		017613		gzip compressed data
X
XUse the first form if your machine is a 386 or a Vax (little-endian machine),
Xthe second or third form otherwise.
X
X7. To rename .z files with the new .gz suffix, you can use or adapt
X   the following shell script:
X
X#!/bin/sh
Xfor i in `find . -name '*.z' -type f -print`
Xdo
X    new=`echo "$i" | sed 's/\.z$/.gz/'`
X    mv "$i" "$new" || echo Failed renaming $i to $new
Xdone
X
XIf you wish to keep the old .z suffix as default without setting the
XGZIP environment variable to "--suffix .z", you can compile gzip with:
X
X   make CFLAGS='-DZ_SUFFIX=\".z\"'
X
X
X8.  Special targets
X
X- For MSDOS, OS/2, VMS, Atari, Amiga, Primos, use the makefile or command
X  file provided in the appropriate subdirectory.
X
X- On Xenix, some preprocessors do not define M_XENIX. You may have to do:
X
X	DEFS='-DM_XENIX' ./configure
X
X- On Xenix 2.3.2 for 286, do: make xenix_286
X
X- On Coherent, do: make coherent
X
X- On NeXT 3.0 or higher, Bill Bumgarner <bbum@stone.com> recommends:
X
X   (setenv DEFS "-D_POSIX_SOURCE"; ./configure --prefix=/LocalDeveloper)
X    make CFLAGS="-O2" LDFLAGS="-s -object"
X
X   To build a gzip package that can run on either the m68k or i386 family:
X
X (setenv DEFS "-D_POSIX_SOURCE -DNO_ASM"; ./configure --prefix=/LocalDeveloper)
X  make "CFLAGS=-O2 -arch m68k -arch i386" LDFLAGS="-s -object"
X
X- If your system is a pure BSD system but incorrectly links string.h to
X  strings.h, you may get undefined mem* and str* symbols. Try recompiling with
X
X      make clean
X      make CFLAGS="-DNO_STRING_H"
END_OF_FILE
if test 8260 -ne `wc -c <'gzip-1.2.2/INSTALL'`; then
    echo shar: \"'gzip-1.2.2/INSTALL'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/INSTALL'
fi
if test -f 'gzip-1.2.2/Makefile.in' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/Makefile.in'\"
else
echo shar: Extracting \"'gzip-1.2.2/Makefile.in'\" \(11141 characters\)
sed "s/^X//" >'gzip-1.2.2/Makefile.in' <<'END_OF_FILE'
X# Makefile for gzip (GNU zip)    -*- Indented-Text -*-
X# Copyright (C) 1992-1993 Jean-loup Gailly and the Free Software Foundation
X
X# This program is free software; you can redistribute it and/or modify
X# it under the terms of the GNU General Public License as published by
X# the Free Software Foundation; either version 2, or (at your option)
X# any later version.
X
X# This program is distributed in the hope that it will be useful,
X# but WITHOUT ANY WARRANTY; without even the implied warranty of
X# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X# GNU General Public License for more details.
X
X# You should have received a copy of the GNU General Public License
X# along with this program; if not, write to the Free Software
X# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
X# $Id: Makefile.in,v 0.22 1993/06/16 17:24:19 jloup Exp $
X
X#### Start of system configuration section. ####
X
X
Xsrcdir = @srcdir@
XVPATH = @srcdir@
X
XCC = @CC@
XCPP = @CPP@
X
XINSTALL = @INSTALL@
XINSTALL_PROGRAM = @INSTALL_PROGRAM@
XINSTALL_DATA = @INSTALL_DATA@
X
X# Things you might add to DEFS (configure usually figures out what to do):
X# -DGNU_STANDARD        Behave as gzip even if invoked as gunzip (GNU standard)
X# -DDIRENT              Use <dirent.h>  for recursion (-r)
X# -DSYSDIR              Use <sys/dir.h> for recursion (-r)
X# -DSYSNDIR             Use <sys/ndir.h> for recursion (-r)
X# -DNDIR                Use <ndir.h> for recursion (-r)
X# -DSTDC_HEADERS        Use <stdlib.h>
X# -DHAVE_UNISTD_H	Use <unistd.h>
X# -DNO_FCNTL_H          Don't use <fcntl.h>
X# -DNO_UTIME_H		Don't use <utime.h>
X# -DHAVE_SYSUTIME_H	Use <sys/utime.h>
X# -DNO_MEMORY_H         Don't use <memory.h>. Not needed if STDC_HEADERS.
X# -DNO_STRING_H         Use strings.h, not string.h. Not needed if STDC_HEADERS
X# -DRETSIGTYPE=int      Define this if signal handlers must return an int.
X# -DNO_SYMLINK          OS defines S_IFLNK but does not support symbolic links
X# -DNO_MULTIPLE_DOTS    System does not allow file names with multiple dots
X# -DNO_UTIME		System does not support setting file modification time
X# -DNO_CHOWN		System does not support setting file owner
X# -DNO_DIR		System does not support readdir()
X# -DPROTO		Force function prototypes even if __STDC__ not defined
X# -DASMV		Use asm version match.S
X# -DMSDOS		MSDOS specific
X# -DOS2			OS/2 specific
X# -DVAXC		Vax/VMS with Vax C compiler
X# -DVMS			Vax/VMS with gcc
X# -DDEBUG		Debug code
X# -DDYN_ALLOC		Use dynamic allocation of large data structures
X# -DMAXSEG_64K		Maximum array size is 64K (for 16 bit system)
X# -DRECORD_IO           read() and write() are rounded to record sizes.
X# -DNO_STDIN_FSTAT      fstat() is not available on stdin
X# -DNO_FSTAT            fstat() is not available
X# -DNO_SIZE_CHECK       stat() does not give a reliable file size
X
XDEFS = @DEFS@
XLIBS = @LIBS@
XALLOCA = @ALLOCA@ 
X
X# additional assembly sources for particular systems may be required.
XOBJA = @OBJA@
X
XSEDCMD = @SEDCMD@
X
XCFLAGS = @CFLAGS@
X# If you want debug on by default, use: CFLAGS="-g" ./configure
XLDFLAGS = $(CFLAGS)
X
XX=
X# For OS/2 or MSDOS, use: X=.exe
X
XO=.o
X# For OS/2 or MSDOS, use: O=.obj
X
XZCAT=zcat
X# To install zcat executable and man page as gzcat, use: ZCAT=gzcat
X
Xprefix = /usr/local
Xexec_prefix = $(prefix)
X
Xbindir = $(exec_prefix)/bin
Xscriptdir = $(bindir)
X# scriptdir is the directory in which shell scripts should be installed
Xdatadir = $(prefix)/lib
Xlibdir = $(prefix)/lib
Xinfodir = $(prefix)/info
X
X# Extension (not including `.') for the installed manual page filenames.
Xmanext = 1
X# Where to install the manual pages.
Xmandir = $(prefix)/man/man$(manext)
X
Xalldirs = $(bindir) $(scriptdir) $(datadir) $(libdir) $(infodir) $(mandir)
X
X#### End of system configuration section. ####
X
XSHELL = /bin/sh
X
XLOADLIBES = $(LIBS)
X
XTAR = tar
X
XSRCS = gzip.c zip.c deflate.c trees.c bits.c unzip.c inflate.c util.c crypt.c\
X       lzw.c unlzw.c unpack.c unlzh.c getopt.c alloca.c match.S
X
XOBJS = gzip$O zip$O deflate$O trees$O bits$O unzip$O inflate$O util$O \
X       crypt$O lzw$O unlzw$O unpack$O unlzh$O getopt$O $(OBJA) $(ALLOCA)
X
XHDRS = gzip.h lzw.h tailor.h revision.h crypt.h getopt.h
X
XGENFILES =  README NEWS INSTALL Makefile.in configure.in configure COPYING \
X  TODO THANKS ChangeLog $(SRCS) $(HDRS) zmore.in znew.in zdiff.in zgrep.in \
X  zforce.in gzexe.in gzip.1 zdiff.1 zgrep.1 zmore.1 znew.1 gzexe.1 zforce.1 \
X  gzip.doc algorithm.doc gzip.texi texinfo.tex gpl.texinfo gzip.info
X
XsampleFILES =  sample/makecrc.c sample/zread.c sample/add.c sample/sub.c \
X       sample/ztouch
X
XmsdosFILES = msdos/tailor.c msdos/match.asm msdos/gzip.prj msdos/doturboc.bat \
X  msdos/Makefile.msc msdos/Makefile.bor msdos/Makefile.djg
X
Xos2FILES = os2/Makefile.os2 os2/gzip.def os2/gzip16.def
X
XvmsFILES = vms/Makefile.vms vms/Makefile.gcc vms/makegzip.com \
X   vms/Makefile.mms vms/vms.c vms/gzip.hlp
X
XamigaFILES = amiga/Makefile.sasc amiga/Makefile.gcc amiga/tailor.c \
X  amiga/utime.h amiga/match.a
X
XatariFILES = atari/Makefile.st
X
XprimosFILES = primos/readme primos/primos.c primos/alloca.pma primos/ci.opts \
X   primos/build.cpl primos/include/errno.h primos/include/fcntl.h \
X   primos/include/stdlib.h primos/include/sysStat.h primos/include/sysTypes.h
X
XDISTFILES = $(GENFILES) $(sampleFILES) $(msdosFILES) $(os2FILES) $(vmsFILES)\
X   $(amigaFILES) $(atariFILES) $(primosFILES)
X
X.c$O:
X	$(CC) -c $(DEFS) $(CFLAGS) $<
X
X#.PHONY: default all force test check
X
Xdefault:  gzip$X
Xall:	gzip$X zdiff zgrep zmore znew zforce gzexe
Xforce:
X
X#### Start of specific targets section. ####
X#
X# 'configure' works only on Unix systems. For other systems able to make
X# sense of this makefile, you can define target specific entries here.
X# For other systems such as MSDOS, separate Makefiles are
X# provided in subdirectories.
X
X# gcc with emx 0.8f kit (use by preference os2/Makefile.os2)
Xos2_gcc:
X	$(MAKE) all CC=gcc CFLAGS="-O -DOS2" X=".exe"
X
X# Xenix 2.3.2 for 286:
Xxenix_286:
X	$(MAKE) all CFLAGS="-LARGE -M2l"
X
X# Coherent (with broken /bin/sh):
Xcoherent:
X	$(MAKE) all OBJA=match.o DEFS=\
X	"-DASMV -DSTDC_HEADERS=1 -DHAVE_UNISTD_H=1 -DDIRENT=1"
X
X#### End of specific targets section. ####
X
Xinstall: all gzip.info installdirs
X	$(INSTALL_PROGRAM) gzip$X $(bindir)/gzip$X
X	for f in zdiff zgrep zmore znew zforce gzexe; do \
X	  $(INSTALL_PROGRAM) $${f} $(scriptdir)/$${f}; done
X	rm -f $(scriptdir)/zcmp; ln $(scriptdir)/zdiff $(scriptdir)/zcmp
X	for f in gunzip$X ungzip$X $(ZCAT)$X ; do \
X	  rm -f $(bindir)/$${f}; done
X	@if echo $(DEFS) | grep GNU_STANDARD > /dev/null; then \
X	  echo 'exec gzip -d  $${1+"$$@"}' > $(bindir)/gunzip$X; \
X	  echo 'exec gzip -dc $${1+"$$@"}' > $(bindir)/$(ZCAT)$X; \
X	  chmod 755 $(bindir)/gunzip$X  $(bindir)/$(ZCAT)$X; \
X	else \
X	  ln $(bindir)/gzip$X $(bindir)/gunzip$X; \
X	  ln $(bindir)/gzip$X $(bindir)/$(ZCAT)$X; \
X	fi
X	for f in gzip gunzip $(ZCAT) zcmp zdiff zgrep zmore znew zforce gzexe; do \
X	  rm -f $(mandir)/$${f}.$(manext); done
X	-cd $(srcdir); \
X	  for f in gzip zdiff zgrep zmore znew zforce gzexe; do \
X	  $(INSTALL_DATA) $${f}.1 $(mandir)/$${f}.$(manext); done
X	echo .so man$(manext)/gzip.$(manext) > $(mandir)/$(ZCAT).$(manext)
X	echo .so man$(manext)/gzip.$(manext) > $(mandir)/gunzip.$(manext)
X	echo .so man$(manext)/zdiff.$(manext) > $(mandir)/zcmp.$(manext)
X	-cd $(srcdir); for f in gzip.info* ; do $(INSTALL_DATA) $${f} \
X	  $(infodir)/$${f}; done
X
Xuninstall: force
X	-cd $(bindir); rm -f gzip$X gunzip$X $(ZCAT)$X
X	-cd $(scriptdir); rm -f zcmp zdiff zgrep zmore znew zforce gzexe
X	-for f in gzip gunzip $(ZCAT) zcmp zdiff zgrep zmore znew gzexe; do \
X	  rm -f $(mandir)/$${f}.$(manext); done
X	-cd $(infodir); rm -f gzip.info*
X
X# install all files and replace compress (not recommended)
Xinstall_compress: install
X	-test -f $(bindir)/compress.old || \
X	  mv $(bindir)/compress$X $(bindir)/compress.old
X	ln $(bindir)/gzip$X $(bindir)/compress$X
X	rm -f $(bindir)/uncompress$X
X	ln $(bindir)/gzip$X $(bindir)/uncompress$X
X
X# Make sure all installation directories, e.g. $(bindir) actually exist by
X# making them if necessary. At most one level is created (except for man).
Xinstalldirs:
X	-if test ! -d $(prefix)/man; then \
X	   mkdir $(prefix)/man; fi
X	-for dir in $(alldirs) ; do \
X	   if test ! -d $${dir}; then \
X	     mkdir $${dir}; fi; \
X	done
X
Xtest: check
Xcheck:	gzip$X
X	./gzip -6 < $(srcdir)/texinfo.tex > _gztest.gz
X	@LANG=""; export LANG; if test `wc -c < _gztest.gz` -eq 30890; then \
X	   true; \
X	else \
X	   echo FAILED gzip test: incorrect size; \
X	fi
X	rm -f _gztest
X	./gzip -d _gztest.gz
X	@if cmp _gztest $(srcdir)/texinfo.tex; then \
X	   echo gzip test OK; \
X	else \
X	   echo FAILED gzip test: incorrect decompress; \
X	fi
X	rm -f _gztest*
X
XTAGS: $(SRCS) $(HDRS)
X	cd $(srcdir); etags $(SRCS) $(HDRS)
X
XMakefile: Makefile.in ./config.status
X	./config.status
X
X./config.status: configure
X	$(srcdir)/configure --srcdir=$(srcdir) --no-create
X
Xconfigure: configure.in
X	@echo Warning: configure is out of date
X#	cd $(srcdir); autoconf
X
Xclean:
X	rm -f *$O gzip$X gunzip$X ungzip$X $(ZCAT)$X add$X sub$X a.out core
X	rm -f zcmp zdiff zgrep zmore znew zforce gzexe _gztest*
X	rm -f *.aux *.cp *.cps *.dvi *.fn *.fns *.ky *.kys *.log
X	rm -f *.pg *.pgs *.toc *.tp *.tps *.vr *.vrs
X
Xmostlyclean: clean
X
Xdistclean: clean
X	rm -f Makefile config.status
X
Xrealclean: distclean
X	rm -f TAGS gzip.info* gzip.doc
X
Xdist: $(DISTFILES) Makefile
X	d=gzip-`sed -e '/VERSION/!d' -e 's/[^0-9.]*\([0-9.]*\).*/\1/' \
X	            -e q revision.h` ; \
X	rm -f ../$$d; \
X	ln -s `pwd` ../$$d; \
X	cd ..; \
X	files=""; \
X	for f in $(DISTFILES); do files="$$files $$d/$$f"; done; \
X	GZIP=-9 $(TAR) chofz $$d/$$d.tar.gz $$files; \
X	rm -f $$d
X
Xzipdist: $(DISTFILES) Makefile
X	zip -u9T gzip`sed -e '/VERSION/!d' -e 's/[^0-9.]*\([0-9.]*\).*/\1/' \
X			  -e s/[.]//g -e q revision.h` $(DISTFILES)
X
X# Actual build-related targets
X
Xgzip$X:	Makefile $(OBJS)
X	$(CC) $(LDFLAGS) -o $@ $(OBJS) $(LIBS)
X	rm -f gunzip$X $(ZCAT)$X
X	ln gzip$X gunzip$X
X	ln gzip$X $(ZCAT)$X
X
Xgzip$O zip$O deflate$O trees$O bits$O unzip$O inflate$O: gzip.h tailor.h
Xutil$O lzw$O unlzw$O unpack$O unlzh$O crypt$O: gzip.h tailor.h
X
Xgzip$O unlzw$O: revision.h lzw.h
X
Xbits$O unzip$O util$O zip$O: crypt.h
X
Xgzip$O getopt$O: getopt.h
X
Xmatch$O: match.S
X	$(CPP) $(srcdir)/match.S > _match.s
X	$(CC) -c _match.s
X	mv _match$O match$O
X	rm -f _match.s
X
Xzdiff: zdiff.in
X	sed -e "$(SEDCMD)" -e "s|BINDIR|$(bindir)|" $(srcdir)/zdiff.in > zdiff
X	chmod 755 zdiff
X
Xzgrep: zgrep.in
X	sed -e "$(SEDCMD)" -e "s|BINDIR|$(bindir)|" $(srcdir)/zgrep.in > zgrep
X	chmod 755 zgrep
X
Xzmore: zmore.in
X	sed -e "$(SEDCMD)" -e "s|BINDIR|$(bindir)|" $(srcdir)/zmore.in > zmore
X	chmod 755 zmore
X
Xznew: znew.in
X	sed -e "$(SEDCMD)" -e "s|BINDIR|$(bindir)|" $(srcdir)/znew.in > znew
X	chmod 755 znew
X
Xzforce: zforce.in
X	sed -e "$(SEDCMD)" -e "s|BINDIR|$(bindir)|" $(srcdir)/zforce.in >zforce
X	chmod 755 zforce
X
Xgzexe: gzexe.in
X	sed -e "$(SEDCMD)" -e "s|BINDIR|$(bindir)|" $(srcdir)/gzexe.in > gzexe
X	chmod 755 gzexe
X
Xgzip.info: gzip.texi
X	cd $(srcdir); makeinfo gzip.texi
X
Xgzip.dvi: gzip.texi
X	cd $(srcdir); texi2dvi gzip.texi
X
Xgzip.doc: gzip.1
X	nroff -man $(srcdir)/gzip.1 | col -b | uniq > gzip.doc
X
X# Prevent GNU make v3 from overflowing arg limit on SysV.
X.NOEXPORT:
X
X# end of file
END_OF_FILE
if test 11141 -ne `wc -c <'gzip-1.2.2/Makefile.in'`; then
    echo shar: \"'gzip-1.2.2/Makefile.in'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/Makefile.in'
fi
if test -f 'gzip-1.2.2/configure.in' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/configure.in'\"
else
echo shar: Extracting \"'gzip-1.2.2/configure.in'\" \(2189 characters\)
sed "s/^X//" >'gzip-1.2.2/configure.in' <<'END_OF_FILE'
Xdnl Process this file with autoconf to produce a configure script for gzip
Xdnl
Xdnl Same as AC_RETSIGTYPE, but use a void default.
Xdnl
Xdefine(AC_RETSIGTYP,
X[AC_COMPILE_CHECK([return type of signal handlers],
X[#include <sys/types.h>
X#include <signal.h>
X#ifdef signal
X#undef signal
X#endif
Xextern int (*signal ()) ();],
X[int i;],
X[AC_DEFINE(RETSIGTYPE, int)],
X[],
X)]
X)dnl
Xdnl
Xdnl End of local macros
Xdnl
XAC_INIT(gzip.c)
XAC_PROG_CC
Xdnl AC_PROG_CPP
Xdnl
Xdnl Try to assemble match.S with and without leading underline.
Xdnl cc -E produces incorrect asm files on SVR4, we must use /lib/cpp.
Xdnl Also, "gcc -E match.s" ignores -E, so we must use match.S.
Xecho checking for underline in external names
Xtest -z "$CPP" -a -f /lib/cpp && CPP=/lib/cpp
Xtest -z "$CPP" && CPP="$CC -E"
Xcat > conftest.c <<EOF
Xint foo() {return 0;}
XEOF
Xeval "$CC -c conftest.c > /dev/null 2>&1"
Xif nm conftest.o | grep _foo > /dev/null 2>&1 ; then
X  :
Xelse
X  CPP="${CPP} -DNO_UNDERLINE"
Xfi
Xrm -f _match.o conftest.c conftest.o
Xif echo "$DEFS" | grep NO_ASM >/dev/null; then
X  :
Xelse
X  echo checking for assembler
X  OBJA=""
X  if eval "$CPP $srcdir/match.S > _match.s 2>/dev/null"; then
X    if test ! -s _match.s || grep error < _match.s > /dev/null; then
X      :
X    elif eval "$CC -c _match.s >/dev/null 2>&1" && test -f _match.o; then
X      DEFS="${DEFS} -DASMV"
X      OBJA=match.o
X    fi
X  fi
X  rm -f _match.s _match.o
Xfi
Xdnl
XAC_PROG_INSTALL
XAC_AIX
XAC_MINIX
XAC_ISC_POSIX
XAC_DYNIX_SEQ
XAC_STDC_HEADERS
Xdnl if STDC_HEADERS can't be defined, look for special files:
XAC_HEADER_CHECK(string.h, ,AC_DEFINE(NO_STRING_H))
XAC_HEADER_CHECK(stdlib.h, ,AC_DEFINE(NO_STDLIB_H))
XAC_HEADER_CHECK(memory.h, ,AC_DEFINE(NO_MEMORY_H))
XAC_HEADER_CHECK(fcntl.h,  ,AC_DEFINE(NO_FCNTL_H))
XAC_HEADER_CHECK(time.h,   ,AC_DEFINE(NO_TIME_H))
XAC_HAVE_HEADERS(unistd.h)
Xutime=0
XAC_HEADER_CHECK(utime.h, utime=1 ,AC_DEFINE(NO_UTIME_H))
Xif test $utime -eq 0; then
X  AC_HAVE_HEADERS(sys/utime.h)
Xfi
XAC_DIR_HEADER
XAC_XENIX_DIR
XAC_ALLOCA
XAC_RETSIGTYP
XAC_SIZE_T
XAC_HEADER_EGREP(off_t, sys/types.h, ,AC_DEFINE(NO_OFF_T))
XAC_HAVE_POUNDBANG([SEDCMD="1d"], [SEDCMD=""])
XAC_PREFIX(gzip)
XAC_SUBST(CFLAGS)dnl
XAC_SUBST(OBJA)dnl
XAC_SUBST(SEDCMD)dnl
XAC_OUTPUT(Makefile)
END_OF_FILE
if test 2189 -ne `wc -c <'gzip-1.2.2/configure.in'`; then
    echo shar: \"'gzip-1.2.2/configure.in'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/configure.in'
fi
if test -f 'gzip-1.2.2/configure' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/configure'\"
else
echo shar: Extracting \"'gzip-1.2.2/configure'\" \(23427 characters\)
sed "s/^X//" >'gzip-1.2.2/configure' <<'END_OF_FILE'
X#!/bin/sh
X# Guess values for system-dependent variables and create Makefiles.
X# Generated automatically using autoconf.
X# Copyright (C) 1991, 1992, 1993 Free Software Foundation, Inc.
X
X# This program is free software; you can redistribute it and/or modify
X# it under the terms of the GNU General Public License as published by
X# the Free Software Foundation; either version 2, or (at your option)
X# any later version.
X
X# This program is distributed in the hope that it will be useful,
X# but WITHOUT ANY WARRANTY; without even the implied warranty of
X# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X# GNU General Public License for more details.
X
X# You should have received a copy of the GNU General Public License
X# along with this program; if not, write to the Free Software
X# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
X# Usage: configure [--srcdir=DIR] [--host=HOST] [--gas] [--nfp] [--no-create]
X#        [--prefix=PREFIX] [--exec-prefix=PREFIX] [--with-PACKAGE] [TARGET]
X# Ignores all args except --srcdir, --prefix, --exec-prefix, --no-create, and
X# --with-PACKAGE unless this script has special code to handle it.
X
X
Xfor arg
Xdo
X  # Handle --exec-prefix with a space before the argument.
X  if test x$next_exec_prefix = xyes; then exec_prefix=$arg; next_exec_prefix=
X  # Handle --host with a space before the argument.
X  elif test x$next_host = xyes; then next_host=
X  # Handle --prefix with a space before the argument.
X  elif test x$next_prefix = xyes; then prefix=$arg; next_prefix=
X  # Handle --srcdir with a space before the argument.
X  elif test x$next_srcdir = xyes; then srcdir=$arg; next_srcdir=
X  else
X    case $arg in
X     # For backward compatibility, also recognize exact --exec_prefix.
X     -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* | --exec=* | --exe=* | --ex=* | --e=*)
X	exec_prefix=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- | --exec | --exe | --ex | --e)
X	next_exec_prefix=yes ;;
X
X     -gas | --gas | --ga | --g) ;;
X
X     -host=* | --host=* | --hos=* | --ho=* | --h=*) ;;
X     -host | --host | --hos | --ho | --h)
X	next_host=yes ;;
X
X     -nfp | --nfp | --nf) ;;
X
X     -no-create | --no-create | --no-creat | --no-crea | --no-cre | --no-cr | --no-c | --no- | --no)
X        no_create=1 ;;
X
X     -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
X	prefix=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
X	next_prefix=yes ;;
X
X     -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=* | --s=*)
X	srcdir=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -srcdir | --srcdir | --srcdi | --srcd | --src | --sr | --s)
X	next_srcdir=yes ;;
X
X     -with-* | --with-*)
X       package=`echo $arg|sed 's/-*with-//'`
X       # Delete all the valid chars; see if any are left.
X       if test -n "`echo $package|sed 's/[-a-zA-Z0-9_]*//g'`"; then
X         echo "configure: $package: invalid package name" >&2; exit 1
X       fi
X       eval "with_`echo $package|sed s/-/_/g`=1" ;;
X
X     -v | -verbose | --verbose | --verbos | --verbo | --verb | --ver | --ve | --v)
X       verbose=yes ;;
X
X     *) ;;
X    esac
X  fi
Xdone
X
Xtrap 'rm -f conftest* core; exit 1' 1 3 15
X
X# Needed for some versions of `tr' so that character classes in `[]' work.
X#if test "${LANG+set}" = "set" ; then
X   LANG=C
X   LC_ALL=C
X   export LANG LC_ALL
X#fi
X
Xrm -f conftest*
Xcompile='${CC-cc} $CFLAGS $DEFS conftest.c -o conftest $LIBS >/dev/null 2>&1'
X
X# A filename unique to this package, relative to the directory that
X# configure is in, which we can look for to find out if srcdir is correct.
Xunique_file=gzip.c
X
X# Find the source files, if location was not specified.
Xif test -z "$srcdir"; then
X  srcdirdefaulted=yes
X  # Try the directory containing this script, then `..'.
X  prog=$0
X  confdir=`echo $prog|sed 's%/[^/][^/]*$%%'`
X  test "X$confdir" = "X$prog" && confdir=.
X  srcdir=$confdir
X  if test ! -r $srcdir/$unique_file; then
X    srcdir=..
X  fi
Xfi
Xif test ! -r $srcdir/$unique_file; then
X  if test x$srcdirdefaulted = xyes; then
X    echo "configure: Can not find sources in \`${confdir}' or \`..'." 1>&2
X  else
X    echo "configure: Can not find sources in \`${srcdir}'." 1>&2
X  fi
X  exit 1
Xfi
X# Preserve a srcdir of `.' to avoid automounter screwups with pwd.
X# But we can't avoid them for `..', to make subdirectories work.
Xcase $srcdir in
X  .|/*|~*) ;;
X  *) srcdir=`cd $srcdir; pwd` ;; # Make relative path absolute.
Xesac
X
Xif test -z "$CC"; then
X  # Extract the first word of `gcc', so it can be a program name with args.
X  set dummy gcc; word=$2
X  echo checking for $word
X  IFS="${IFS= 	}"; saveifs="$IFS"; IFS="${IFS}:"
X  for dir in $PATH; do
X    test -z "$dir" && dir=.
X    if test -f $dir/$word; then
X      CC="gcc"
X      break
X    fi
X  done
X  IFS="$saveifs"
Xfi
Xtest -z "$CC" && CC="cc"
Xtest -n "$CC" -a -n "$verbose" && echo "	setting CC to $CC"
X
X# Find out if we are using GNU C, under whatever name.
Xcat > conftest.c <<EOF
X#ifdef __GNUC__
X  yes
X#endif
XEOF
X${CC-cc} -E conftest.c > conftest.out 2>&1
Xif egrep yes conftest.out >/dev/null 2>&1; then
X  GCC=1 # For later tests.
X  CFLAGS="${CFLAGS--O}"
Xfi
Xrm -f conftest*
X
Xecho checking for underline in external names
Xtest -z "$CPP" -a -f /lib/cpp && CPP=/lib/cpp
Xtest -z "$CPP" && CPP="$CC -E"
Xcat > conftest.c <<EOF
Xint foo() {return 0;}
XEOF
Xeval "$CC -c conftest.c > /dev/null 2>&1"
Xif nm conftest.o | grep _foo > /dev/null 2>&1 ; then
X  :
Xelse
X  CPP="${CPP} -DNO_UNDERLINE"
Xfi
Xrm -f _match.o conftest.c conftest.o
Xif echo "$DEFS" | grep NO_ASM >/dev/null; then
X  :
Xelse
X  echo checking for assembler
X  OBJA=""
X  if eval "$CPP $srcdir/match.S > _match.s 2>/dev/null"; then
X    if test ! -s _match.s || grep error < _match.s > /dev/null; then
X      :
X    elif eval "$CC -c _match.s >/dev/null 2>&1" && test -f _match.o; then
X      DEFS="${DEFS} -DASMV"
X      OBJA=match.o
X    fi
X  fi
X  rm -f _match.s _match.o
Xfi
X# Make sure to not get the incompatible SysV /etc/install and
X# /usr/sbin/install, which might be in PATH before a BSD-like install,
X# or the SunOS /usr/etc/install directory, or the AIX /bin/install,
X# or the AFS install, which mishandles nonexistent args, or
X# /usr/ucb/install on SVR4, which tries to use the nonexistent group
X# `staff'.  On most BSDish systems install is in /usr/bin, not /usr/ucb
X# anyway.  Sigh.
Xif test "z${INSTALL}" = "z" ; then
X  echo checking for install
X  IFS="${IFS= 	}"; saveifs="$IFS"; IFS="${IFS}:"
X  for dir in $PATH; do
X    test -z "$dir" && dir=.
X    case $dir in
X    /etc|/usr/sbin|/usr/etc|/usr/afsws/bin|/usr/ucb) ;;
X    *)
X      if test -f $dir/installbsd; then
X	INSTALL="$dir/installbsd -c" # OSF1
X	INSTALL_PROGRAM='$(INSTALL)'
X	INSTALL_DATA='$(INSTALL) -m 644'
X	break
X      fi
X      if test -f $dir/install; then
X	if grep dspmsg $dir/install >/dev/null 2>&1; then
X	  : # AIX
X	else
X	  INSTALL="$dir/install -c"
X	  INSTALL_PROGRAM='$(INSTALL)'
X	  INSTALL_DATA='$(INSTALL) -m 644'
X	  break
X	fi
X      fi
X      ;;
X    esac
X  done
X  IFS="$saveifs"
Xfi
XINSTALL=${INSTALL-cp}
XINSTALL_PROGRAM=${INSTALL_PROGRAM-'$(INSTALL)'}
XINSTALL_DATA=${INSTALL_DATA-'$(INSTALL)'}
X
Xecho checking for AIX
Xecho checking how to run the C preprocessor
Xif test -z "$CPP"; then
X  CPP='${CC-cc} -E'
X  cat > conftest.c <<EOF
X#include <stdio.h>
XEOF
Xerr=`eval "($CPP \$DEFS conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  :
Xelse
X  CPP=/lib/cpp
Xfi
Xrm -f conftest*
Xfi
X
Xcat > conftest.c <<EOF
X#ifdef _AIX
X  yes
X#endif
X
XEOF
Xeval "$CPP \$DEFS conftest.c > conftest.out 2>&1"
Xif egrep "yes" conftest.out >/dev/null 2>&1; then
X  {
Xtest -n "$verbose" && \
Xecho '	defining' _ALL_SOURCE
XDEFS="$DEFS -D_ALL_SOURCE=1"
X}
X
Xfi
Xrm -f conftest*
X
X
Xecho checking for minix/config.h
Xcat > conftest.c <<EOF
X#include <minix/config.h>
XEOF
Xerr=`eval "($CPP \$DEFS conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  MINIX=1
Xfi
Xrm -f conftest*
X
X# The Minix shell can't assign to the same variable on the same line!
Xif test -n "$MINIX"; then
X  {
Xtest -n "$verbose" && \
Xecho '	defining' _POSIX_SOURCE
XDEFS="$DEFS -D_POSIX_SOURCE=1"
X}
X
X  {
Xtest -n "$verbose" && \
Xecho '	defining' _POSIX_1_SOURCE to be '2'
XDEFS="$DEFS -D_POSIX_1_SOURCE=2"
X}
X
X  {
Xtest -n "$verbose" && \
Xecho '	defining' _MINIX
XDEFS="$DEFS -D_MINIX=1"
X}
X
Xfi
X
Xecho checking for POSIXized ISC
Xif test -d /etc/conf/kconfig.d &&
X  grep _POSIX_VERSION /usr/include/sys/unistd.h >/dev/null 2>&1
Xthen
X  ISC=1 # If later tests want to check for ISC.
X  {
Xtest -n "$verbose" && \
Xecho '	defining' _POSIX_SOURCE
XDEFS="$DEFS -D_POSIX_SOURCE=1"
X}
X
X  if test -n "$GCC"; then
X    CC="$CC -posix"
X  else
X    CC="$CC -Xp"
X  fi
Xfi
X
Xecho checking for DYNIX/ptx libseq
Xcat > conftest.c <<EOF
X#if defined(_SEQUENT_)
X  yes
X#endif
X
XEOF
Xeval "$CPP \$DEFS conftest.c > conftest.out 2>&1"
Xif egrep "yes" conftest.out >/dev/null 2>&1; then
X  SEQUENT=1
Xfi
Xrm -f conftest*
X
Xtest -n "$SEQUENT" && test -f /usr/lib/libseq.a &&
X  LIBS="$LIBS -lseq"
X
Xecho checking for ANSI C header files
Xcat > conftest.c <<EOF
X#include <stdlib.h>
X#include <stdarg.h>
X#include <string.h>
X#include <float.h>
XEOF
Xerr=`eval "($CPP \$DEFS conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
Xecho '#include <string.h>' > conftest.c
Xeval "$CPP \$DEFS conftest.c > conftest.out 2>&1"
Xif egrep "memchr" conftest.out >/dev/null 2>&1; then
X  # SGI's /bin/cc from Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
Xcat > conftest.c <<EOF
X#include <ctype.h>
X#define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
X#define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
X#define XOR(e,f) (((e) && !(f)) || (!(e) && (f)))
Xint main () { int i; for (i = 0; i < 256; i++)
Xif (XOR (islower (i), ISLOWER (i)) || toupper (i) != TOUPPER (i)) exit(2);
Xexit (0); }
X
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  {
Xtest -n "$verbose" && \
Xecho '	defining' STDC_HEADERS
XDEFS="$DEFS -DSTDC_HEADERS=1"
X}
X
Xfi
Xrm -f conftest*
Xfi
Xrm -f conftest*
X
Xfi
Xrm -f conftest*
X
Xecho checking for string.h
Xcat > conftest.c <<EOF
X#include <string.h>
XEOF
Xerr=`eval "($CPP \$DEFS conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  :
Xelse
X  {
Xtest -n "$verbose" && \
Xecho '	defining' NO_STRING_H
XDEFS="$DEFS -DNO_STRING_H=1"
X}
X
Xfi
Xrm -f conftest*
X
Xecho checking for stdlib.h
Xcat > conftest.c <<EOF
X#include <stdlib.h>
XEOF
Xerr=`eval "($CPP \$DEFS conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  :
Xelse
X  {
Xtest -n "$verbose" && \
Xecho '	defining' NO_STDLIB_H
XDEFS="$DEFS -DNO_STDLIB_H=1"
X}
X
Xfi
Xrm -f conftest*
X
Xecho checking for memory.h
Xcat > conftest.c <<EOF
X#include <memory.h>
XEOF
Xerr=`eval "($CPP \$DEFS conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  :
Xelse
X  {
Xtest -n "$verbose" && \
Xecho '	defining' NO_MEMORY_H
XDEFS="$DEFS -DNO_MEMORY_H=1"
X}
X
Xfi
Xrm -f conftest*
X
Xecho checking for fcntl.h
Xcat > conftest.c <<EOF
X#include <fcntl.h>
XEOF
Xerr=`eval "($CPP \$DEFS conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  :
Xelse
X  {
Xtest -n "$verbose" && \
Xecho '	defining' NO_FCNTL_H
XDEFS="$DEFS -DNO_FCNTL_H=1"
X}
X
Xfi
Xrm -f conftest*
X
Xecho checking for time.h
Xcat > conftest.c <<EOF
X#include <time.h>
XEOF
Xerr=`eval "($CPP \$DEFS conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  :
Xelse
X  {
Xtest -n "$verbose" && \
Xecho '	defining' NO_TIME_H
XDEFS="$DEFS -DNO_TIME_H=1"
X}
X
Xfi
Xrm -f conftest*
X
Xfor hdr in unistd.h
Xdo
Xtrhdr=HAVE_`echo $hdr | tr '[a-z]./' '[A-Z]__'`
Xecho checking for ${hdr}
Xcat > conftest.c <<EOF
X#include <${hdr}>
XEOF
Xerr=`eval "($CPP \$DEFS conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  {
Xtest -n "$verbose" && \
Xecho '	defining' ${trhdr}
XDEFS="$DEFS -D${trhdr}=1"
X}
X
Xfi
Xrm -f conftest*
Xdone
X
Xutime=0
Xecho checking for utime.h
Xcat > conftest.c <<EOF
X#include <utime.h>
XEOF
Xerr=`eval "($CPP \$DEFS conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  utime=1 
Xelse
X  {
Xtest -n "$verbose" && \
Xecho '	defining' NO_UTIME_H
XDEFS="$DEFS -DNO_UTIME_H=1"
X}
X
Xfi
Xrm -f conftest*
X
Xif test $utime -eq 0; then
X  for hdr in sys/utime.h
Xdo
Xtrhdr=HAVE_`echo $hdr | tr '[a-z]./' '[A-Z]__'`
Xecho checking for ${hdr}
Xcat > conftest.c <<EOF
X#include <${hdr}>
XEOF
Xerr=`eval "($CPP \$DEFS conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  {
Xtest -n "$verbose" && \
Xecho '	defining' ${trhdr}
XDEFS="$DEFS -D${trhdr}=1"
X}
X
Xfi
Xrm -f conftest*
Xdone
X
Xfi
Xecho checking for directory library header
Xdirheader=
Xif test -z "$dirheader"; then
X  echo checking for dirent.h
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <dirent.h>
Xint main() { exit(0); }
Xint t() { DIR *dirp = opendir ("/"); }
XEOF
Xif eval $compile; then
X  {
Xtest -n "$verbose" && \
Xecho '	defining' DIRENT
XDEFS="$DEFS -DDIRENT=1"
X}
X dirheader=dirent.h
Xfi
Xrm -f conftest*
Xfi
Xif test -z "$dirheader"; then
X  echo checking for sys/ndir.h
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <sys/ndir.h>
Xint main() { exit(0); }
Xint t() { DIR *dirp = opendir ("/"); }
XEOF
Xif eval $compile; then
X  {
Xtest -n "$verbose" && \
Xecho '	defining' SYSNDIR
XDEFS="$DEFS -DSYSNDIR=1"
X}
X dirheader=sys/ndir.h
Xfi
Xrm -f conftest*
Xfi
Xif test -z "$dirheader"; then
X  echo checking for sys/dir.h
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <sys/dir.h>
Xint main() { exit(0); }
Xint t() { DIR *dirp = opendir ("/"); }
XEOF
Xif eval $compile; then
X  {
Xtest -n "$verbose" && \
Xecho '	defining' SYSDIR
XDEFS="$DEFS -DSYSDIR=1"
X}
X dirheader=sys/dir.h
Xfi
Xrm -f conftest*
Xfi
Xif test -z "$dirheader"; then
X  echo checking for ndir.h
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <ndir.h>
Xint main() { exit(0); }
Xint t() { DIR *dirp = opendir ("/"); }
XEOF
Xif eval $compile; then
X  {
Xtest -n "$verbose" && \
Xecho '	defining' NDIR
XDEFS="$DEFS -DNDIR=1"
X}
X dirheader=ndir.h
Xfi
Xrm -f conftest*
Xfi
X
Xecho checking for closedir return value
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <$dirheader>
Xint closedir(); main() { exit(closedir(opendir(".")) != 0); }
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  :
Xelse
X  {
Xtest -n "$verbose" && \
Xecho '	defining' VOID_CLOSEDIR
XDEFS="$DEFS -DVOID_CLOSEDIR=1"
X}
X
Xfi
Xrm -f conftest*
X
Xecho checking for Xenix
Xcat > conftest.c <<EOF
X#if defined(M_XENIX) && !defined(M_UNIX)
X  yes
X#endif
X
XEOF
Xeval "$CPP \$DEFS conftest.c > conftest.out 2>&1"
Xif egrep "yes" conftest.out >/dev/null 2>&1; then
X  XENIX=1
Xfi
Xrm -f conftest*
X
Xif test -n "$XENIX"; then
X  LIBS="$LIBS -lx"
X  case "$DEFS" in
X  *SYSNDIR*) ;;
X  *) LIBS="-ldir $LIBS" ;; # Make sure -ldir precedes any -lx.
X  esac
Xfi
X
X# The Ultrix 4.2 mips builtin alloca declared by alloca.h only works
X# for constant arguments.  Useless!
Xecho checking for working alloca.h
Xcat > conftest.c <<EOF
X#include <alloca.h>
Xint main() { exit(0); }
Xint t() { char *p = alloca(2 * sizeof(int)); }
XEOF
Xif eval $compile; then
X  {
Xtest -n "$verbose" && \
Xecho '	defining' HAVE_ALLOCA_H
XDEFS="$DEFS -DHAVE_ALLOCA_H=1"
X}
X
Xfi
Xrm -f conftest*
X
Xdecl="#ifdef __GNUC__
X#define alloca __builtin_alloca
X#else
X#if HAVE_ALLOCA_H
X#include <alloca.h>
X#else
X#ifdef _AIX
X #pragma alloca
X#else
X#ifdef supermax
X/* On Supermax, cc returns 0 for an include of an non existing .h file */
X error
X#else
Xchar *alloca ();
X#endif
X#endif
X#endif
X#endif
X"
Xecho checking for alloca
Xcat > conftest.c <<EOF
X$decl
Xint main() { exit(0); }
Xint t() { char *p = (char *) alloca(1); }
XEOF
Xif eval $compile; then
X  :
Xelse
X  alloca_missing=1
Xcat > conftest.c <<EOF
X
X#if defined(CRAY) && ! defined(CRAY2)
Xwinnitude
X#else
Xlossage
X#endif
X
XEOF
Xeval "$CPP \$DEFS conftest.c > conftest.out 2>&1"
Xif egrep "winnitude" conftest.out >/dev/null 2>&1; then
X  echo checking for _getb67
Xcat > conftest.c <<EOF
X#include <ctype.h>
Xint main() { exit(0); }
Xint t() { 
X/* The GNU C library defines this for functions which it implements
X    to always fail with ENOSYS.  Some functions are actually named
X    something starting with __ and the normal name is an alias.  */
X#if defined (__stub__getb67) || defined (__stub____getb67)
Xchoke me
X#else
X/* Override any gcc2 internal prototype to avoid an error.  */
Xextern char _getb67(); _getb67();
X#endif
X }
XEOF
Xif eval $compile; then
X  {
Xtest -n "$verbose" && \
Xecho '	defining' CRAY_STACKSEG_END to be '_getb67'
XDEFS="$DEFS -DCRAY_STACKSEG_END=_getb67"
X}
X
Xelse
X  echo checking for GETB67
Xcat > conftest.c <<EOF
X#include <ctype.h>
Xint main() { exit(0); }
Xint t() { 
X/* The GNU C library defines this for functions which it implements
X    to always fail with ENOSYS.  Some functions are actually named
X    something starting with __ and the normal name is an alias.  */
X#if defined (__stub_GETB67) || defined (__stub___GETB67)
Xchoke me
X#else
X/* Override any gcc2 internal prototype to avoid an error.  */
Xextern char GETB67(); GETB67();
X#endif
X }
XEOF
Xif eval $compile; then
X  {
Xtest -n "$verbose" && \
Xecho '	defining' CRAY_STACKSEG_END to be 'GETB67'
XDEFS="$DEFS -DCRAY_STACKSEG_END=GETB67"
X}
X
Xelse
X  echo checking for getb67
Xcat > conftest.c <<EOF
X#include <ctype.h>
Xint main() { exit(0); }
Xint t() { 
X/* The GNU C library defines this for functions which it implements
X    to always fail with ENOSYS.  Some functions are actually named
X    something starting with __ and the normal name is an alias.  */
X#if defined (__stub_getb67) || defined (__stub___getb67)
Xchoke me
X#else
X/* Override any gcc2 internal prototype to avoid an error.  */
Xextern char getb67(); getb67();
X#endif
X }
XEOF
Xif eval $compile; then
X  {
Xtest -n "$verbose" && \
Xecho '	defining' CRAY_STACKSEG_END to be 'getb67'
XDEFS="$DEFS -DCRAY_STACKSEG_END=getb67"
X}
X
Xfi
Xrm -f conftest*
X
Xfi
Xrm -f conftest*
X
Xfi
Xrm -f conftest*
X
Xfi
Xrm -f conftest*
X
X
Xfi
Xrm -f conftest*
X
Xif test -n "$alloca_missing"; then
X  # The SVR3 libPW and SVR4 libucb both contain incompatible functions
X  # that cause trouble.  Some versions do not even contain alloca or
X  # contain a buggy version.  If you still want to use their alloca,
X  # use ar to extract alloca.o from them instead of compiling alloca.c.
X  ALLOCA=alloca.o
Xif test -z "check_stack_dir"; then
X  echo 'checking stack direction for C alloca'
X  echo checking whether cross-compiling
X# If we cannot run a trivial program, we must be cross compiling.
Xcat > conftest.c <<EOF
Xmain(){exit(0);}
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  :
Xelse
X  cross_compiling=1
Xfi
Xrm -f conftest*
X
Xif test -n "$cross_compiling"
Xthen
X  {
Xtest -n "$verbose" && \
Xecho '	defining' STACK_DIRECTION to be '0'
XDEFS="$DEFS -DSTACK_DIRECTION=0"
X}
X
Xelse
Xcat > conftest.c <<EOF
Xfind_stack_direction ()
X{
X  static char *addr = 0;
X  auto char dummy;
X  if (addr == 0)
X    {
X      addr = &dummy;
X      return find_stack_direction ();
X    }
X  else
X    return (&dummy > addr) ? 1 : -1;
X}
Xmain ()
X{
X  exit (find_stack_direction() < 0);
X}
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  {
Xtest -n "$verbose" && \
Xecho '	defining' STACK_DIRECTION to be '1'
XDEFS="$DEFS -DSTACK_DIRECTION=1"
X}
X
Xelse
X  {
Xtest -n "$verbose" && \
Xecho '	defining' STACK_DIRECTION to be '-1'
XDEFS="$DEFS -DSTACK_DIRECTION=-1"
X}
X
Xfi
Xfi
Xrm -f conftest*
Xfi
Xfi
X
Xecho checking for return type of signal handlers
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <signal.h>
X#ifdef signal
X#undef signal
X#endif
Xextern int (*signal ()) ();
Xint main() { exit(0); }
Xint t() { int i; }
XEOF
Xif eval $compile; then
X  {
Xtest -n "$verbose" && \
Xecho '	defining' RETSIGTYPE to be 'int'
XDEFS="$DEFS -DRETSIGTYPE=int"
X}
X
Xfi
Xrm -f conftest*
X
X
Xecho checking for size_t in sys/types.h
Xecho '#include <sys/types.h>' > conftest.c
Xeval "$CPP \$DEFS conftest.c > conftest.out 2>&1"
Xif egrep "size_t" conftest.out >/dev/null 2>&1; then
X  :
Xelse
X  {
Xtest -n "$verbose" && \
Xecho '	defining' size_t to be 'unsigned'
XDEFS="$DEFS -Dsize_t=unsigned"
X}
X
Xfi
Xrm -f conftest*
X
Xecho '#include <sys/types.h>' > conftest.c
Xeval "$CPP \$DEFS conftest.c > conftest.out 2>&1"
Xif egrep "off_t" conftest.out >/dev/null 2>&1; then
X  :
Xelse
X  {
Xtest -n "$verbose" && \
Xecho '	defining' NO_OFF_T
XDEFS="$DEFS -DNO_OFF_T=1"
X}
X
Xfi
Xrm -f conftest*
X
Xecho "checking if \`#!' works in shell scripts"
Xcat <<'__EOF__' > conftest.csh
X#!/bin/csh -f
Xsetenv SHELL /bin/csh
X# Avoid tcsh bug 'Bad Hertz Value':
Xsetenv HZ 60
X# Make sure foo doesn't get exported into the environment
X# Astoundingly, some versions of csh don't have unsetenv.
Xif (${?foo}) unsetenv foo >& /dev/null
Xif (${?foo}) unset foo
Xset output="`./conftest.sh`"
Xif ( "$output" == "foo=bar" ) then
X   exit 0
Xendif
Xexit 1
X__EOF__
Xcat <<'__EOF__' > conftest.sh
X#!/bin/sh
Xset foo=bar
Xecho "$*"
X__EOF__
Xchmod 777 conftest.csh conftest.sh
X(csh -f ./conftest.csh) 2> /dev/null
Xif test $? = 0 ; then
X   :; SEDCMD="1d"
Xelse
X   :; SEDCMD=""
Xfi
Xrm -f conftest.csh conftest.sh
X
Xif test -z "$prefix"
Xthen
X  echo checking for gzip to derive installation directory prefix
X  IFS="${IFS= 	}"; saveifs="$IFS"; IFS="$IFS:"
X  for dir in $PATH; do
X    test -z "$dir" && dir=.
X    if test $dir != . && test -f $dir/gzip; then
X      # Not all systems have dirname.
X      prefix=`echo $dir|sed 's%/[^/][^/]*$%%'`
X      break
X    fi
X  done
X  IFS="$saveifs"
X  echo "	chose installation directory prefix ${prefix}"
Xfi
X
Xif test -n "$prefix"; then
X  test -z "$exec_prefix" && exec_prefix='${prefix}'
X  prsub="s%^prefix\\([ 	]*\\)=\\([ 	]*\\).*$%prefix\\1=\\2$prefix%"
Xfi
Xif test -n "$exec_prefix"; then
X  prsub="$prsub
Xs%^exec_prefix\\([ 	]*\\)=\\([ 	]*\\).*$%\
Xexec_prefix\\1=\\2$exec_prefix%"
Xfi
Xcat >conftest.def <<EOF
X$DEFS
XEOF
Xescape_ampersand_and_backslash='s%[&\\]%\\&%g'
XDEFS=`sed "$escape_ampersand_and_backslash" <conftest.def`
Xrm -f conftest.def
X
Xtrap 'rm -f config.status; exit 1' 1 3 15
Xecho creating config.status
Xrm -f config.status
Xcat > config.status <<EOF
X#!/bin/sh
X# Generated automatically by configure.
X# Run this file to recreate the current configuration.
X# This directory was configured as follows,
X# on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
X#
X# $0 $*
X
Xfor arg
Xdo
X  case "\$arg" in
X    -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
X    exec /bin/sh $0 $* ;;
X    *) echo "Usage: config.status --recheck" 2>&1; exit 1 ;;
X  esac
Xdone
X
Xtrap 'rm -f Makefile; exit 1' 1 3 15
XCC='$CC'
XINSTALL='$INSTALL'
XINSTALL_PROGRAM='$INSTALL_PROGRAM'
XINSTALL_DATA='$INSTALL_DATA'
XCPP='$CPP'
XALLOCA='$ALLOCA'
XCFLAGS='$CFLAGS'
XOBJA='$OBJA'
XSEDCMD='$SEDCMD'
XLIBS='$LIBS'
Xsrcdir='$srcdir'
XDEFS='$DEFS'
Xprefix='$prefix'
Xexec_prefix='$exec_prefix'
Xprsub='$prsub'
XEOF
Xcat >> config.status <<\EOF
X
Xtop_srcdir=$srcdir
X
X# Allow make-time overrides of the generated file list.
Xtest -n "$gen_files" || gen_files="Makefile"
X
Xfor file in .. $gen_files; do if [ "x$file" != "x.." ]; then
X  srcdir=$top_srcdir
X  # Remove last slash and all that follows it.  Not all systems have dirname.
X  dir=`echo $file|sed 's%/[^/][^/]*$%%'`
X  if test "$dir" != "$file"; then
X    test "$top_srcdir" != . && srcdir=$top_srcdir/$dir
X    test ! -d $dir && mkdir $dir
X  fi
X  echo creating $file
X  rm -f $file
X  echo "# Generated automatically from `echo $file|sed 's|.*/||'`.in by configure." > $file
X  sed -e "
X$prsub
Xs%@CC@%$CC%g
Xs%@INSTALL@%$INSTALL%g
Xs%@INSTALL_PROGRAM@%$INSTALL_PROGRAM%g
Xs%@INSTALL_DATA@%$INSTALL_DATA%g
Xs%@CPP@%$CPP%g
Xs%@ALLOCA@%$ALLOCA%g
Xs%@CFLAGS@%$CFLAGS%g
Xs%@OBJA@%$OBJA%g
Xs%@SEDCMD@%$SEDCMD%g
Xs%@LIBS@%$LIBS%g
Xs%@srcdir@%$srcdir%g
Xs%@DEFS@%$DEFS%
X" $top_srcdir/${file}.in >> $file
Xfi; done
X
Xexit 0
XEOF
Xchmod +x config.status
Xtest -n "$no_create" || ./config.status
X
END_OF_FILE
if test 23427 -ne `wc -c <'gzip-1.2.2/configure'`; then
    echo shar: \"'gzip-1.2.2/configure'\" unpacked with wrong size!
fi
chmod +x 'gzip-1.2.2/configure'
# end of 'gzip-1.2.2/configure'
fi
if test -f 'gzip-1.2.2/COPYING' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/COPYING'\"
else
echo shar: Extracting \"'gzip-1.2.2/COPYING'\" \(17982 characters\)
sed "s/^X//" >'gzip-1.2.2/COPYING' <<'END_OF_FILE'
X		    GNU GENERAL PUBLIC LICENSE
X		       Version 2, June 1991
X
X Copyright (C) 1989, 1991 Free Software Foundation, Inc.
X                          675 Mass Ave, Cambridge, MA 02139, USA
X Everyone is permitted to copy and distribute verbatim copies
X of this license document, but changing it is not allowed.
X
X			    Preamble
X
X  The licenses for most software are designed to take away your
Xfreedom to share and change it.  By contrast, the GNU General Public
XLicense is intended to guarantee your freedom to share and change free
Xsoftware--to make sure the software is free for all its users.  This
XGeneral Public License applies to most of the Free Software
XFoundation's software and to any other program whose authors commit to
Xusing it.  (Some other Free Software Foundation software is covered by
Xthe GNU Library General Public License instead.)  You can apply it to
Xyour programs, too.
X
X  When we speak of free software, we are referring to freedom, not
Xprice.  Our General Public Licenses are designed to make sure that you
Xhave the freedom to distribute copies of free software (and charge for
Xthis service if you wish), that you receive source code or can get it
Xif you want it, that you can change the software or use pieces of it
Xin new free programs; and that you know you can do these things.
X
X  To protect your rights, we need to make restrictions that forbid
Xanyone to deny you these rights or to ask you to surrender the rights.
XThese restrictions translate to certain responsibilities for you if you
Xdistribute copies of the software, or if you modify it.
X
X  For example, if you distribute copies of such a program, whether
Xgratis or for a fee, you must give the recipients all the rights that
Xyou have.  You must make sure that they, too, receive or can get the
Xsource code.  And you must show them these terms so they know their
Xrights.
X
X  We protect your rights with two steps: (1) copyright the software, and
X(2) offer you this license which gives you legal permission to copy,
Xdistribute and/or modify the software.
X
X  Also, for each author's protection and ours, we want to make certain
Xthat everyone understands that there is no warranty for this free
Xsoftware.  If the software is modified by someone else and passed on, we
Xwant its recipients to know that what they have is not the original, so
Xthat any problems introduced by others will not reflect on the original
Xauthors' reputations.
X
X  Finally, any free program is threatened constantly by software
Xpatents.  We wish to avoid the danger that redistributors of a free
Xprogram will individually obtain patent licenses, in effect making the
Xprogram proprietary.  To prevent this, we have made it clear that any
Xpatent must be licensed for everyone's free use or not licensed at all.
X
X  The precise terms and conditions for copying, distribution and
Xmodification follow.
X
X		    GNU GENERAL PUBLIC LICENSE
X   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
X
X  0. This License applies to any program or other work which contains
Xa notice placed by the copyright holder saying it may be distributed
Xunder the terms of this General Public License.  The "Program", below,
Xrefers to any such program or work, and a "work based on the Program"
Xmeans either the Program or any derivative work under copyright law:
Xthat is to say, a work containing the Program or a portion of it,
Xeither verbatim or with modifications and/or translated into another
Xlanguage.  (Hereinafter, translation is included without limitation in
Xthe term "modification".)  Each licensee is addressed as "you".
X
XActivities other than copying, distribution and modification are not
Xcovered by this License; they are outside its scope.  The act of
Xrunning the Program is not restricted, and the output from the Program
Xis covered only if its contents constitute a work based on the
XProgram (independent of having been made by running the Program).
XWhether that is true depends on what the Program does.
X
X  1. You may copy and distribute verbatim copies of the Program's
Xsource code as you receive it, in any medium, provided that you
Xconspicuously and appropriately publish on each copy an appropriate
Xcopyright notice and disclaimer of warranty; keep intact all the
Xnotices that refer to this License and to the absence of any warranty;
Xand give any other recipients of the Program a copy of this License
Xalong with the Program.
X
XYou may charge a fee for the physical act of transferring a copy, and
Xyou may at your option offer warranty protection in exchange for a fee.
X
X  2. You may modify your copy or copies of the Program or any portion
Xof it, thus forming a work based on the Program, and copy and
Xdistribute such modifications or work under the terms of Section 1
Xabove, provided that you also meet all of these conditions:
X
X    a) You must cause the modified files to carry prominent notices
X    stating that you changed the files and the date of any change.
X
X    b) You must cause any work that you distribute or publish, that in
X    whole or in part contains or is derived from the Program or any
X    part thereof, to be licensed as a whole at no charge to all third
X    parties under the terms of this License.
X
X    c) If the modified program normally reads commands interactively
X    when run, you must cause it, when started running for such
X    interactive use in the most ordinary way, to print or display an
X    announcement including an appropriate copyright notice and a
X    notice that there is no warranty (or else, saying that you provide
X    a warranty) and that users may redistribute the program under
X    these conditions, and telling the user how to view a copy of this
X    License.  (Exception: if the Program itself is interactive but
X    does not normally print such an announcement, your work based on
X    the Program is not required to print an announcement.)
X
XThese requirements apply to the modified work as a whole.  If
Xidentifiable sections of that work are not derived from the Program,
Xand can be reasonably considered independent and separate works in
Xthemselves, then this License, and its terms, do not apply to those
Xsections when you distribute them as separate works.  But when you
Xdistribute the same sections as part of a whole which is a work based
Xon the Program, the distribution of the whole must be on the terms of
Xthis License, whose permissions for other licensees extend to the
Xentire whole, and thus to each and every part regardless of who wrote it.
X
XThus, it is not the intent of this section to claim rights or contest
Xyour rights to work written entirely by you; rather, the intent is to
Xexercise the right to control the distribution of derivative or
Xcollective works based on the Program.
X
XIn addition, mere aggregation of another work not based on the Program
Xwith the Program (or with a work based on the Program) on a volume of
Xa storage or distribution medium does not bring the other work under
Xthe scope of this License.
X
X  3. You may copy and distribute the Program (or a work based on it,
Xunder Section 2) in object code or executable form under the terms of
XSections 1 and 2 above provided that you also do one of the following:
X
X    a) Accompany it with the complete corresponding machine-readable
X    source code, which must be distributed under the terms of Sections
X    1 and 2 above on a medium customarily used for software interchange; or,
X
X    b) Accompany it with a written offer, valid for at least three
X    years, to give any third party, for a charge no more than your
X    cost of physically performing source distribution, a complete
X    machine-readable copy of the corresponding source code, to be
X    distributed under the terms of Sections 1 and 2 above on a medium
X    customarily used for software interchange; or,
X
X    c) Accompany it with the information you received as to the offer
X    to distribute corresponding source code.  (This alternative is
X    allowed only for noncommercial distribution and only if you
X    received the program in object code or executable form with such
X    an offer, in accord with Subsection b above.)
X
XThe source code for a work means the preferred form of the work for
Xmaking modifications to it.  For an executable work, complete source
Xcode means all the source code for all modules it contains, plus any
Xassociated interface definition files, plus the scripts used to
Xcontrol compilation and installation of the executable.  However, as a
Xspecial exception, the source code distributed need not include
Xanything that is normally distributed (in either source or binary
Xform) with the major components (compiler, kernel, and so on) of the
Xoperating system on which the executable runs, unless that component
Xitself accompanies the executable.
X
XIf distribution of executable or object code is made by offering
Xaccess to copy from a designated place, then offering equivalent
Xaccess to copy the source code from the same place counts as
Xdistribution of the source code, even though third parties are not
Xcompelled to copy the source along with the object code.
X
X  4. You may not copy, modify, sublicense, or distribute the Program
Xexcept as expressly provided under this License.  Any attempt
Xotherwise to copy, modify, sublicense or distribute the Program is
Xvoid, and will automatically terminate your rights under this License.
XHowever, parties who have received copies, or rights, from you under
Xthis License will not have their licenses terminated so long as such
Xparties remain in full compliance.
X
X  5. You are not required to accept this License, since you have not
Xsigned it.  However, nothing else grants you permission to modify or
Xdistribute the Program or its derivative works.  These actions are
Xprohibited by law if you do not accept this License.  Therefore, by
Xmodifying or distributing the Program (or any work based on the
XProgram), you indicate your acceptance of this License to do so, and
Xall its terms and conditions for copying, distributing or modifying
Xthe Program or works based on it.
X
X  6. Each time you redistribute the Program (or any work based on the
XProgram), the recipient automatically receives a license from the
Xoriginal licensor to copy, distribute or modify the Program subject to
Xthese terms and conditions.  You may not impose any further
Xrestrictions on the recipients' exercise of the rights granted herein.
XYou are not responsible for enforcing compliance by third parties to
Xthis License.
X
X  7. If, as a consequence of a court judgment or allegation of patent
Xinfringement or for any other reason (not limited to patent issues),
Xconditions are imposed on you (whether by court order, agreement or
Xotherwise) that contradict the conditions of this License, they do not
Xexcuse you from the conditions of this License.  If you cannot
Xdistribute so as to satisfy simultaneously your obligations under this
XLicense and any other pertinent obligations, then as a consequence you
Xmay not distribute the Program at all.  For example, if a patent
Xlicense would not permit royalty-free redistribution of the Program by
Xall those who receive copies directly or indirectly through you, then
Xthe only way you could satisfy both it and this License would be to
Xrefrain entirely from distribution of the Program.
X
XIf any portion of this section is held invalid or unenforceable under
Xany particular circumstance, the balance of the section is intended to
Xapply and the section as a whole is intended to apply in other
Xcircumstances.
X
XIt is not the purpose of this section to induce you to infringe any
Xpatents or other property right claims or to contest validity of any
Xsuch claims; this section has the sole purpose of protecting the
Xintegrity of the free software distribution system, which is
Ximplemented by public license practices.  Many people have made
Xgenerous contributions to the wide range of software distributed
Xthrough that system in reliance on consistent application of that
Xsystem; it is up to the author/donor to decide if he or she is willing
Xto distribute software through any other system and a licensee cannot
Ximpose that choice.
X
XThis section is intended to make thoroughly clear what is believed to
Xbe a consequence of the rest of this License.
X
X  8. If the distribution and/or use of the Program is restricted in
Xcertain countries either by patents or by copyrighted interfaces, the
Xoriginal copyright holder who places the Program under this License
Xmay add an explicit geographical distribution limitation excluding
Xthose countries, so that distribution is permitted only in or among
Xcountries not thus excluded.  In such case, this License incorporates
Xthe limitation as if written in the body of this License.
X
X  9. The Free Software Foundation may publish revised and/or new versions
Xof the General Public License from time to time.  Such new versions will
Xbe similar in spirit to the present version, but may differ in detail to
Xaddress new problems or concerns.
X
XEach version is given a distinguishing version number.  If the Program
Xspecifies a version number of this License which applies to it and "any
Xlater version", you have the option of following the terms and conditions
Xeither of that version or of any later version published by the Free
XSoftware Foundation.  If the Program does not specify a version number of
Xthis License, you may choose any version ever published by the Free Software
XFoundation.
X
X  10. If you wish to incorporate parts of the Program into other free
Xprograms whose distribution conditions are different, write to the author
Xto ask for permission.  For software which is copyrighted by the Free
XSoftware Foundation, write to the Free Software Foundation; we sometimes
Xmake exceptions for this.  Our decision will be guided by the two goals
Xof preserving the free status of all derivatives of our free software and
Xof promoting the sharing and reuse of software generally.
X
X			    NO WARRANTY
X
X  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
XFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
XOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
XPROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
XOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
XMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
XTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
XPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
XREPAIR OR CORRECTION.
X
X  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
XWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
XREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
XINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
XOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
XTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
XYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
XPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
XPOSSIBILITY OF SUCH DAMAGES.
X
X		     END OF TERMS AND CONDITIONS
X
X	Appendix: How to Apply These Terms to Your New Programs
X
X  If you develop a new program, and you want it to be of the greatest
Xpossible use to the public, the best way to achieve this is to make it
Xfree software which everyone can redistribute and change under these terms.
X
X  To do so, attach the following notices to the program.  It is safest
Xto attach them to the start of each source file to most effectively
Xconvey the exclusion of warranty; and each file should have at least
Xthe "copyright" line and a pointer to where the full notice is found.
X
X    <one line to give the program's name and a brief idea of what it does.>
X    Copyright (C) 19yy  <name of author>
X
X    This program is free software; you can redistribute it and/or modify
X    it under the terms of the GNU General Public License as published by
X    the Free Software Foundation; either version 2 of the License, or
X    (at your option) any later version.
X
X    This program is distributed in the hope that it will be useful,
X    but WITHOUT ANY WARRANTY; without even the implied warranty of
X    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X    GNU General Public License for more details.
X
X    You should have received a copy of the GNU General Public License
X    along with this program; if not, write to the Free Software
X    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
XAlso add information on how to contact you by electronic and paper mail.
X
XIf the program is interactive, make it output a short notice like this
Xwhen it starts in an interactive mode:
X
X    Gnomovision version 69, Copyright (C) 19yy name of author
X    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
X    This is free software, and you are welcome to redistribute it
X    under certain conditions; type `show c' for details.
X
XThe hypothetical commands `show w' and `show c' should show the appropriate
Xparts of the General Public License.  Of course, the commands you use may
Xbe called something other than `show w' and `show c'; they could even be
Xmouse-clicks or menu items--whatever suits your program.
X
XYou should also get your employer (if you work as a programmer) or your
Xschool, if any, to sign a "copyright disclaimer" for the program, if
Xnecessary.  Here is a sample; alter the names:
X
X  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
X  `Gnomovision' (which makes passes at compilers) written by James Hacker.
X
X  <signature of Ty Coon>, 1 April 1989
X  Ty Coon, President of Vice
X
XThis General Public License does not permit incorporating your program into
Xproprietary programs.  If your program is a subroutine library, you may
Xconsider it more useful to permit linking proprietary applications with the
Xlibrary.  If this is what you want to do, use the GNU Library General
XPublic License instead of this License.
END_OF_FILE
if test 17982 -ne `wc -c <'gzip-1.2.2/COPYING'`; then
    echo shar: \"'gzip-1.2.2/COPYING'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/COPYING'
fi
if test -f 'gzip-1.2.2/TODO' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/TODO'\"
else
echo shar: Extracting \"'gzip-1.2.2/TODO'\" \(2412 characters\)
sed "s/^X//" >'gzip-1.2.2/TODO' <<'END_OF_FILE'
XTODO file for gzip.
X
XSome of the planned features include:
X
X- Structure the sources so that the compression and decompression code
X  form a library usable by any program, and write both gzip and zip on
X  top of this library. This would ideally be a reentrant (thread safe)
X  library, but this would degrade performance. In the meantime, you can
X  look at the sample program zread.c.
X
X- Make it convenient to define alternative user interfaces (in
X  particular for windowing environments).
X
X- Support in-memory compression for arbitrarily large amounts of data
X  (zip currently supports in-memory compression only for a single buffer.)
X
X- Map files in memory when possible, this is generally much faster
X  than read/write. (zip currently maps entire files at once, this
X  should be done in chunks to reduce memory usage.)
X
X- Add a super-fast compression method, suitable for implementing
X  file systems with transparent compression. One problem is that the
X  best candidate (lzrw1) is patented twice (Waterworth 4,701,745
X  and Gibson & Graybill 5,049,881). The lzrw series of algorithms
X  are available by ftp in ftp.adelaide.edu.au:/pub/compression/lzrw*.
X
X- Add a super-tight (but slow) compression method, suitable for long
X  term archives.  One problem is that the best versions of arithmetic
X  coding are patented (4,286,256 4,295,125 4,463,342 4,467,317
X  4,633,490 4,652,856 4,891,643 4,905,297 4,935,882 4,973,961
X  5,023,611 5,025,258).
X
X  Note: I will introduce new compression methods only if they are
X  significantly better in either speed or compression ratio than the
X  existing method(s). So the total number of different methods should
X  reasonably not exceed 3. (The current 9 compression levels are just
X  tuning parameters for a single method, deflation.)
X
X- Add optional error correction. One problem is that the current version
X  of ecc cannot recover from inserted or missing bytes. It would be
X  nice to recover from the most common error (transfer of a binary
X  file in ascii mode).
X
X- Add a block size (-b) option to improve error recovery in case of
X  failure of a complete sector. Each block could be extracted
X  independently, but this reduces the compression ratio.
X
X- Use a larger window size to deal with some large redundant files that
X  'compress' currently handles better than gzip.
X
X- Implement the -e (encrypt) option.
X   
XSend comments to Jean-loup Gailly <jloup@chorus.fr>.
END_OF_FILE
if test 2412 -ne `wc -c <'gzip-1.2.2/TODO'`; then
    echo shar: \"'gzip-1.2.2/TODO'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/TODO'
fi
if test -f 'gzip-1.2.2/THANKS' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/THANKS'\"
else
echo shar: Extracting \"'gzip-1.2.2/THANKS'\" \(10638 characters\)
sed "s/^X//" >'gzip-1.2.2/THANKS' <<'END_OF_FILE'
Xgzip was written by Jean-loup Gailly <jloup@chorus.fr>, with portions
Xwritten by Mark Adler (inflate.c), Peter Jannesen (unlzw.c) and
XHaruhiko Okumura (unlzh.c). The zip deflate format was defined by Phil Katz.
XThanks to those who reported problems and suggested various
Ximprovements.  Here is a partial list of them:
X
XJay Adams               jka@ece.cmu.edu
XMark Adler              madler@cco.caltech.edu
XEdwin Allum             edwin@csri.toronto.edu
XJoseph Arceneaux	jla@gnu.ai.mit.edu
XTim Auckland            tda10@cus.cam.ac.uk
XKen-ichiro Aoki         aoki@madonna.physics.ucla.edu
XDavid Ascher            da@marlowe.cog.brown.edu
XEric Backus             ericb@lsid.hp.com
XBecky A. Badgett        badgett@cs.utexas.edu
XDave Barber             dbarber@apocalypse.bbn.com
XRene Beaulieu           reneb@distri.hydro.qc.ca
XNeal Becker             neal@ctd.comsat.com 
XDieter Becker           becker@med-in.uni-sb.de
XNelson H. F. Beebe      beebe@geronimo.math.utah.edu
XJeff Beadles		jeff@onion.rain.com
XDavid J. N. Begley      dbegley@st.nepean.uws.edu.au
XJim Bernard             jbernard@iola.mines.colorado.edu
XKarl Berry              karl@cs.umb.edu
XJames W. Birdsall       jwbirdsa@picarefy.picarefy.com
XWayne E. Bouchard       web@paladine.hacks.arizona.edu
XMarc Boucher            marc@cam.org
XOla Brahammar           pt90ob@pt.hk-r.se
XDave Brennan            brennan@hal.com
XAlan Brown              dogbowl@dogbox.acme.gen.nz
XRodney Brown            rdb@mel.cocam.oz.au
XBruce                   bde@runx.oz.au
XBill Bumgarner          bbum@stone.com
XLeila Burrell-Davis     leilabd@syma.sussex.ac.uk
XRoger Butenuth          butenuth@ira.uka.de
XBud Carlson             bud@isle.pegasus.com
XLim Fung Chai           fclim@i1sin.daq.semi.harris.com
XWes Chalfant            wes@kofax.com
XAndrew A. Chernov       ache@astral.msk.su
XPaul Close              pdc@lunch.wpd.sgi.com
XKevin Cosgrove          kevinc@tekig6.pen.tek.com
XStephen J Cowley        s.j.cowley@amtp.cam.ac.uk
XFrank Crawford          frank@photon.ansto.gov.au
XJames R. Crawford       qralston@cislabs.pitt.edu
XLawrence Crowl          crowl@research.cs.orst.edu 
XKlaus Dahlenburg        kdburg@incoahe.hanse.de
XWilliam E Davidsen      davidsen@ariel.crd.ge.com
XJohn M. DeDourek        dedourek@aixive2.cs.unb.ca
XJeff Deifik             jdeifik@isi.edu
XVince DeMarco           vince@whatnxt.cuc.ab.ca
XMichael De La Rue       p91152@cplab.physics.edinburgh.ac.uk
XJohn DeRoo              deroo@grout.adv.shr.dec.com
XStefano Diomedi         sd@teculx.tecsiel.it
XLawrence R. Dodd        dodd@roebling.poly.edu
XMatthew Donadio         donadio@mxd120.rh.psu.edu
XAndy Dougherty          andy@crystal.phys.lafayette.edu
XJohn Eaton              jwe@che.utexas.edu
XBrian Edmonds           edmonds@edmonds.home.cs.ubc.ca
XPaul Eggert             eggert@twinsun.com
XEnami                   enami@sys.ptg.sony.co.jp
XKristoffer Eriksson     ske@pkmab.se
XDaniel Eriksson         m91der@bellatrix.tdb.uu.se
XRik Faith               faith@cs.unc.edu
XLarry Fahnoe            fahnoe@c1mpls.mn.org 
XCristian Ferretti       cfs@poincare.mat.puc.cl
XKarl-Jose Filler        pla_jfi@pki-nbg.philips.de
XPer Foreby              perf@efd.lth.se
XAlexander Fraser        alex@cs.umb.edu
XNoah Friedman		friedman@gnu.ai.mit.edu
XBob Friesenhahn         bfriesen@iphase.com
XAndy Fyfe               andy@scp.caltech.edu
XGeoff                   geoff@frs.faxon.com
XKaveh R. Ghazi          ghazi@staccato.rutgers.edu
XTorbjorn Granlund       tege@sics.se
XCarl Greco              cgreco@parrot.creighton.edu
XBruno Haible            haible@ma2s2.mathematik.uni-karlsruhe.de
XJunio Hamano            junio@shadow.twinsun.com
XHarald Hanche-Olsen     hanche@ams.sunysb.edu
XDarrel R. Hankerson     hankedr@mail.auburn.edu
XLars Hecking            st000002@hrz1.hrz.th-darmstadt.de
XRuediger Helsch         ruediger@ramz.ing.tu-bs.de
XMark C. Henderson       mch@sqwest.wimsey.bc.ca
XKarl Heuer              karl@kelp.boston.ma.us
XJarkko Hietaniemi       jhi@dol-guldur.hut.fi
XThomas Hiller           hiller@fzi.de
XEiji Hirai              hirai@cc.swarthmore.edu
XKjetil Torgrim Homme    kjetilho@ifi.uio.no
XJim Howard              jim_howard@mentorg.com
XPreston Hunt            gt5708a@prism.gatech.edu
XShane C Hutchins        sch@nymph.msel.unh.edu
XHutch			hutchinson@wrair-emh1.army.mil
XLester Ingber		ingber@alumni.caltech.edu
XKen Ishii               ishii@sni-usa.com
XPer Steinar Iversen     iversen@vsfys1.fi.uib.no
XMichal Jaegermann       ntomczak@vm.ucs.ualberta.ca
XBrian Jones             brianj@skat.usc.edu
XDenny de Jonge          witaddj@dutrex.tudelft.nl
XArne H. Juul            arnej@lise.unit.no
XDana Jacobsen           jacobsd@solar.cor2.epa.gov
XPeter Jannesen		peter@ncs.nl
XTom Judson              judson@scf.usc.edu
XHenry G. Juengst        juengst@saph2.physik.uni-bonn.de
XSarantos Kapidakis      sarantos%manteion@ics.forth.gr
XAmir J. Katz            amir@matis.ingr.com
XSteve Kelem             kelem@castor.xilinx.com
XRandy Kirchhof          rkk@posms.aus.tx.us
XNed Kittlitz            kittlitz@seagoon.sw.stratus.com
XSakai Kiyotaka          ksakai@mtl.t.u-tokyo.ac.jp
XPhilip C Kizer          pckizer@gonzo.tamu.edu
XPete Klammer            pklammer@ouray.denver.colorado.edu
XFritz Kleemann          kleemann@informatik.uni-wuerzburg.dbp.de
XTom Kloos               tk@sequent.com
XCarsten Koch            carsten.koch@icem.de
XWinfried Koenig         win@in.rhein-main.de
XSteph Konigsdorfer      s.konigsdorfer@frmy.bull.fr
XLeif Kornstaedt         leif@rumtifsl.ruessel.sub.org
XMichael D. Lawler       mdlawler@bsu-cs.bsu.edu
XKevin Layer             layer@franz.com
XHoward D. Leadmon       howardl@wb3ffv.ampr.org
XAlexander Lehmann       alex@hal.rhein-main.de
XSimon Leinen            simon@lia.di.epfl.ch
XBurt Leland             burt@molecular.com
XHugues Leroy            hugues.leroy@irisa.fr 
XCharles Levert          charles@aramis.comm.polymtl.ca
XRichard Levitte         levitte@e.kth.se
XTorbj|rn Lindh          toobii@elixir.e.kth.se
XDavid R. Linn		drl@vuse.vanderbilt.edu
XAntonio Lioy            cat@athena.polito.it
XJamie Lokier            u90jl@ecs.oxford.ac.uk
XDavid J. MacKenzie	djm@eng.umd.edu
XJohn R MacMillan        john@chance.gts.org
XRon Male                male@eso.mc.xerox.com
XDon R. Maszle           maze@bea.lbl.gov
XSteeve McCauley         steeve@pooh.geophys.mcgill.ca
XTom McConnell           tmcconne@sedona.intel.com
XTod McQuillin           mcquill@ccit05.duq.edu
XTye McQueen             tye@spillman.com
XBernd Melchers          melchers@chemie.fu-berlin.de
XJason Merrill           jason@jarthur.claremont.edu
XDean S. Messing         deanm@medulla.labs.tek.com
XM. Mesturino            mesturino@cselt.stet.it
XLuke Mewburn            zak@rmit.edu.au
XJim Meyering		meyering@cs.utexas.edu 
XFrederic Miserey        none.fred@applelink.apple.com
XMarcel J.E. Mol         marcel@duteca.et.tudelft.nl
XSoren Juul Moller       sjm@dde.dk
XChris Moore             moore@src.bae.co.uk
XHelmut Muelner          hmuelner@fiicmds04.tu-graz.ac.at
XUrban D Mueller         umueller@amiga.physik.unizh.ch
XTimothy Murphy          tim@maths.tcd.ie
XGreg Naber              greg@squally.halcyon.com
XJay Nayegandhi          jayng@bbiv02.enet.dec.com
XKarl L. Noell           noell@informatik.fh-wiesbaden.dbp.de
XArthur David Olson      ado@elsie.nci.nih.gov
XPiet van Oostrum        piet@cs.ruu.nl
XRafael R. Pappalardo    rafapa@obelix.cica.es 
XYves Perrenoud          pyves@nuga.alphanet.ch
XHal Peterson            hrp@pecan.cray.com
XPascal Petit            petit@cadillac.ibp.fr
XBruno Pillard		bp@chorus.fr
XFranc,ois Pinard        pinard@iro.umontreal.ca
XJay Pinkos              pinkos@butyng.bu.edu
XThomas Plass            thomas@cogsci.ed.ac.uk
XMike Polo               mikep@cfsmo.honeywell.com
XFrancesco Potorti       pot@fly.cnuce.cnr.it
XDavid Purves            purves@apogee.com
XAndreas Raab            ar@nvmr.robin.de
XEric S. Raymond         esr@snark.thyrsus.com
XKlaus Reimann           kr@cip.physik.uni-stuttgart.de
XMichael Rendell         michael@mercury.cs.mun.ca
XHal Render              render@massive.uccs.edu
XJulian F. Reschke       julian@math.uni-muenster.de
XPhil Richards           Phil.Richards@prg.oxford.ac.uk
XRoland B Roberts        roberts@nsrl31.nsrl.rochester.edu
XArnold Robbins          arnold@cc.gatech.edu
XKevin Rodgers           kevin@rolling-stone.den.mmc.com
XKai Uwe Rommel          rommel@informatik.tu-muenchen.de
XPaul Rubin              phr@america.telebit.com
XWolfgang Rupprecht      wolfgang@wsrcc.com
XJonathan Ryshpan        jon@amito.hitachi.com
XPaul A Sand             pas@unh.edu
XTony Sanders            sanders@bsdi.com
XMike Sangrey            mike@sojurn.lns.pa.us
XNiimi Satoshi           a01309@cfi.waseda.ac.jp
XMarc Schaefer           sysadm@alphanet.ch
XAndreas Schwab          schwab@lamothe.informatik.uni-dortmund.de
XEric Schenk             schenk@cs.toronto.edu
XSunando Sen             sens@fasecon.econ.nyu.edu
XRick Sladkey            jrs@world.std.com
XDaniel L Smith          dls@autodesk.com
XFred Smith              fredex%fcshome@merk.merk.com
XStephen Soliday         soliday@ncat.edu
XPaul Southworth         pauls@css.itd.umich.edu
XRob Spencer             robbie@winkle.bhpese.oz.au
XRichard Stallman	rms@gnu.ai.mit.edu
XCarsten Steger          carsten.steger@informatik.tu-muenchen.de
XDavid Sundstrom         sunds@anon.asic.sc.ti.com
XEd Sznyter              ews@babel.babel.com
XHideaki Tanabe          arctanx@iyeyasu.ynl.t.u-tokyo.ac.jp
XAndrew Telford          ajt@peregrin.resmel.bhp.com.au
XGlenn E. Thobe          thobe@getunx.info.com
XKei Thomsen             kt@keihh.hanse.de
XKarsten Thygesen        karthy@dannug.dk
XMark Towfiq             towfiq@microdyne.com
XJeff Treece             treece@sabbagh.com
XOliver Trepte           oliver@ikaros.fysik4.kth.se
XStephane Tsacas         slt@is21.isoft.fr
XStephen Tweedie         sct@dcs.ed.ac.uk
XSotiris Vassilopoulos   vassilopoulos@virginia.edu
XPedro A. M. Vazquez     vazquez@iqm.unicamp.br
XArjan de Vet            devet@win.tue.nl
XVadim V. Vlasov         vvlasov@inucres.msk.su
XEduard Vopicka          eduard.vopicka@vse.cs 
XTheo Vosse              vosse@ruls41.leidenuniv.nl
XMarcel Waldvogel        marcel@nice.usergroup.ethz.ch
XStephen J. Walick       steve@nshore.org
XGray Watson		gray@antaire.com
XScott Weikart           scott@igc.apc.org
XIvo Welch               iwelch@agsm.ucla.edu
XJochen Wiedmann         zrawi01@zmcipdec1.zdv.uni-tuebingen.de
XGijsb. Wiesenekker      wiesenecker@sara.nl 
XWietze van Winden       wietze@swi.psy.uva.nl
XLarry W. Virden         lwv26@cas.org 
XBill Wohler             wohler@sap-ag.de
XJamie Zawinski          jwz@lucid.com
XChristos Zoulas         christos@deshaw.com
END_OF_FILE
if test 10638 -ne `wc -c <'gzip-1.2.2/THANKS'`; then
    echo shar: \"'gzip-1.2.2/THANKS'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/THANKS'
fi
if test -f 'gzip-1.2.2/ChangeLog' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/ChangeLog'\"
else
echo shar: Extracting \"'gzip-1.2.2/ChangeLog'\" \(23171 characters\)
sed "s/^X//" >'gzip-1.2.2/ChangeLog' <<'END_OF_FILE'
XThu Jun 17 13:47:05 1993  Jean-loup Gailly  (jloup@chorus.fr)
X
X	* version 1.2.2
X	Fix a compilation error in gzip.c on Sun with cc (worked with gcc).
X
X
XWed Jun 16 11:20:27 1993  Jean-loup Gailly  (jloup@chorus.fr)
X
X	* version 1.2.1
X	 Let zmore act as more if the data is not gzipped.
X         By default, display output name only when name was actually truncated.
X	 Use absolute path names in gzexe'd programs for better security.
X	 In gzexe, use chmod 700 instead of 755 and don't gzexe tail,rm,etc...
X	 Update vms/gzip.hlp.
X	 Added a note about the fast options (-1 to -3) in algorithm.doc.
X	 Improved man page for zgrep.
X	 Minor fixes to gzip.texi.
X	 Always set LC_ALL and LANG in configure (for tr on HPUX)
X
XMon Jun 14 10:03:24 1993  Jean-loup Gailly  (jloup@chorus.fr)
X
X	* version 1.2
X	 Added the --list option to display the file characteristics.
X         Added the --no-name option: do not save or restore original filename
X           Save the original name by default.
X         Allow gunzip --suffix "" to attempt decompression on any file
X           regardless of its extension if an original name is present.
X	 Add support for the SCO compress -H format.
X         gzip --fast now compresses faster (speed close to that of compress)
X           with degraded compression ratio (but still better than compress).
X	   Default level changed to -6 (acts exactly as previous level -5) to
X           be a better indication of its placement in the speed/ratio range.
X	 Use smart name truncation: 123456789012.c -> 123456789.c.gz
X	   instead of 12345678901.gz
X	 With --force, let zcat pass non gzip'ed data unchanged (zcat == cat)
X	 Added the zgrep shell script.
X	 Made sub.c useful for 16 bit sound, 24 bit images, etc..
X	 Supress warnings about suffix for gunzip -r, except with --verbose.
X	 Moved the sample programs to a subdirectory sample.
X	 On MSDOS, use .gz extension when possible (files without extension)
X	 Added a "Special targets" section in INSTALL.
X	 Use stty -g correctly in zmore.in.
X	 Use cheaper test for gzipness in zforce.in.
X	 Remove space before $ in match.S (no longer accepted by gas 2.x)
X	 For the shell scripts, do not assume that gzip is in the path.
X	 Fix syntax error and define lnk$library in vms/Makefile.mms
X	 REGSIGTYPE is void on the Amiga.
X	 Do not write empty line when decompressing stdin with --verbose.
X	 Fix the 1.1.2 fix for VMS (bug in get_suffix)
X	 Added warning in README about compiler bug on Solaris 2.1 for x86.
X	 Added warning about 'rehash' in INSTALL.
X	 Removed default value of read_buf in bits.c (supermax doesn't like).
X	 In tailor.h, added support for Borland C and Zortech C on OS/2.
X	 Added warning in gzexe about Ultrix buggy sh (use /bin/sh5 instead).
X	 Added warning in zdiff about AIX buggy sh (use /bin/ksh instead).
X	 In configure.in, do not try the asm code if DEFS contains NO_ASM
X
XFri Jun  4 09:49:33 1993  Jean-loup Gailly  (jloup@chorus.fr)
X
X	* version 1.1.2
X	 Fix serious bug for VMS (-gz not removed when decompressing).
X	 Allow suffix other than .gz in znew.
X	 Do not display compression ratio when decompressing stdin.
X	 In zmore.in, work around brain damaged stty -g (Ultrix).
X	 Display a correct compression ratio for .Z files.
X	 Added .z to .gz renaming script in INTALL.
X	 Allow setting CFLAGS in configure.
X	 Add warning in README about bug in Concentrix cc compiler.
X	 Avoid || in Makefile.in (at least one make doesn't support this).
X	 Disable useless --ascii option for the Amiga.
X	 Add a pointer to the Primos executable in README.
X	 Added description of extra field in algorithm.doc.
X	 Do not redefine NULL in alloca.c.
X	 Added check for unsupported compression methods.
X	 Avoid getopt redeclaration on OSF/1.
X
XTue Jun  1 09:07:15 1993  Jean-loup Gailly  (jloup@chorus.fr)
X
X	* version 1.1.1
X	 Fix serious bug in vms.c (== instead of =).
X	 Added --ascii option.
X	 Add workaround in configure.in for Ultrix (quote eval argument)
X	 Do not use unset in znew (not supported on Ultrix)
X	 Use tar.gz instead of tar.z for the distribution of gzip.
X	 Add missing menu item in gzip.texi.
X	 Use size_t instead of unsigned, add AC_SIZE_T in configure.in.
X
XFri May 28 11:40:01 1993  Jean-loup Gailly  (jloup@chorus.fr)
X
X	* version 1.1
X	 Use .gz suffix by default, add --suffix option.
X	 Let gunzip accept a "_z" suffix (used by one 'compress' on Vax/VMS).
X	 Quit when reading garbage from stdin instead of reporting an error.
X	 Added sub.c and add.c for compression of 8 bit images.
X	 Added makefile for VAX/MMS and support for wildcards on VMS.
X	 Added support for MSC under OS/2.
X	 Added support for Prime/PRIMOS.
X	 Display compression ratio also when decompressing.
X	 Quit after --version (GNU standard)
X	 Use --force to bypass isatty() check.
X	 Accept --silent as synonym for --quiet (see longopts.table)
X	 Accept --to-stdout as synonym for --stdout (see longopts.table)
X	 Accept -H and -? in addition to -h and --help.
X	 Added comparison of zip and gzip in the readme file.
X	 Return an error code in all main compression/decompression functions.
X	 Continue processing other files in case of recoverable error.
X	 Add description of -f in znew.1.
X	 Do not keep uncompressed version for znew -t if .gz already exists.
X	 On Unix, use only st_ino and st_dev in same_file().
X	 Use S_IRUSR and S_IWUSR if they exist.
X	 "test $1 = -d" -> "test x$1 = x-d" in gzexe.
X	 In match.S, use symbol sysV68 to detect the Motorola Delta.
X	 Do not include memory.h with gcc (conflicting declarations on Sun).
X	 Fix more typos.
X	 On VMS, define unlink as delete also for gcc.
X	 In "make check", unset LANG because "wc -c" fails on Kanji.
X	 Renamed shdir as scriptdir.
X	 Use the 68020 code instead of 68000 code on the NeXT.
X	 Documented --uncompress as synonym for --decompress.
X	 Include the standard header files before gzip.h (needed on Bull).
X	 Do not assume that _POSIX_VERSION implies dirent.h present.
X	 Removed gzip-tar.patch since tar 1.11.2 handles gzip directly.
X	 Use less memory when compiled with -DSMALL_MEM (for MSDOS).
X	 Optimized updcrc().
X	 Don't complain if cc -E does not work correctly.
X	 Do not attempt reading 64K bytes on 16 bit Unix systems.
X	 Do not use the variable name 'overhead' which is reserved on Lynx!
X	 One BULL compiler does not like *p++ in inflate.c => *p, p++.
X	 Use casts on free and memcmp to avoid warnings.
X         Remove the "off by more than one minute" time stamp kludge, but
X           document how to avoid saving the time stamp on pipes if desired.
X	 Include crypt.h in inflate.c (one system predefines the CRYPT symbol).
X	 Add links to gunzip and (g)zcat in the default make rule.
X         Create installation directories if they do not exist.
X	 Clarified --prefix option in INSTALL.
X	 Use symbol mc68k in match.S for the DIAB DS90.
X	 Guard against zero length _match.s in configure.in.
X	 In zmore, restore all tty options using stty -g.
X	 Added support for MacOS
X	 Simplified makecrc.c.
X	 Avoid warnings in getopt.c, util.c, unlzw.c.
X	 Use autoconf 1.4, in particular for INSTALL and AC_HAVE_POUNDBANG
X	 Use .so instead of hard links for zcat.1, gunzip.1 and zcmp.1.
X	 Fixed declration of sig_type.
X	 Make consistency check in fcfree.
X	 Added ztouch.
X	 Do not complain if utime fails on a directory (for OS/2).
X
XThu Mar 18 18:56:43 1993  Jean-loup Gailly  (jloup@chorus.fr)
X
X	* version 1.0.7
X	  Allow zmore to read from standard input (like more).
X	  Support the 68000 (Atari ST) in match.S.
X	  Retry partial writes (required on Linux when gzip is suspended in
X	    a pipe).
X	  Allow full pathnames and renamings in gzexe.
X	  Don't let gzexe compress setuid executables or gzip itself.
X	  Added vms/Makefile.gcc for gcc on the Vax.
X	  Give a pointer to Solaris and VMS executables of gzip in README.
X	  Allow installation of binaries and shell scripts in different dirs.
X	  Do not use alloca on the Cray.
X	  Provide strspn and strcspn if string.h does not exist.
X	  Define O_CREAT and O_EXCL from FCREAT and FEXCL if necessary.
X	  Remove gzip.doc in make realclean.
X	  Fixed many typos. (Corrections to my English are welcome.)
X	  Put "make manext=l install" at the correct place in INSTALL.
X	  Fix incorrect examples in INSTALL and give more examples.
X	  Include zdiff.1 for install and uninstall.
X	  Allows complex PAGER variable in zmore (e.g.: PAGER="col -x | more")
X	  Avoid warning on unused indfound in getopt.c.
X	  Cast memset arg to void* (required by some buggy compilers).
X	  Include sys/types.h before dirent.h in acgeneral.m4.
X	  Fix acgeneral.m4 AC_COMPILE_CHECK to avoid warnings.
X	  Don't use alloca.c with gcc. (One NeXT user did not have alloca.h).
X	  Change all error messages according to GNU standards.
X	  Restore time stamp only if off by more than one minute.
X	  Allow installation of zcat as gzcat.
X	  Suppress help message  and send compressed data to the terminal when
X	    gzip is invoked without parameters and without redirection.
X	   (Explicit request from Noah Friedman.)
X	  Add compile option GNU_STANDARD to respect the GNU coding standards:
X	    with -DGNU_STANDARD, behave as gzip even if invoked under the
X	    name gunzip. (Complaints to /dev/null or the FSF, not to me!)
X
XFri Mar 10 13:27:18 1993  Jean-loup Gailly  (jloup@chorus.fr)
X
X	* version 1.0.6
X	  Let gzexe detect executables that are already gzexe'd.
X	  Don't try restoring record format on VMS (the simple 1.0.5 code
X	    worked correctly only on fixed-512 files). Suppress text_mode.
X	  Added asm version for 68000 in amiga/match.a.
X	  Use asm version for Atari TT.
X	  Fix "make clean" in vms/Makefile.vms.
X	  For OS/2, assume HPFS by default, add flag OS2FAT if necessary.
X	  Fixed some bugs in zdiff and define zcmp as a link to zdiff.
X	  Added zdiff.1
X	  Remove configure hack for NeXT; add general fix to autoconf instead
X	  Do not strip a ".z" extension if this results in an empty name.
X	  Avoid array overflow in get_prefix() for extensions > 10 chars.
X	  Accept either q or e to quit zmore.
X	  In zmore, try restoring tty mode in all cases.
X	  Use Motorola style for match.S on the NeXT.
X	  configure.in: unsetenv *hangs* with the Siemens csh...
X	  Update vms/gzip.hlp.
X
XThu Mar 4 14:13:34 1993  Jean-loup Gailly  (jloup@chorus.fr)
X
X	* version 1.0.5
X	  For VMS, restore the file type for variable record format, otherwise
X	    extract in fixed length format (not perfect, but better than
X            forcing all files to be in stream_LF format).
X	  Use "-z" suffix for VMS.
X	  Use only .z, .*-z, .tgz, .taz as valid gzip extensions; update
X	   zforce accordingly.
X	  Allow a version number in input file names for VMS.
X	  Added sample program zread.c.
X	  Fix "make check" for some implementations of /bin/sh.
X	  Don't rely on stat() for filenames with extension > 3 chars
X	    on MSDOS, OS2 and Atari.
X	  Garbage collect files in /tmp created by gzexe.
X	  Quote $opt in znew.
X	  Use TOUCH env variable in znew if it exists.
X	  Better error message for gunzip on empty or truncated file.
X	  Allow prototypes in getopt.h when __STDC__ defined but 0.
X	  Added "make clean" in vms/Makefile.vms.
X	  Removed -g from default CFLAGS (with Noah's permission!)
X	  Avoid too many HAVE_xxx_H for most systems; use common defaults.
X	  Moved default Atari flags into tailor.h for consistency.
X	  Use memzero() to clear the hash table.
X	  Update vms/gzip.hlp to reflect the VMS behavior.
X	  Fix OS_CODE (to fit in a byte).
X	  Add utime.h for the Amiga.
X	  Add gcc support for the Amiga.
X	  Work around incorrect dirent.h for NeXT 2.0.
X	  Added Makefile entry for Coherent.
X
XFri Feb 22 11:20:49 1993  Jean-loup Gailly  (jloup@chorus.fr)
X
X	* version 1.0.4
X	  Added optimized asm version for 68020.
X	  Add support for DJGPP.
X	  Add support for the Atari ST.
X	  Added zforce to rename gzip'ed files with truncated names.
X	  Do not install with name uncompress (some systems rely on the
X	    absence of any check in the old uncompress).
X	  Added missing function (fcfree) in msdos/tailor.c
X	  Let gunzip handle .tgz files, and let gzip skip them.
X	  Added 'stty min 1' in zmore for SysV and fixed trap code.
X	  Suppress .PHONY in Makefile.in, which breaks old makes.
X	  Added documentation about pcat and unpack in INSTALL.
X	  Add cast to getenv for systems without stdlib.h.
X	  Use VAXC instead of VMS to avoid confusion for gcc.
X	  Add -K to znew.1.
X	  Add gzexe.1.
X	  Try preserving file permissions in gzexe.
X	  Added -d option for gzexe.
X	  Guard against spaces in file names in gzexe.
X	  Use CMP env. variable in zcmp.
X	  Return a warning exit status for gzip of file with .z suffix.
X	  Suppress usage of d_ino which is not portable to all systems.
X	  Use #ifdef instead of #if for consistency.
X	  For VMS, use "cc util.c" instead of "cc util" (pb with logical names)
X	  Added utime() for Amiga.
X	  Renamed gzcat.1 as zcat.1.
X	  Include fcntl.h for Amiga (for read and write).
X	  For VMS, add definition of symbols and links in the makefiles.
X	  Give a VMS look to vms/gzip.hlp.
X	  Save the original name only when necessary.
X	  Add a mode parameter for open in read mode (required by VMS).
X	  For VMS, remove the version suffix from the original name.
X	  Accept both / and \ as path separator for MSDOS.
X	  Let gunzip extract stored .zip files correctly.
X	  Added warning about VFC format in vms/gzip.hlp.
X	  In znew, skip a bad file but process the others.
X	  Cleanup tailor.h.
X	  Use GZIP_OPT for VMS to avoid conflict with program name.
X	  Added description of GZIP variable in gzip.texi.
X
XThu Feb 11 17:21:32 1993  Jean-loup Gailly  (jloup@chorus.fr)
X
X	* version 1.0.3
X	  Add -K option for znew to keep old .Z files if smaller.
X	  Add -q option (quiet) to cancel -v in GZIP env variable.
X          For Turbo C, normalize pointers before freeing them.
X          Add more safety checks in add_envopt().
X          Add do_exit() for uniform exit path (always free memory).
X          Reduce MAX_PATH_LEN for MSDOS.
X	  Include sys/types.h before signal.h
X	  Avoid strdup, the NeXT does not have it.
X          Made gzexe safer on systems with filename limitation to 14 chars.
X
XFri Feb  10 09:45:49 1993  Jean-loup Gailly  (jloup@chorus.fr)
X
X	* version 1.0.2
X	  Added env variable GZIP for default options.
X	  Added support for the Amiga.
X	  znew now keeps the old .Z if it is smaller than the .z file.
X	  Added gzexe to compress rarely used executables.
X	  Reduce memory usage when using static allocation (no DYN_ALLOC).
X	  Better separation of warning and error return codes.
X	  Fix unlzw.c to make DYN_ALLOC and MAXSEG_64K independent options.
X	  Allow INBUFSIZ to be >= 32K in unlzw (don't use sign of rsize)
X	  Generate tar file in old format to avoid problems with old systems.
X	  Preserve time stamp in znew -P if touch -r works.
X	  Use ${PAGER-more} instead of ${PAGER:-more} in zmore.
X	  Do not use unsigned instead of mode_t.
X	  Better error message for trailing garbage in .z file; ignore this
X	   garbage on VMS.
X	  In zmore, use icanon instead of -cbreak on SYSV.
X	  Add trap handler in zmore.
X	  Use char* instead of void* for non STDC compilers.
X	  Added makefile entry for Xenix on 286.
X	  Return an error code when existing file was not overwritten.
X	  Use prototype of lzw.h for lzw.c.
X	  Fix znew with -P option alone.
X	  Give warning for directories even without -v.
X	  Close output file before unlink() in case of error.
X	  Suppress all target dependent ifdef from the portable files.
X	  Free all dynamically allocated variables upon exit.
X
XThu Feb 4 18:23:56 1993  Jean-loup Gailly  (jloup@chorus.fr)
X
X	* version 1.0.1
X	  Fixed some trivial errors in msdos/Makefile.bor
X
XThu Feb 4 10:00:59 1993  Jean-loup Gailly  (jloup@chorus.fr)
X
X	* version 1.0
X	  gzip now runs on Vax/VMS (Amiga support will come in next version).
X	  Do not overwrite files without -f when using /bin/sh.
X          Support the test option -t for compressed (.Z) files.
X	  Flush output for bad compressed files. Add warning in README.
X	  Added makefiles for MSDOS.
X	  Don't rely on presence of csh in configure
X	  Added gunzip.1 and gzcat.1.
X	  Updated znew.1.
X	  Check reserved flags in unlzw().
X	  Return dummy value in main to avoid lint warning.
X	  Define OF in lzw.h for lint.
X	  Allow both "znew -v -t" and "znew -vt".
X	  Don't overwrite the output file name for multiple parts.
X	  Echo just a warning if configure is out of date.
X	  Use ; instead of , in trees.c (confuses the SAS Amiga compiler).
X	  In INSTALL, document "DEFS='-DM_XENIX' ./configure".
X	  Use OTHER_PATH_SEP for more portability (DOS, OS2, VMS, AMIGA).
X	  Make all directories world writable for broken versions of tar.
X	  Use gzip -cd instead of zcat in zmore, zcmp, zdiff.
X	  Don't use GNU tar for distributions, some systems can't untar.
X	  Do not exit() for gzip --version.
X
XMon Jan 26 10:26:42 1993  Jean-loup Gailly  (jloup@chorus.fr)
X
X	* Beta version 0.8.2
X	  Avoid 'far' declarations for MSDOS.
X	  Use test -f instead of test -x in configure.in (for Ultrix)
X	  Add empty else part to if in Makefile.in for broken shells.
X	  Use NO_UNDERLINE instead of UNDERLINE (pb with Linux cpp)
X	  Accept continuation files with -ff (for damage recovery)
X	  Small patch to Makefile.os2
X	  Use memzero instead of bzero to avoid potential conflicts
X	  Document restriction on extraction of zip files.
X	  Fix quoting in ACL_HAVE_SHELL_HACK.
X          Do not check file size on MSDOS because of bug in DIET.
X	  Allow zcat on a file with multiple links.
X	  Add fix in inflate.c for compatibility with pkzip 2.04c.
X	  Release gzip in tar.z and tar format. (No tar.Z).
X
XFri Jan 22 10:04:13 1993  Jean-loup Gailly  (jloup@chorus.fr)
X
X	* Beta version 0.8.1
X	  Fixed Makefile.os2
X	  Fixed #if directives that TurboC does not like.
X	  Don't rely on uncompress in znew, use gzip -d.
X	  Add the pipe option -P in znew.
X	  Add some more ideas in TODO.
X	  Support both NDIR and SYSNDIR.
X
XSat Jan  21 15:46:38 1993  Jean-loup Gailly  (jloup@chorus.fr)
X
X	* Beta version 0.8
X	  Support unpack.
X	  Check for _match.o in configure.in in addition to return status.
X	  Include <sys/types.h> in zip.c
X	  Define local variables and functions as local.
X	  Accept more alternative names for the program (pcat, gzcat, ...).
X	  Accept .exe as well as .EXE.
X	  Uncompress files with multiple links only with -f.
X	  Better error message for gunzip of non-existent file.z.
X	  Fix the entry for /etc/magic in INSTALL.
X	  Use AC_HAVE_HEADERS uniformly instead of special macros.
X	  Install the man pages as .1 by default instead of .l.
X	  Document crypt++.el in README.
X	  Fix for unlzw() on 16-bit machines (bitmask must be unsigned).
X	  Complain if input and output files are identical.
X	  Create a correct output name for files of exactly 13 chars.
X	  Do not overwrite CPP if set
X	  Check for i386 before trying to assemble match.s
X	  Check for underline in external name before assembling
X	  Add patch for tar 1.11.1.
X
XMon Jan  5 10:16:24 1993  Jean-loup Gailly  (jloup@chorus.fr)
X
X	* Beta version 0.7
X	  Use "make check" instead of "make test".
X	  Do not rely on dirname in znew.
X	  Keep time stamp and pass options to gzip in znew.
X	  Rename .l files back to .1 to avoid conflict with lex
X	  Do not create .z.z files with gzip -r.
X	  Use nice_match in match.asm
X	  Unroll loops in deflate.c
X	  Do not attempt matches beyond the window end
X	  Allow again gunzip .zip files (was working in 0.5)
X	  Allow again compilation with TurboC 2.0 (was working in 0.4)
X
XTue Dec 30 20:00:19 1992  Jean-loup Gailly  (jloup@chorus.fr)
X
X	* Beta version 0.6
X	  The .z extension is used by pack, not compact (README, gzip.1)
X	  Accept gzcat in addition to zcat.
X	  Use PAGER in zmore if defined.
X	  Man pages for /usr/local/man/manl should have extension .l.
X	  Don't redefine bzero on the NeXT
X	  Allow incomplete Huffman table if there is only one code.
X	  Don't lookahead more than 7 bits (caused premature EOF).
X	  Added "make test" to check for compiler bugs.
X	  Don't rely on `i386`; try to assemble directly
X	  Change magic header to avoid conflict with freeze 1.x.
X	  Added entry for /etc/magic in INSTALL.
X	  Do not destroy an input .zip file with more than one member.
X	  Display "untested" instead of "OK" for gzip -t foo.Z
X	  With -t, skip stdin in .Z format
X	  Allow multiple compressed members in an input file.
X	  Ignore a zero time stamp.
X	  Made znew safer.
X
XTue Dec 29 10:00:19 1992   Noah Friedman  (friedman@gnu.ai.mit.edu)
X
X	  Added test for #!/bin/sh in configure.in.
X	  Fix some references to $srcdir in Makefile.in
X
XMon Dec 21 17:33:35 1992  Jean-Loup Gailly  (jloup@chorus.fr)
X
X	* Beta version 0.5
X	  Put RCS ids in all files.
X	  Added znew to recompress old .Z files with gzip.
X	  Avoid "already .z suffix" messages for -r and no -v.
X	  Put back check for d_ino in treat_dir().
X	  Use HAVE_STRING_H instead of USG.
X	  Added os2/Makefile.os2
X	  Use SYSUTIME on OS/2.
X	  Info dir is $(prefix)/info, not $(prefix)/lib/info.
X	  Support long options, added getopt and alloca
X	  Support -V and -t
X	  Reorder configure.in according to suggestions in autoconf.info
X	  Allow links when not removing original file
X	  Allow either .z or .Z in zdiff
X
XWed Nov 25 11:40:04 1992  Jean-loup Gailly  (jloup@chorus.fr)
X
X	* Beta version 0.4.1
X	  Save only the original base name, don't include any directory prefix.
X	  Don't use HAVE_LONG_FILE_NAMES (support multiple file system types).
X	  Fix declaration of abort_gzip in gzip.h.
X	  Include unistd.h when it exists to avoid warnings with gcc -Wall.
X
XMon Nov 23 12:39:01 1992    Jean-loup Gailly  (jloup@chorus.fr)
X
X	* Beta version 0.4
X          Lots of cleanup
X	  Use autoconf generated 'configure'
X          Fixed the NO_MULTIPLE_DOTS code
X          Fixed the save_orig_name code
X          Support for MSDOS (Turbo C)
X
XThu Nov 19 15:18:22 1992    Jean-loup Gailly  (jloup@chorus.fr)
X
X	* Beta version 0.3
X	  Added auto configuration. Just type "make" now.
X	  Don't overwrite compress by default in "make install". Use
X	    "make install_compress" to overwrite.
X	  Add match.s for 386 boxes.
X	  Added documentation in texinfo format.
X	  Provide help for "gunzip" invoked without redirected input.
X	  Save original file name when necessary.
X	  Support OS/2 (Kai-Uwe Rommel).
X
XTue Nov 17 14:32:53 1992  Jean-loup Gailly  (jloup@chorus.fr)
X
X	* Alpha version 0.2.4
X	  Return 0 in get_istat() when ok (caused error with zcat).
X	  Don't update crc on compressed data (caused crc errors on
X	    large files).
X
XFri Nov 13 15:04:12 1992  Jean-loup Gailly  (jloup@chorus.fr)
X
X	* Alpha version 0.2.3
X	  Initialize rsize in unlzw.c
X	  Initialize ofd for zcat.
X	  Do not use volatile ifname as argument of treat_dir.
X	  Add -1 to -9 in gzip.1.
X
XSat Oct 31 18:30:00 1992  Jean-loup Gailly  (jloup@chorus.fr)
X
X	* Alpha version 0.2.2.
X	  Fix error messages.
X	  Accept gunzip on zip files.
X
XSat Oct 31 17:15:00 1992  Jean-loup Gailly  (jloup@chorus.fr)
X
X	* Alpha version 0.2.1
X	  Use ctype.h in util.c (problem on SysV).
X	  Create BINDIR if it does not exist.
X	  Use cc by default.
X	  Added zcmp, zmore, zdiff.
X	  Fixed the man page gzip.1.
X
XSat Oct 31 17:00:00 1992  Jean-loup Gailly  (jloup@chorus.fr)
X
X	* Alpha version 0.2
X	  Fixed compilation problems with gcc
X
XSat Oct 31 12:46:00 1992  Jean-loup Gailly  (jloup@chorus.fr)
X
X	* Alpha version 0.1 released (under time pressure), so it's not
X	  much tested, sorry.
X
END_OF_FILE
if test 23171 -ne `wc -c <'gzip-1.2.2/ChangeLog'`; then
    echo shar: \"'gzip-1.2.2/ChangeLog'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/ChangeLog'
fi
if test -f 'gzip-1.2.2/gzip.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/gzip.c'\"
else
echo shar: Extracting \"'gzip-1.2.2/gzip.c'\" \(50229 characters\)
sed "s/^X//" >'gzip-1.2.2/gzip.c' <<'END_OF_FILE'
X/* gzip (GNU zip) -- compress files with zip algorithm and 'compress' interface
X * Copyright (C) 1992-1993 Jean-loup Gailly
X * The unzip code was written and put in the public domain by Mark Adler.
X * Portions of the lzw code are derived from the public domain 'compress'
X * written by Spencer Thomas, Joe Orost, James Woods, Jim McKie, Steve Davies,
X * Ken Turkowski, Dave Mack and Peter Jannesen.
X *
X * See the license_msg below and the file COPYING for the software license.
X * See the file algorithm.doc for the compression algorithms and file formats.
X */
X
Xstatic char  *license_msg[] = {
X"   Copyright (C) 1992-1993 Jean-loup Gailly",
X"   This program is free software; you can redistribute it and/or modify",
X"   it under the terms of the GNU General Public License as published by",
X"   the Free Software Foundation; either version 2, or (at your option)",
X"   any later version.",
X"",
X"   This program is distributed in the hope that it will be useful,",
X"   but WITHOUT ANY WARRANTY; without even the implied warranty of",
X"   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
X"   GNU General Public License for more details.",
X"",
X"   You should have received a copy of the GNU General Public License",
X"   along with this program; if not, write to the Free Software",
X"   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.",
X0};
X
X/* Compress files with zip algorithm and 'compress' interface.
X * See usage() and help() functions below for all options.
X * Outputs:
X *        file.gz:   compressed file with same mode, owner, and utimes
X *     or stdout with -c option or if stdin used as input.
X * If the output file name had to be truncated, the original name is kept
X * in the compressed file.
X * On MSDOS, file.tmp -> file.tmz. On VMS, file.tmp -> file.tmp-gz.
X *
X * Using gz on MSDOS would create too many file name conflicts. For
X * example, foo.txt -> foo.tgz (.tgz must be reserved as shorthand for
X * tar.gz). Similarly, foo.dir and foo.doc would both be mapped to foo.dgz.
X * I also considered 12345678.txt -> 12345txt.gz but this truncates the name
X * too heavily. There is no ideal solution given the MSDOS 8+3 limitation. 
X *
X * For the meaning of all compilation flags, see comments in Makefile.in.
X */
X
X#ifndef lint
Xstatic char rcsid[] = "$Id: gzip.c,v 0.22 1993/06/16 16:53:43 jloup Exp $";
X#endif
X
X#include <ctype.h>
X#include <sys/types.h>
X#include <signal.h>
X#include <sys/stat.h>
X#include <errno.h>
X
X#include "tailor.h"
X#include "gzip.h"
X#include "lzw.h"
X#include "revision.h"
X#include "getopt.h"
X
X		/* configuration */
X
X#ifdef NO_TIME_H
X#  include <sys/time.h>
X#else
X#  include <time.h>
X#endif
X
X#ifndef NO_FCNTL_H
X#  include <fcntl.h>
X#endif
X
X#ifdef HAVE_UNISTD_H
X#  include <unistd.h>
X#endif
X
X#if defined(STDC_HEADERS) || !defined(NO_STDLIB_H)
X#  include <stdlib.h>
X#else
X   extern int errno;
X#endif
X
X#if defined(DIRENT)
X#  include <dirent.h>
X   typedef struct dirent dir_type;
X#  define NLENGTH(dirent) ((int)strlen((dirent)->d_name))
X#  define DIR_OPT "DIRENT"
X#else
X#  define NLENGTH(dirent) ((dirent)->d_namlen)
X#  ifdef SYSDIR
X#    include <sys/dir.h>
X     typedef struct direct dir_type;
X#    define DIR_OPT "SYSDIR"
X#  else
X#    ifdef SYSNDIR
X#      include <sys/ndir.h>
X       typedef struct direct dir_type;
X#      define DIR_OPT "SYSNDIR"
X#    else
X#      ifdef NDIR
X#        include <ndir.h>
X         typedef struct direct dir_type;
X#        define DIR_OPT "NDIR"
X#      else
X#        define NO_DIR
X#        define DIR_OPT "NO_DIR"
X#      endif
X#    endif
X#  endif
X#endif
X
X#ifndef NO_UTIME
X#  ifndef NO_UTIME_H
X#    include <utime.h>
X#    define TIME_OPT "UTIME"
X#  else
X#    ifdef HAVE_SYS_UTIME_H
X#      include <sys/utime.h>
X#      define TIME_OPT "SYS_UTIME"
X#    else
X       struct utimbuf {
X         time_t actime;
X         time_t modtime;
X       };
X#      define TIME_OPT ""
X#    endif
X#  endif
X#else
X#  define TIME_OPT "NO_UTIME"
X#endif
X
X#if !defined(S_ISDIR) && defined(S_IFDIR)
X#  define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
X#endif
X#if !defined(S_ISREG) && defined(S_IFREG)
X#  define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
X#endif
X
Xtypedef RETSIGTYPE (*sig_type) OF((int));
X
X#ifndef	O_BINARY
X#  define  O_BINARY  0  /* creation mode for open() */
X#endif
X
X#ifndef O_CREAT
X   /* Pure BSD system? */
X#  include <sys/file.h>
X#  ifndef O_CREAT
X#    define O_CREAT FCREAT
X#  endif
X#  ifndef O_EXCL
X#    define O_EXCL FEXCL
X#  endif
X#endif
X
X#ifndef S_IRUSR
X#  define S_IRUSR 0400
X#endif
X#ifndef S_IWUSR
X#  define S_IWUSR 0200
X#endif
X#define RW_USER (S_IRUSR | S_IWUSR)  /* creation mode for open() */
X
X#ifndef MAX_PATH_LEN
X#  define MAX_PATH_LEN   1024 /* max pathname length */
X#endif
X
X#ifndef SEEK_END
X#  define SEEK_END 2
X#endif
X
X#ifdef NO_OFF_T
X  typedef long off_t;
X  off_t lseek OF((int fd, off_t offset, int whence));
X#endif
X
X/* Separator for file name parts (see shorten_name()) */
X#ifdef NO_MULTIPLE_DOTS
X#  define PART_SEP "-"
X#else
X#  define PART_SEP "."
X#endif
X
X		/* global buffers */
X
XDECLARE(uch, inbuf,  INBUFSIZ +INBUF_EXTRA);
XDECLARE(uch, outbuf, OUTBUFSIZ+OUTBUF_EXTRA);
XDECLARE(ush, d_buf,  DIST_BUFSIZE);
XDECLARE(uch, window, 2L*WSIZE);
X#ifndef MAXSEG_64K
X    DECLARE(ush, tab_prefix, 1L<<BITS);
X#else
X    DECLARE(ush, tab_prefix0, 1L<<(BITS-1));
X    DECLARE(ush, tab_prefix1, 1L<<(BITS-1));
X#endif
X
X		/* local variables */
X
Xint ascii = 0;        /* convert end-of-lines to local OS conventions */
Xint to_stdout = 0;    /* output to stdout (-c) */
Xint decompress = 0;   /* decompress (-d) */
Xint force = 0;        /* don't ask questions, compress links (-f) */
Xint no_name = 0;      /* don't save or restore the original file name */
Xint recursive = 0;    /* recurse through directories (-r) */
Xint list = 0;         /* list the file contents (-l) */
Xint verbose = 0;      /* be verbose (-v) */
Xint quiet = 0;        /* be very quiet (-q) */
Xint do_lzw = 0;       /* generate output compatible with old compress (-Z) */
Xint test = 0;         /* test .gz file integrity */
Xint foreground;       /* set if program run in foreground */
Xchar *progname;       /* program name */
Xint maxbits = BITS;   /* max bits per code for LZW */
Xint method = DEFLATED;/* compression method */
Xint level = 6;        /* compression level */
Xint exit_code = OK;   /* program exit code */
Xint save_orig_name;   /* set if original name must be saved */
Xint last_member;      /* set for .zip and .Z files */
Xint part_nb;          /* number of parts in .gz file */
Xlong time_stamp;       /* original time stamp (modification time) */
Xlong ifile_size;      /* input file size, -1 for devices (debug only) */
Xchar *env;            /* contents of GZIP env variable */
Xchar **args = NULL;   /* argv pointer if GZIP env variable defined */
Xchar z_suffix[MAX_SUFFIX+1]; /* default suffix (can be set with --suffix) */
Xint  z_len;           /* strlen(z_suffix) */
X
Xlong bytes_in;             /* number of input bytes */
Xlong bytes_out;            /* number of output bytes */
Xlong total_in = 0;         /* input bytes for all files */
Xlong total_out = 0;        /* output bytes for all files */
Xchar ifname[MAX_PATH_LEN]; /* input file name */
Xchar ofname[MAX_PATH_LEN]; /* output file name */
Xint  remove_ofname = 0;	   /* remove output file on error */
Xstruct stat istat;         /* status for input file */
Xint  ifd;                  /* input file descriptor */
Xint  ofd;                  /* output file descriptor */
Xunsigned insize;           /* valid bytes in inbuf */
Xunsigned inptr;            /* index of next byte to be processed in inbuf */
Xunsigned outcnt;           /* bytes in output buffer */
X
Xstruct option longopts[] =
X{
X /* { name  has_arg  *flag  val } */
X    {"ascii",      0, 0, 'a'}, /* ascii text mode */
X    {"to-stdout",  0, 0, 'c'}, /* write output on standard output */
X    {"stdout",     0, 0, 'c'}, /* write output on standard output */
X    {"decompress", 0, 0, 'd'}, /* decompress */
X    {"uncompress", 0, 0, 'd'}, /* decompress */
X /* {"encrypt",    0, 0, 'e'},    encrypt */
X    {"force",      0, 0, 'f'}, /* force overwrite of output file */
X    {"help",       0, 0, 'h'}, /* give help */
X /* {"pkzip",      0, 0, 'k'},    force output in pkzip format */
X    {"list",       0, 0, 'l'}, /* list .gz file contents */
X    {"license",    0, 0, 'L'}, /* display software license */
X    {"no-name",    0, 0, 'n'}, /* don't save or restore the original name */
X    {"quiet",      0, 0, 'q'}, /* quiet mode */
X    {"silent",     0, 0, 'q'}, /* quiet mode */
X    {"recurse",    0, 0, 'r'}, /* recurse through directories */
X    {"suffix",     1, 0, 'S'}, /* use given suffix instead of .gz */
X    {"test",       0, 0, 't'}, /* test compressed file integrity */
X    {"verbose",    0, 0, 'v'}, /* verbose mode */
X    {"version",    0, 0, 'V'}, /* display version number */
X    {"fast",       0, 0, '1'}, /* compress faster */
X    {"best",       0, 0, '9'}, /* compress better */
X    {"lzw",        0, 0, 'Z'}, /* make output compatible with old compress */
X    {"bits",       1, 0, 'b'}, /* max number of bits per code (implies -Z) */
X    { 0, 0, 0, 0 }
X};
X
X/* local functions */
X
Xlocal void usage        OF((void));
Xlocal void help         OF((void));
Xlocal void license      OF((void));
Xlocal void version      OF((void));
Xlocal void treat_stdin  OF((void));
Xlocal void treat_file   OF((char *iname));
Xlocal int create_outfile OF((void));
Xlocal int  do_stat      OF((char *name, struct stat *sbuf));
Xlocal char *get_suffix  OF((char *name));
Xlocal int  get_istat    OF((char *iname, struct stat *sbuf));
Xlocal int  make_ofname  OF((void));
Xlocal int  same_file    OF((struct stat *stat1, struct stat *stat2));
Xlocal int name_too_long OF((char *name, struct stat *statb));
Xlocal void shorten_name  OF((char *name));
Xlocal int  get_method   OF((int in));
Xlocal void do_list      OF((int ifd, int method));
Xlocal int  check_ofname OF((void));
Xlocal void reset_times  OF((char *name, struct stat *statb));
Xlocal void copy_stat    OF((struct stat *ifstat));
Xlocal void treat_dir    OF((char *dir));
Xlocal void do_exit      OF((int exitcode));
X      int main          OF((int argc, char **argv));
X
Xint (*work) OF((int infile, int outfile)) = zip; /* function to call */
X
X#define strequ(s1, s2) (strcmp((s1),(s2)) == 0)
X
X/* ======================================================================== */
Xlocal void usage()
X{
X    fprintf(stderr, "usage: %s [-%scdfhlLn%stvV19] [-S suffix] [file ...]\n",
X	    progname,
X#if O_BINARY
X	    "a",
X#else
X	    "",
X#endif
X#ifdef NO_DIR
X	    ""
X#else
X	    "r"
X#endif
X	    );
X}
X
X/* ======================================================================== */
Xlocal void help()
X{
X    static char  *help_msg[] = {
X#if O_BINARY
X " -a --ascii       ascii text; convert end-of-lines using local conventions",
X#endif
X " -c --stdout      write on standard output, keep original files unchanged",
X " -d --decompress  decompress",
X/* -e --encrypt     encrypt */
X " -f --force       force overwrite of output file and compress links",
X " -h --help        give this help",
X/* -k --pkzip       force output in pkzip format */
X " -l --list        list .gz file contents",
X " -L --license     display software license",
X " -n --no-name     do not save or restore the original name",
X " -q --quiet       suppress all warnings",
X#ifndef NO_DIR
X " -r --recurse     recurse through directories",
X#endif
X#ifdef MAX_EXT_CHARS
X " -S .suf  --suffix .suf     use suffix .suf instead of .z",
X#else
X " -S .suf  --suffix .suf     use suffix .suf instead of .gz",
X#endif
X " -t --test        test compressed file integrity",
X " -v --verbose     verbose mode",
X " -V --version     display version number",
X " -1 --fast        compress faster",
X " -9 --best        compress better",
X#ifdef LZW
X " -Z --lzw         produce output compatible with old compress",
X " -b --bits maxbits   max number of bits per code (implies -Z)",
X#endif
X " file...          files to (de)compress. If none given, use standard input.",
X  0};
X    char **p = help_msg;
X
X    fprintf(stderr,"%s %s (%s)\n", progname, VERSION, REVDATE);
X    usage();
X    while (*p) fprintf(stderr, "%s\n", *p++);
X}
X
X/* ======================================================================== */
Xlocal void license()
X{
X    char **p = license_msg;
X
X    fprintf(stderr,"%s %s (%s)\n", progname, VERSION, REVDATE);
X    while (*p) fprintf(stderr, "%s\n", *p++);
X}
X
X/* ======================================================================== */
Xlocal void version()
X{
X    fprintf(stderr,"%s %s (%s)\n", progname, VERSION, REVDATE);
X
X    fprintf(stderr, "Compilation options:\n%s %s ", DIR_OPT, TIME_OPT);
X#ifdef STDC_HEADERS
X    fprintf(stderr, "STDC_HEADERS ");
X#endif
X#ifdef HAVE_UNISTD_H
X    fprintf(stderr, "HAVE_UNISTD_H ");
X#endif
X#ifdef NO_MEMORY_H
X    fprintf(stderr, "NO_MEMORY_H ");
X#endif
X#ifdef NO_STRING_H
X    fprintf(stderr, "NO_STRING_H ");
X#endif
X#ifdef NO_SYMLINK
X    fprintf(stderr, "NO_SYMLINK ");
X#endif
X#ifdef NO_MULTIPLE_DOTS
X    fprintf(stderr, "NO_MULTIPLE_DOTS ");
X#endif
X#ifdef NO_CHOWN
X    fprintf(stderr, "NO_CHOWN ");
X#endif
X#ifdef PROTO
X    fprintf(stderr, "PROTO ");
X#endif
X#ifdef ASMV
X    fprintf(stderr, "ASMV ");
X#endif
X#ifdef DEBUG
X    fprintf(stderr, "DEBUG ");
X#endif
X#ifdef DYN_ALLOC
X    fprintf(stderr, "DYN_ALLOC ");
X#endif
X#ifdef MAXSEG_64K
X    fprintf(stderr, "MAXSEG_64K");
X#endif
X    fprintf(stderr, "\n");
X}
X
X/* ======================================================================== */
Xint main (argc, argv)
X    int argc;
X    char **argv;
X{
X    int file_count = 0; /* number of files to precess */
X    int proglen;        /* length of progname */
X    int optc;           /* current option */
X
X    EXPAND(argc, argv); /* wild card expansion if necessary */
X
X    progname = basename(argv[0]);
X    proglen = strlen(progname);
X
X    /* Suppress .exe for MSDOS, OS/2 and VMS: */
X    if (proglen > 4 && strequ(progname+proglen-4, ".exe")) {
X        progname[proglen-4] = '\0';
X    }
X
X    /* Add options in GZIP environment variable if there is one */
X    env = add_envopt(&argc, &argv, OPTIONS_VAR);
X    if (env != NULL) args = argv;
X
X    foreground = signal(SIGINT, SIG_IGN) != SIG_IGN;
X    if (foreground) {
X	signal (SIGINT, (sig_type)abort_gzip);
X    }
X#ifdef SIGTERM
X    signal(SIGTERM, (sig_type)abort_gzip);
X#endif
X#ifdef SIGHUP
X    signal(SIGHUP,  (sig_type)abort_gzip);
X#endif
X
X#ifndef GNU_STANDARD
X    /* For compatibility with old compress, use program name as an option.
X     * If you compile with -DGNU_STANDARD, this program will behave as
X     * gzip even if it is invoked under the name gunzip or zcat.
X     *
X     * Systems which do not support links can still use -d or -dc.
X     * Ignore an .exe extension for MSDOS, OS/2 and VMS.
X     */
X    if (  strncmp(progname, "un",  2) == 0     /* ungzip, uncompress */
X       || strncmp(progname, "gun", 3) == 0) {  /* gunzip */
X	decompress = 1;
X    } else if (strequ(progname+1, "cat")       /* zcat, pcat, gcat */
X	    || strequ(progname, "gzcat")) {    /* gzcat */
X	decompress = to_stdout = 1;
X    }
X#endif
X
X    strncpy(z_suffix, Z_SUFFIX, sizeof(z_suffix)-1);
X    z_len = strlen(z_suffix);
X
X    while ((optc = getopt_long (argc, argv, "ab:cdfhlLnqrS:tvVZ123456789",
X				longopts, (int *)0)) != EOF) {
X	switch (optc) {
X        case 'a':
X            ascii = 1; break;
X	case 'b':
X	    maxbits = atoi(optarg);
X	    break;
X	case 'c':
X	    to_stdout = 1; break;
X	case 'd':
X	    decompress = 1; break;
X	case 'f':
X	    force++; break;
X	case 'h': case 'H': case '?':
X	    help(); do_exit(OK); break;
X	case 'l':
X	    list = decompress = to_stdout = 1; break;
X	case 'L':
X	    license(); do_exit(OK); break;
X	case 'n':
X	    no_name = 1; break;
X	case 'q':
X	    quiet = 1; verbose = 0; break;
X	case 'r':
X#ifdef NO_DIR
X	    fprintf(stderr, "%s: -r not supported on this system\n", progname);
X	    usage();
X	    do_exit(ERROR); break;
X#else
X	    recursive = 1; break;
X#endif
X	case 'S':
X#ifdef NO_MULTIPLE_DOTS
X            if (*optarg == '.') optarg++;
X#endif
X            z_len = strlen(optarg);
X            strcpy(z_suffix, optarg);
X            break;
X	case 't':
X	    test = decompress = to_stdout = 1;
X	    break;
X	case 'v':
X	    verbose++; quiet = 0; break;
X	case 'V':
X	    version(); do_exit(OK); break;
X	case 'Z':
X#ifdef LZW
X	    do_lzw = 1; break;
X#else
X	    fprintf(stderr, "%s: -Z not supported in this version\n",
X		    progname);
X	    usage();
X	    do_exit(ERROR); break;
X#endif
X	case '1':  case '2':  case '3':  case '4':
X	case '5':  case '6':  case '7':  case '8':  case '9':
X	    level = optc - '0';
X	    break;
X	default:
X	    /* Error message already emitted by getopt_long. */
X	    usage();
X	    do_exit(ERROR);
X	}
X    } /* loop on all arguments */
X
X    file_count = argc - optind;
X
X#if O_BINARY
X#else
X    if (ascii && !quiet) {
X	fprintf(stderr, "%s: option --ascii ignored on this system\n",
X		progname);
X    }
X#endif
X    if ((z_len == 0 && !decompress) || z_len > MAX_SUFFIX) {
X        fprintf(stderr, "%s: incorrect suffix '%s'\n",
X                progname, optarg);
X        do_exit(ERROR);
X    }
X    if (do_lzw && !decompress) work = lzw;
X
X    /* Allocate all global buffers (for DYN_ALLOC option) */
X    ALLOC(uch, inbuf,  INBUFSIZ +INBUF_EXTRA);
X    ALLOC(uch, outbuf, OUTBUFSIZ+OUTBUF_EXTRA);
X    ALLOC(ush, d_buf,  DIST_BUFSIZE);
X    ALLOC(uch, window, 2L*WSIZE);
X#ifndef MAXSEG_64K
X    ALLOC(ush, tab_prefix, 1L<<BITS);
X#else
X    ALLOC(ush, tab_prefix0, 1L<<(BITS-1));
X    ALLOC(ush, tab_prefix1, 1L<<(BITS-1));
X#endif
X
X    /* And get to work */
X    if (file_count != 0) {
X	if (to_stdout && !test && !list && (!decompress || !ascii)) {
X	    SET_BINARY_MODE(fileno(stdout));
X	}
X        while (optind < argc) {
X	    treat_file(argv[optind++]);
X	}
X    } else {  /* Standard input */
X	treat_stdin();
X    }
X    if (list && !quiet) {
X	do_list(-1, -1); /* print totals */
X    }
X    do_exit(exit_code);
X    return exit_code; /* just to avoid lint warning */
X}
X
X/* ========================================================================
X * Compress or decompress stdin
X */
Xlocal void treat_stdin()
X{
X    if (!force && isatty(fileno((FILE *)(decompress ? stdin : stdout)))) {
X	/* Do not send compressed data to the terminal or read it from
X	 * the terminal. We get here when user invoked the program
X	 * without parameters, so be helpful. According to the GNU standards:
X	 *
X	 *   If there is one behavior you think is most useful when the output
X	 *   is to a terminal, and another that you think is most useful when
X	 *   the output is a file or a pipe, then it is usually best to make
X	 *   the default behavior the one that is useful with output to a
X	 *   terminal, and have an option for the other behavior.
X	 *
X	 * Here we use the --force option to get the other behavior.
X	 */
X	fprintf(stderr,
X    "%s: compressed data not %s a terminal. Use -f to force %scompression.\n",
X		progname, decompress ? "read from" : "written to",
X		decompress ? "de" : "");
X	fprintf(stderr,"For help, type: %s -h\n", progname);
X	do_exit(ERROR);
X    }
X
X    if (decompress || !ascii) {
X	SET_BINARY_MODE(fileno(stdin));
X    }
X    if (!test && !list && (!decompress || !ascii)) {
X	SET_BINARY_MODE(fileno(stdout));
X    }
X    strcpy(ifname, "stdin");
X    strcpy(ofname, "stdout");
X
X    /* Get the time stamp on the input file. */
X#ifdef NO_STDIN_FSTAT
X    time_stamp = 0; /* time unknown */
X#else
X    if (fstat(fileno(stdin), &istat) != 0) {
X	error("fstat(stdin)");
X    }
X    /* If you do not wish to save the time stamp when input comes from a pipe,
X     * compile with -DNO_PIPE_TIMESTAMP.
X     */
X#ifdef NO_PIPE_TIMESTAMP
X    if (!S_ISREG(istat.st_mode))
X	time_stamp = 0;
X    else
X#endif
X	time_stamp = istat.st_mtime;
X#endif
X    ifile_size = -1L; /* convention for unknown size */
X
X    clear_bufs(); /* clear input and output buffers */
X    to_stdout = 1;
X    part_nb = 0;
X
X    if (decompress) {
X	method = get_method(ifd);
X	if (method < 0) {
X	    do_exit(exit_code); /* error message already emitted */
X	}
X    }
X    if (list) {
X        do_list(ifd, method);
X        return;
X    }
X
X    /* Actually do the compression/decompression. Loop over zipped members.
X     */
X    for (;;) {
X	if ((*work)(fileno(stdin), fileno(stdout)) != OK) return;
X
X	if (!decompress || last_member || inptr == insize) break;
X	/* end of file */
X
X	method = get_method(ifd);
X	if (method < 0) return; /* error message already emitted */
X	bytes_out = 0;            /* required for length check */
X    }
X
X    if (verbose) {
X	if (test) {
X	    fprintf(stderr, " OK\n");
X
X	} else if (!decompress) {
X	    display_ratio(bytes_in-(bytes_out-header_bytes), bytes_in, stderr);
X	    fprintf(stderr, "\n");
X#ifdef DISPLAY_STDIN_RATIO
X	} else {
X	    display_ratio(bytes_out-(bytes_in-header_bytes), bytes_out,stderr);
X	    fprintf(stderr, "\n");
X#endif
X	}
X    }
X}
X
X/* ========================================================================
X * Compress or decompress the given file
X */
Xlocal void treat_file(iname)
X    char *iname;
X{
X    /* Check if the input file is present, set ifname and istat: */
X    if (get_istat(iname, &istat) != OK) return;
X
X    /* If the input name is that of a directory, recurse or ignore: */
X    if (S_ISDIR(istat.st_mode)) {
X#ifndef NO_DIR
X	if (recursive) {
X	    struct stat st;
X	    st = istat;
X	    treat_dir(iname);
X	    /* Warning: ifname is now garbage */
X	    reset_times (iname, &st);
X	} else
X#endif
X	WARN((stderr,"%s: %s is a directory -- ignored\n", progname, ifname));
X	return;
X    }
X    if (!S_ISREG(istat.st_mode)) {
X	WARN((stderr,
X	      "%s: %s is not a directory or a regular file - ignored\n",
X	      progname, ifname));
X	return;
X    }
X    if (istat.st_nlink > 1 && !to_stdout && !force) {
X	WARN((stderr, "%s: %s has %d other link%c -- unchanged\n",
X	      progname, ifname,
X	      (int)istat.st_nlink - 1, istat.st_nlink > 2 ? 's' : ' '));
X	return;
X    }
X
X    ifile_size = istat.st_size;
X    time_stamp = istat.st_mtime;
X
X    /* Generate output file name */
X    if (to_stdout && !list) {
X	strcpy(ofname, "stdout");
X
X    } else if (make_ofname() != OK) {
X	return;
X    }
X
X    /* Open the input file and determine compression method. The mode
X     * parameter is ignored but required by some systems (VMS) and forbidden
X     * on other systems (MacOS).
X     */
X    ifd = OPEN(ifname, ascii && !decompress ? O_RDONLY : O_RDONLY | O_BINARY,
X	       RW_USER);
X    if (ifd == -1) {
X	fprintf(stderr, "%s: ", progname);
X	perror(ifname);
X	exit_code = ERROR;
X	return;
X    }
X    clear_bufs(); /* clear input and output buffers */
X    part_nb = 0;
X
X    if (decompress) {
X	method = get_method(ifd); /* updates ofname if original given */
X	if (method < 0) {
X	    close(ifd);
X	    return;               /* error message already emitted */
X	}
X    }
X    if (list) {
X        do_list(ifd, method);
X        close(ifd);
X        return;
X    }
X
X    /* If compressing to a file, check if ofname is not ambiguous
X     * because the operating system truncates names. Otherwise, generate
X     * a new ofname and save the original name in the compressed file.
X     */
X    if (to_stdout) {
X	ofd = fileno(stdout);
X	/* keep remove_ofname as zero */
X    } else {
X	if (create_outfile() != OK) return;
X
X	if (save_orig_name && !verbose && !quiet) {
X	    fprintf(stderr, "%s: %s compressed to %s\n",
X		    progname, ifname, ofname);
X	}
X    }
X    /* Keep the name even if not truncated except with --no-name: */
X    if (!save_orig_name) save_orig_name = !no_name;
X
X    if (verbose) {
X	fprintf(stderr, "%s:\t%s", ifname, (int)strlen(ifname) >= 15 ? 
X		"" : ((int)strlen(ifname) >= 7 ? "\t" : "\t\t"));
X    }
X
X    /* Actually do the compression/decompression. Loop over zipped members.
X     */
X    for (;;) {
X	if ((*work)(ifd, ofd) != OK) {
X	    method = -1; /* force cleanup */
X	    break;
X	}
X	if (!decompress || last_member || inptr == insize) break;
X	/* end of file */
X
X	method = get_method(ifd);
X	if (method < 0) break;    /* error message already emitted */
X	bytes_out = 0;            /* required for length check */
X    }
X
X    close(ifd);
X    if (!to_stdout && close(ofd)) {
X	write_error();
X    }
X    if (method == -1) {
X	if (!to_stdout) unlink (ofname);
X	return;
X    }
X    /* Display statistics */
X    if(verbose) {
X	if (test) {
X	    fprintf(stderr, " OK");
X	} else if (decompress) {
X	    display_ratio(bytes_out-(bytes_in-header_bytes), bytes_out,stderr);
X	} else {
X	    display_ratio(bytes_in-(bytes_out-header_bytes), bytes_in, stderr);
X	}
X	if (!test && !to_stdout) {
X	    fprintf(stderr, " -- replaced with %s", ofname);
X	}
X	fprintf(stderr, "\n");
X    }
X    /* Copy modes, times, ownership, and remove the input file */
X    if (!to_stdout) {
X	copy_stat(&istat);
X    }
X}
X
X/* ========================================================================
X * Create the output file. Return OK or ERROR.
X * Try several times if necessary to avoid truncating the z_suffix. For
X * example, do not create a compressed file of name "1234567890123."
X * Sets save_orig_name to true if the file name has been truncated.
X * IN assertions: the input file has already been open (ifd is set) and
X *   ofname has already been updated if there was an original name.
X * OUT assertions: ifd and ofd are closed in case of error.
X */
Xlocal int create_outfile()
X{
X    struct stat	ostat; /* stat for ofname */
X    int flags = O_WRONLY | O_CREAT | O_EXCL | O_BINARY;
X
X    if (ascii && decompress) {
X	flags &= ~O_BINARY; /* force ascii text mode */
X    }
X    for (;;) {
X	/* Make sure that ofname is not an existing file */
X	if (check_ofname() != OK) {
X	    close(ifd);
X	    return ERROR;
X	}
X	/* Create the output file */
X	remove_ofname = 1;
X	ofd = OPEN(ofname, flags, RW_USER);
X	if (ofd == -1) {
X	    perror(ofname);
X	    close(ifd);
X	    exit_code = ERROR;
X	    return ERROR;
X	}
X
X	/* Check for name truncation on new file (1234567890123.gz) */
X#ifdef NO_FSTAT
X	if (stat(ofname, &ostat) != 0) {
X#else
X	if (fstat(ofd, &ostat) != 0) {
X#endif
X	    fprintf(stderr, "%s: ", progname);
X	    perror(ofname);
X	    close(ifd); close(ofd);
X	    unlink(ofname);
X	    exit_code = ERROR;
X	    return ERROR;
X	}
X	if (!name_too_long(ofname, &ostat)) return OK;
X
X	if (decompress) {
X	    /* name might be too long if an original name was saved */
X	    WARN((stderr, "%s: %s: warning, name truncated\n",
X		  progname, ofname));
X	    return OK;
X	}
X	close(ofd);
X	unlink(ofname);
X#ifdef NO_MULTIPLE_DOTS
X	/* Should never happen, see check_ofname() */
X	fprintf(stderr, "%s: %s: name too long\n", progname, ofname);
X	do_exit(ERROR);
X#endif
X	shorten_name(ofname);
X    }
X}
X
X/* ========================================================================
X * Use lstat if available, except for -c or -f. Use stat otherwise.
X * This allows links when not removing the original file.
X */
Xlocal int do_stat(name, sbuf)
X    char *name;
X    struct stat *sbuf;
X{
X    errno = 0;
X#if (defined(S_IFLNK) || defined (S_ISLNK)) && !defined(NO_SYMLINK)
X    if (!to_stdout && !force) {
X	return lstat(name, sbuf);
X    }
X#endif
X    return stat(name, sbuf);
X}
X
X/* ========================================================================
X * Return a pointer to the 'z' suffix of a file name, or NULL. For all
X * systems, ".gz", ".z", ".Z", ".taz", ".tgz", "-gz", "-z" and "_z" are
X * accepted suffixes, in addition to the value of the --suffix option.
X * ".tgz" is a useful convention for tar.z files on systems limited
X * to 3 characters extensions. On such systems, ".?z" and ".??z" are
X * also accepted suffixes. For Unix, we do not want to accept any
X * .??z suffix as indicating a compressed file; some people use .xyz
X * to denote volume data.
X *   On systems allowing multiple versions of the same file (such as VMS),
X * this function removes any version suffix in the given name.
X */
Xlocal char *get_suffix(name)
X    char *name;
X{
X    int nlen, slen;
X    char suffix[MAX_SUFFIX+3]; /* last chars of name, forced to lower case */
X    static char *known_suffixes[] =
X       {z_suffix, ".gz", ".z", ".taz", ".tgz", "-gz", "-z", "_z",
X#ifdef MAX_EXT_CHARS
X          "z",
X#endif
X          NULL};
X    char **suf = known_suffixes;
X
X    if (strequ(z_suffix, "z")) suf++; /* check long suffixes first */
X
X#ifdef SUFFIX_SEP
X    /* strip a version number from the file name */
X    {
X	char *v = strrchr(name, SUFFIX_SEP);
X 	if (v != NULL) *v = '\0';
X    }
X#endif
X    nlen = strlen(name);
X    if (nlen <= MAX_SUFFIX+2) {
X        strcpy(suffix, name);
X    } else {
X        strcpy(suffix, name+nlen-MAX_SUFFIX-2);
X    }
X    strlwr(suffix);
X    slen = strlen(suffix);
X    do {
X       int s = strlen(*suf);
X       if (slen > s && suffix[slen-s-1] != PATH_SEP
X           && strequ(suffix + slen - s, *suf)) {
X           return name+nlen-s;
X       }
X    } while (*++suf != NULL);
X
X    return NULL;
X}
X
X
X/* ========================================================================
X * Set ifname to the input file name (with a suffix appended if necessary)
X * and istat to its stats. For decompression, if no file exists with the
X * original name, try adding successively z_suffix, .gz, .z, -z and .Z.
X * For MSDOS, we try only z_suffix and z.
X * Return OK or ERROR.
X */
Xlocal int get_istat(iname, sbuf)
X    char *iname;
X    struct stat *sbuf;
X{
X    int ilen;  /* strlen(ifname) */
X    static char *suffixes[] = {z_suffix, ".gz", ".z", "-z", ".Z", NULL};
X    char **suf = suffixes;
X    char *s;
X#ifdef NO_MULTIPLE_DOTS
X    char *dot; /* pointer to ifname extension, or NULL */
X#endif
X
X    strcpy(ifname, iname);
X
X    /* If input file exists, return OK. */
X    if (do_stat(ifname, sbuf) == 0) return OK;
X
X    if (!decompress || errno != ENOENT) {
X	perror(ifname);
X	exit_code = ERROR;
X	return ERROR;
X    }
X    /* file.ext doesn't exist, try adding a suffix (after removing any
X     * version number for VMS).
X     */
X    s = get_suffix(ifname);
X    if (s != NULL) {
X	perror(ifname); /* ifname already has z suffix and does not exist */
X	exit_code = ERROR;
X	return ERROR;
X    }
X#ifdef NO_MULTIPLE_DOTS
X    dot = strrchr(ifname, '.');
X    if (dot == NULL) {
X        strcat(ifname, ".");
X        dot = strrchr(ifname, '.');
X    }
X#endif
X    ilen = strlen(ifname);
X    if (strequ(z_suffix, ".gz")) suf++;
X
X    /* Search for all suffixes */
X    do {
X        s = *suf;
X#ifdef NO_MULTIPLE_DOTS
X        if (*s == '.') s++;
X#endif
X#ifdef MAX_EXT_CHARS
X        strcpy(ifname, iname);
X        /* Needed if the suffixes are not sorted by increasing length */
X
X        if (*dot == '\0') strcpy(dot, ".");
X        dot[MAX_EXT_CHARS+1-strlen(s)] = '\0';
X#endif
X        strcat(ifname, s);
X        if (do_stat(ifname, sbuf) == 0) return OK;
X	ifname[ilen] = '\0';
X    } while (*++suf != NULL);
X
X    /* No suffix found, complain using z_suffix: */
X#ifdef MAX_EXT_CHARS
X    strcpy(ifname, iname);
X    if (*dot == '\0') strcpy(dot, ".");
X    dot[MAX_EXT_CHARS+1-z_len] = '\0';
X#endif
X    strcat(ifname, z_suffix);
X    perror(ifname);
X    exit_code = ERROR;
X    return ERROR;
X}
X
X/* ========================================================================
X * Generate ofname given ifname. Return OK, or WARNING if file must be skipped.
X * Sets save_orig_name to true if the file name has been truncated.
X */
Xlocal int make_ofname()
X{
X    char *suff;            /* ofname z suffix */
X
X    strcpy(ofname, ifname);
X    /* strip a version number if any and get the gzip suffix if present: */
X    suff = get_suffix(ofname);
X
X    if (decompress) {
X	if (suff == NULL) {
X            if (list) return OK;
X	    /* Avoid annoying messages with -r */
X	    if (verbose || (!recursive && !quiet)) {
X		WARN((stderr,"%s: %s: unknown suffix -- ignored\n",
X		      progname, ifname));
X	    }
X	    return WARNING;
X	}
X	/* Make a special case for .tgz and .taz: */
X	strlwr(suff);
X	if (strequ(suff, ".tgz") || strequ(suff, ".taz")) {
X	    strcpy(suff, ".tar");
X	} else {
X	    *suff = '\0'; /* strip the z suffix */
X	}
X        /* ofname might be changed later if infile contains an original name */
X
X    } else if (suff != NULL) {
X	/* Avoid annoying messages with -r (see treat_dir()) */
X	if (verbose || (!recursive && !quiet)) {
X	    fprintf(stderr, "%s: %s already has %s suffix -- unchanged\n",
X		    progname, ifname, suff);
X	}
X	if (exit_code == OK) exit_code = WARNING;
X	return WARNING;
X    } else {
X        save_orig_name = 0;
X
X#ifdef NO_MULTIPLE_DOTS
X	suff = strrchr(ofname, '.');
X	if (suff == NULL) {
X            strcat(ofname, ".");
X#  ifdef MAX_EXT_CHARS
X	    if (strequ(z_suffix, "z")) {
X		strcat(ofname, "gz"); /* enough room */
X		return OK;
X	    }
X        /* On the Atari and some versions of MSDOS, name_too_long()
X         * does not work correctly because of a bug in stat(). So we
X         * must truncate here.
X         */
X        } else if (strlen(suff)-1 + z_len > MAX_SUFFIX) {
X            suff[MAX_SUFFIX+1-z_len] = '\0';
X            save_orig_name = 1;
X#  endif
X        }
X#endif /* NO_MULTIPLE_DOTS */
X	strcat(ofname, z_suffix);
X
X    } /* decompress ? */
X    return OK;
X}
X
X
X/* ========================================================================
X * Check the magic number of the input file and update ofname if an
X * original name was given and to_stdout is not set.
X * Return the compression method, -1 for error, -2 for warning.
X * Set inptr to the offset of the next byte to be processed.
X * This function may be called repeatedly for an input file consisting
X * of several contiguous gzip'ed members.
X * IN assertions: there is at least one remaining compressed member.
X *   If the member is a zip file, it must be the only one.
X */
Xlocal int get_method(in)
X    int in;        /* input file descriptor */
X{
X    uch flags;
X    char magic[2]; /* magic header */
X
X    /* If --force and --stdout, zcat == cat, so do not complain about
X     * premature end of file: use try_byte instead of get_byte.
X     */
X    if (force && to_stdout) {
X	magic[0] = (char)try_byte();
X	magic[1] = (char)try_byte();
X	/* If try_byte returned EOF, magic[1] == 0xff */
X    } else {
X	magic[0] = (char)get_byte();
X	magic[1] = (char)get_byte();
X    }
X    time_stamp = istat.st_mtime; /* may be modified later for some methods */
X    method = -1;                 /* unknown yet */
X    part_nb++;                   /* number of parts in gzip file */
X    header_bytes = 0;
X    last_member = RECORD_IO;
X    /* assume multiple members in gzip file except for record oriented I/O */
X
X    if (memcmp(magic, GZIP_MAGIC, 2) == 0
X        || memcmp(magic, OLD_GZIP_MAGIC, 2) == 0) {
X
X	method = (int)get_byte();
X	if (method != DEFLATED) {
X	    fprintf(stderr,
X		    "%s: %s: unknown method %d -- get newer version of gzip\n",
X		    progname, ifname, method);
X	    exit_code = ERROR;
X	    return -1;
X	}
X	work = unzip;
X	flags  = (uch)get_byte();
X
X	if ((flags & ENCRYPTED) != 0) {
X	    fprintf(stderr,
X		    "%s: %s is encrypted -- get newer version of gzip\n",
X		    progname, ifname);
X	    exit_code = ERROR;
X	    return -1;
X	}
X	if ((flags & CONTINUATION) != 0) {
X	    fprintf(stderr,
X	   "%s: %s is a a multi-part gzip file -- get newer version of gzip\n",
X		    progname, ifname);
X	    exit_code = ERROR;
X	    if (force <= 1) return -1;
X	}
X	if ((flags & RESERVED) != 0) {
X	    fprintf(stderr,
X		    "%s: %s has flags 0x%x -- get newer version of gzip\n",
X		    progname, ifname, flags);
X	    exit_code = ERROR;
X	    if (force <= 1) return -1;
X	}
X	time_stamp  = (ulg)get_byte();
X	time_stamp |= ((ulg)get_byte()) << 8;
X	time_stamp |= ((ulg)get_byte()) << 16;
X	time_stamp |= ((ulg)get_byte()) << 24;
X
X	(void)get_byte();  /* Ignore extra flags for the moment */
X	(void)get_byte();  /* Ignore OS type for the moment */
X
X	if ((flags & CONTINUATION) != 0) {
X	    unsigned part = (unsigned)get_byte();
X	    part |= ((unsigned)get_byte())<<8;
X	    if (verbose) {
X		fprintf(stderr,"%s: %s: part number %u\n",
X			progname, ifname, part);
X	    }
X	}
X	if ((flags & EXTRA_FIELD) != 0) {
X	    unsigned len = (unsigned)get_byte();
X	    len |= ((unsigned)get_byte())<<8;
X	    if (verbose) {
X		fprintf(stderr,"%s: %s: extra field of %u bytes ignored\n",
X			progname, ifname, len);
X	    }
X	    while (len--) (void)get_byte();
X	}
X
X	/* Get original file name if it was truncated */
X	if ((flags & ORIG_NAME) != 0) {
X	    if (no_name || (to_stdout && !list) || part_nb > 1) {
X		/* Discard the old name */
X		char c; /* dummy used for NeXTstep 3.0 cc optimizer bug */
X		while ((c=get_byte()) != 0) c++;
X	    } else {
X		/* Copy the base name. Keep a directory prefix intact. */
X                char *p = basename(ofname);
X                char *base = p;
X		for (;;) {
X		    *p = (char)get_char();
X		    if (*p++ == '\0') break;
X		    if (p >= ofname+sizeof(ofname)) {
X			error("corrupted input -- file name too large");
X		    }
X		}
X                /* If necessary, adapt the name to local OS conventions: */
X                if (!list) {
X                   MAKE_LEGAL_NAME(base);
X		   base++; /* avoid warning about unused variable */
X                }
X	    } /* no_name || to_stdout */
X	} /* ORIG_NAME */
X
X	/* Discard file comment if any */
X	if ((flags & COMMENT) != 0) {
X	    while (get_char() != 0) /* null */ ;
X	}
X	if (part_nb == 1) {
X	    header_bytes = inptr + 2*sizeof(long); /* include crc and size */
X	}
X
X    } else if (memcmp(magic, PKZIP_MAGIC, 2) == 0 && inptr == 2
X	    && memcmp((char*)inbuf, PKZIP_MAGIC, 4) == 0) {
X	/* To simplify the code, we support a zip file when alone only.
X         * We are thus guaranteed that the entire local header fits in inbuf.
X         */
X        inptr = 0;
X	work = unzip;
X	if (check_zipfile(in) != OK) return -1;
X	/* check_zipfile may get ofname from the local header */
X	last_member = 1;
X
X    } else if (memcmp(magic, PACK_MAGIC, 2) == 0) {
X	work = unpack;
X	method = PACKED;
X
X    } else if (memcmp(magic, LZW_MAGIC, 2) == 0) {
X	work = unlzw;
X	method = COMPRESSED;
X	last_member = 1;
X
X    } else if (memcmp(magic, LZH_MAGIC, 2) == 0) {
X	work = unlzh;
X	method = LZHED;
X	last_member = 1;
X
X    } else if (force && to_stdout) { /* pass input unchanged */
X	method = STORED;
X	work = copy;
X        inptr = 0;
X	last_member = 1;
X    }
X    if (method >= 0) return method;
X
X    if (part_nb == 1) {
X	fprintf(stderr, "\n%s: %s: not in gzip format\n", progname, ifname);
X	exit_code = ERROR;
X	return -1;
X    } else {
X	WARN((stderr, "\n%s: %s: decompression OK, trailing garbage ignored\n",
X	      progname, ifname));
X	return -2;
X    }
X}
X
X/* ========================================================================
X * Display the characteristics of the compressed file.
X * If the given method is < 0, display the accumulated totals.
X * IN assertions: time_stamp, header_bytes and ifile_size are initialized.
X */
Xlocal void do_list(ifd, method)
X    int ifd;     /* input file descriptor */
X    int method;  /* compression method */
X{
X    ulg crc;  /* original crc */
X    static int first_time = 1;
X    static char* methods[MAX_METHODS] = {
X        "store",  /* 0 */
X        "compr",  /* 1 */
X        "pack ",  /* 2 */
X        "lzh  ",  /* 3 */
X        "", "", "", "", /* 4 to 7 reserved */
X        "defla"}; /* 8 */
X    char *date;
X
X    if (first_time && method >= 0) {
X	first_time = 0;
X	if (verbose)  {
X	    printf("method  crc     date  time  ");
X	}
X	if (!quiet) {
X	    printf("compressed  uncompr. ratio uncompressed_name\n");
X	}
X    } else if (method < 0) {
X	if (total_in <= 0 || total_out <= 0) return;
X	if (verbose) {
X	    printf("                            %9lu %9lu ",
X		   total_in, total_out);
X	} else if (!quiet) {
X	    printf("%9ld %9ld ", total_in, total_out);
X	}
X	display_ratio(total_out-(total_in-header_bytes), total_out, stdout);
X	/* header_bytes is not meaningful but used to ensure the same
X	 * ratio if there is a single file.
X	 */
X	printf(" (totals)\n");
X	return;
X    }
X    crc = ~0; /* unknown */
X    bytes_out = -1L;
X    bytes_in = ifile_size;
X
X#if RECORD_IO == 0
X    if (method == DEFLATED && !last_member) {
X        /* Get the crc and uncompressed size for gzip'ed (not zip'ed) files.
X         * If the lseek fails, we could use read() to get to the end, but
X         * --list is used to get quick results.
X         * Use "gunzip < foo.gz | wc -c" to get the uncompressed size if
X         * you are not concerned about speed.
X         */
X        bytes_in = (long)lseek(ifd, (off_t)(-8), SEEK_END);
X        if (bytes_in != -1L) {
X            uch buf[8];
X            bytes_in += 8L;
X            if (read(ifd, buf, sizeof(buf)) != sizeof(buf)) {
X                read_error();
X            }
X            crc       = LG(buf);
X	    bytes_out = LG(buf+4);
X	}
X    }
X#endif /* RECORD_IO */
X    date = ctime(&time_stamp) + 4; /* skip the day of the week */
X    date[12] = '\0';               /* suppress the 1/100sec and the year */
X    if (verbose) {
X        printf("%5s %08lx %11s ", methods[method], crc, date);
X    }
X    printf("%9ld %9ld ", bytes_in, bytes_out);
X    if (bytes_in  == -1L) {
X	total_in = -1L;
X	bytes_in = bytes_out = header_bytes = 0;
X    } else if (total_in >= 0) {
X	total_in  += bytes_in;
X    }
X    if (bytes_out == -1L) {
X	total_out = -1L;
X	bytes_in = bytes_out = header_bytes = 0;
X    } else if (total_out >= 0) {
X	total_out += bytes_out;
X    }
X    display_ratio(bytes_out-(bytes_in-header_bytes), bytes_out, stdout);
X    printf(" %s\n", ofname);
X}
X
X/* ========================================================================
X * Return true if the two stat structures correspond to the same file.
X */
Xlocal int same_file(stat1, stat2)
X    struct stat *stat1;
X    struct stat *stat2;
X{
X    return stat1->st_ino   == stat2->st_ino
X	&& stat1->st_dev   == stat2->st_dev
X#ifdef NO_ST_INO
X        /* Can't rely on st_ino and st_dev, use other fields: */
X	&& stat1->st_mode  == stat2->st_mode
X	&& stat1->st_uid   == stat2->st_uid
X	&& stat1->st_gid   == stat2->st_gid
X	&& stat1->st_size  == stat2->st_size
X	&& stat1->st_atime == stat2->st_atime
X	&& stat1->st_mtime == stat2->st_mtime
X	&& stat1->st_ctime == stat2->st_ctime
X#endif
X	    ;
X}
X
X/* ========================================================================
X * Return true if a file name is ambiguous because the operating system
X * truncates file names.
X */
Xlocal int name_too_long(name, statb)
X    char *name;           /* file name to check */
X    struct stat *statb;   /* stat buf for this file name */
X{
X    int s = strlen(name);
X    char c = name[s-1];
X    struct stat	tstat; /* stat for truncated name */
X    int res;
X
X    tstat = *statb;      /* Just in case OS does not fill all fields */
X    name[s-1] = '\0';
X    res = stat(name, &tstat) == 0 && same_file(statb, &tstat);
X    name[s-1] = c;
X    Trace((stderr, " too_long(%s) => %d\n", name, res));
X    return res;
X}
X
X/* ========================================================================
X * Shorten the given name by one character, or replace a .tar extension
X * with .tgz. Truncate the last part of the name which is longer than
X * MIN_PART characters: 1234.678.012.gz -> 123.678.012.gz. If the name
X * has only parts shorter than MIN_PART truncate the longest part.
X *
X * IN assertion: This function is only called for the compressed file;
X * the suffix of the given name is z_suffix.
X */
Xlocal void shorten_name(name)
X    char *name;
X{
X    int len;                 /* length of name without z_suffix */
X    char *trunc = NULL;      /* character to be truncated */
X    int plen;                /* current part length */
X    int min_part = MIN_PART; /* current minimum part length */
X    char *p;
X
X    p = get_suffix(name);
X    if (p == NULL) error("can't recover suffix\n");
X    *p = '\0';
X    len = strlen(name);
X    save_orig_name = 1;
X
X    /* compress 1234567890.tar to 1234567890.tgz */
X    if (len > 4 && strequ(p-4, ".tar")) {
X	strcpy(p-4, ".tgz");
X	return;
X    }
X    /* Try keeping short extensions intact:
X     * 1234.678.012.gz -> 123.678.012.gz
X     */
X    do {
X	p = strrchr(name, PATH_SEP);
X	p = p ? p+1 : name;
X	while (*p) {
X	    plen = strcspn(p, PART_SEP);
X	    p += plen;
X	    if (plen > min_part) trunc = p-1;
X	    if (*p) p++;
X	}
X    } while (trunc == NULL && --min_part != 0);
X
X    if (trunc != NULL) {
X	do {
X	    trunc[0] = trunc[1];
X	} while (*trunc++);
X	trunc--;
X    } else {
X	trunc = strrchr(name, PART_SEP[0]);
X	if (trunc == NULL) error("internal error in shorten_name");
X	if (trunc[1] == '\0') trunc--; /* force truncation */
X    }
X    strcpy(trunc, z_suffix);
X}
X
X/* ========================================================================
X * If compressing to a file, check if ofname is not ambiguous
X * because the operating system truncates names. Otherwise, generate
X * a new ofname and save the original name in the compressed file.
X * If the compressed file already exists, ask for confirmation.
X *    The check for name truncation is made dynamically, because different
X * file systems on the same OS might use different truncation rules (on SVR4
X * s5 truncates to 14 chars and ufs does not truncate).
X *    This function returns -1 if the file must be skipped, and
X * updates save_orig_name if necessary.
X * IN assertions: save_orig_name is already set if ofname has been
X * already truncated because of NO_MULTIPLE_DOTS. The input file has
X * already been open and istat is set.
X */
Xlocal int check_ofname()
X{
X    struct stat	ostat; /* stat for ofname */
X
X    if (stat(ofname, &ostat) != 0) return 0;
X
X    /* Check for name truncation on existing file: */
X    if (!decompress && name_too_long(ofname, &ostat)) {
X	shorten_name(ofname);
X	if (stat(ofname, &ostat) != 0) return 0;
X    }
X
X    /* Check that the input and output files are different (could be
X     * the same by name truncation or links).
X     */
X    if (same_file(&istat, &ostat)) {
X	fprintf(stderr, "%s: %s and %s are the same file\n",
X		progname, ifname, ofname);
X	exit_code = ERROR;
X	return ERROR;
X    }
X    /* Ask permission to overwrite the existing file */
X    if (!force) {
X	char response[80];
X	strcpy(response,"n");
X	fprintf(stderr, "%s: %s already exists;", progname, ofname);
X	if (foreground && isatty(fileno(stdin))) {
X	    fprintf(stderr, " do you wish to overwrite (y or n)? ");
X	    fflush(stderr);
X	    (void)fgets(response, sizeof(response)-1, stdin);
X	}
X	if (tolow(*response) != 'y') {
X	    fprintf(stderr, "\tnot overwritten\n");
X	    if (exit_code == OK) exit_code = WARNING;
X	    return ERROR;
X	}
X    }
X    (void) chmod(ofname, 0777);
X    if (unlink(ofname)) {
X	fprintf(stderr, "%s: ", progname);
X	perror(ofname);
X	exit_code = ERROR;
X	return ERROR;
X    }
X    return OK;
X}
X
X
X/* ========================================================================
X * Set the access and modification times from the given stat buffer.
X */
Xlocal void reset_times (name, statb)
X    char *name;
X    struct stat *statb;
X{
X#ifndef NO_UTIME
X    struct utimbuf	timep;
X
X    /* Copy the time stamp */
X    timep.actime  = statb->st_atime;
X    timep.modtime = statb->st_mtime;
X
X    /* Some systems (at least OS/2) do not support utime on directories */
X    if (utime(name, &timep) && !S_ISDIR(statb->st_mode)) {
X	WARN((stderr, "%s: ", progname));
X	if (!quiet) perror(ofname);
X    }
X#else
X    name = name; statb = statb; /* avoid warnings */
X#endif
X}
X
X
X/* ========================================================================
X * Copy modes, times, ownership from input file to output file.
X * IN assertion: to_stdout is false.
X */
Xlocal void copy_stat(ifstat)
X    struct stat *ifstat;
X{
X#ifndef NO_UTIME
X    if (decompress && time_stamp != 0 && ifstat->st_mtime != time_stamp) {
X	ifstat->st_mtime = time_stamp;
X	if (verbose) {
X	    fprintf(stderr, "%s: time stamp restored\n", ofname);
X	}
X    }
X    reset_times(ofname, ifstat);
X#endif
X    /* Copy the protection modes */
X    if (chmod(ofname, ifstat->st_mode & 07777)) {
X	WARN((stderr, "%s: ", progname));
X	if (!quiet) perror(ofname);
X    }
X#ifndef NO_CHOWN
X    chown(ofname, ifstat->st_uid, ifstat->st_gid);  /* Copy ownership */
X#endif
X    remove_ofname = 0;
X    /* It's now safe to remove the input file: */
X    (void) chmod(ifname, 0777);
X    if (unlink(ifname)) {
X	WARN((stderr, "%s: ", progname));
X	if (!quiet) perror(ifname);
X    }
X}
X
X#ifndef NO_DIR
X
X/* ========================================================================
X * Recurse through the given directory. This code is taken from ncompress.
X */
Xlocal void treat_dir(dir)
X    char *dir;
X{
X    dir_type *dp;
X    DIR      *dirp;
X    char     nbuf[MAX_PATH_LEN];
X    int      len;
X
X    dirp = opendir(dir);
X    
X    if (dirp == NULL) {
X	fprintf(stderr, "%s: %s unreadable\n", progname, dir);
X	exit_code = ERROR;
X	return ;
X    }
X    /*
X     ** WARNING: the following algorithm could occasionally cause
X     ** compress to produce error warnings of the form "<filename>.gz
X     ** already has .gz suffix - ignored". This occurs when the
X     ** .gz output file is inserted into the directory below
X     ** readdir's current pointer.
X     ** These warnings are harmless but annoying, so they are suppressed
X     ** with option -r (except when -v is on). An alternative
X     ** to allowing this would be to store the entire directory
X     ** list in memory, then compress the entries in the stored
X     ** list. Given the depth-first recursive algorithm used here,
X     ** this could use up a tremendous amount of memory. I don't
X     ** think it's worth it. -- Dave Mack
X     ** (An other alternative might be two passes to avoid depth-first.)
X     */
X    
X    while ((dp = readdir(dirp)) != NULL) {
X
X	if (strequ(dp->d_name,".") || strequ(dp->d_name,"..")) {
X	    continue;
X	}
X	len = strlen(dir);
X	if (len + NLENGTH(dp) + 1 < MAX_PATH_LEN - 1) {
X	    strcpy(nbuf,dir);
X	    if (len != 0 /* dir = "" means current dir on Amiga */
X#ifdef PATH_SEP2
X		&& dir[len-1] != PATH_SEP2
X#endif
X#ifdef PATH_SEP3
X		&& dir[len-1] != PATH_SEP3
X#endif
X	    ) {
X		nbuf[len++] = PATH_SEP;
X	    }
X	    strcpy(nbuf+len, dp->d_name);
X	    treat_file(nbuf);
X	} else {
X	    fprintf(stderr,"%s: %s/%s: pathname too long\n",
X		    progname, dir, dp->d_name);
X	    exit_code = ERROR;
X	}
X    }
X    closedir(dirp);
X}
X#endif /* ? NO_DIR */
X
X/* ========================================================================
X * Free all dynamically allocated variables and exit with the given code.
X */
Xlocal void do_exit(exitcode)
X    int exitcode;
X{
X    if (env != NULL)  free(env),  env  = NULL;
X    if (args != NULL) free((char*)args), args = NULL;
X    FREE(inbuf);
X    FREE(outbuf);
X    FREE(d_buf);
X    FREE(window);
X#ifndef MAXSEG_64K
X    FREE(tab_prefix);
X#else
X    FREE(tab_prefix0);
X    FREE(tab_prefix1);
X#endif
X    exit(exitcode);
X}
X
X/* ========================================================================
X * Signal and error handler.
X */
XRETSIGTYPE abort_gzip()
X{
X   if (remove_ofname) {
X       close(ofd);
X       unlink (ofname);
X   }
X   do_exit(ERROR);
X}
END_OF_FILE
if test 50229 -ne `wc -c <'gzip-1.2.2/gzip.c'`; then
    echo shar: \"'gzip-1.2.2/gzip.c'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/gzip.c'
fi
if test -f 'gzip-1.2.2/zip.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/zip.c'\"
else
echo shar: Extracting \"'gzip-1.2.2/zip.c'\" \(3170 characters\)
sed "s/^X//" >'gzip-1.2.2/zip.c' <<'END_OF_FILE'
X/* zip.c -- compress files to the gzip or pkzip format
X * Copyright (C) 1992-1993 Jean-loup Gailly
X * This is free software; you can redistribute it and/or modify it under the
X * terms of the GNU General Public License, see the file COPYING.
X */
X
X#ifndef lint
Xstatic char rcsid[] = "$Id: zip.c,v 0.17 1993/06/10 13:29:25 jloup Exp $";
X#endif
X
X#include <ctype.h>
X#include <sys/types.h>
X
X#include "tailor.h"
X#include "gzip.h"
X#include "crypt.h"
X
X#ifdef HAVE_UNISTD_H
X#  include <unistd.h>
X#endif
X#ifndef NO_FCNTL_H
X#  include <fcntl.h>
X#endif
X
Xlocal ulg crc;       /* crc on uncompressed file data */
Xlong header_bytes;   /* number of bytes in gzip header */
X
X/* ===========================================================================
X * Deflate in to out.
X * IN assertions: the input and output buffers are cleared.
X *   The variables time_stamp and save_orig_name are initialized.
X */
Xint zip(in, out)
X    int in, out;            /* input and output file descriptors */
X{
X    uch  flags = 0;         /* general purpose bit flags */
X    ush  attr = 0;          /* ascii/binary flag */
X    ush  deflate_flags = 0; /* pkzip -es, -en or -ex equivalent */
X
X    ifd = in;
X    ofd = out;
X    outcnt = 0;
X
X    /* Write the header to the gzip file. See algorithm.doc for the format */
X
X    method = DEFLATED;
X    put_byte(GZIP_MAGIC[0]); /* magic header */
X    put_byte(GZIP_MAGIC[1]);
X    put_byte(DEFLATED);      /* compression method */
X
X    if (save_orig_name) {
X	flags |= ORIG_NAME;
X    }
X    put_byte(flags);         /* general flags */
X    put_long(time_stamp);
X
X    /* Write deflated file to zip file */
X    crc = updcrc(0, 0);
X
X    bi_init(out);
X    ct_init(&attr, &method);
X    lm_init(level, &deflate_flags);
X
X    put_byte((uch)deflate_flags); /* extra flags */
X    put_byte(OS_CODE);            /* OS identifier */
X
X    if (save_orig_name) {
X	char *p = basename(ifname); /* Don't save the directory part. */
X	do {
X	    put_char(*p);
X	} while (*p++);
X    }
X    header_bytes = (long)outcnt;
X
X    (void)deflate();
X
X#if !defined(NO_SIZE_CHECK) && !defined(RECORD_IO)
X  /* Check input size (but not in VMS -- variable record lengths mess it up)
X   * and not on MSDOS -- diet in TSR mode reports an incorrect file size)
X   */
X    if (ifile_size != -1L && isize != (ulg)ifile_size) {
X	Trace((stderr, " actual=%ld, read=%ld ", ifile_size, isize));
X	fprintf(stderr, "%s: %s: file size changed while zipping\n",
X		progname, ifname);
X    }
X#endif
X
X    /* Write the crc and uncompressed size */
X    put_long(crc);
X    put_long(isize);
X    header_bytes += 2*sizeof(long);
X
X    flush_outbuf();
X    return OK;
X}
X
X
X/* ===========================================================================
X * Read a new buffer from the current input file, perform end-of-line
X * translation, and update the crc and input file size.
X * IN assertion: size >= 2 (for end-of-line translation)
X */
Xint file_read(buf, size)
X    char *buf;
X    unsigned size;
X{
X    unsigned len;
X
X    Assert(insize == 0, "inbuf not empty");
X
X    len = read(ifd, buf, size);
X    if (len == (unsigned)(-1) || len == 0) return (int)len;
X
X    crc = updcrc((uch*)buf, len);
X    isize += (ulg)len;
X    return (int)len;
X}
END_OF_FILE
if test 3170 -ne `wc -c <'gzip-1.2.2/zip.c'`; then
    echo shar: \"'gzip-1.2.2/zip.c'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/zip.c'
fi
if test -f 'gzip-1.2.2/deflate.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/deflate.c'\"
else
echo shar: Extracting \"'gzip-1.2.2/deflate.c'\" \(29149 characters\)
sed "s/^X//" >'gzip-1.2.2/deflate.c' <<'END_OF_FILE'
X/* deflate.c -- compress data using the deflation algorithm
X * Copyright (C) 1992-1993 Jean-loup Gailly
X * This is free software; you can redistribute it and/or modify it under the
X * terms of the GNU General Public License, see the file COPYING.
X */
X
X/*
X *  PURPOSE
X *
X *      Identify new text as repetitions of old text within a fixed-
X *      length sliding window trailing behind the new text.
X *
X *  DISCUSSION
X *
X *      The "deflation" process depends on being able to identify portions
X *      of the input text which are identical to earlier input (within a
X *      sliding window trailing behind the input currently being processed).
X *
X *      The most straightforward technique turns out to be the fastest for
X *      most input files: try all possible matches and select the longest.
X *      The key feature of this algorithm is that insertions into the string
X *      dictionary are very simple and thus fast, and deletions are avoided
X *      completely. Insertions are performed at each input character, whereas
X *      string matches are performed only when the previous match ends. So it
X *      is preferable to spend more time in matches to allow very fast string
X *      insertions and avoid deletions. The matching algorithm for small
X *      strings is inspired from that of Rabin & Karp. A brute force approach
X *      is used to find longer strings when a small match has been found.
X *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
X *      (by Leonid Broukhis).
X *         A previous version of this file used a more sophisticated algorithm
X *      (by Fiala and Greene) which is guaranteed to run in linear amortized
X *      time, but has a larger average cost, uses more memory and is patented.
X *      However the F&G algorithm may be faster for some highly redundant
X *      files if the parameter max_chain_length (described below) is too large.
X *
X *  ACKNOWLEDGEMENTS
X *
X *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
X *      I found it in 'freeze' written by Leonid Broukhis.
X *      Thanks to many info-zippers for bug reports and testing.
X *
X *  REFERENCES
X *
X *      APPNOTE.TXT documentation file in PKZIP 1.93a distribution.
X *
X *      A description of the Rabin and Karp algorithm is given in the book
X *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
X *
X *      Fiala,E.R., and Greene,D.H.
X *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
X *
X *  INTERFACE
X *
X *      void lm_init (int pack_level, ush *flags)
X *          Initialize the "longest match" routines for a new file
X *
X *      ulg deflate (void)
X *          Processes a new input file and return its compressed length. Sets
X *          the compressed length, crc, deflate flags and internal file
X *          attributes.
X */
X
X#include <stdio.h>
X
X#include "tailor.h"
X#include "gzip.h"
X#include "lzw.h" /* just for consistency checking */
X
X#ifndef lint
Xstatic char rcsid[] = "$Id: deflate.c,v 0.14 1993/06/12 20:11:10 jloup Exp $";
X#endif
X
X/* ===========================================================================
X * Configuration parameters
X */
X
X/* Compile with MEDIUM_MEM to reduce the memory requirements or
X * with SMALL_MEM to use as little memory as possible. Use BIG_MEM if the
X * entire input file can be held in memory (not possible on 16 bit systems).
X * Warning: defining these symbols affects HASH_BITS (see below) and thus
X * affects the compression ratio. The compressed output
X * is still correct, and might even be smaller in some cases.
X */
X
X#ifdef SMALL_MEM
X#   define HASH_BITS  13  /* Number of bits used to hash strings */
X#endif
X#ifdef MEDIUM_MEM
X#   define HASH_BITS  14
X#endif
X#ifndef HASH_BITS
X#   define HASH_BITS  15
X   /* For portability to 16 bit machines, do not use values above 15. */
X#endif
X
X/* To save space (see unlzw.c), we overlay prev+head with tab_prefix and
X * window with tab_suffix. Check that we can do this:
X */
X#if WSIZE<<1 > 1<<BITS
X   error: cannot overlay window with tab_suffix and prev with tab_prefix0
X#endif
X#if HASH_BITS > BITS-1
X   error: cannot overlay head with tab_prefix1
X#endif
X
X#define HASH_SIZE (unsigned)(1<<HASH_BITS)
X#define HASH_MASK (HASH_SIZE-1)
X#define WMASK     (WSIZE-1)
X/* HASH_SIZE and WSIZE must be powers of two */
X
X#define NIL 0
X/* Tail of hash chains */
X
X#define FAST 4
X#define SLOW 2
X/* speed options for the general purpose bit flag */
X
X#ifndef TOO_FAR
X#  define TOO_FAR 4096
X#endif
X/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
X
X/* ===========================================================================
X * Local data used by the "longest match" routines.
X */
X
Xtypedef ush Pos;
Xtypedef unsigned IPos;
X/* A Pos is an index in the character window. We use short instead of int to
X * save space in the various tables. IPos is used only for parameter passing.
X */
X
X/* DECLARE(uch, window, 2L*WSIZE); */
X/* Sliding window. Input bytes are read into the second half of the window,
X * and move to the first half later to keep a dictionary of at least WSIZE
X * bytes. With this organization, matches are limited to a distance of
X * WSIZE-MAX_MATCH bytes, but this ensures that IO is always
X * performed with a length multiple of the block size. Also, it limits
X * the window size to 64K, which is quite useful on MSDOS.
X * To do: limit the window size to WSIZE+BSZ if SMALL_MEM (the code would
X * be less efficient).
X */
X
X/* DECLARE(Pos, prev, WSIZE); */
X/* Link to older string with same hash index. To limit the size of this
X * array to 64K, this link is maintained only for the last 32K strings.
X * An index in this array is thus a window index modulo 32K.
X */
X
X/* DECLARE(Pos, head, 1<<HASH_BITS); */
X/* Heads of the hash chains or NIL. */
X
Xulg window_size = (ulg)2*WSIZE;
X/* window size, 2*WSIZE except for MMAP or BIG_MEM, where it is the
X * input file length plus MIN_LOOKAHEAD.
X */
X
Xlong block_start;
X/* window position at the beginning of the current output block. Gets
X * negative when the window is moved backwards.
X */
X
Xlocal unsigned ins_h;  /* hash index of string to be inserted */
X
X#define H_SHIFT  ((HASH_BITS+MIN_MATCH-1)/MIN_MATCH)
X/* Number of bits by which ins_h and del_h must be shifted at each
X * input step. It must be such that after MIN_MATCH steps, the oldest
X * byte no longer takes part in the hash key, that is:
X *   H_SHIFT * MIN_MATCH >= HASH_BITS
X */
X
Xunsigned int near prev_length;
X/* Length of the best match at previous step. Matches not greater than this
X * are discarded. This is used in the lazy match evaluation.
X */
X
X      unsigned near strstart;      /* start of string to insert */
X      unsigned near match_start;   /* start of matching string */
Xlocal int           eofile;        /* flag set at end of input file */
Xlocal unsigned      lookahead;     /* number of valid bytes ahead in window */
X
Xunsigned near max_chain_length;
X/* To speed up deflation, hash chains are never searched beyond this length.
X * A higher limit improves compression ratio but degrades the speed.
X */
X
Xlocal unsigned int max_lazy_match;
X/* Attempt to find a better match only when the current match is strictly
X * smaller than this value. This mechanism is used only for compression
X * levels >= 4.
X */
X#define max_insert_length  max_lazy_match
X/* Insert new strings in the hash table only if the match length
X * is not greater than this length. This saves time but degrades compression.
X * max_insert_length is used only for compression levels <= 3.
X */
X
Xlocal int compr_level;
X/* compression level (1..9) */
X
Xint near good_match;
X/* Use a faster search when the previous match is longer than this */
X
X
X/* Values for max_lazy_match, good_match and max_chain_length, depending on
X * the desired pack level (0..9). The values given below have been tuned to
X * exclude worst case performance for pathological files. Better values may be
X * found for specific files.
X */
X
Xtypedef struct config {
X   ush good_length; /* reduce lazy search above this match length */
X   ush max_lazy;    /* do not perform lazy search above this match length */
X   ush nice_length; /* quit search above this match length */
X   ush max_chain;
X} config;
X
X#ifdef  FULL_SEARCH
X# define nice_match MAX_MATCH
X#else
X  int near nice_match; /* Stop searching when current match exceeds this */
X#endif
X
Xlocal config configuration_table[10] = {
X/*      good lazy nice chain */
X/* 0 */ {0,    0,  0,    0},  /* store only */
X/* 1 */ {4,    4,  8,    4},  /* maximum speed, no lazy matches */
X/* 2 */ {4,    5, 16,    8},
X/* 3 */ {4,    6, 32,   32},
X
X/* 4 */ {4,    4, 16,   16},  /* lazy matches */
X/* 5 */ {8,   16, 32,   32},
X/* 6 */ {8,   16, 128, 128},
X/* 7 */ {8,   32, 128, 256},
X/* 8 */ {32, 128, 258, 1024},
X/* 9 */ {32, 258, 258, 4096}}; /* maximum compression */
X
X/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
X * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
X * meaning.
X */
X
X#define EQUAL 0
X/* result of memcmp for equal strings */
X
X/* ===========================================================================
X *  Prototypes for local functions.
X */
Xlocal void fill_window   OF((void));
Xlocal ulg deflate_fast   OF((void));
X
X      int  longest_match OF((IPos cur_match));
X#ifdef ASMV
X      void match_init OF((void)); /* asm code initialization */
X#endif
X
X#ifdef DEBUG
Xlocal  void check_match OF((IPos start, IPos match, int length));
X#endif
X
X/* ===========================================================================
X * Update a hash value with the given input byte
X * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
X *    input characters, so that a running hash key can be computed from the
X *    previous key instead of complete recalculation each time.
X */
X#define UPDATE_HASH(h,c) (h = (((h)<<H_SHIFT) ^ (c)) & HASH_MASK)
X
X/* ===========================================================================
X * Insert string s in the dictionary and set match_head to the previous head
X * of the hash chain (the most recent string with same hash key). Return
X * the previous length of the hash chain.
X * IN  assertion: all calls to to INSERT_STRING are made with consecutive
X *    input characters and the first MIN_MATCH bytes of s are valid
X *    (except for the last MIN_MATCH-1 bytes of the input file).
X */
X#define INSERT_STRING(s, match_head) \
X   (UPDATE_HASH(ins_h, window[(s) + MIN_MATCH-1]), \
X    prev[(s) & WMASK] = match_head = head[ins_h], \
X    head[ins_h] = (s))
X
X/* ===========================================================================
X * Initialize the "longest match" routines for a new file
X */
Xvoid lm_init (pack_level, flags)
X    int pack_level; /* 0: store, 1: best speed, 9: best compression */
X    ush *flags;     /* general purpose bit flag */
X{
X    register unsigned j;
X
X    if (pack_level < 1 || pack_level > 9) error("bad pack level");
X    compr_level = pack_level;
X
X    /* Initialize the hash table. */
X#if defined(MAXSEG_64K) && HASH_BITS == 15
X    for (j = 0;  j < HASH_SIZE; j++) head[j] = NIL;
X#else
X    memzero((char*)head, HASH_SIZE*sizeof(*head));
X#endif
X    /* prev will be initialized on the fly */
X
X    /* Set the default configuration parameters:
X     */
X    max_lazy_match   = configuration_table[pack_level].max_lazy;
X    good_match       = configuration_table[pack_level].good_length;
X#ifndef FULL_SEARCH
X    nice_match       = configuration_table[pack_level].nice_length;
X#endif
X    max_chain_length = configuration_table[pack_level].max_chain;
X    if (pack_level == 1) {
X       *flags |= FAST;
X    } else if (pack_level == 9) {
X       *flags |= SLOW;
X    }
X    /* ??? reduce max_chain_length for binary files */
X
X    strstart = 0;
X    block_start = 0L;
X#ifdef ASMV
X    match_init(); /* initialize the asm code */
X#endif
X
X    lookahead = read_buf((char*)window,
X			 sizeof(int) <= 2 ? (unsigned)WSIZE : 2*WSIZE);
X
X    if (lookahead == 0 || lookahead == (unsigned)EOF) {
X       eofile = 1, lookahead = 0;
X       return;
X    }
X    eofile = 0;
X    /* Make sure that we always have enough lookahead. This is important
X     * if input comes from a device such as a tty.
X     */
X    while (lookahead < MIN_LOOKAHEAD && !eofile) fill_window();
X
X    ins_h = 0;
X    for (j=0; j<MIN_MATCH-1; j++) UPDATE_HASH(ins_h, window[j]);
X    /* If lookahead < MIN_MATCH, ins_h is garbage, but this is
X     * not important since only literal bytes will be emitted.
X     */
X}
X
X/* ===========================================================================
X * Set match_start to the longest match starting at the given string and
X * return its length. Matches shorter or equal to prev_length are discarded,
X * in which case the result is equal to prev_length and match_start is
X * garbage.
X * IN assertions: cur_match is the head of the hash chain for the current
X *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
X */
X#ifndef ASMV
X/* For MSDOS, OS/2 and 386 Unix, an optimized version is in match.asm or
X * match.s. The code is functionally equivalent, so you can use the C version
X * if desired.
X */
Xint longest_match(cur_match)
X    IPos cur_match;                             /* current match */
X{
X    unsigned chain_length = max_chain_length;   /* max hash chain length */
X    register uch *scan = window + strstart;     /* current string */
X    register uch *match;                        /* matched string */
X    register int len;                           /* length of current match */
X    int best_len = prev_length;                 /* best match length so far */
X    IPos limit = strstart > (IPos)MAX_DIST ? strstart - (IPos)MAX_DIST : NIL;
X    /* Stop when cur_match becomes <= limit. To simplify the code,
X     * we prevent matches with the string of window index 0.
X     */
X
X/* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
X * It is easy to get rid of this optimization if necessary.
X */
X#if HASH_BITS < 8 || MAX_MATCH != 258
X   error: Code too clever
X#endif
X
X#ifdef UNALIGNED_OK
X    /* Compare two bytes at a time. Note: this is not always beneficial.
X     * Try with and without -DUNALIGNED_OK to check.
X     */
X    register uch *strend = window + strstart + MAX_MATCH - 1;
X    register ush scan_start = *(ush*)scan;
X    register ush scan_end   = *(ush*)(scan+best_len-1);
X#else
X    register uch *strend = window + strstart + MAX_MATCH;
X    register uch scan_end1  = scan[best_len-1];
X    register uch scan_end   = scan[best_len];
X#endif
X
X    /* Do not waste too much time if we already have a good match: */
X    if (prev_length >= good_match) {
X        chain_length >>= 2;
X    }
X    Assert(strstart <= window_size-MIN_LOOKAHEAD, "insufficient lookahead");
X
X    do {
X        Assert(cur_match < strstart, "no future");
X        match = window + cur_match;
X
X        /* Skip to next match if the match length cannot increase
X         * or if the match length is less than 2:
X         */
X#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
X        /* This code assumes sizeof(unsigned short) == 2. Do not use
X         * UNALIGNED_OK if your compiler uses a different size.
X         */
X        if (*(ush*)(match+best_len-1) != scan_end ||
X            *(ush*)match != scan_start) continue;
X
X        /* It is not necessary to compare scan[2] and match[2] since they are
X         * always equal when the other bytes match, given that the hash keys
X         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
X         * strstart+3, +5, ... up to strstart+257. We check for insufficient
X         * lookahead only every 4th comparison; the 128th check will be made
X         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
X         * necessary to put more guard bytes at the end of the window, or
X         * to check more often for insufficient lookahead.
X         */
X        scan++, match++;
X        do {
X        } while (*(ush*)(scan+=2) == *(ush*)(match+=2) &&
X                 *(ush*)(scan+=2) == *(ush*)(match+=2) &&
X                 *(ush*)(scan+=2) == *(ush*)(match+=2) &&
X                 *(ush*)(scan+=2) == *(ush*)(match+=2) &&
X                 scan < strend);
X        /* The funny "do {}" generates better code on most compilers */
X
X        /* Here, scan <= window+strstart+257 */
X        Assert(scan <= window+(unsigned)(window_size-1), "wild scan");
X        if (*scan == *match) scan++;
X
X        len = (MAX_MATCH - 1) - (int)(strend-scan);
X        scan = strend - (MAX_MATCH-1);
X
X#else /* UNALIGNED_OK */
X
X        if (match[best_len]   != scan_end  ||
X            match[best_len-1] != scan_end1 ||
X            *match            != *scan     ||
X            *++match          != scan[1])      continue;
X
X        /* The check at best_len-1 can be removed because it will be made
X         * again later. (This heuristic is not always a win.)
X         * It is not necessary to compare scan[2] and match[2] since they
X         * are always equal when the other bytes match, given that
X         * the hash keys are equal and that HASH_BITS >= 8.
X         */
X        scan += 2, match++;
X
X        /* We check for insufficient lookahead only every 8th comparison;
X         * the 256th check will be made at strstart+258.
X         */
X        do {
X        } while (*++scan == *++match && *++scan == *++match &&
X                 *++scan == *++match && *++scan == *++match &&
X                 *++scan == *++match && *++scan == *++match &&
X                 *++scan == *++match && *++scan == *++match &&
X                 scan < strend);
X
X        len = MAX_MATCH - (int)(strend - scan);
X        scan = strend - MAX_MATCH;
X
X#endif /* UNALIGNED_OK */
X
X        if (len > best_len) {
X            match_start = cur_match;
X            best_len = len;
X            if (len >= nice_match) break;
X#ifdef UNALIGNED_OK
X            scan_end = *(ush*)(scan+best_len-1);
X#else
X            scan_end1  = scan[best_len-1];
X            scan_end   = scan[best_len];
X#endif
X        }
X    } while ((cur_match = prev[cur_match & WMASK]) > limit
X	     && --chain_length != 0);
X
X    return best_len;
X}
X#endif /* ASMV */
X
X#ifdef DEBUG
X/* ===========================================================================
X * Check that the match at match_start is indeed a match.
X */
Xlocal void check_match(start, match, length)
X    IPos start, match;
X    int length;
X{
X    /* check that the match is indeed a match */
X    if (memcmp((char*)window + match,
X                (char*)window + start, length) != EQUAL) {
X        fprintf(stderr,
X            " start %d, match %d, length %d\n",
X            start, match, length);
X        error("invalid match");
X    }
X    if (verbose > 1) {
X        fprintf(stderr,"\\[%d,%d]", start-match, length);
X        do { putc(window[start++], stderr); } while (--length != 0);
X    }
X}
X#else
X#  define check_match(start, match, length)
X#endif
X
X/* ===========================================================================
X * Fill the window when the lookahead becomes insufficient.
X * Updates strstart and lookahead, and sets eofile if end of input file.
X * IN assertion: lookahead < MIN_LOOKAHEAD && strstart + lookahead > 0
X * OUT assertions: at least one byte has been read, or eofile is set;
X *    file reads are performed for at least two bytes (required for the
X *    translate_eol option).
X */
Xlocal void fill_window()
X{
X    register unsigned n, m;
X    unsigned more = (unsigned)(window_size - (ulg)lookahead - (ulg)strstart);
X    /* Amount of free space at the end of the window. */
X
X    /* If the window is almost full and there is insufficient lookahead,
X     * move the upper half to the lower one to make room in the upper half.
X     */
X    if (more == (unsigned)EOF) {
X        /* Very unlikely, but possible on 16 bit machine if strstart == 0
X         * and lookahead == 1 (input done one byte at time)
X         */
X        more--;
X    } else if (strstart >= WSIZE+MAX_DIST) {
X        /* By the IN assertion, the window is not empty so we can't confuse
X         * more == 0 with more == 64K on a 16 bit machine.
X         */
X        Assert(window_size == (ulg)2*WSIZE, "no sliding with BIG_MEM");
X
X        memcpy((char*)window, (char*)window+WSIZE, (unsigned)WSIZE);
X        match_start -= WSIZE;
X        strstart    -= WSIZE; /* we now have strstart >= MAX_DIST: */
X
X        block_start -= (long) WSIZE;
X
X        for (n = 0; n < HASH_SIZE; n++) {
X            m = head[n];
X            head[n] = (Pos)(m >= WSIZE ? m-WSIZE : NIL);
X        }
X        for (n = 0; n < WSIZE; n++) {
X            m = prev[n];
X            prev[n] = (Pos)(m >= WSIZE ? m-WSIZE : NIL);
X            /* If n is not on any hash chain, prev[n] is garbage but
X             * its value will never be used.
X             */
X        }
X        more += WSIZE;
X    }
X    /* At this point, more >= 2 */
X    if (!eofile) {
X        n = read_buf((char*)window+strstart+lookahead, more);
X        if (n == 0 || n == (unsigned)EOF) {
X            eofile = 1;
X        } else {
X            lookahead += n;
X        }
X    }
X}
X
X/* ===========================================================================
X * Flush the current block, with given end-of-file flag.
X * IN assertion: strstart is set to the end of the current match.
X */
X#define FLUSH_BLOCK(eof) \
X   flush_block(block_start >= 0L ? (char*)&window[(unsigned)block_start] : \
X                (char*)NULL, (long)strstart - block_start, (eof))
X
X/* ===========================================================================
X * Processes a new input file and return its compressed length. This
X * function does not perform lazy evaluationof matches and inserts
X * new strings in the dictionary only for unmatched strings. It is used
X * only for the fast compression options.
X */
Xlocal ulg deflate_fast()
X{
X    IPos hash_head; /* head of the hash chain */
X    int flush;      /* set if current block must be flushed */
X    unsigned match_length = 0;  /* length of best match */
X
X    prev_length = MIN_MATCH-1;
X    while (lookahead != 0) {
X        /* Insert the string window[strstart .. strstart+2] in the
X         * dictionary, and set hash_head to the head of the hash chain:
X         */
X        INSERT_STRING(strstart, hash_head);
X
X        /* Find the longest match, discarding those <= prev_length.
X         * At this point we have always match_length < MIN_MATCH
X         */
X        if (hash_head != NIL && strstart - hash_head <= MAX_DIST) {
X            /* To simplify the code, we prevent matches with the string
X             * of window index 0 (in particular we have to avoid a match
X             * of the string with itself at the start of the input file).
X             */
X            match_length = longest_match (hash_head);
X            /* longest_match() sets match_start */
X            if (match_length > lookahead) match_length = lookahead;
X        }
X        if (match_length >= MIN_MATCH) {
X            check_match(strstart, match_start, match_length);
X
X            flush = ct_tally(strstart-match_start, match_length - MIN_MATCH);
X
X            lookahead -= match_length;
X
X	    /* Insert new strings in the hash table only if the match length
X             * is not too large. This saves time but degrades compression.
X             */
X            if (match_length <= max_insert_length) {
X                match_length--; /* string at strstart already in hash table */
X                do {
X                    strstart++;
X                    INSERT_STRING(strstart, hash_head);
X                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
X                     * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH
X                     * these bytes are garbage, but it does not matter since
X                     * the next lookahead bytes will be emitted as literals.
X                     */
X                } while (--match_length != 0);
X	        strstart++; 
X            } else {
X	        strstart += match_length;
X	        match_length = 0;
X	        ins_h = window[strstart];
X	        UPDATE_HASH(ins_h, window[strstart+1]);
X#if MIN_MATCH != 3
X                Call UPDATE_HASH() MIN_MATCH-3 more times
X#endif
X            }
X        } else {
X            /* No match, output a literal byte */
X            Tracevv((stderr,"%c",window[strstart]));
X            flush = ct_tally (0, window[strstart]);
X            lookahead--;
X	    strstart++; 
X        }
X        if (flush) FLUSH_BLOCK(0), block_start = strstart;
X
X        /* Make sure that we always have enough lookahead, except
X         * at the end of the input file. We need MAX_MATCH bytes
X         * for the next match, plus MIN_MATCH bytes to insert the
X         * string following the next match.
X         */
X        while (lookahead < MIN_LOOKAHEAD && !eofile) fill_window();
X
X    }
X    return FLUSH_BLOCK(1); /* eof */
X}
X
X/* ===========================================================================
X * Same as above, but achieves better compression. We use a lazy
X * evaluation for matches: a match is finally adopted only if there is
X * no better match at the next window position.
X */
Xulg deflate()
X{
X    IPos hash_head;          /* head of hash chain */
X    IPos prev_match;         /* previous match */
X    int flush;               /* set if current block must be flushed */
X    int match_available = 0; /* set if previous match exists */
X    register unsigned match_length = MIN_MATCH-1; /* length of best match */
X#ifdef DEBUG
X    extern long isize;        /* byte length of input file, for debug only */
X#endif
X
X    if (compr_level <= 3) return deflate_fast(); /* optimized for speed */
X
X    /* Process the input block. */
X    while (lookahead != 0) {
X        /* Insert the string window[strstart .. strstart+2] in the
X         * dictionary, and set hash_head to the head of the hash chain:
X         */
X        INSERT_STRING(strstart, hash_head);
X
X        /* Find the longest match, discarding those <= prev_length.
X         */
X        prev_length = match_length, prev_match = match_start;
X        match_length = MIN_MATCH-1;
X
X        if (hash_head != NIL && prev_length < max_lazy_match &&
X            strstart - hash_head <= MAX_DIST) {
X            /* To simplify the code, we prevent matches with the string
X             * of window index 0 (in particular we have to avoid a match
X             * of the string with itself at the start of the input file).
X             */
X            match_length = longest_match (hash_head);
X            /* longest_match() sets match_start */
X            if (match_length > lookahead) match_length = lookahead;
X
X            /* Ignore a length 3 match if it is too distant: */
X            if (match_length == MIN_MATCH && strstart-match_start > TOO_FAR){
X                /* If prev_match is also MIN_MATCH, match_start is garbage
X                 * but we will ignore the current match anyway.
X                 */
X                match_length--;
X            }
X        }
X        /* If there was a match at the previous step and the current
X         * match is not better, output the previous match:
X         */
X        if (prev_length >= MIN_MATCH && match_length <= prev_length) {
X
X            check_match(strstart-1, prev_match, prev_length);
X
X            flush = ct_tally(strstart-1-prev_match, prev_length - MIN_MATCH);
X
X            /* Insert in hash table all strings up to the end of the match.
X             * strstart-1 and strstart are already inserted.
X             */
X            lookahead -= prev_length-1;
X            prev_length -= 2;
X            do {
X                strstart++;
X                INSERT_STRING(strstart, hash_head);
X                /* strstart never exceeds WSIZE-MAX_MATCH, so there are
X                 * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH
X                 * these bytes are garbage, but it does not matter since the
X                 * next lookahead bytes will always be emitted as literals.
X                 */
X            } while (--prev_length != 0);
X            match_available = 0;
X            match_length = MIN_MATCH-1;
X            strstart++;
X            if (flush) FLUSH_BLOCK(0), block_start = strstart;
X
X        } else if (match_available) {
X            /* If there was no match at the previous position, output a
X             * single literal. If there was a match but the current match
X             * is longer, truncate the previous match to a single literal.
X             */
X            Tracevv((stderr,"%c",window[strstart-1]));
X            if (ct_tally (0, window[strstart-1])) {
X                FLUSH_BLOCK(0), block_start = strstart;
X            }
X            strstart++;
X            lookahead--;
X        } else {
X            /* There is no previous match to compare with, wait for
X             * the next step to decide.
X             */
X            match_available = 1;
X            strstart++;
X            lookahead--;
X        }
X        Assert (strstart <= isize && lookahead <= isize, "a bit too far");
X
X        /* Make sure that we always have enough lookahead, except
X         * at the end of the input file. We need MAX_MATCH bytes
X         * for the next match, plus MIN_MATCH bytes to insert the
X         * string following the next match.
X         */
X        while (lookahead < MIN_LOOKAHEAD && !eofile) fill_window();
X    }
X    if (match_available) ct_tally (0, window[strstart-1]);
X
X    return FLUSH_BLOCK(1); /* eof */
X}
END_OF_FILE
if test 29149 -ne `wc -c <'gzip-1.2.2/deflate.c'`; then
    echo shar: \"'gzip-1.2.2/deflate.c'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/deflate.c'
fi
if test -f 'gzip-1.2.2/trees.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/trees.c'\"
else
echo shar: Extracting \"'gzip-1.2.2/trees.c'\" \(40691 characters\)
sed "s/^X//" >'gzip-1.2.2/trees.c' <<'END_OF_FILE'
X/* trees.c -- output deflated data using Huffman coding
X * Copyright (C) 1992-1993 Jean-loup Gailly
X * This is free software; you can redistribute it and/or modify it under the
X * terms of the GNU General Public License, see the file COPYING.
X */
X
X/*
X *  PURPOSE
X *
X *      Encode various sets of source values using variable-length
X *      binary code trees.
X *
X *  DISCUSSION
X *
X *      The PKZIP "deflation" process uses several Huffman trees. The more
X *      common source values are represented by shorter bit sequences.
X *
X *      Each code tree is stored in the ZIP file in a compressed form
X *      which is itself a Huffman encoding of the lengths of
X *      all the code strings (in ascending order by source values).
X *      The actual code strings are reconstructed from the lengths in
X *      the UNZIP process, as described in the "application note"
X *      (APPNOTE.TXT) distributed as part of PKWARE's PKZIP program.
X *
X *  REFERENCES
X *
X *      Lynch, Thomas J.
X *          Data Compression:  Techniques and Applications, pp. 53-55.
X *          Lifetime Learning Publications, 1985.  ISBN 0-534-03418-7.
X *
X *      Storer, James A.
X *          Data Compression:  Methods and Theory, pp. 49-50.
X *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
X *
X *      Sedgewick, R.
X *          Algorithms, p290.
X *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
X *
X *  INTERFACE
X *
X *      void ct_init (ush *attr, int *methodp)
X *          Allocate the match buffer, initialize the various tables and save
X *          the location of the internal file attribute (ascii/binary) and
X *          method (DEFLATE/STORE)
X *
X *      void ct_tally (int dist, int lc);
X *          Save the match info and tally the frequency counts.
X *
X *      long flush_block (char *buf, ulg stored_len, int eof)
X *          Determine the best encoding for the current block: dynamic trees,
X *          static trees or store, and output the encoded block to the zip
X *          file. Returns the total compressed length for the file so far.
X *
X */
X
X#include <ctype.h>
X
X#include "tailor.h"
X#include "gzip.h"
X
X#ifndef lint
Xstatic char rcsid[] = "$Id: trees.c,v 0.12 1993/06/10 13:27:54 jloup Exp $";
X#endif
X
X/* ===========================================================================
X * Constants
X */
X
X#define MAX_BITS 15
X/* All codes must not exceed MAX_BITS bits */
X
X#define MAX_BL_BITS 7
X/* Bit length codes must not exceed MAX_BL_BITS bits */
X
X#define LENGTH_CODES 29
X/* number of length codes, not counting the special END_BLOCK code */
X
X#define LITERALS  256
X/* number of literal bytes 0..255 */
X
X#define END_BLOCK 256
X/* end of block literal code */
X
X#define L_CODES (LITERALS+1+LENGTH_CODES)
X/* number of Literal or Length codes, including the END_BLOCK code */
X
X#define D_CODES   30
X/* number of distance codes */
X
X#define BL_CODES  19
X/* number of codes used to transfer the bit lengths */
X
X
Xlocal int near extra_lbits[LENGTH_CODES] /* extra bits for each length code */
X   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
X
Xlocal int near extra_dbits[D_CODES] /* extra bits for each distance code */
X   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
X
Xlocal int near extra_blbits[BL_CODES]/* extra bits for each bit length code */
X   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};
X
X#define STORED_BLOCK 0
X#define STATIC_TREES 1
X#define DYN_TREES    2
X/* The three kinds of block type */
X
X#ifndef LIT_BUFSIZE
X#  ifdef SMALL_MEM
X#    define LIT_BUFSIZE  0x2000
X#  else
X#  ifdef MEDIUM_MEM
X#    define LIT_BUFSIZE  0x4000
X#  else
X#    define LIT_BUFSIZE  0x8000
X#  endif
X#  endif
X#endif
X#ifndef DIST_BUFSIZE
X#  define DIST_BUFSIZE  LIT_BUFSIZE
X#endif
X/* Sizes of match buffers for literals/lengths and distances.  There are
X * 4 reasons for limiting LIT_BUFSIZE to 64K:
X *   - frequencies can be kept in 16 bit counters
X *   - if compression is not successful for the first block, all input data is
X *     still in the window so we can still emit a stored block even when input
X *     comes from standard input.  (This can also be done for all blocks if
X *     LIT_BUFSIZE is not greater than 32K.)
X *   - if compression is not successful for a file smaller than 64K, we can
X *     even emit a stored file instead of a stored block (saving 5 bytes).
X *   - creating new Huffman trees less frequently may not provide fast
X *     adaptation to changes in the input data statistics. (Take for
X *     example a binary file with poorly compressible code followed by
X *     a highly compressible string table.) Smaller buffer sizes give
X *     fast adaptation but have of course the overhead of transmitting trees
X *     more frequently.
X *   - I can't count above 4
X * The current code is general and allows DIST_BUFSIZE < LIT_BUFSIZE (to save
X * memory at the expense of compression). Some optimizations would be possible
X * if we rely on DIST_BUFSIZE == LIT_BUFSIZE.
X */
X#if LIT_BUFSIZE > INBUFSIZ
X    error cannot overlay l_buf and inbuf
X#endif
X
X#define REP_3_6      16
X/* repeat previous bit length 3-6 times (2 bits of repeat count) */
X
X#define REPZ_3_10    17
X/* repeat a zero length 3-10 times  (3 bits of repeat count) */
X
X#define REPZ_11_138  18
X/* repeat a zero length 11-138 times  (7 bits of repeat count) */
X
X/* ===========================================================================
X * Local data
X */
X
X/* Data structure describing a single value and its code string. */
Xtypedef struct ct_data {
X    union {
X        ush  freq;       /* frequency count */
X        ush  code;       /* bit string */
X    } fc;
X    union {
X        ush  dad;        /* father node in Huffman tree */
X        ush  len;        /* length of bit string */
X    } dl;
X} ct_data;
X
X#define Freq fc.freq
X#define Code fc.code
X#define Dad  dl.dad
X#define Len  dl.len
X
X#define HEAP_SIZE (2*L_CODES+1)
X/* maximum heap size */
X
Xlocal ct_data near dyn_ltree[HEAP_SIZE];   /* literal and length tree */
Xlocal ct_data near dyn_dtree[2*D_CODES+1]; /* distance tree */
X
Xlocal ct_data near static_ltree[L_CODES+2];
X/* The static literal tree. Since the bit lengths are imposed, there is no
X * need for the L_CODES extra codes used during heap construction. However
X * The codes 286 and 287 are needed to build a canonical tree (see ct_init
X * below).
X */
X
Xlocal ct_data near static_dtree[D_CODES];
X/* The static distance tree. (Actually a trivial tree since all codes use
X * 5 bits.)
X */
X
Xlocal ct_data near bl_tree[2*BL_CODES+1];
X/* Huffman tree for the bit lengths */
X
Xtypedef struct tree_desc {
X    ct_data near *dyn_tree;      /* the dynamic tree */
X    ct_data near *static_tree;   /* corresponding static tree or NULL */
X    int     near *extra_bits;    /* extra bits for each code or NULL */
X    int     extra_base;          /* base index for extra_bits */
X    int     elems;               /* max number of elements in the tree */
X    int     max_length;          /* max bit length for the codes */
X    int     max_code;            /* largest code with non zero frequency */
X} tree_desc;
X
Xlocal tree_desc near l_desc =
X{dyn_ltree, static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS, 0};
X
Xlocal tree_desc near d_desc =
X{dyn_dtree, static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS, 0};
X
Xlocal tree_desc near bl_desc =
X{bl_tree, (ct_data near *)0, extra_blbits, 0,      BL_CODES, MAX_BL_BITS, 0};
X
X
Xlocal ush near bl_count[MAX_BITS+1];
X/* number of codes at each bit length for an optimal tree */
X
Xlocal uch near bl_order[BL_CODES]
X   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
X/* The lengths of the bit length codes are sent in order of decreasing
X * probability, to avoid transmitting the lengths for unused bit length codes.
X */
X
Xlocal int near heap[2*L_CODES+1]; /* heap used to build the Huffman trees */
Xlocal int heap_len;               /* number of elements in the heap */
Xlocal int heap_max;               /* element of largest frequency */
X/* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
X * The same heap array is used to build all trees.
X */
X
Xlocal uch near depth[2*L_CODES+1];
X/* Depth of each subtree used as tie breaker for trees of equal frequency */
X
Xlocal uch length_code[MAX_MATCH-MIN_MATCH+1];
X/* length code for each normalized match length (0 == MIN_MATCH) */
X
Xlocal uch dist_code[512];
X/* distance codes. The first 256 values correspond to the distances
X * 3 .. 258, the last 256 values correspond to the top 8 bits of
X * the 15 bit distances.
X */
X
Xlocal int near base_length[LENGTH_CODES];
X/* First normalized length for each code (0 = MIN_MATCH) */
X
Xlocal int near base_dist[D_CODES];
X/* First normalized distance for each code (0 = distance of 1) */
X
X#define l_buf inbuf
X/* DECLARE(uch, l_buf, LIT_BUFSIZE);  buffer for literals or lengths */
X
X/* DECLARE(ush, d_buf, DIST_BUFSIZE); buffer for distances */
X
Xlocal uch near flag_buf[(LIT_BUFSIZE/8)];
X/* flag_buf is a bit array distinguishing literals from lengths in
X * l_buf, thus indicating the presence or absence of a distance.
X */
X
Xlocal unsigned last_lit;    /* running index in l_buf */
Xlocal unsigned last_dist;   /* running index in d_buf */
Xlocal unsigned last_flags;  /* running index in flag_buf */
Xlocal uch flags;            /* current flags not yet saved in flag_buf */
Xlocal uch flag_bit;         /* current bit used in flags */
X/* bits are filled in flags starting at bit 0 (least significant).
X * Note: these flags are overkill in the current code since we don't
X * take advantage of DIST_BUFSIZE == LIT_BUFSIZE.
X */
X
Xlocal ulg opt_len;        /* bit length of current block with optimal trees */
Xlocal ulg static_len;     /* bit length of current block with static trees */
X
Xlocal ulg compressed_len; /* total bit length of compressed file */
X
Xlocal ulg input_len;      /* total byte length of input file */
X/* input_len is for debugging only since we can get it by other means. */
X
Xush *file_type;        /* pointer to UNKNOWN, BINARY or ASCII */
Xint *file_method;      /* pointer to DEFLATE or STORE */
X
X#ifdef DEBUG
Xextern ulg bits_sent;  /* bit length of the compressed data */
Xextern long isize;     /* byte length of input file */
X#endif
X
Xextern long block_start;       /* window offset of current block */
Xextern unsigned near strstart; /* window offset of current string */
X
X/* ===========================================================================
X * Local (static) routines in this file.
X */
X
Xlocal void init_block     OF((void));
Xlocal void pqdownheap     OF((ct_data near *tree, int k));
Xlocal void gen_bitlen     OF((tree_desc near *desc));
Xlocal void gen_codes      OF((ct_data near *tree, int max_code));
Xlocal void build_tree     OF((tree_desc near *desc));
Xlocal void scan_tree      OF((ct_data near *tree, int max_code));
Xlocal void send_tree      OF((ct_data near *tree, int max_code));
Xlocal int  build_bl_tree  OF((void));
Xlocal void send_all_trees OF((int lcodes, int dcodes, int blcodes));
Xlocal void compress_block OF((ct_data near *ltree, ct_data near *dtree));
Xlocal void set_file_type  OF((void));
X
X
X#ifndef DEBUG
X#  define send_code(c, tree) send_bits(tree[c].Code, tree[c].Len)
X   /* Send a code of the given tree. c and tree must not have side effects */
X
X#else /* DEBUG */
X#  define send_code(c, tree) \
X     { if (verbose>1) fprintf(stderr,"\ncd %3d ",(c)); \
X       send_bits(tree[c].Code, tree[c].Len); }
X#endif
X
X#define d_code(dist) \
X   ((dist) < 256 ? dist_code[dist] : dist_code[256+((dist)>>7)])
X/* Mapping from a distance to a distance code. dist is the distance - 1 and
X * must not have side effects. dist_code[256] and dist_code[257] are never
X * used.
X */
X
X#define MAX(a,b) (a >= b ? a : b)
X/* the arguments must not have side effects */
X
X/* ===========================================================================
X * Allocate the match buffer, initialize the various tables and save the
X * location of the internal file attribute (ascii/binary) and method
X * (DEFLATE/STORE).
X */
Xvoid ct_init(attr, methodp)
X    ush  *attr;   /* pointer to internal file attribute */
X    int  *methodp; /* pointer to compression method */
X{
X    int n;        /* iterates over tree elements */
X    int bits;     /* bit counter */
X    int length;   /* length value */
X    int code;     /* code value */
X    int dist;     /* distance index */
X
X    file_type = attr;
X    file_method = methodp;
X    compressed_len = input_len = 0L;
X        
X    if (static_dtree[0].Len != 0) return; /* ct_init already called */
X
X    /* Initialize the mapping length (0..255) -> length code (0..28) */
X    length = 0;
X    for (code = 0; code < LENGTH_CODES-1; code++) {
X        base_length[code] = length;
X        for (n = 0; n < (1<<extra_lbits[code]); n++) {
X            length_code[length++] = (uch)code;
X        }
X    }
X    Assert (length == 256, "ct_init: length != 256");
X    /* Note that the length 255 (match length 258) can be represented
X     * in two different ways: code 284 + 5 bits or code 285, so we
X     * overwrite length_code[255] to use the best encoding:
X     */
X    length_code[length-1] = (uch)code;
X
X    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
X    dist = 0;
X    for (code = 0 ; code < 16; code++) {
X        base_dist[code] = dist;
X        for (n = 0; n < (1<<extra_dbits[code]); n++) {
X            dist_code[dist++] = (uch)code;
X        }
X    }
X    Assert (dist == 256, "ct_init: dist != 256");
X    dist >>= 7; /* from now on, all distances are divided by 128 */
X    for ( ; code < D_CODES; code++) {
X        base_dist[code] = dist << 7;
X        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
X            dist_code[256 + dist++] = (uch)code;
X        }
X    }
X    Assert (dist == 256, "ct_init: 256+dist != 512");
X
X    /* Construct the codes of the static literal tree */
X    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
X    n = 0;
X    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
X    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
X    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
X    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
X    /* Codes 286 and 287 do not exist, but we must include them in the
X     * tree construction to get a canonical Huffman tree (longest code
X     * all ones)
X     */
X    gen_codes((ct_data near *)static_ltree, L_CODES+1);
X
X    /* The static distance tree is trivial: */
X    for (n = 0; n < D_CODES; n++) {
X        static_dtree[n].Len = 5;
X        static_dtree[n].Code = bi_reverse(n, 5);
X    }
X
X    /* Initialize the first block of the first file: */
X    init_block();
X}
X
X/* ===========================================================================
X * Initialize a new block.
X */
Xlocal void init_block()
X{
X    int n; /* iterates over tree elements */
X
X    /* Initialize the trees. */
X    for (n = 0; n < L_CODES;  n++) dyn_ltree[n].Freq = 0;
X    for (n = 0; n < D_CODES;  n++) dyn_dtree[n].Freq = 0;
X    for (n = 0; n < BL_CODES; n++) bl_tree[n].Freq = 0;
X
X    dyn_ltree[END_BLOCK].Freq = 1;
X    opt_len = static_len = 0L;
X    last_lit = last_dist = last_flags = 0;
X    flags = 0; flag_bit = 1;
X}
X
X#define SMALLEST 1
X/* Index within the heap array of least frequent node in the Huffman tree */
X
X
X/* ===========================================================================
X * Remove the smallest element from the heap and recreate the heap with
X * one less element. Updates heap and heap_len.
X */
X#define pqremove(tree, top) \
X{\
X    top = heap[SMALLEST]; \
X    heap[SMALLEST] = heap[heap_len--]; \
X    pqdownheap(tree, SMALLEST); \
X}
X
X/* ===========================================================================
X * Compares to subtrees, using the tree depth as tie breaker when
X * the subtrees have equal frequency. This minimizes the worst case length.
X */
X#define smaller(tree, n, m) \
X   (tree[n].Freq < tree[m].Freq || \
X   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))
X
X/* ===========================================================================
X * Restore the heap property by moving down the tree starting at node k,
X * exchanging a node with the smallest of its two sons if necessary, stopping
X * when the heap property is re-established (each father smaller than its
X * two sons).
X */
Xlocal void pqdownheap(tree, k)
X    ct_data near *tree;  /* the tree to restore */
X    int k;               /* node to move down */
X{
X    int v = heap[k];
X    int j = k << 1;  /* left son of k */
X    while (j <= heap_len) {
X        /* Set j to the smallest of the two sons: */
X        if (j < heap_len && smaller(tree, heap[j+1], heap[j])) j++;
X
X        /* Exit if v is smaller than both sons */
X        if (smaller(tree, v, heap[j])) break;
X
X        /* Exchange v with the smallest son */
X        heap[k] = heap[j];  k = j;
X
X        /* And continue down the tree, setting j to the left son of k */
X        j <<= 1;
X    }
X    heap[k] = v;
X}
X
X/* ===========================================================================
X * Compute the optimal bit lengths for a tree and update the total bit length
X * for the current block.
X * IN assertion: the fields freq and dad are set, heap[heap_max] and
X *    above are the tree nodes sorted by increasing frequency.
X * OUT assertions: the field len is set to the optimal bit length, the
X *     array bl_count contains the frequencies for each bit length.
X *     The length opt_len is updated; static_len is also updated if stree is
X *     not null.
X */
Xlocal void gen_bitlen(desc)
X    tree_desc near *desc; /* the tree descriptor */
X{
X    ct_data near *tree  = desc->dyn_tree;
X    int near *extra     = desc->extra_bits;
X    int base            = desc->extra_base;
X    int max_code        = desc->max_code;
X    int max_length      = desc->max_length;
X    ct_data near *stree = desc->static_tree;
X    int h;              /* heap index */
X    int n, m;           /* iterate over the tree elements */
X    int bits;           /* bit length */
X    int xbits;          /* extra bits */
X    ush f;              /* frequency */
X    int overflow = 0;   /* number of elements with bit length too large */
X
X    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
X
X    /* In a first pass, compute the optimal bit lengths (which may
X     * overflow in the case of the bit length tree).
X     */
X    tree[heap[heap_max]].Len = 0; /* root of the heap */
X
X    for (h = heap_max+1; h < HEAP_SIZE; h++) {
X        n = heap[h];
X        bits = tree[tree[n].Dad].Len + 1;
X        if (bits > max_length) bits = max_length, overflow++;
X        tree[n].Len = (ush)bits;
X        /* We overwrite tree[n].Dad which is no longer needed */
X
X        if (n > max_code) continue; /* not a leaf node */
X
X        bl_count[bits]++;
X        xbits = 0;
X        if (n >= base) xbits = extra[n-base];
X        f = tree[n].Freq;
X        opt_len += (ulg)f * (bits + xbits);
X        if (stree) static_len += (ulg)f * (stree[n].Len + xbits);
X    }
X    if (overflow == 0) return;
X
X    Trace((stderr,"\nbit length overflow\n"));
X    /* This happens for example on obj2 and pic of the Calgary corpus */
X
X    /* Find the first bit length which could increase: */
X    do {
X        bits = max_length-1;
X        while (bl_count[bits] == 0) bits--;
X        bl_count[bits]--;      /* move one leaf down the tree */
X        bl_count[bits+1] += 2; /* move one overflow item as its brother */
X        bl_count[max_length]--;
X        /* The brother of the overflow item also moves one step up,
X         * but this does not affect bl_count[max_length]
X         */
X        overflow -= 2;
X    } while (overflow > 0);
X
X    /* Now recompute all bit lengths, scanning in increasing frequency.
X     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
X     * lengths instead of fixing only the wrong ones. This idea is taken
X     * from 'ar' written by Haruhiko Okumura.)
X     */
X    for (bits = max_length; bits != 0; bits--) {
X        n = bl_count[bits];
X        while (n != 0) {
X            m = heap[--h];
X            if (m > max_code) continue;
X            if (tree[m].Len != (unsigned) bits) {
X                Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
X                opt_len += ((long)bits-(long)tree[m].Len)*(long)tree[m].Freq;
X                tree[m].Len = (ush)bits;
X            }
X            n--;
X        }
X    }
X}
X
X/* ===========================================================================
X * Generate the codes for a given tree and bit counts (which need not be
X * optimal).
X * IN assertion: the array bl_count contains the bit length statistics for
X * the given tree and the field len is set for all tree elements.
X * OUT assertion: the field code is set for all tree elements of non
X *     zero code length.
X */
Xlocal void gen_codes (tree, max_code)
X    ct_data near *tree;        /* the tree to decorate */
X    int max_code;              /* largest code with non zero frequency */
X{
X    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
X    ush code = 0;              /* running code value */
X    int bits;                  /* bit index */
X    int n;                     /* code index */
X
X    /* The distribution counts are first used to generate the code values
X     * without bit reversal.
X     */
X    for (bits = 1; bits <= MAX_BITS; bits++) {
X        next_code[bits] = code = (code.html + bl_count[bits-1]) << 1;
X    }
X    /* Check that the bit counts in bl_count are consistent. The last code
X     * must be all ones.
X     */
X    Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
X            "inconsistent bit counts");
X    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
X
X    for (n = 0;  n <= max_code; n++) {
X        int len = tree[n].Len;
X        if (len == 0) continue;
X        /* Now reverse the bits */
X        tree[n].Code = bi_reverse(next_code[len]++, len);
X
X        Tracec(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
X             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
X    }
X}
X
X/* ===========================================================================
X * Construct one Huffman tree and assigns the code bit strings and lengths.
X * Update the total bit length for the current block.
X * IN assertion: the field freq is set for all tree elements.
X * OUT assertions: the fields len and code are set to the optimal bit length
X *     and corresponding code. The length opt_len is updated; static_len is
X *     also updated if stree is not null. The field max_code is set.
X */
Xlocal void build_tree(desc)
X    tree_desc near *desc; /* the tree descriptor */
X{
X    ct_data near *tree   = desc->dyn_tree;
X    ct_data near *stree  = desc->static_tree;
X    int elems            = desc->elems;
X    int n, m;          /* iterate over heap elements */
X    int max_code = -1; /* largest code with non zero frequency */
X    int node = elems;  /* next internal node of the tree */
X
X    /* Construct the initial heap, with least frequent element in
X     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
X     * heap[0] is not used.
X     */
X    heap_len = 0, heap_max = HEAP_SIZE;
X
X    for (n = 0; n < elems; n++) {
X        if (tree[n].Freq != 0) {
X            heap[++heap_len] = max_code = n;
X            depth[n] = 0;
X        } else {
X            tree[n].Len = 0;
X        }
X    }
X
X    /* The pkzip format requires that at least one distance code exists,
X     * and that at least one bit should be sent even if there is only one
X     * possible code. So to avoid special checks later on we force at least
X     * two codes of non zero frequency.
X     */
X    while (heap_len < 2) {
X        int new = heap[++heap_len] = (max_code < 2 ? ++max_code : 0);
X        tree[new].Freq = 1;
X        depth[new] = 0;
X        opt_len--; if (stree) static_len -= stree[new].Len;
X        /* new is 0 or 1 so it does not have extra bits */
X    }
X    desc->max_code = max_code;
X
X    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
X     * establish sub-heaps of increasing lengths:
X     */
X    for (n = heap_len/2; n >= 1; n--) pqdownheap(tree, n);
X
X    /* Construct the Huffman tree by repeatedly combining the least two
X     * frequent nodes.
X     */
X    do {
X        pqremove(tree, n);   /* n = node of least frequency */
X        m = heap[SMALLEST];  /* m = node of next least frequency */
X
X        heap[--heap_max] = n; /* keep the nodes sorted by frequency */
X        heap[--heap_max] = m;
X
X        /* Create a new node father of n and m */
X        tree[node].Freq = tree[n].Freq + tree[m].Freq;
X        depth[node] = (uch) (MAX(depth[n], depth[m]) + 1);
X        tree[n].Dad = tree[m].Dad = (ush)node;
X#ifdef DUMP_BL_TREE
X        if (tree == bl_tree) {
X            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
X                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
X        }
X#endif
X        /* and insert the new node in the heap */
X        heap[SMALLEST] = node++;
X        pqdownheap(tree, SMALLEST);
X
X    } while (heap_len >= 2);
X
X    heap[--heap_max] = heap[SMALLEST];
X
X    /* At this point, the fields freq and dad are set. We can now
X     * generate the bit lengths.
X     */
X    gen_bitlen((tree_desc near *)desc);
X
X    /* The field len is now set, we can generate the bit codes */
X    gen_codes ((ct_data near *)tree, max_code);
X}
X
X/* ===========================================================================
X * Scan a literal or distance tree to determine the frequencies of the codes
X * in the bit length tree. Updates opt_len to take into account the repeat
X * counts. (The contribution of the bit length codes will be added later
X * during the construction of bl_tree.)
X */
Xlocal void scan_tree (tree, max_code)
X    ct_data near *tree; /* the tree to be scanned */
X    int max_code;       /* and its largest code of non zero frequency */
X{
X    int n;                     /* iterates over all tree elements */
X    int prevlen = -1;          /* last emitted length */
X    int curlen;                /* length of current code */
X    int nextlen = tree[0].Len; /* length of next code */
X    int count = 0;             /* repeat count of the current code */
X    int max_count = 7;         /* max repeat count */
X    int min_count = 4;         /* min repeat count */
X
X    if (nextlen == 0) max_count = 138, min_count = 3;
X    tree[max_code+1].Len = (ush)0xffff; /* guard */
X
X    for (n = 0; n <= max_code; n++) {
X        curlen = nextlen; nextlen = tree[n+1].Len;
X        if (++count < max_count && curlen == nextlen) {
X            continue;
X        } else if (count < min_count) {
X            bl_tree[curlen].Freq += count;
X        } else if (curlen != 0) {
X            if (curlen != prevlen) bl_tree[curlen].Freq++;
X            bl_tree[REP_3_6].Freq++;
X        } else if (count <= 10) {
X            bl_tree[REPZ_3_10].Freq++;
X        } else {
X            bl_tree[REPZ_11_138].Freq++;
X        }
X        count = 0; prevlen = curlen;
X        if (nextlen == 0) {
X            max_count = 138, min_count = 3;
X        } else if (curlen == nextlen) {
X            max_count = 6, min_count = 3;
X        } else {
X            max_count = 7, min_count = 4;
X        }
X    }
X}
X
X/* ===========================================================================
X * Send a literal or distance tree in compressed form, using the codes in
X * bl_tree.
X */
Xlocal void send_tree (tree, max_code)
X    ct_data near *tree; /* the tree to be scanned */
X    int max_code;       /* and its largest code of non zero frequency */
X{
X    int n;                     /* iterates over all tree elements */
X    int prevlen = -1;          /* last emitted length */
X    int curlen;                /* length of current code */
X    int nextlen = tree[0].Len; /* length of next code */
X    int count = 0;             /* repeat count of the current code */
X    int max_count = 7;         /* max repeat count */
X    int min_count = 4;         /* min repeat count */
X
X    /* tree[max_code+1].Len = -1; */  /* guard already set */
X    if (nextlen == 0) max_count = 138, min_count = 3;
X
X    for (n = 0; n <= max_code; n++) {
X        curlen = nextlen; nextlen = tree[n+1].Len;
X        if (++count < max_count && curlen == nextlen) {
X            continue;
X        } else if (count < min_count) {
X            do { send_code(curlen, bl_tree); } while (--count != 0);
X
X        } else if (curlen != 0) {
X            if (curlen != prevlen) {
X                send_code(curlen, bl_tree); count--;
X            }
X            Assert(count >= 3 && count <= 6, " 3_6?");
X            send_code(REP_3_6, bl_tree); send_bits(count-3, 2);
X
X        } else if (count <= 10) {
X            send_code(REPZ_3_10, bl_tree); send_bits(count-3, 3);
X
X        } else {
X            send_code(REPZ_11_138, bl_tree); send_bits(count-11, 7);
X        }
X        count = 0; prevlen = curlen;
X        if (nextlen == 0) {
X            max_count = 138, min_count = 3;
X        } else if (curlen == nextlen) {
X            max_count = 6, min_count = 3;
X        } else {
X            max_count = 7, min_count = 4;
X        }
X    }
X}
X
X/* ===========================================================================
X * Construct the Huffman tree for the bit lengths and return the index in
X * bl_order of the last bit length code to send.
X */
Xlocal int build_bl_tree()
X{
X    int max_blindex;  /* index of last bit length code of non zero freq */
X
X    /* Determine the bit length frequencies for literal and distance trees */
X    scan_tree((ct_data near *)dyn_ltree, l_desc.max_code);
X    scan_tree((ct_data near *)dyn_dtree, d_desc.max_code);
X
X    /* Build the bit length tree: */
X    build_tree((tree_desc near *)(&bl_desc));
X    /* opt_len now includes the length of the tree representations, except
X     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
X     */
X
X    /* Determine the number of bit length codes to send. The pkzip format
X     * requires that at least 4 bit length codes be sent. (appnote.txt says
X     * 3 but the actual value used is 4.)
X     */
X    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
X        if (bl_tree[bl_order[max_blindex]].Len != 0) break;
X    }
X    /* Update opt_len to include the bit length tree and counts */
X    opt_len += 3*(max_blindex+1) + 5+5+4;
X    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld", opt_len, static_len));
X
X    return max_blindex;
X}
X
X/* ===========================================================================
X * Send the header for a block using dynamic Huffman trees: the counts, the
X * lengths of the bit length codes, the literal tree and the distance tree.
X * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
X */
Xlocal void send_all_trees(lcodes, dcodes, blcodes)
X    int lcodes, dcodes, blcodes; /* number of codes for each tree */
X{
X    int rank;                    /* index in bl_order */
X
X    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
X    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
X            "too many codes");
X    Tracev((stderr, "\nbl counts: "));
X    send_bits(lcodes-257, 5); /* not +255 as stated in appnote.txt */
X    send_bits(dcodes-1,   5);
X    send_bits(blcodes-4,  4); /* not -3 as stated in appnote.txt */
X    for (rank = 0; rank < blcodes; rank++) {
X        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
X        send_bits(bl_tree[bl_order[rank]].Len, 3);
X    }
X    Tracev((stderr, "\nbl tree: sent %ld", bits_sent));
X
X    send_tree((ct_data near *)dyn_ltree, lcodes-1); /* send the literal tree */
X    Tracev((stderr, "\nlit tree: sent %ld", bits_sent));
X
X    send_tree((ct_data near *)dyn_dtree, dcodes-1); /* send the distance tree */
X    Tracev((stderr, "\ndist tree: sent %ld", bits_sent));
X}
X
X/* ===========================================================================
X * Determine the best encoding for the current block: dynamic trees, static
X * trees or store, and output the encoded block to the zip file. This function
X * returns the total compressed length for the file so far.
X */
Xulg flush_block(buf, stored_len, eof)
X    char *buf;        /* input block, or NULL if too old */
X    ulg stored_len;   /* length of input block */
X    int eof;          /* true if this is the last block for a file */
X{
X    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
X    int max_blindex;  /* index of last bit length code of non zero freq */
X
X    flag_buf[last_flags] = flags; /* Save the flags for the last 8 items */
X
X     /* Check if the file is ascii or binary */
X    if (*file_type == (ush)UNKNOWN) set_file_type();
X
X    /* Construct the literal and distance trees */
X    build_tree((tree_desc near *)(&l_desc));
X    Tracev((stderr, "\nlit data: dyn %ld, stat %ld", opt_len, static_len));
X
X    build_tree((tree_desc near *)(&d_desc));
X    Tracev((stderr, "\ndist data: dyn %ld, stat %ld", opt_len, static_len));
X    /* At this point, opt_len and static_len are the total bit lengths of
X     * the compressed block data, excluding the tree representations.
X     */
X
X    /* Build the bit length tree for the above two trees, and get the index
X     * in bl_order of the last bit length code to send.
X     */
X    max_blindex = build_bl_tree();
X
X    /* Determine the best encoding. Compute first the block length in bytes */
X    opt_lenb = (opt_len+3+7)>>3;
X    static_lenb = (static_len+3+7)>>3;
X    input_len += stored_len; /* for debugging only */
X
X    Trace((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u dist %u ",
X            opt_lenb, opt_len, static_lenb, static_len, stored_len,
X            last_lit, last_dist));
X
X    if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
X
X    /* If compression failed and this is the first and last block,
X     * and if the zip file can be seeked (to rewrite the local header),
X     * the whole file is transformed into a stored file:
X     */
X#ifdef FORCE_METHOD
X    if (level == 1 && eof && compressed_len == 0L) { /* force stored file */
X#else
X    if (stored_len <= opt_lenb && eof && compressed_len == 0L && seekable()) {
X#endif
X        /* Since LIT_BUFSIZE <= 2*WSIZE, the input data must be there: */
X        if (buf == (char*)0) error ("block vanished");
X
X        copy_block(buf, (unsigned)stored_len, 0); /* without header */
X        compressed_len = stored_len << 3;
X        *file_method = STORED;
X
X#ifdef FORCE_METHOD
X    } else if (level == 2 && buf != (char*)0) { /* force stored block */
X#else
X    } else if (stored_len+4 <= opt_lenb && buf != (char*)0) {
X                       /* 4: two words for the lengths */
X#endif
X        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
X         * Otherwise we can't have processed more than WSIZE input bytes since
X         * the last block flush, because compression would have been
X         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
X         * transform a block into a stored block.
X         */
X        send_bits((STORED_BLOCK<<1)+eof, 3);  /* send block type */
X        compressed_len = (compressed_len + 3 + 7) & ~7L;
X        compressed_len += (stored_len + 4) << 3;
X
X        copy_block(buf, (unsigned)stored_len, 1); /* with header */
X
X#ifdef FORCE_METHOD
X    } else if (level == 3) { /* force static trees */
X#else
X    } else if (static_lenb == opt_lenb) {
X#endif
X        send_bits((STATIC_TREES<<1)+eof, 3);
X        compress_block((ct_data near *)static_ltree, (ct_data near *)static_dtree);
X        compressed_len += 3 + static_len;
X    } else {
X        send_bits((DYN_TREES<<1)+eof, 3);
X        send_all_trees(l_desc.max_code+1, d_desc.max_code+1, max_blindex+1);
X        compress_block((ct_data near *)dyn_ltree, (ct_data near *)dyn_dtree);
X        compressed_len += 3 + opt_len;
X    }
X    Assert (compressed_len == bits_sent, "bad compressed size");
X    init_block();
X
X    if (eof) {
X        Assert (input_len == isize, "bad input size");
X        bi_windup();
X        compressed_len += 7;  /* align on byte boundary */
X    }
X    Tracev((stderr,"\ncomprlen %lu(%lu) ", compressed_len>>3,
X           compressed_len-7*eof));
X
X    return compressed_len >> 3;
X}
X
X/* ===========================================================================
X * Save the match info and tally the frequency counts. Return true if
X * the current block must be flushed.
X */
Xint ct_tally (dist, lc)
X    int dist;  /* distance of matched string */
X    int lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
X{
X    l_buf[last_lit++] = (uch)lc;
X    if (dist == 0) {
X        /* lc is the unmatched char */
X        dyn_ltree[lc].Freq++;
X    } else {
X        /* Here, lc is the match length - MIN_MATCH */
X        dist--;             /* dist = match distance - 1 */
X        Assert((ush)dist < (ush)MAX_DIST &&
X               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
X               (ush)d_code(dist) < (ush)D_CODES,  "ct_tally: bad match");
X
X        dyn_ltree[length_code[lc]+LITERALS+1].Freq++;
X        dyn_dtree[d_code(dist)].Freq++;
X
X        d_buf[last_dist++] = (ush)dist;
X        flags |= flag_bit;
X    }
X    flag_bit <<= 1;
X
X    /* Output the flags if they fill a byte: */
X    if ((last_lit & 7) == 0) {
X        flag_buf[last_flags++] = flags;
X        flags = 0, flag_bit = 1;
X    }
X    /* Try to guess if it is profitable to stop the current block here */
X    if (level > 2 && (last_lit & 0xfff) == 0) {
X        /* Compute an upper bound for the compressed length */
X        ulg out_length = (ulg)last_lit*8L;
X        ulg in_length = (ulg)strstart-block_start;
X        int dcode;
X        for (dcode = 0; dcode < D_CODES; dcode++) {
X            out_length += (ulg)dyn_dtree[dcode].Freq*(5L+extra_dbits[dcode]);
X        }
X        out_length >>= 3;
X        Trace((stderr,"\nlast_lit %u, last_dist %u, in %ld, out ~%ld(%ld%%) ",
X               last_lit, last_dist, in_length, out_length,
X               100L - out_length*100L/in_length));
X        if (last_dist < last_lit/2 && out_length < in_length/2) return 1;
X    }
X    return (last_lit == LIT_BUFSIZE-1 || last_dist == DIST_BUFSIZE);
X    /* We avoid equality with LIT_BUFSIZE because of wraparound at 64K
X     * on 16 bit machines and because stored blocks are restricted to
X     * 64K-1 bytes.
X     */
X}
X
X/* ===========================================================================
X * Send the block data compressed using the given Huffman trees
X */
Xlocal void compress_block(ltree, dtree)
X    ct_data near *ltree; /* literal tree */
X    ct_data near *dtree; /* distance tree */
X{
X    unsigned dist;      /* distance of matched string */
X    int lc;             /* match length or unmatched char (if dist == 0) */
X    unsigned lx = 0;    /* running index in l_buf */
X    unsigned dx = 0;    /* running index in d_buf */
X    unsigned fx = 0;    /* running index in flag_buf */
X    uch flag = 0;       /* current flags */
X    unsigned code;      /* the code to send */
X    int extra;          /* number of extra bits to send */
X
X    if (last_lit != 0) do {
X        if ((lx & 7) == 0) flag = flag_buf[fx++];
X        lc = l_buf[lx++];
X        if ((flag & 1) == 0) {
X            send_code(lc, ltree); /* send a literal byte */
X            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
X        } else {
X            /* Here, lc is the match length - MIN_MATCH */
X            code = length_code%5blc%5d%3b.html
X            send_code(code+LITERALS+1, ltree); /* send the length code */
X            extra = extra_lbits[code];
X            if (extra != 0) {
X                lc -= base_length[code];
X                send_bits(lc, extra);        /* send the extra length bits */
X            }
X            dist = d_buf[dx++];
X            /* Here, dist is the match distance - 1 */
X            code = d_code(dist)%3b.html
X            Assert (code < D_CODES, "bad d_code");
X
X            send_code(code, dtree);       /* send the distance code */
X            extra = extra_dbits[code];
X            if (extra != 0) {
X                dist -= base_dist[code];
X                send_bits(dist, extra);   /* send the extra distance bits */
X            }
X        } /* literal or match pair ? */
X        flag >>= 1;
X    } while (lx < last_lit);
X
X    send_code(END_BLOCK, ltree);
X}
X
X/* ===========================================================================
X * Set the file type to ASCII or BINARY, using a crude approximation:
X * binary if more than 20% of the bytes are <= 6 or >= 128, ascii otherwise.
X * IN assertion: the fields freq of dyn_ltree are set and the total of all
X * frequencies does not exceed 64K (to fit in an int on 16 bit machines).
X */
Xlocal void set_file_type()
X{
X    int n = 0;
X    unsigned ascii_freq = 0;
X    unsigned bin_freq = 0;
X    while (n < 7)        bin_freq += dyn_ltree[n++].Freq;
X    while (n < 128)    ascii_freq += dyn_ltree[n++].Freq;
X    while (n < LITERALS) bin_freq += dyn_ltree[n++].Freq;
X    *file_type = bin_freq > (ascii_freq >> 2) ? BINARY : ASCII;
X    if (*file_type == BINARY && translate_eol) {
X        warn("-l used on binary file", "");
X    }
X}
END_OF_FILE
if test 40691 -ne `wc -c <'gzip-1.2.2/trees.c'`; then
    echo shar: \"'gzip-1.2.2/trees.c'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/trees.c'
fi
if test -f 'gzip-1.2.2/bits.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/bits.c'\"
else
echo shar: Extracting \"'gzip-1.2.2/bits.c'\" \(5878 characters\)
sed "s/^X//" >'gzip-1.2.2/bits.c' <<'END_OF_FILE'
X/* bits.c -- output variable-length bit strings
X * Copyright (C) 1992-1993 Jean-loup Gailly
X * This is free software; you can redistribute it and/or modify it under the
X * terms of the GNU General Public License, see the file COPYING.
X */
X
X
X/*
X *  PURPOSE
X *
X *      Output variable-length bit strings. Compression can be done
X *      to a file or to memory. (The latter is not supported in this version.)
X *
X *  DISCUSSION
X *
X *      The PKZIP "deflate" file format interprets compressed file data
X *      as a sequence of bits.  Multi-bit strings in the file may cross
X *      byte boundaries without restriction.
X *
X *      The first bit of each byte is the low-order bit.
X *
X *      The routines in this file allow a variable-length bit value to
X *      be output right-to-left (useful for literal values). For
X *      left-to-right output (useful for code strings from the tree routines),
X *      the bits must have been reversed first with bi_reverse().
X *
X *      For in-memory compression, the compressed bit stream goes directly
X *      into the requested output buffer. The input data is read in blocks
X *      by the mem_read() function. The buffer is limited to 64K on 16 bit
X *      machines.
X *
X *  INTERFACE
X *
X *      void bi_init (FILE *zipfile)
X *          Initialize the bit string routines.
X *
X *      void send_bits (int value, int length)
X *          Write out a bit string, taking the source bits right to
X *          left.
X *
X *      int bi_reverse (int value, int length)
X *          Reverse the bits of a bit string, taking the source bits left to
X *          right and emitting them right to left.
X *
X *      void bi_windup (void)
X *          Write out any remaining bits in an incomplete byte.
X *
X *      void copy_block(char *buf, unsigned len, int header)
X *          Copy a stored block to the zip file, storing first the length and
X *          its one's complement if requested.
X *
X */
X
X#include "tailor.h"
X#include "gzip.h"
X#include "crypt.h"
X
X#ifdef DEBUG
X#  include <stdio.h>
X#endif
X
X#ifndef lint
Xstatic char rcsid[] = "$Id: bits.c,v 0.9 1993/06/11 10:16:58 jloup Exp $";
X#endif
X
X/* ===========================================================================
X * Local data used by the "bit string" routines.
X */
X
Xlocal file_t zfile; /* output gzip file */
X
Xlocal unsigned short bi_buf;
X/* Output buffer. bits are inserted starting at the bottom (least significant
X * bits).
X */
X
X#define Buf_size (8 * 2*sizeof(char))
X/* Number of bits used within bi_buf. (bi_buf might be implemented on
X * more than 16 bits on some systems.)
X */
X
Xlocal int bi_valid;
X/* Number of valid bits in bi_buf.  All bits above the last valid bit
X * are always zero.
X */
X
Xint (*read_buf) OF((char *buf, unsigned size));
X/* Current input function. Set to mem_read for in-memory compression */
X
X#ifdef DEBUG
X  ulg bits_sent;   /* bit length of the compressed data */
X#endif
X
X/* ===========================================================================
X * Initialize the bit string routines.
X */
Xvoid bi_init (zipfile)
X    file_t zipfile; /* output zip file, NO_FILE for in-memory compression */
X{
X    zfile  = zipfile;
X    bi_buf = 0;
X    bi_valid = 0;
X#ifdef DEBUG
X    bits_sent = 0L;
X#endif
X
X    /* Set the defaults for file compression. They are set by memcompress
X     * for in-memory compression.
X     */
X    if (zfile != NO_FILE) {
X	read_buf  = file_read;
X    }
X}
X
X/* ===========================================================================
X * Send a value on a given number of bits.
X * IN assertion: length <= 16 and value fits in length bits.
X */
Xvoid send_bits(value, length)
X    int value;  /* value to send */
X    int length; /* number of bits */
X{
X#ifdef DEBUG
X    Tracev((stderr," l %2d v %4x ", length, value));
X    Assert(length > 0 && length <= 15, "invalid length");
X    bits_sent += (ulg)length;
X#endif
X    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
X     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
X     * unused bits in value.
X     */
X    if (bi_valid > (int)Buf_size - length) {
X        bi_buf |= (value << bi_valid);
X        put_short(bi_buf);
X        bi_buf = (ush)value >> (Buf_size - bi_valid);
X        bi_valid += length - Buf_size;
X    } else {
X        bi_buf |= value << bi_valid;
X        bi_valid += length;
X    }
X}
X
X/* ===========================================================================
X * Reverse the first len bits of a code, using straightforward code (a faster
X * method would use a table)
X * IN assertion: 1 <= len <= 15
X */
Xunsigned bi_reverse(code, len)
X    unsigned code; /* the value to invert */
X    int len;       /* its bit length */
X{
X    register unsigned res = 0;
X    do {
X        res |= code & 1;
X        code >>= 1, res <<= 1;
X    } while (--len > 0);
X    return res >> 1;
X}
X
X/* ===========================================================================
X * Write out any remaining bits in an incomplete byte.
X */
Xvoid bi_windup()
X{
X    if (bi_valid > 8) {
X        put_short(bi_buf);
X    } else if (bi_valid > 0) {
X        put_byte(bi_buf);
X    }
X    bi_buf = 0;
X    bi_valid = 0;
X#ifdef DEBUG
X    bits_sent = (bits_sent+7) & ~7;
X#endif
X}
X
X/* ===========================================================================
X * Copy a stored block to the zip file, storing first the length and its
X * one's complement if requested.
X */
Xvoid copy_block(buf, len, header)
X    char     *buf;    /* the input data */
X    unsigned len;     /* its length */
X    int      header;  /* true if block header must be written */
X{
X    bi_windup();              /* align on byte boundary */
X
X    if (header) {
X        put_short((ush)len);   
X        put_short((ush)~len);
X#ifdef DEBUG
X        bits_sent += 2*16;
X#endif
X    }
X#ifdef DEBUG
X    bits_sent += (ulg)len<<3;
X#endif
X    while (len--) {
X#ifdef CRYPT
X        int t;
X	if (key) zencode(*buf, t);
X#endif
X	put_byte(*buf++);
X    }
X}
END_OF_FILE
if test 5878 -ne `wc -c <'gzip-1.2.2/bits.c'`; then
    echo shar: \"'gzip-1.2.2/bits.c'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/bits.c'
fi
if test -f 'gzip-1.2.2/unzip.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/unzip.c'\"
else
echo shar: Extracting \"'gzip-1.2.2/unzip.c'\" \(6019 characters\)
sed "s/^X//" >'gzip-1.2.2/unzip.c' <<'END_OF_FILE'
X/* unzip.c -- decompress files in gzip or pkzip format.
X * Copyright (C) 1992-1993 Jean-loup Gailly
X * This is free software; you can redistribute it and/or modify it under the
X * terms of the GNU General Public License, see the file COPYING.
X *
X * The code in this file is derived from the file funzip.c written
X * and put in the public domain by Mark Adler.
X */
X
X/*
X   This version can extract files in gzip or pkzip format.
X   For the latter, only the first entry is extracted, and it has to be
X   either deflated or stored.
X */
X
X#ifndef lint
Xstatic char rcsid[] = "$Id: unzip.c,v 0.13 1993/06/10 13:29:00 jloup Exp $";
X#endif
X
X#include "tailor.h"
X#include "gzip.h"
X#include "crypt.h"
X
X/* PKZIP header definitions */
X#define LOCSIG 0x04034b50L      /* four-byte lead-in (lsb first) */
X#define LOCFLG 6                /* offset of bit flag */
X#define  CRPFLG 1               /*  bit for encrypted entry */
X#define  EXTFLG 8               /*  bit for extended local header */
X#define LOCHOW 8                /* offset of compression method */
X#define LOCTIM 10               /* file mod time (for decryption) */
X#define LOCCRC 14               /* offset of crc */
X#define LOCSIZ 18               /* offset of compressed size */
X#define LOCLEN 22               /* offset of uncompressed length */
X#define LOCFIL 26               /* offset of file name field length */
X#define LOCEXT 28               /* offset of extra field length */
X#define LOCHDR 30               /* size of local header, including sig */
X#define EXTHDR 16               /* size of extended local header, inc sig */
X
X
X/* Globals */
X
Xint decrypt;        /* flag to turn on decryption */
Xchar *key;          /* not used--needed to link crypt.c */
Xint pkzip = 0;      /* set for a pkzip file */
Xint ext_header = 0; /* set if extended local header */
X
X/* ===========================================================================
X * Check zip file and advance inptr to the start of the compressed data.
X * Get ofname from the local header if necessary.
X */
Xint check_zipfile(in)
X    int in;   /* input file descriptors */
X{
X    uch *h = inbuf + inptr; /* first local header */
X
X    ifd = in;
X
X    /* Check validity of local header, and skip name and extra fields */
X    inptr += LOCHDR + SH(h + LOCFIL) + SH(h + LOCEXT);
X
X    if (inptr > insize || LG(h) != LOCSIG) {
X	fprintf(stderr, "\n%s: %s: not a valid zip file\n",
X		progname, ifname);
X	exit_code = ERROR;
X	return ERROR;
X    }
X    method = h[LOCHOW];
X    if (method != STORED && method != DEFLATED) {
X	fprintf(stderr,
X		"\n%s: %s: first entry not deflated or stored -- use unzip\n",
X		progname, ifname);
X	exit_code = ERROR;
X	return ERROR;
X    }
X
X    /* If entry encrypted, decrypt and validate encryption header */
X    if ((decrypt = h[LOCFLG] & CRPFLG) != 0) {
X	fprintf(stderr, "\n%s: %s: encrypted file -- use unzip\n",
X		progname, ifname);
X	exit_code = ERROR;
X	return ERROR;
X    }
X
X    /* Save flags for unzip() */
X    ext_header = (h[LOCFLG] & EXTFLG) != 0;
X    pkzip = 1;
X
X    /* Get ofname and time stamp from local header (to be done) */
X    return OK;
X}
X
X/* ===========================================================================
X * Unzip in to out.  This routine works on both gzip and pkzip files.
X *
X * IN assertions: the buffer inbuf contains already the beginning of
X *   the compressed data, from offsets inptr to insize-1 included.
X *   The magic header has already been checked. The output buffer is cleared.
X */
Xint unzip(in, out)
X    int in, out;   /* input and output file descriptors */
X{
X    ulg orig_crc = 0;       /* original crc */
X    ulg orig_len = 0;       /* original uncompressed length */
X    int n;
X    uch buf[EXTHDR];        /* extended local header */
X
X    ifd = in;
X    ofd = out;
X
X    updcrc(NULL, 0);           /* initialize crc */
X
X    if (pkzip && !ext_header) {  /* crc and length at the end otherwise */
X	orig_crc = LG(inbuf + LOCCRC);
X	orig_len = LG(inbuf + LOCLEN);
X    }
X
X    /* Decompress */
X    if (method == DEFLATED)  {
X
X	int res = inflate();
X
X	if (res == 3) {
X	    error("out of memory");
X	} else if (res != 0) {
X	    error("invalid compressed data--format violated");
X	}
X
X    } else if (pkzip && method == STORED) {
X
X	register ulg n = LG(inbuf + LOCLEN);
X
X	if (n != LG(inbuf + LOCSIZ) - (decrypt ? RAND_HEAD_LEN : 0)) {
X
X	    fprintf(stderr, "len %ld, siz %ld\n", n, LG(inbuf + LOCSIZ));
X	    error("invalid compressed data--length mismatch");
X	}
X	while (n--) {
X	    uch c = (uch)get_byte();
X#ifdef CRYPT
X	    if (decrypt) zdecode(c);
X#endif
X	    put_ubyte(c);
X	}
X	flush_window();
X    } else {
X	error("internal error, invalid method");
X    }
X
X    /* Get the crc and original length */
X    if (!pkzip) {
X        /* crc32  (see algorithm.doc)
X	 * uncompressed input size modulo 2^32
X         */
X	for (n = 0; n < 8; n++) {
X	    buf[n] = (uch)get_byte(); /* may cause an error if EOF */
X	}
X	orig_crc = LG(buf);
X	orig_len = LG(buf+4);
X
X    } else if (ext_header) {  /* If extended header, check it */
X	/* signature - 4bytes: 0x50 0x4b 0x07 0x08
X	 * CRC-32 value
X         * compressed size 4-bytes
X         * uncompressed size 4-bytes
X	 */
X	for (n = 0; n < EXTHDR; n++) {
X	    buf[n] = (uch)get_byte(); /* may cause an error if EOF */
X	}
X	orig_crc = LG(buf+4);
X	orig_len = LG(buf+12);
X    }
X
X    /* Validate decompression */
X    if (orig_crc != updcrc(outbuf, 0)) {
X	error("invalid compressed data--crc error");
X    }
X    if (orig_len != bytes_out) {
X	error("invalid compressed data--length error");
X    }
X
X    /* Check if there are more entries in a pkzip file */
X    if (pkzip && inptr + 4 < insize && LG(inbuf+inptr) == LOCSIG) {
X	if (to_stdout) {
X	    WARN((stderr,
X		  "%s: %s has more than one entry--rest ignored\n",
X		  progname, ifname));
X	} else {
X	    /* Don't destroy the input zip file */
X	    fprintf(stderr,
X		    "%s: %s has more than one entry -- unchanged\n",
X		    progname, ifname);
X	    exit_code = ERROR;
X	    ext_header = pkzip = 0;
X	    return ERROR;
X	}
X    }
X    ext_header = pkzip = 0; /* for next file */
X    return OK;
X}
END_OF_FILE
if test 6019 -ne `wc -c <'gzip-1.2.2/unzip.c'`; then
    echo shar: \"'gzip-1.2.2/unzip.c'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/unzip.c'
fi
if test -f 'gzip-1.2.2/inflate.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/inflate.c'\"
else
echo shar: Extracting \"'gzip-1.2.2/inflate.c'\" \(31533 characters\)
sed "s/^X//" >'gzip-1.2.2/inflate.c' <<'END_OF_FILE'
X/* inflate.c -- Not copyrighted 1992 by Mark Adler
X   version c10p1, 10 January 1993 */
X
X/* You can do whatever you like with this source file, though I would
X   prefer that if you modify it and redistribute it that you include
X   comments to that effect with your name and the date.  Thank you.
X   [The history has been moved to the file ChangeLog.]
X */
X
X/*
X   Inflate deflated (PKZIP's method 8 compressed) data.  The compression
X   method searches for as much of the current string of bytes (up to a
X   length of 258) in the previous 32K bytes.  If it doesn't find any
X   matches (of at least length 3), it codes the next byte.  Otherwise, it
X   codes the length of the matched string and its distance backwards from
X   the current position.  There is a single Huffman code that codes both
X   single bytes (called "literals") and match lengths.  A second Huffman
X   code codes the distance information, which follows a length code.  Each
X   length or distance code actually represents a base value and a number
X   of "extra" (sometimes zero) bits to get to add to the base value.  At
X   the end of each deflated block is a special end-of-block (EOB) literal/
X   length code.  The decoding process is basically: get a literal/length
X   code; if EOB then done; if a literal, emit the decoded byte; if a
X   length then get the distance and emit the referred-to bytes from the
X   sliding window of previously emitted data.
X
X   There are (currently) three kinds of inflate blocks: stored, fixed, and
X   dynamic.  The compressor deals with some chunk of data at a time, and
X   decides which method to use on a chunk-by-chunk basis.  A chunk might
X   typically be 32K or 64K.  If the chunk is uncompressible, then the
X   "stored" method is used.  In this case, the bytes are simply stored as
X   is, eight bits per byte, with none of the above coding.  The bytes are
X   preceded by a count, since there is no longer an EOB code.
X
X   If the data is compressible, then either the fixed or dynamic methods
X   are used.  In the dynamic method, the compressed data is preceded by
X   an encoding of the literal/length and distance Huffman codes that are
X   to be used to decode this block.  The representation is itself Huffman
X   coded, and so is preceded by a description of that code.  These code
X   descriptions take up a little space, and so for small blocks, there is
X   a predefined set of codes, called the fixed codes.  The fixed method is
X   used if the block codes up smaller that way (usually for quite small
X   chunks), otherwise the dynamic method is used.  In the latter case, the
X   codes are customized to the probabilities in the current block, and so
X   can code it much better than the pre-determined fixed codes.
X 
X   The Huffman codes themselves are decoded using a mutli-level table
X   lookup, in order to maximize the speed of decoding plus the speed of
X   building the decoding tables.  See the comments below that precede the
X   lbits and dbits tuning parameters.
X */
X
X
X/*
X   Notes beyond the 1.93a appnote.txt:
X
X   1. Distance pointers never point before the beginning of the output
X      stream.
X   2. Distance pointers can point back across blocks, up to 32k away.
X   3. There is an implied maximum of 7 bits for the bit length table and
X      15 bits for the actual data.
X   4. If only one code exists, then it is encoded using one bit.  (Zero
X      would be more efficient, but perhaps a little confusing.)  If two
X      codes exist, they are coded using one bit each (0 and 1).
X   5. There is no way of sending zero distance codes--a dummy must be
X      sent if there are none.  (History: a pre 2.0 version of PKZIP would
X      store blocks with no distance codes, but this was discovered to be
X      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow
X      zero distance codes, which is sent as one code of zero bits in
X      length.
X   6. There are up to 286 literal/length codes.  Code 256 represents the
X      end-of-block.  Note however that the static length tree defines
X      288 codes just to fill out the Huffman codes.  Codes 286 and 287
X      cannot be used though, since there is no length base or extra bits
X      defined for them.  Similarly, there are up to 30 distance codes.
X      However, static trees define 32 codes (all 5 bits) to fill out the
X      Huffman codes, but the last two had better not show up in the data.
X   7. Unzip can check dynamic Huffman blocks for complete code sets.
X      The exception is that a single code would not be complete (see #4).
X   8. The five bits following the block type is really the number of
X      literal codes sent minus 257.
X   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits
X      (1+6+6).  Therefore, to output three times the length, you output
X      three codes (1+1+1), whereas to output four times the same length,
X      you only need two codes (1+3).  Hmm.
X  10. In the tree reconstruction algorithm, Code = Code.html + Increment
X      only if BitLength(i) is not zero.  (Pretty obvious.)
X  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)
X  12. Note: length code 284 can represent 227-258, but length code 285
X      really is 258.  The last length deserves its own, short code
X      since it gets used a lot in very redundant files.  The length
X      258 is special since 258 - 3 (the min match length) is 255.
X  13. The literal/length and distance code bit lengths are read as a
X      single stream of lengths.  It is possible (and advantageous) for
X      a repeat code (16, 17, or 18) to go across the boundary between
X      the two sets of lengths.
X */
X
X#ifndef lint
Xstatic char rcsid[] = "$Id: inflate.c,v 0.14 1993/06/10 13:27:04 jloup Exp $";
X#endif
X
X#include <sys/types.h>
X
X#include "tailor.h"
X
X#if defined(STDC_HEADERS) || !defined(NO_STDLIB_H)
X#  include <stdlib.h>
X#endif
X
X#include "gzip.h"
X#define slide window
X
X/* Huffman code lookup table entry--this entry is four bytes for machines
X   that have 16-bit pointers (e.g. PC's in the small or medium model).
X   Valid extra bits are 0..13.  e == 15 is EOB (end of block), e == 16
X   means that v is a literal, 16 < e < 32 means that v is a pointer to
X   the next table, which codes e - 16 bits, and lastly e == 99 indicates
X   an unused code.  If a code with e == 99 is looked up, this implies an
X   error in the data. */
Xstruct huft {
X  uch e;                /* number of extra bits or operation */
X  uch b;                /* number of bits in this code or subcode */
X  union {
X    ush n;              /* literal, length base, or distance base */
X    struct huft *t;     /* pointer to next level of table */
X  } v;
X};
X
X
X/* Function prototypes */
Xint huft_build OF((unsigned *, unsigned, unsigned, ush *, ush *,
X                   struct huft **, int *));
Xint huft_free OF((struct huft *));
Xint inflate_codes OF((struct huft *, struct huft *, int, int));
Xint inflate_stored OF((void));
Xint inflate_fixed OF((void));
Xint inflate_dynamic OF((void));
Xint inflate_block OF((int *));
Xint inflate OF((void));
X
X
X/* The inflate algorithm uses a sliding 32K byte window on the uncompressed
X   stream to find repeated byte strings.  This is implemented here as a
X   circular buffer.  The index is updated simply by incrementing and then
X   and'ing with 0x7fff (32K-1). */
X/* It is left to other modules to supply the 32K area.  It is assumed
X   to be usable as if it were declared "uch slide[32768];" or as just
X   "uch *slide;" and then malloc'ed in the latter case.  The definition
X   must be in unzip.h, included above. */
X/* unsigned wp;             current position in slide */
X#define wp outcnt
X#define flush_output(w) (wp=(w),flush_window())
X
X/* Tables for deflate from PKZIP's appnote.txt. */
Xstatic unsigned border[] = {    /* Order of the bit length code lengths */
X        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
Xstatic ush cplens[] = {         /* Copy lengths for literal codes 257..285 */
X        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
X        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
X        /* note: see note #13 above about the 258 in this list. */
Xstatic ush cplext[] = {         /* Extra bits for literal codes 257..285 */
X        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
X        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99}; /* 99==invalid */
Xstatic ush cpdist[] = {         /* Copy offsets for distance codes 0..29 */
X        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
X        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
X        8193, 12289, 16385, 24577};
Xstatic ush cpdext[] = {         /* Extra bits for distance codes */
X        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
X        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
X        12, 12, 13, 13};
X
X
X
X/* Macros for inflate() bit peeking and grabbing.
X   The usage is:
X   
X        NEEDBITS(j)
X        x = b & mask_bits[j];
X        DUMPBITS(j)
X
X   where NEEDBITS makes sure that b has at least j bits in it, and
X   DUMPBITS removes the bits from b.  The macros use the variable k
X   for the number of bits in b.  Normally, b and k are register
X   variables for speed, and are initialized at the beginning of a
X   routine that uses these macros from a global bit buffer and count.
X
X   If we assume that EOB will be the longest code, then we will never
X   ask for bits with NEEDBITS that are beyond the end of the stream.
X   So, NEEDBITS should not read any more bytes than are needed to
X   meet the request.  Then no bytes need to be "returned" to the buffer
X   at the end of the last block.
X
X   However, this assumption is not true for fixed blocks--the EOB code
X   is 7 bits, but the other literal/length codes can be 8 or 9 bits.
X   (The EOB code is shorter than other codes because fixed blocks are
X   generally short.  So, while a block always has an EOB, many other
X   literal/length codes have a significantly lower probability of
X   showing up at all.)  However, by making the first table have a
X   lookup of seven bits, the EOB code will be found in that first
X   lookup, and so will not require that too many bits be pulled from
X   the stream.
X */
X
Xulg bb;                         /* bit buffer */
Xunsigned bk;                    /* bits in bit buffer */
X
Xush mask_bits[] = {
X    0x0000,
X    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
X    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
X};
X
X#ifdef CRYPT
X  uch cc;
X#  define NEXTBYTE() \
X     (decrypt ? (cc = get_byte(), zdecode(cc), cc) : get_byte())
X#else
X#  define NEXTBYTE()  (uch)get_byte()
X#endif
X#define NEEDBITS(n) {while(k<(n)){b|=((ulg)NEXTBYTE())<<k;k+=8;}}
X#define DUMPBITS(n) {b>>=(n);k-=(n);}
X
X
X/*
X   Huffman code decoding is performed using a multi-level table lookup.
X   The fastest way to decode is to simply build a lookup table whose
X   size is determined by the longest code.  However, the time it takes
X   to build this table can also be a factor if the data being decoded
X   is not very long.  The most common codes are necessarily the
X   shortest codes, so those codes dominate the decoding time, and hence
X   the speed.  The idea is you can have a shorter table that decodes the
X   shorter, more probable codes, and then point to subsidiary tables for
X   the longer codes.  The time it costs to decode the longer codes is
X   then traded against the time it takes to make longer tables.
X
X   This results of this trade are in the variables lbits and dbits
X   below.  lbits is the number of bits the first level table for literal/
X   length codes can decode in one step, and dbits is the same thing for
X   the distance codes.  Subsequent tables are also less than or equal to
X   those sizes.  These values may be adjusted either when all of the
X   codes are shorter than that, in which case the longest code length in
X   bits is used, or when the shortest code is *longer* than the requested
X   table size, in which case the length of the shortest code in bits is
X   used.
X
X   There are two different values for the two tables, since they code a
X   different number of possibilities each.  The literal/length table
X   codes 286 possible values, or in a flat code, a little over eight
X   bits.  The distance table codes 30 possible values, or a little less
X   than five bits, flat.  The optimum values for speed end up being
X   about one bit more than those, so lbits is 8+1 and dbits is 5+1.
X   The optimum values may differ though from machine to machine, and
X   possibly even between compilers.  Your mileage may vary.
X */
X
X
Xint lbits = 9;          /* bits in base literal/length lookup table */
Xint dbits = 6;          /* bits in base distance lookup table */
X
X
X/* If BMAX needs to be larger than 16, then h and x[] should be ulg. */
X#define BMAX 16         /* maximum bit length of any code (16 for explode) */
X#define N_MAX 288       /* maximum number of codes in any set */
X
X
Xunsigned hufts;         /* track memory usage */
X
X
Xint huft_build(b, n, s, d, e, t, m)
Xunsigned *b;            /* code lengths in bits (all assumed <= BMAX) */
Xunsigned n;             /* number of codes (assumed <= N_MAX) */
Xunsigned s;             /* number of simple-valued codes (0..s-1) */
Xush *d;                 /* list of base values for non-simple codes */
Xush *e;                 /* list of extra bits for non-simple codes */
Xstruct huft **t;        /* result: starting table */
Xint *m;                 /* maximum lookup bits, returns actual */
X/* Given a list of code lengths and a maximum table size, make a set of
X   tables to decode that set of codes.  Return zero on success, one if
X   the given code set is incomplete (the tables are still built in this
X   case), two if the input is invalid (all zero length codes or an
X   oversubscribed set of lengths), and three if not enough memory. */
X{
X  unsigned a;                   /* counter for codes of length k */
X  unsigned c[BMAX+1];           /* bit length count table */
X  unsigned f;                   /* i repeats in table every f entries */
X  int g;                        /* maximum code length */
X  int h;                        /* table level */
X  register unsigned i;          /* counter, current code */
X  register unsigned j;          /* counter */
X  register int k;               /* number of bits in current code */
X  int l;                        /* bits per table (returned in m) */
X  register unsigned *p;         /* pointer into c[], b[], or v[] */
X  register struct huft *q;      /* points to current table */
X  struct huft r;                /* table entry for structure assignment */
X  struct huft *u[BMAX];         /* table stack */
X  unsigned v[N_MAX];            /* values in order of bit length */
X  register int w;               /* bits before this table == (l * h) */
X  unsigned x[BMAX+1];           /* bit offsets, then code stack */
X  unsigned *xp;                 /* pointer into x */
X  int y;                        /* number of dummy codes added */
X  unsigned z;                   /* number of entries in current table */
X
X
X  /* Generate counts for each bit length */
X  memzero(c, sizeof(c));
X  p = b;  i = n;
X  do {
X    Tracecv(*p, (stderr, (n-i >= ' ' && n-i <= '~' ? "%c %d\n" : "0x%x %d\n"), 
X	    n-i, *p));
X    c[*p++]++;                  /* assume all entries <= BMAX */
X  } while (--i);
X  if (c[0] == n)                /* null input--all zero length codes */
X  {
X    *t = (struct huft *)NULL;
X    *m = 0;
X    return 0;
X  }
X
X
X  /* Find minimum and maximum length, bound *m by those */
X  l = *m;
X  for (j = 1; j <= BMAX; j++)
X    if (c[j])
X      break;
X  k = j;                        /* minimum code length */
X  if ((unsigned)l < j)
X    l = j;
X  for (i = BMAX; i; i--)
X    if (c[i])
X      break;
X  g = i;                        /* maximum code length */
X  if ((unsigned)l > i)
X    l = i;
X  *m = l;
X
X
X  /* Adjust last length count to fill out codes, if needed */
X  for (y = 1 << j; j < i; j++, y <<= 1)
X    if ((y -= c[j]) < 0)
X      return 2;                 /* bad input: more codes than bits */
X  if ((y -= c[i]) < 0)
X    return 2;
X  c[i] += y;
X
X
X  /* Generate starting offsets into the value table for each length */
X  x[1] = j = 0;
X  p = c + 1;  xp = x + 2;
X  while (--i) {                 /* note that i == g from above */
X    *xp++ = (j += *p++);
X  }
X
X
X  /* Make a table of values in order of bit lengths */
X  p = b;  i = 0;
X  do {
X    if ((j = *p++) != 0)
X      v[x[j]++] = i;
X  } while (++i < n);
X
X
X  /* Generate the Huffman codes and for each, make the table entries */
X  x[0] = i = 0;                 /* first Huffman code is zero */
X  p = v;                        /* grab values in bit order */
X  h = -1;                       /* no tables yet--level -1 */
X  w = -l;                       /* bits decoded == (l * h) */
X  u[0] = (struct huft *)NULL;   /* just to keep compilers happy */
X  q = (struct huft *)NULL;      /* ditto */
X  z = 0;                        /* ditto */
X
X  /* go through the bit lengths (k already is bits in shortest code) */
X  for (; k <= g; k++)
X  {
X    a = c[k];
X    while (a--)
X    {
X      /* here i is the Huffman code of length k bits for value *p */
X      /* make tables up to required level */
X      while (k > w + l)
X      {
X        h++;
X        w += l;                 /* previous table always l bits */
X
X        /* compute minimum size table less than or equal to l bits */
X        z = (z = g - w) > (unsigned)l ? l : z;  /* upper limit on table size */
X        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
X        {                       /* too few codes for k-w bit table */
X          f -= a + 1;           /* deduct codes from patterns left */
X          xp = c + k;
X          while (++j < z)       /* try smaller tables up to z bits */
X          {
X            if ((f <<= 1) <= *++xp)
X              break;            /* enough codes to use up j bits */
X            f -= *xp;           /* else deduct codes from patterns */
X          }
X        }
X        z = 1 << j;             /* table entries for j-bit table */
X
X        /* allocate and link in new table */
X        if ((q = (struct huft *)malloc((z + 1)*sizeof(struct huft))) ==
X            (struct huft *)NULL)
X        {
X          if (h)
X            huft_free(u[0]);
X          return 3;             /* not enough memory */
X        }
X        hufts += z + 1;         /* track memory usage */
X        *t = q + 1;             /* link to list for huft_free() */
X        *(t = &(q->v.t)) = (struct huft *)NULL;
X        u[h] = ++q;             /* table starts after link */
X
X        /* connect to last table, if there is one */
X        if (h)
X        {
X          x[h] = i;             /* save pattern for backing up */
X          r.b = (uch)l;         /* bits to dump before this table */
X          r.e = (uch)(16 + j);  /* bits in this table */
X          r.v.t = q;            /* pointer to this table */
X          j = i >> (w - l);     /* (get around Turbo C bug) */
X          u[h-1][j] = r;        /* connect to last table */
X        }
X      }
X
X      /* set up table entry in r */
X      r.b = (uch)(k - w);
X      if (p >= v + n)
X        r.e = 99;               /* out of values--invalid code */
X      else if (*p < s)
X      {
X        r.e = (uch)(*p < 256 ? 16 : 15);    /* 256 is end-of-block code */
X        r.v.n = (ush)(*p);             /* simple code is just the value */
X	p++;                           /* one compiler does not like *p++ */
X      }
X      else
X      {
X        r.e = (uch)e[*p - s];   /* non-simple--look up in lists */
X        r.v.n = d[*p++ - s];
X      }
X
X      /* fill code-like entries with r */
X      f = 1 << (k - w);
X      for (j = i >> w; j < z; j += f)
X        q[j] = r;
X
X      /* backwards increment the k-bit code i */
X      for (j = 1 << (k - 1); i & j; j >>= 1)
X        i ^= j;
X      i ^= j;
X
X      /* backup over finished tables */
X      while ((i & ((1 << w) - 1)) != x[h])
X      {
X        h--;                    /* don't need to update q */
X        w -= l;
X      }
X    }
X  }
X
X
X  /* Return true (1) if we were given an incomplete table */
X  return y != 0 && g != 1;
X}
X
X
X
Xint huft_free(t)
Xstruct huft *t;         /* table to free */
X/* Free the malloc'ed tables built by huft_build(), which makes a linked
X   list of the tables it made, with the links in a dummy first entry of
X   each table. */
X{
X  register struct huft *p, *q;
X
X
X  /* Go through linked list, freeing from the malloced (t[-1]) address. */
X  p = t;
X  while (p != (struct huft *)NULL)
X  {
X    q = (--p)->v.t;
X    free((char*)p);
X    p = q;
X  } 
X  return 0;
X}
X
X
Xint inflate_codes(tl, td, bl, bd)
Xstruct huft *tl, *td;   /* literal/length and distance decoder tables */
Xint bl, bd;             /* number of bits decoded by tl[] and td[] */
X/* inflate (decompress) the codes in a deflated (compressed) block.
X   Return an error code or zero if it all goes ok. */
X{
X  register unsigned e;  /* table entry flag/number of extra bits */
X  unsigned n, d;        /* length and index for copy */
X  unsigned w;           /* current window position */
X  struct huft *t;       /* pointer to table entry */
X  unsigned ml, md;      /* masks for bl and bd bits */
X  register ulg b;       /* bit buffer */
X  register unsigned k;  /* number of bits in bit buffer */
X
X
X  /* make local copies of globals */
X  b = bb;                       /* initialize bit buffer */
X  k = bk;
X  w = wp;                       /* initialize window position */
X
X  /* inflate the coded data */
X  ml = mask_bits[bl];           /* precompute masks for speed */
X  md = mask_bits[bd];
X  for (;;)                      /* do until end of block */
X  {
X    NEEDBITS((unsigned)bl)
X    if ((e = (t = tl + ((unsigned)b & ml))->e) > 16)
X      do {
X        if (e == 99)
X          return 1;
X        DUMPBITS(t->b)
X        e -= 16;
X        NEEDBITS(e)
X      } while ((e = (t = t->v.t + ((unsigned)b & mask_bits[e]))->e) > 16);
X    DUMPBITS(t->b)
X    if (e == 16)                /* then it's a literal */
X    {
X      slide[w++] = (uch)t->v.n;
X      Tracevv((stderr, "%c", slide[w-1]));
X      if (w == WSIZE)
X      {
X        flush_output(w);
X        w = 0;
X      }
X    }
X    else                        /* it's an EOB or a length */
X    {
X      /* exit if end of block */
X      if (e == 15)
X        break;
X
X      /* get length of block to copy */
X      NEEDBITS(e)
X      n = t->v.n + ((unsigned)b & mask_bits[e]);
X      DUMPBITS(e);
X
X      /* decode distance of block to copy */
X      NEEDBITS((unsigned)bd)
X      if ((e = (t = td + ((unsigned)b & md))->e) > 16)
X        do {
X          if (e == 99)
X            return 1;
X          DUMPBITS(t->b)
X          e -= 16;
X          NEEDBITS(e)
X        } while ((e = (t = t->v.t + ((unsigned)b & mask_bits[e]))->e) > 16);
X      DUMPBITS(t->b)
X      NEEDBITS(e)
X      d = w - t->v.n - ((unsigned)b & mask_bits[e]);
X      DUMPBITS(e)
X      Tracevv((stderr,"\\[%d,%d]", w-d, n));
X
X      /* do the copy */
X      do {
X        n -= (e = (e = WSIZE - ((d &= WSIZE-1) > w ? d : w)) > n ? n : e);
X#if !defined(NOMEMCPY) && !defined(DEBUG)
X        if (w - d >= e)         /* (this test assumes unsigned comparison) */
X        {
X          memcpy(slide + w, slide + d, e);
X          w += e;
X          d += e;
X        }
X        else                      /* do it slow to avoid memcpy() overlap */
X#endif /* !NOMEMCPY */
X          do {
X            slide[w++] = slide[d++];
X	    Tracevv((stderr, "%c", slide[w-1]));
X          } while (--e);
X        if (w == WSIZE)
X        {
X          flush_output(w);
X          w = 0;
X        }
X      } while (n);
X    }
X  }
X
X
X  /* restore the globals from the locals */
X  wp = w;                       /* restore global window pointer */
X  bb = b;                       /* restore global bit buffer */
X  bk = k;
X
X  /* done */
X  return 0;
X}
X
X
X
Xint inflate_stored()
X/* "decompress" an inflated type 0 (stored) block. */
X{
X  unsigned n;           /* number of bytes in block */
X  unsigned w;           /* current window position */
X  register ulg b;       /* bit buffer */
X  register unsigned k;  /* number of bits in bit buffer */
X
X
X  /* make local copies of globals */
X  b = bb;                       /* initialize bit buffer */
X  k = bk;
X  w = wp;                       /* initialize window position */
X
X
X  /* go to byte boundary */
X  n = k & 7;
X  DUMPBITS(n);
X
X
X  /* get the length and its complement */
X  NEEDBITS(16)
X  n = ((unsigned)b & 0xffff);
X  DUMPBITS(16)
X  NEEDBITS(16)
X  if (n != (unsigned)((~b) & 0xffff))
X    return 1;                   /* error in compressed data */
X  DUMPBITS(16)
X
X
X  /* read and output the compressed data */
X  while (n--)
X  {
X    NEEDBITS(8)
X    slide[w++] = (uch)b;
X    if (w == WSIZE)
X    {
X      flush_output(w);
X      w = 0;
X    }
X    DUMPBITS(8)
X  }
X
X
X  /* restore the globals from the locals */
X  wp = w;                       /* restore global window pointer */
X  bb = b;                       /* restore global bit buffer */
X  bk = k;
X  return 0;
X}
X
X
X
Xint inflate_fixed()
X/* decompress an inflated type 1 (fixed Huffman codes) block.  We should
X   either replace this with a custom decoder, or at least precompute the
X   Huffman tables. */
X{
X  int i;                /* temporary variable */
X  struct huft *tl;      /* literal/length code table */
X  struct huft *td;      /* distance code table */
X  int bl;               /* lookup bits for tl */
X  int bd;               /* lookup bits for td */
X  unsigned l[288];      /* length list for huft_build */
X
X
X  /* set up literal table */
X  for (i = 0; i < 144; i++)
X    l[i] = 8;
X  for (; i < 256; i++)
X    l[i] = 9;
X  for (; i < 280; i++)
X    l[i] = 7;
X  for (; i < 288; i++)          /* make a complete, but wrong code set */
X    l[i] = 8;
X  bl = 7;
X  if ((i = huft_build(l, 288, 257, cplens, cplext, &tl, &bl)) != 0)
X    return i;
X
X
X  /* set up distance table */
X  for (i = 0; i < 30; i++)      /* make an incomplete code set */
X    l[i] = 5;
X  bd = 5;
X  if ((i = huft_build(l, 30, 0, cpdist, cpdext, &td, &bd)) > 1)
X  {
X    huft_free(tl);
X    return i;
X  }
X
X
X  /* decompress until an end-of-block code */
X  if (inflate_codes(tl, td, bl, bd))
X    return 1;
X
X
X  /* free the decoding tables, return */
X  huft_free(tl);
X  huft_free(td);
X  return 0;
X}
X
X
X
Xint inflate_dynamic()
X/* decompress an inflated type 2 (dynamic Huffman codes) block. */
X{
X  int i;                /* temporary variables */
X  unsigned j;
X  unsigned l;           /* last length */
X  unsigned m;           /* mask for bit lengths table */
X  unsigned n;           /* number of lengths to get */
X  struct huft *tl;      /* literal/length code table */
X  struct huft *td;      /* distance code table */
X  int bl;               /* lookup bits for tl */
X  int bd;               /* lookup bits for td */
X  unsigned nb;          /* number of bit length codes */
X  unsigned nl;          /* number of literal/length codes */
X  unsigned nd;          /* number of distance codes */
X#ifdef PKZIP_BUG_WORKAROUND
X  unsigned ll[288+32];  /* literal/length and distance code lengths */
X#else
X  unsigned ll[286+30];  /* literal/length and distance code lengths */
X#endif
X  register ulg b;       /* bit buffer */
X  register unsigned k;  /* number of bits in bit buffer */
X
X
X  /* make local bit buffer */
X  b = bb;
X  k = bk;
X
X
X  /* read in table lengths */
X  NEEDBITS(5)
X  nl = 257 + ((unsigned)b & 0x1f);      /* number of literal/length codes */
X  DUMPBITS(5)
X  NEEDBITS(5)
X  nd = 1 + ((unsigned)b & 0x1f);        /* number of distance codes */
X  DUMPBITS(5)
X  NEEDBITS(4)
X  nb = 4 + ((unsigned)b & 0xf);         /* number of bit length codes */
X  DUMPBITS(4)
X#ifdef PKZIP_BUG_WORKAROUND
X  if (nl > 288 || nd > 32)
X#else
X  if (nl > 286 || nd > 30)
X#endif
X    return 1;                   /* bad lengths */
X
X
X  /* read in bit-length-code lengths */
X  for (j = 0; j < nb; j++)
X  {
X    NEEDBITS(3)
X    ll[border[j]] = (unsigned)b & 7;
X    DUMPBITS(3)
X  }
X  for (; j < 19; j++)
X    ll[border[j]] = 0;
X
X
X  /* build decoding table for trees--single level, 7 bit lookup */
X  bl = 7;
X  if ((i = huft_build(ll, 19, 19, NULL, NULL, &tl, &bl)) != 0)
X  {
X    if (i == 1)
X      huft_free(tl);
X    return i;                   /* incomplete code set */
X  }
X
X
X  /* read in literal and distance code lengths */
X  n = nl + nd;
X  m = mask_bits[bl];
X  i = l = 0;
X  while ((unsigned)i < n)
X  {
X    NEEDBITS((unsigned)bl)
X    j = (td = tl + ((unsigned)b & m))->b;
X    DUMPBITS(j)
X    j = td->v.n;
X    if (j < 16)                 /* length of code in bits (0..15) */
X      ll[i++] = l = j;          /* save last length in l */
X    else if (j == 16)           /* repeat last length 3 to 6 times */
X    {
X      NEEDBITS(2)
X      j = 3 + ((unsigned)b & 3);
X      DUMPBITS(2)
X      if ((unsigned)i + j > n)
X        return 1;
X      while (j--)
X        ll[i++] = l;
X    }
X    else if (j == 17)           /* 3 to 10 zero length codes */
X    {
X      NEEDBITS(3)
X      j = 3 + ((unsigned)b & 7);
X      DUMPBITS(3)
X      if ((unsigned)i + j > n)
X        return 1;
X      while (j--)
X        ll[i++] = 0;
X      l = 0;
X    }
X    else                        /* j == 18: 11 to 138 zero length codes */
X    {
X      NEEDBITS(7)
X      j = 11 + ((unsigned)b & 0x7f);
X      DUMPBITS(7)
X      if ((unsigned)i + j > n)
X        return 1;
X      while (j--)
X        ll[i++] = 0;
X      l = 0;
X    }
X  }
X
X
X  /* free decoding table for trees */
X  huft_free(tl);
X
X
X  /* restore the global bit buffer */
X  bb = b;
X  bk = k;
X
X
X  /* build the decoding tables for literal/length and distance codes */
X  bl = lbits;
X  if ((i = huft_build(ll, nl, 257, cplens, cplext, &tl, &bl)) != 0)
X  {
X    if (i == 1) {
X      fprintf(stderr, " incomplete literal tree\n");
X      huft_free(tl);
X    }
X    return i;                   /* incomplete code set */
X  }
X  bd = dbits;
X  if ((i = huft_build(ll + nl, nd, 0, cpdist, cpdext, &td, &bd)) != 0)
X  {
X    if (i == 1) {
X      fprintf(stderr, " incomplete distance tree\n");
X#ifdef PKZIP_BUG_WORKAROUND
X      i = 0;
X    }
X#else
X      huft_free(td);
X    }
X    huft_free(tl);
X    return i;                   /* incomplete code set */
X#endif
X  }
X
X
X  /* decompress until an end-of-block code */
X  if (inflate_codes(tl, td, bl, bd))
X    return 1;
X
X
X  /* free the decoding tables, return */
X  huft_free(tl);
X  huft_free(td);
X  return 0;
X}
X
X
X
Xint inflate_block(e)
Xint *e;                 /* last block flag */
X/* decompress an inflated block */
X{
X  unsigned t;           /* block type */
X  register ulg b;       /* bit buffer */
X  register unsigned k;  /* number of bits in bit buffer */
X
X
X  /* make local bit buffer */
X  b = bb;
X  k = bk;
X
X
X  /* read in last block bit */
X  NEEDBITS(1)
X  *e = (int)b & 1;
X  DUMPBITS(1)
X
X
X  /* read in block type */
X  NEEDBITS(2)
X  t = (unsigned)b & 3;
X  DUMPBITS(2)
X
X
X  /* restore the global bit buffer */
X  bb = b;
X  bk = k;
X
X
X  /* inflate that block type */
X  if (t == 2)
X    return inflate_dynamic();
X  if (t == 0)
X    return inflate_stored();
X  if (t == 1)
X    return inflate_fixed();
X
X
X  /* bad block type */
X  return 2;
X}
X
X
X
Xint inflate()
X/* decompress an inflated entry */
X{
X  int e;                /* last block flag */
X  int r;                /* result code */
X  unsigned h;           /* maximum struct huft's malloc'ed */
X
X
X  /* initialize window, bit buffer */
X  wp = 0;
X  bk = 0;
X  bb = 0;
X
X
X  /* decompress until the last block */
X  h = 0;
X  do {
X    hufts = 0;
X    if ((r = inflate_block(&e)) != 0)
X      return r;
X    if (hufts > h)
X      h = hufts;
X  } while (!e);
X
X  /* Undo too much lookahead. The next read will be byte aligned so we
X   * can discard unused bits in the last meaningful byte.
X   */
X  while (bk >= 8) {
X    bk -= 8;
X    inptr--;
X  }
X
X  /* flush out slide */
X  flush_output(wp);
X
X
X  /* return success */
X#ifdef DEBUG
X  fprintf(stderr, "<%u> ", h);
X#endif /* DEBUG */
X  return 0;
X}
END_OF_FILE
if test 31533 -ne `wc -c <'gzip-1.2.2/inflate.c'`; then
    echo shar: \"'gzip-1.2.2/inflate.c'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/inflate.c'
fi
if test -f 'gzip-1.2.2/util.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/util.c'\"
else
echo shar: Extracting \"'gzip-1.2.2/util.c'\" \(14111 characters\)
sed "s/^X//" >'gzip-1.2.2/util.c' <<'END_OF_FILE'
X/* util.c -- utility functions for gzip support
X * Copyright (C) 1992-1993 Jean-loup Gailly
X * This is free software; you can redistribute it and/or modify it under the
X * terms of the GNU General Public License, see the file COPYING.
X */
X
X#ifndef lint
Xstatic char rcsid[] = "$Id: util.c,v 0.15 1993/06/15 09:04:13 jloup Exp $";
X#endif
X
X#include <ctype.h>
X#include <errno.h>
X#include <sys/types.h>
X
X#include "tailor.h"
X
X#ifdef HAVE_UNISTD_H
X#  include <unistd.h>
X#endif
X#ifndef NO_FCNTL_H
X#  include <fcntl.h>
X#endif
X
X#if defined(STDC_HEADERS) || !defined(NO_STDLIB_H)
X#  include <stdlib.h>
X#else
X   extern int errno;
X#endif
X
X#include "gzip.h"
X#include "crypt.h"
X
Xextern ulg crc_32_tab[];   /* crc table, defined below */
X
X/* ===========================================================================
X * Copy input to output unchanged: zcat == cat with --force.
X * IN assertion: insize bytes have already been read in inbuf.
X */
Xint copy(in, out)
X    int in, out;   /* input and output file descriptors */
X{
X    errno = 0;
X    while (insize != 0 && (int)insize != EOF) {
X	write_buf(out, (char*)inbuf, insize);
X	bytes_out += insize;
X	insize = read(in, (char*)inbuf, INBUFSIZ);
X    }
X    if ((int)insize == EOF && errno != 0) {
X	read_error();
X    }
X    bytes_in = bytes_out;
X    return OK;
X}
X
X/* ===========================================================================
X * Run a set of bytes through the crc shift register.  If s is a NULL
X * pointer, then initialize the crc shift register contents instead.
X * Return the current crc in either case.
X */
Xulg updcrc(s, n)
X    uch *s;                 /* pointer to bytes to pump through */
X    unsigned n;             /* number of bytes in s[] */
X{
X    register ulg c;         /* temporary variable */
X
X    static ulg crc = (ulg)0xffffffffL; /* shift register contents */
X
X    if (s == NULL) {
X	c = 0xffffffffL;
X    } else {
X	c = crc;
X        if (n) do {
X            c = crc_32_tab[((int)c ^ (*s++)) & 0xff] ^ (c >> 8);
X        } while (--n);
X    }
X    crc = c;
X    return c ^ 0xffffffffL;       /* (instead of ~c for 64-bit machines) */
X}
X
X/* ===========================================================================
X * Clear input and output buffers
X */
Xvoid clear_bufs()
X{
X    outcnt = 0;
X    insize = inptr = 0;
X    bytes_in = bytes_out = 0L;
X}
X
X/* ===========================================================================
X * Fill the input buffer. This is called only when the buffer is empty.
X */
Xint fill_inbuf(eof_ok)
X    int eof_ok;          /* set if EOF acceptable as a result */
X{
X    int len;
X
X    /* Read as much as possible */
X    insize = 0;
X    errno = 0;
X    do {
X	len = read(ifd, (char*)inbuf+insize, INBUFSIZ-insize);
X        if (len == 0 || len == EOF) break;
X	insize += len;
X    } while (insize < INBUFSIZ);
X
X    if (insize == 0) {
X	if (eof_ok) return EOF;
X	read_error();
X    }
X    bytes_in += (ulg)insize;
X    inptr = 1;
X    return inbuf[0];
X}
X
X/* ===========================================================================
X * Write the output buffer outbuf[0..outcnt-1] and update bytes_out.
X * (used for the compressed data only)
X */
Xvoid flush_outbuf()
X{
X    if (outcnt == 0) return;
X
X    write_buf(ofd, (char *)outbuf, outcnt);
X    bytes_out += (ulg)outcnt;
X    outcnt = 0;
X}
X
X/* ===========================================================================
X * Write the output window window[0..outcnt-1] and update crc and bytes_out.
X * (Used for the decompressed data only.)
X */
Xvoid flush_window()
X{
X    if (outcnt == 0) return;
X    updcrc(window, outcnt);
X
X    if (!test) {
X	write_buf(ofd, (char *)window, outcnt);
X    }
X    bytes_out += (ulg)outcnt;
X    outcnt = 0;
X}
X
X/* ===========================================================================
X * Does the same as write(), but also handles partial pipe writes and checks
X * for error return.
X */
Xvoid write_buf(fd, buf, cnt)
X    int       fd;
X    voidp     buf;
X    unsigned  cnt;
X{
X    unsigned  n;
X
X    while ((n = write(fd, buf, cnt)) != cnt) {
X	if (n == (unsigned)(-1)) {
X	    write_error();
X	}
X	cnt -= n;
X	buf = (voidp)((char*)buf+n);
X    }
X}
X
X/* ========================================================================
X * Put string s in lower case, return s.
X */
Xchar *strlwr(s)
X    char *s;
X{
X    char *t;
X    for (t = s; *t; t++) *t = tolow(*t);
X    return s;
X}
X
X/* ========================================================================
X * Return the base name of a file (remove any directory prefix and
X * any version suffix). For systems with file names that are not
X * case sensitive, force the base name to lower case.
X */
Xchar *basename(fname)
X    char *fname;
X{
X    char *p;
X
X    if ((p = strrchr(fname, PATH_SEP))  != NULL) fname = p+1;
X#ifdef PATH_SEP2
X    if ((p = strrchr(fname, PATH_SEP2)) != NULL) fname = p+1;
X#endif
X#ifdef PATH_SEP3
X    if ((p = strrchr(fname, PATH_SEP3)) != NULL) fname = p+1;
X#endif
X#ifdef SUFFIX_SEP
X    if ((p = strrchr(fname, SUFFIX_SEP)) != NULL) *p = '\0';
X#endif
X    if (casemap('A') == 'a') strlwr(fname);
X    return fname;
X}
X
X/* ========================================================================
X * Make a file name legal for file systems not allowing file names with
X * multiple dots or starting with a dot (such as MSDOS), by changing
X * all dots except the last one into underlines.  A target dependent
X * function can be used instead of this simple function by defining the macro
X * MAKE_LEGAL_NAME in tailor.h and providing the function in a target
X * dependent module.
X */
Xvoid make_simple_name(name)
X    char *name;
X{
X    char *p = strrchr(name, '.');
X    if (p == NULL) return;
X    if (p == name) p++;
X    do {
X        if (*--p == '.') *p = '_';
X    } while (p != name);
X}
X
X
X#if defined(NO_STRING_H) && !defined(STDC_HEADERS)
X
X/* Provide missing strspn and strcspn functions. */
X
X#  ifndef __STDC__
X#    define const
X#  endif
X
Xint strspn  OF((const char *s, const char *accept));
Xint strcspn OF((const char *s, const char *reject));
X
X/* ========================================================================
X * Return the length of the maximum initial segment
X * of s which contains only characters in accept.
X */
Xint strspn(s, accept)
X    const char *s;
X    const char *accept;
X{
X    register const char *p;
X    register const char *a;
X    register int count = 0;
X
X    for (p = s; *p != '\0'; ++p) {
X	for (a = accept; *a != '\0'; ++a) {
X	    if (*p == *a) break;
X	}
X	if (*a == '\0') return count;
X	++count;
X    }
X    return count;
X}
X
X/* ========================================================================
X * Return the length of the maximum inital segment of s
X * which contains no characters from reject.
X */
Xint strcspn(s, reject)
X    const char *s;
X    const char *reject;
X{
X    register int count = 0;
X
X    while (*s != '\0') {
X	if (strchr(reject, *s++) != NULL) return count;
X	++count;
X    }
X    return count;
X}
X
X#endif /* NO_STRING_H */
X
X/* ========================================================================
X * Add an environment variable (if any) before argv, and update argc.
X * Return the expanded environment variable to be freed later, or NULL 
X * if no options were added to argv.
X */
X#define SEPARATOR	" \t"	/* separators in env variable */
X
Xchar *add_envopt(argcp, argvp, env)
X    int *argcp;          /* pointer to argc */
X    char ***argvp;       /* pointer to argv */
X    char *env;           /* name of environment variable */
X{
X    char *p;             /* running pointer through env variable */
X    char **oargv;        /* runs through old argv array */
X    char **nargv;        /* runs through new argv array */
X    int	 oargc = *argcp; /* old argc */
X    int  nargc = 0;      /* number of arguments in env variable */
X
X    env = (char*)getenv(env);
X    if (env == NULL) return NULL;
X
X    p = (char*)xmalloc(strlen(env)+1);
X    env = strcpy(p, env);                    /* keep env variable intact */
X
X    for (p = env; *p; nargc++ ) {            /* move through env */
X	p += strspn(p, SEPARATOR);	     /* skip leading separators */
X	if (*p == '\0') break;
X
X	p += strcspn(p, SEPARATOR);	     /* find end of word */
X	if (*p) *p++ = '\0';		     /* mark it */
X    }
X    if (nargc == 0) {
X	free(env); env = NULL;
X	return NULL;
X    }
X    *argcp += nargc;
X    /* Allocate the new argv array, with an extra element just in case
X     * the original arg list did not end with a NULL.
X     */
X    nargv = (char**)calloc(*argcp+1, sizeof(char *));
X    if (nargv == NULL) error("out of memory");
X    oargv  = *argvp;
X    *argvp = nargv;
X
X    /* Copy the program name first */
X    if (oargc-- < 0) error("argc<=0");
X    *(nargv++) = *(oargv++);
X
X    /* Then copy the environment args */
X    for (p = env; nargc > 0; nargc--) {
X	p += strspn(p, SEPARATOR);	     /* skip separators */
X	*(nargv++) = p;			     /* store start */
X	while (*p++) ;			     /* skip over word */
X    }
X
X    /* Finally copy the old args and add a NULL (usual convention) */
X    while (oargc--) *(nargv++) = *(oargv++);
X    *nargv = NULL;
X    return env;
X}
X
X/* ========================================================================
X * Error handlers.
X */
Xvoid error(m)
X    char *m;
X{
X    fprintf(stderr, "\n%s: %s: %s\n", progname, ifname, m);
X    abort_gzip();
X}
X
Xvoid warn(a, b)
X    char *a, *b;            /* message strings juxtaposed in output */
X{
X    WARN((stderr, "%s: %s: warning: %s%s\n", progname, ifname, a, b));
X}
X
Xvoid read_error()
X{
X    fprintf(stderr, "\n%s: ", progname);
X    if (errno != 0) {
X	perror(ifname);
X    } else {
X	fprintf(stderr, "%s: unexpected end of file\n", ifname);
X    }
X    abort_gzip();
X}
X
Xvoid write_error()
X{
X    fprintf(stderr, "\n%s: ", progname);
X    perror(ofname);
X    abort_gzip();
X}
X
X/* ========================================================================
X * Display compression ratio on the given stream on 6 characters.
X */
Xvoid display_ratio(num, den, file)
X    long num;
X    long den;
X    FILE *file;
X{
X    long ratio;  /* 1000 times the compression ratio */
X
X    if (den == 0) {
X	ratio = 0; /* no compression */
X    } else if (den < 2147483L) { /* (2**31 -1)/1000 */
X	ratio = 1000L*num/den;
X    } else {
X	ratio = num/(den/1000L);
X    }
X    if (ratio < 0) {
X	putc('-', file);
X	ratio = -ratio;
X    } else {
X	putc(' ', file);
X    }
X    fprintf(file, "%2ld.%1ld%%", ratio / 10L, ratio % 10L);
X}
X
X
X/* ========================================================================
X * Semi-safe malloc -- never returns NULL.
X */
Xvoidp xmalloc (size)
X    unsigned size;
X{
X    voidp cp = (voidp)malloc (size);
X
X    if (cp == NULL) error("out of memory");
X    return cp;
X}
X
X/* ========================================================================
X * Table of CRC-32's of all single-byte values (made by makecrc.c)
X */
Xulg crc_32_tab[] = {
X  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
X  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
X  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
X  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
X  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
X  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
X  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
X  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
X  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
X  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
X  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
X  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
X  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
X  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
X  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
X  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
X  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
X  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
X  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
X  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
X  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
X  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
X  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
X  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
X  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
X  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
X  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
X  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
X  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
X  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
X  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
X  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
X  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
X  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
X  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
X  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
X  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
X  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
X  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
X  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
X  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
X  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
X  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
X  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
X  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
X  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
X  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
X  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
X  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
X  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
X  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
X  0x2d02ef8dL
X};
END_OF_FILE
if test 14111 -ne `wc -c <'gzip-1.2.2/util.c'`; then
    echo shar: \"'gzip-1.2.2/util.c'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/util.c'
fi
if test -f 'gzip-1.2.2/crypt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/crypt.c'\"
else
echo shar: Extracting \"'gzip-1.2.2/crypt.c'\" \(189 characters\)
sed "s/^X//" >'gzip-1.2.2/crypt.c' <<'END_OF_FILE'
X/* crypt.c (dummy version) -- do not perform encryption
X * Hardly worth copyrighting :-)
X */
X#ifndef lint
Xstatic char rcsid[] = "$Id: crypt.c,v 0.6 1993/03/22 09:48:47 jloup Exp $";
X#endif
END_OF_FILE
if test 189 -ne `wc -c <'gzip-1.2.2/crypt.c'`; then
    echo shar: \"'gzip-1.2.2/crypt.c'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/crypt.c'
fi
if test -f 'gzip-1.2.2/lzw.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/lzw.c'\"
else
echo shar: Extracting \"'gzip-1.2.2/lzw.c'\" \(574 characters\)
sed "s/^X//" >'gzip-1.2.2/lzw.c' <<'END_OF_FILE'
X/* lzw.c -- compress files in LZW format.
X * This is a dummy version avoiding patent problems.
X */
X
X#ifndef lint
Xstatic char rcsid[] = "$Id: lzw.c,v 0.9 1993/06/10 13:27:31 jloup Exp $";
X#endif
X
X#include "tailor.h"
X#include "gzip.h"
X#include "lzw.h"
X
Xstatic int msg_done = 0;
X
X/* Compress in to out with lzw method. */
Xint lzw(in, out)
X    int in, out;
X{
X    if (msg_done) return ERROR;
X    msg_done = 1;
X    fprintf(stderr,"output in compress .Z format not supported\n");
X    in++, out++; /* avoid warnings on unused variables */
X    exit_code = ERROR;
X    return ERROR;
X}
END_OF_FILE
if test 574 -ne `wc -c <'gzip-1.2.2/lzw.c'`; then
    echo shar: \"'gzip-1.2.2/lzw.c'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/lzw.c'
fi
if test -f 'gzip-1.2.2/unlzw.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/unlzw.c'\"
else
echo shar: Extracting \"'gzip-1.2.2/unlzw.c'\" \(8729 characters\)
sed "s/^X//" >'gzip-1.2.2/unlzw.c' <<'END_OF_FILE'
X/* unlzw.c -- decompress files in LZW format.
X * The code in this file is directly derived from the public domain 'compress'
X * written by Spencer Thomas, Joe Orost, James Woods, Jim McKie, Steve Davies,
X * Ken Turkowski, Dave Mack and Peter Jannesen.
X *
X * This is a temporary version which will be rewritten in some future version
X * to accommodate in-memory decompression.
X */
X
X#ifndef lint
Xstatic char rcsid[] = "$Id: unlzw.c,v 0.15 1993/06/10 13:28:35 jloup Exp $";
X#endif
X
X#include <sys/types.h>
X
X#include "tailor.h"
X
X#ifdef HAVE_UNISTD_H
X#  include <unistd.h>
X#endif
X#ifndef NO_FCNTL_H
X#  include <fcntl.h>
X#endif
X
X#include "gzip.h"
X#include "lzw.h"
X
Xtypedef	unsigned char	char_type;
Xtypedef          long   code_int;
Xtypedef unsigned long 	count_int;
Xtypedef unsigned short	count_short;
Xtypedef unsigned long 	cmp_code_int;
X
X#define MAXCODE(n)	(1L << (n))
X    
X#ifndef	REGISTERS
X#	define	REGISTERS	2
X#endif
X#define	REG1	
X#define	REG2	
X#define	REG3	
X#define	REG4	
X#define	REG5	
X#define	REG6	
X#define	REG7	
X#define	REG8	
X#define	REG9	
X#define	REG10
X#define	REG11	
X#define	REG12	
X#define	REG13
X#define	REG14
X#define	REG15
X#define	REG16
X#if REGISTERS >= 1
X#	undef	REG1
X#	define	REG1	register
X#endif
X#if REGISTERS >= 2
X#	undef	REG2
X#	define	REG2	register
X#endif
X#if REGISTERS >= 3
X#	undef	REG3
X#	define	REG3	register
X#endif
X#if REGISTERS >= 4
X#	undef	REG4
X#	define	REG4	register
X#endif
X#if REGISTERS >= 5
X#	undef	REG5
X#	define	REG5	register
X#endif
X#if REGISTERS >= 6
X#	undef	REG6
X#	define	REG6	register
X#endif
X#if REGISTERS >= 7
X#	undef	REG7
X#	define	REG7	register
X#endif
X#if REGISTERS >= 8
X#	undef	REG8
X#	define	REG8	register
X#endif
X#if REGISTERS >= 9
X#	undef	REG9
X#	define	REG9	register
X#endif
X#if REGISTERS >= 10
X#	undef	REG10
X#	define	REG10	register
X#endif
X#if REGISTERS >= 11
X#	undef	REG11
X#	define	REG11	register
X#endif
X#if REGISTERS >= 12
X#	undef	REG12
X#	define	REG12	register
X#endif
X#if REGISTERS >= 13
X#	undef	REG13
X#	define	REG13	register
X#endif
X#if REGISTERS >= 14
X#	undef	REG14
X#	define	REG14	register
X#endif
X#if REGISTERS >= 15
X#	undef	REG15
X#	define	REG15	register
X#endif
X#if REGISTERS >= 16
X#	undef	REG16
X#	define	REG16	register
X#endif
X    
X#ifndef	BYTEORDER
X#	define	BYTEORDER	0000
X#endif
X	
X#ifndef	NOALLIGN
X#	define	NOALLIGN	0
X#endif
X
X
Xunion	bytes {
X    long  word;
X    struct {
X#if BYTEORDER == 4321
X	char_type	b1;
X	char_type	b2;
X	char_type	b3;
X	char_type	b4;
X#else
X#if BYTEORDER == 1234
X	char_type	b4;
X	char_type	b3;
X	char_type	b2;
X	char_type	b1;
X#else
X#	undef	BYTEORDER
X	int  dummy;
X#endif
X#endif
X    } bytes;
X};
X
X#if BYTEORDER == 4321 && NOALLIGN == 1
X#  define input(b,o,c,n,m){ \
X     (c) = (*(long *)(&(b)[(o)>>3])>>((o)&0x7))&(m); \
X     (o) += (n); \
X   }
X#else
X#  define input(b,o,c,n,m){ \
X     REG1 char_type *p = &(b)[(o)>>3]; \
X     (c) = ((((long)(p[0]))|((long)(p[1])<<8)| \
X     ((long)(p[2])<<16))>>((o)&0x7))&(m); \
X     (o) += (n); \
X   }
X#endif
X
X#ifndef MAXSEG_64K
X   /* DECLARE(ush, tab_prefix, (1<<BITS)); -- prefix code */
X#  define tab_prefixof(i) tab_prefix[i]
X#  define clear_tab_prefixof()	memzero(tab_prefix, 256);
X#else
X   /* DECLARE(ush, tab_prefix0, (1<<(BITS-1)); -- prefix for even codes */
X   /* DECLARE(ush, tab_prefix1, (1<<(BITS-1)); -- prefix for odd  codes */
X   ush *tab_prefix[2];
X#  define tab_prefixof(i) tab_prefix[(i)&1][(i)>>1]
X#  define clear_tab_prefixof()	\
X      memzero(tab_prefix0, 128), \
X      memzero(tab_prefix1, 128);
X#endif
X#define de_stack        ((char_type *)(&d_buf[DIST_BUFSIZE-1]))
X#define tab_suffixof(i) tab_suffix[i]
X
Xint block_mode = BLOCK_MODE; /* block compress mode -C compatible with 2.0 */
X
X/* ============================================================================
X * Decompress in to out.  This routine adapts to the codes in the
X * file building the "string" table on-the-fly; requiring no table to
X * be stored in the compressed file.
X * IN assertions: the buffer inbuf contains already the beginning of
X *   the compressed data, from offsets iptr to insize-1 included.
X *   The magic header has already been checked and skipped.
X *   bytes_in and bytes_out have been initialized.
X */
Xint unlzw(in, out) 
X    int in, out;    /* input and output file descriptors */
X{
X    REG2   char_type  *stackp;
X    REG3   code_int   code;
X    REG4   int        finchar;
X    REG5   code_int   oldcode;
X    REG6   code_int   incode;
X    REG7   long       inbits;
X    REG8   long       posbits;
X    REG9   int        outpos;
X/*  REG10  int        insize; (global) */
X    REG11  unsigned   bitmask;
X    REG12  code_int   free_ent;
X    REG13  code_int   maxcode;
X    REG14  code_int   maxmaxcode;
X    REG15  int        n_bits;
X    REG16  int        rsize;
X    
X#ifdef MAXSEG_64K
X    tab_prefix[0] = tab_prefix0;
X    tab_prefix[1] = tab_prefix1;
X#endif
X    maxbits = get_byte();
X    block_mode = maxbits & BLOCK_MODE;
X    if ((maxbits & LZW_RESERVED) != 0) {
X	WARN((stderr, "\n%s: %s: warning, unknown flags 0x%x\n",
X	      progname, ifname, maxbits & LZW_RESERVED));
X    }
X    maxbits &= BIT_MASK;
X    maxmaxcode = MAXCODE(maxbits);
X    
X    if (maxbits > BITS) {
X	fprintf(stderr,
X		"\n%s: %s: compressed with %d bits, can only handle %d bits\n",
X		progname, ifname, maxbits, BITS);
X	exit_code = ERROR;
X	return ERROR;
X    }
X    rsize = insize;
X    maxcode = MAXCODE(n_bits = INIT_BITS)-1;
X    bitmask = (1<<n_bits)-1;
X    oldcode = -1;
X    finchar = 0;
X    outpos = 0;
X    posbits = inptr<<3;
X
X    free_ent = ((block_mode) ? FIRST : 256);
X    
X    clear_tab_prefixof(); /* Initialize the first 256 entries in the table. */
X    
X    for (code = 255 ; code >= 0 ; --code) {
X	tab_suffixof(code) = (char_type)code;
X    }
X    do {
X	REG1 int i;
X	int  e;
X	int  o;
X	
X    resetbuf:
X	e = insize-(o = (posbits>>3));
X	
X	for (i = 0 ; i < e ; ++i) {
X	    inbuf[i] = inbuf[i+o];
X	}
X	insize = e;
X	posbits = 0;
X	
X	if (insize < INBUF_EXTRA) {
X	    if ((rsize = read(in, (char*)inbuf+insize, INBUFSIZ)) == EOF) {
X		read_error();
X	    }
X	    insize += rsize;
X	    bytes_in += (ulg)rsize;
X	}
X	inbits = ((rsize != 0) ? ((long)insize - insize%n_bits)<<3 : 
X		  ((long)insize<<3)-(n_bits-1));
X	
X	while (inbits > posbits) {
X	    if (free_ent > maxcode) {
X		posbits = ((posbits-1) +
X			   ((n_bits<<3)-(posbits-1+(n_bits<<3))%(n_bits<<3)));
X		++n_bits;
X		if (n_bits == maxbits) {
X		    maxcode = maxmaxcode;
X		} else {
X		    maxcode = MAXCODE(n_bits)-1;
X		}
X		bitmask = (1<<n_bits)-1;
X		goto resetbuf;
X	    }
X	    input(inbuf,posbits,code,n_bits,bitmask);
X	    
X	    if (oldcode == -1) {
X		outbuf[outpos++] = (char_type)(finchar = (int)(oldcode=code));
X		continue;
X	    }
X	    if (code == CLEAR && block_mode) {
X		clear_tab_prefixof();
X		free_ent = FIRST - 1;
X		posbits = ((posbits-1) +
X			   ((n_bits<<3)-(posbits-1+(n_bits<<3))%(n_bits<<3)));
X		maxcode = MAXCODE(n_bits = INIT_BITS)-1;
X		bitmask = (1<<n_bits)-1;
X		goto resetbuf;
X	    }
X	    incode = code;
X	    stackp = de_stack;
X	    
X	    if (code >= free_ent) { /* Special case for KwKwK string. */
X		if (code > free_ent) {
X#ifdef DEBUG		    
X		    char_type *p;
X
X		    posbits -= n_bits;
X		    p = &inbuf[posbits>>3];
X		    fprintf(stderr,
X			    "code:%ld free_ent:%ld n_bits:%d insize:%u\n",
X			    code, free_ent, n_bits, insize);
X		    fprintf(stderr,
X			    "posbits:%ld inbuf:%02X %02X %02X %02X %02X\n",
X			    posbits, p[-1],p[0],p[1],p[2],p[3]);
X#endif
X		    if (!test && outpos > 0) {
X			write_buf(out, (char*)outbuf, outpos);
X			bytes_out += (ulg)outpos;
X		    }
X		    error("corrupt input. Use zcat to recover some data.");
X		}
X		*--stackp = (char_type)finchar;
X		code = oldcode;
X	    }
X
X	    while ((cmp_code_int)code >= (cmp_code_int)256) {
X		/* Generate output characters in reverse order */
X		*--stackp = tab_suffixof(code);
X		code = tab_prefixof(code);
X	    }
X	    *--stackp =	(char_type)(finchar = tab_suffixof(code));
X	    
X	    /* And put them out in forward order */
X	    {
X		REG1 int	i;
X	    
X		if (outpos+(i = (de_stack-stackp)) >= OUTBUFSIZ) {
X		    do {
X			if (i > OUTBUFSIZ-outpos) i = OUTBUFSIZ-outpos;
X
X			if (i > 0) {
X			    memcpy(outbuf+outpos, stackp, i);
X			    outpos += i;
X			}
X			if (outpos >= OUTBUFSIZ) {
X			    if (!test) {
X				write_buf(out, (char*)outbuf, outpos);
X				bytes_out += (ulg)outpos;
X			    }
X			    outpos = 0;
X			}
X			stackp+= i;
X		    } while ((i = (de_stack-stackp)) > 0);
X		} else {
X		    memcpy(outbuf+outpos, stackp, i);
X		    outpos += i;
X		}
X	    }
X
X	    if ((code = free_ent) < maxmaxcode) { /* Generate the new entry. */
X
X		tab_prefixof(code) = (unsigned short)oldcode;
X		tab_suffixof(code) = (char_type)finchar;
X		free_ent = code+1;
X	    } 
X	    oldcode = incode;	/* Remember previous code.	*/
X	}
X    } while (rsize != 0);
X    
X    if (!test && outpos > 0) {
X	write_buf(out, (char*)outbuf, outpos);
X	bytes_out += (ulg)outpos;
X    }
X    return OK;
X}
END_OF_FILE
if test 8729 -ne `wc -c <'gzip-1.2.2/unlzw.c'`; then
    echo shar: \"'gzip-1.2.2/unlzw.c'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/unlzw.c'
fi
if test -f 'gzip-1.2.2/unpack.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/unpack.c'\"
else
echo shar: Extracting \"'gzip-1.2.2/unpack.c'\" \(8169 characters\)
sed "s/^X//" >'gzip-1.2.2/unpack.c' <<'END_OF_FILE'
X/* unpack.c -- decompress files in pack format.
X * Copyright (C) 1992-1993 Jean-loup Gailly
X * This is free software; you can redistribute it and/or modify it under the
X * terms of the GNU General Public License, see the file COPYING.
X */
X
X#ifndef lint
Xstatic char rcsid[] = "$Id: unpack.c,v 1.4 1993/06/11 19:25:36 jloup Exp $";
X#endif
X
X#include "tailor.h"
X#include "gzip.h"
X#include "crypt.h"
X
X#define MIN(a,b) ((a) <= (b) ? (a) : (b))
X/* The arguments must not have side effects. */
X
X#define MAX_BITLEN 25
X/* Maximum length of Huffman codes. (Minor modifications to the code
X * would be needed to support 32 bits codes, but pack never generates
X * more than 24 bits anyway.)
X */
X
X#define LITERALS 256
X/* Number of literals, excluding the End of Block (EOB) code */
X
X#define MAX_PEEK 12
X/* Maximum number of 'peek' bits used to optimize traversal of the
X * Huffman tree.
X */
X
Xlocal ulg orig_len;       /* original uncompressed length */
Xlocal int max_len;        /* maximum bit length of Huffman codes */
X
Xlocal uch literal[LITERALS];
X/* The literal bytes present in the Huffman tree. The EOB code is not
X * represented.
X */
X
Xlocal int lit_base[MAX_BITLEN+1];
X/* All literals of a given bit length are contiguous in literal[] and
X * have contiguous codes. literal[code+lit_base[len]] is the literal
X * for a code of len bits.
X */
X
Xlocal int leaves [MAX_BITLEN+1]; /* Number of leaves for each bit length */
Xlocal int parents[MAX_BITLEN+1]; /* Number of parents for each bit length */
X
Xlocal int peek_bits; /* Number of peek bits currently used */
X
X/* local uch prefix_len[1 << MAX_PEEK]; */
X#define prefix_len outbuf
X/* For each bit pattern b of peek_bits bits, prefix_len[b] is the length
X * of the Huffman code starting with a prefix of b (upper bits), or 0
X * if all codes of prefix b have more than peek_bits bits. It is not
X * necessary to have a huge table (large MAX_PEEK) because most of the
X * codes encountered in the input stream are short codes (by construction).
X * So for most codes a single lookup will be necessary.
X */
X#if 1<<MAX_PEEK > OUTBUFSIZ
X    error cannot overlay prefix_len and outbuf
X#endif
X
Xlocal ulg bitbuf;
X/* Bits are added on the low part of bitbuf and read from the high part. */
X
Xlocal int valid;                  /* number of valid bits in bitbuf */
X/* all bits above the last valid bit are always zero */
X
X/* Set code to the next 'bits' input bits without skipping them. code
X * must be the name of a simple variable and bits must not have side effects.
X * IN assertions: bits <= 25 (so that we still have room for an extra byte
X * when valid is only 24), and mask = (1<<bits)-1.
X */
X#define look_bits(code,bits,mask) \
X{ \
X  while (valid < (bits)) bitbuf = (bitbuf<<8) | (ulg)get_byte(), valid += 8; \
X  code = (bitbuf.html >> (valid-(bits))) & (mask); \
X}
X
X/* Skip the given number of bits (after having peeked at them): */
X#define skip_bits(bits)  (valid -= (bits))
X
X#define clear_bitbuf() (valid = 0, bitbuf = 0)
X
X/* Local functions */
X
Xlocal void read_tree  OF((void));
Xlocal void build_tree OF((void));
X
X/* ===========================================================================
X * Read the Huffman tree.
X */
Xlocal void read_tree()
X{
X    int len;  /* bit length */
X    int base; /* base offset for a sequence of leaves */
X    int n;
X
X    /* Read the original input size, MSB first */
X    orig_len = 0;
X    for (n = 1; n <= 4; n++) orig_len = (orig_len << 8) | (ulg)get_byte();
X
X    max_len = (int)get_byte(); /* maximum bit length of Huffman codes */
X    if (max_len > MAX_BITLEN) {
X	error("invalid compressed data -- Huffman code > 32 bits");
X    }
X
X    /* Get the number of leaves at each bit length */
X    n = 0;
X    for (len = 1; len <= max_len; len++) {
X	leaves[len] = (int)get_byte();
X	n += leaves[len];
X    }
X    if (n > LITERALS) {
X	error("too many leaves in Huffman tree");
X    }
X    Trace((stderr, "orig_len %ld, max_len %d, leaves %d\n",
X	   orig_len, max_len, n));
X    /* There are at least 2 and at most 256 leaves of length max_len.
X     * (Pack arbitrarily rejects empty files and files consisting of
X     * a single byte even repeated.) To fit the last leaf count in a
X     * byte, it is offset by 2. However, the last literal is the EOB
X     * code, and is not transmitted explicitly in the tree, so we must
X     * adjust here by one only.
X     */
X    leaves[max_len]++;
X
X    /* Now read the leaves themselves */
X    base = 0;
X    for (len = 1; len <= max_len; len++) {
X	/* Remember where the literals of this length start in literal[] : */
X	lit_base[len] = base;
X	/* And read the literals: */
X	for (n = leaves[len]; n > 0; n--) {
X	    literal[base++] = (uch)get_byte();
X	}
X    }
X    leaves[max_len]++; /* Now include the EOB code in the Huffman tree */
X}
X
X/* ===========================================================================
X * Build the Huffman tree and the prefix table.
X */
Xlocal void build_tree()
X{
X    int nodes = 0; /* number of nodes (parents+leaves) at current bit length */
X    int len;       /* current bit length */
X    uch *prefixp;  /* pointer in prefix_len */
X
X    for (len = max_len; len >= 1; len--) {
X	/* The number of parent nodes at this level is half the total
X	 * number of nodes at parent level:
X	 */
X	nodes >>= 1;
X	parents[len] = nodes;
X	/* Update lit_base by the appropriate bias to skip the parent nodes
X	 * (which are not represented in the literal array):
X	 */
X	lit_base[len] -= nodes;
X	/* Restore nodes to be parents+leaves: */
X	nodes += leaves[len];
X    }
X    /* Construct the prefix table, from shortest leaves to longest ones.
X     * The shortest code is all ones, so we start at the end of the table.
X     */
X    peek_bits = MIN(max_len, MAX_PEEK);
X    prefixp = &prefix_len[1<<peek_bits];
X    for (len = 1; len <= peek_bits; len++) {
X	int prefixes = leaves[len] << (peek_bits-len); /* may be 0 */
X	while (prefixes--) *--prefixp = (uch)len;
X    }
X    /* The length of all other codes is unknown: */
X    while (prefixp > prefix_len) *--prefixp = 0;
X}
X
X/* ===========================================================================
X * Unpack in to out.  This routine does not support the old pack format
X * with magic header \037\037.
X *
X * IN assertions: the buffer inbuf contains already the beginning of
X *   the compressed data, from offsets inptr to insize-1 included.
X *   The magic header has already been checked. The output buffer is cleared.
X */
Xint unpack(in, out)
X    int in, out;            /* input and output file descriptors */
X{
X    int len;                /* Bit length of current code */
X    unsigned eob;           /* End Of Block code */
X    register unsigned peek; /* lookahead bits */
X    unsigned peek_mask;     /* Mask for peek_bits bits */
X
X    ifd = in;
X    ofd = out;
X
X    read_tree();     /* Read the Huffman tree */
X    build_tree();    /* Build the prefix table */
X    clear_bitbuf();  /* Initialize bit input */
X    peek_mask = (1<<peek_bits)-1;
X
X    /* The eob code is the largest code among all leaves of maximal length: */
X    eob = leaves[max_len]-1;
X    Trace((stderr, "eob %d %x\n", max_len, eob));
X
X    /* Decode the input data: */
X    for (;;) {
X	/* Since eob is the longest code and not shorter than max_len,
X         * we can peek at max_len bits without having the risk of reading
X         * beyond the end of file.
X	 */
X	look_bits(peek, peek_bits, peek_mask);
X	len = prefix_len[peek];
X	if (len > 0) {
X	    peek >>= peek_bits - len; /* discard the extra bits */
X	} else {
X	    /* Code of more than peek_bits bits, we must traverse the tree */
X	    ulg mask = peek_mask;
X	    len = peek_bits;
X	    do {
X                len++, mask = (mask<<1)+1;
X		look_bits(peek, len, mask);
X	    } while (peek < parents[len]);
X	    /* loop as long as peek is a parent node */
X	}
X	/* At this point, peek is the next complete code, of len bits */
X	if (peek == eob && len == max_len) break; /* end of file? */
X	put_ubyte(literal[peek+lit_base[len]]);
X	Tracev((stderr,"%02d %04x %c\n", len, peek,
X		literal[peek+lit_base[len]]));
X	skip_bits(len);
X    } /* for (;;) */
X
X    flush_window();
X    Trace((stderr, "bytes_out %ld\n", bytes_out));
X    if (orig_len != bytes_out) {
X	error("invalid compressed data--length error");
X    }
X    return OK;
X}
END_OF_FILE
if test 8169 -ne `wc -c <'gzip-1.2.2/unpack.c'`; then
    echo shar: \"'gzip-1.2.2/unpack.c'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/unpack.c'
fi
if test -f 'gzip-1.2.2/unlzh.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/unlzh.c'\"
else
echo shar: Extracting \"'gzip-1.2.2/unlzh.c'\" \(8733 characters\)
sed "s/^X//" >'gzip-1.2.2/unlzh.c' <<'END_OF_FILE'
X/* unlzh.c -- decompress files in SCO compress -H (LZH) format.
X * The code in this file is directly derived from the public domain 'ar002'
X * written by Haruhiko Okumura.
X */
X
X#include <stdio.h>
X
X#include "tailor.h"
X#include "gzip.h"
X#include "lzw.h" /* just for consistency checking */
X
X/* decode.c */
X
Xlocal unsigned  decode  OF((unsigned count, uch buffer[]));
Xlocal void decode_start OF((void));
X
X/* huf.c */
Xlocal void huf_decode_start OF((void));
Xlocal unsigned decode_c     OF((void));
Xlocal unsigned decode_p     OF((void));
X
X/* io.c */
Xlocal void fillbuf      OF((int n));
Xlocal unsigned getbits  OF((int n));
Xlocal void init_getbits OF((void));
X
X#define DICBIT    13    /* 12(-lh4-) or 13(-lh5-) */
X#define DICSIZ ((unsigned) 1 << DICBIT)
X
X#ifndef CHAR_BIT
X#  define CHAR_BIT 8
X#endif
X
X#ifndef UCHAR_MAX
X#  define UCHAR_MAX 255
X#endif
X
X#define BITBUFSIZ (CHAR_BIT * 2 * sizeof(char))
X/* Do not use CHAR_BIT * sizeof(bitbuf), does not work on machines
X * for which short is not on 16 bits (Cray).
X */
X
X/* encode.c and decode.c */
X
X#define MAXMATCH 256    /* formerly F (not more than UCHAR_MAX + 1) */
X#define THRESHOLD  3    /* choose optimal value */
X
X/* huf.c */
X
X#define NC (UCHAR_MAX + MAXMATCH + 2 - THRESHOLD)
X	/* alphabet = {0, 1, 2, ..., NC - 1} */
X#define CBIT 9  /* $\lfloor \log_2 NC \rfloor + 1$ */
X#define CODE_BIT  16  /* codeword length */
X
X#define NP (DICBIT + 1)
X#define NT (CODE_BIT + 3)
X#define PBIT 4  /* smallest integer such that (1U << PBIT) > NP */
X#define TBIT 5  /* smallest integer such that (1U << TBIT) > NT */
X#if NT > NP
X# define NPT NT
X#else
X# define NPT NP
X#endif
X
X/* local ush left[2 * NC - 1]; */
X/* local ush right[2 * NC - 1]; */
X#define left  prev
X#define right head
X#if NC > 1<<(BITS-2)
X    error cannot overlay left+right and prev
X#endif
X
X/* local uch c_len[NC]; */
X#define c_len outbuf
X#if NC > OUTBUFSIZ
X    error cannot overlay c_len and outbuf
X#endif
X
Xlocal uch pt_len[NPT];
Xlocal unsigned blocksize;
Xlocal ush pt_table[256];
X
X/* local ush c_table[4096]; */
X#define c_table d_buf
X#if DIST_BUFSIZE < 4096
X    error cannot overlay c_table and d_buf
X#endif
X
Xlocal ush       bitbuf;
Xlocal unsigned  subbitbuf;
Xlocal int       bitcount;
X
Xlocal void fillbuf(n)  /* Shift bitbuf n bits left, read n bits */
X    int n;
X{
X    bitbuf <<= n;
X    while (n > bitcount) {
X	bitbuf |= subbitbuf << (n -= bitcount);
X	subbitbuf = (unsigned)try_byte();
X	if ((int)subbitbuf == EOF) subbitbuf = 0;
X	bitcount = CHAR_BIT;
X    }
X    bitbuf |= subbitbuf >> (bitcount -= n);
X}
X
Xlocal unsigned getbits(n)
X    int n;
X{
X    unsigned x;
X
X    x = bitbuf >> (BITBUFSIZ - n);  fillbuf(n);
X    return x;
X}
X
Xlocal void init_getbits()
X{
X    bitbuf = 0;  subbitbuf = 0;  bitcount = 0;
X    fillbuf(BITBUFSIZ);
X}
X
X/***********************************************************
X	maketbl.c -- make table for decoding
X***********************************************************/
X
Xlocal void make_table(nchar, bitlen, tablebits, table)
X    int nchar;
X    uch bitlen[];
X    int tablebits;
X    ush table[];
X{
X    ush count[17], weight[17], start[18], *p;
X    unsigned i, k, len, ch, jutbits, avail, nextcode, mask;
X
X    for (i = 1; i <= 16; i++) count[i] = 0;
X    for (i = 0; i < nchar; i++) count[bitlen[i]]++;
X
X    start[1] = 0;
X    for (i = 1; i <= 16; i++)
X	start[i + 1] = start[i] + (count[i] << (16 - i));
X    if (start[17] != (ush)((unsigned) 1 << 16))
X	error("Bad table\n");
X
X    jutbits = 16 - tablebits;
X    for (i = 1; i <= tablebits; i++) {
X	start[i] >>= jutbits;
X	weight[i] = (unsigned) 1 << (tablebits - i);
X    }
X    while (i <= 16) {
X	weight[i] = (unsigned) 1 << (16 - i);
X	i++;
X    }
X
X    i = start[tablebits + 1] >> jutbits;
X    if (i != (ush)((unsigned) 1 << 16)) {
X	k = 1 << tablebits;
X	while (i != k) table[i++] = 0;
X    }
X
X    avail = nchar;
X    mask = (unsigned) 1 << (15 - tablebits);
X    for (ch = 0; ch < nchar; ch++) {
X	if ((len = bitlen[ch]) == 0) continue;
X	nextcode = start[len] + weight[len];
X	if (len <= tablebits) {
X	    for (i = start[len]; i < nextcode; i++) table[i] = ch;
X	} else {
X	    k = start[len];
X	    p = &table[k >> jutbits];
X	    i = len - tablebits;
X	    while (i != 0) {
X		if (*p == 0) {
X		    right[avail] = left[avail] = 0;
X		    *p = avail++;
X		}
X		if (k & mask) p = &right[*p];
X		else          p = &left[*p];
X		k <<= 1;  i--;
X	    }
X	    *p = ch;
X	}
X	start[len] = nextcode;
X    }
X}
X
X/***********************************************************
X        huf.c -- static Huffman
X***********************************************************/
X
Xlocal void read_pt_len(nn, nbit, i_special)
X    int nn;
X    int nbit;
X    int i_special;
X{
X    int i, c, n;
X    unsigned mask;
X
X    n = getbits(nbit);
X    if (n == 0) {
X	c = getbits(nbit);
X	for (i = 0; i < nn; i++) pt_len[i] = 0;
X	for (i = 0; i < 256; i++) pt_table[i] = c;
X    } else {
X	i = 0;
X	while (i < n) {
X	    c = bitbuf >> (BITBUFSIZ - 3);
X	    if (c == 7) {
X		mask = (unsigned) 1 << (BITBUFSIZ - 1 - 3);
X		while (mask & bitbuf) {  mask >>= 1;  c++;  }
X	    }
X	    fillbuf((c < 7) ? 3 : c - 3);
X	    pt_len[i++] = c;
X	    if (i == i_special) {
X		c = getbits(2);
X		while (--c >= 0) pt_len[i++] = 0;
X	    }
X	}
X	while (i < nn) pt_len[i++] = 0;
X	make_table(nn, pt_len, 8, pt_table);
X    }
X}
X
Xlocal void read_c_len()
X{
X    int i, c, n;
X    unsigned mask;
X
X    n = getbits(CBIT);
X    if (n == 0) {
X	c = getbits(CBIT);
X	for (i = 0; i < NC; i++) c_len[i] = 0;
X	for (i = 0; i < 4096; i++) c_table[i] = c;
X    } else {
X	i = 0;
X	while (i < n) {
X	    c = pt_table[bitbuf >> (BITBUFSIZ - 8)];
X	    if (c >= NT) {
X		mask = (unsigned) 1 << (BITBUFSIZ - 1 - 8);
X		do {
X		    if (bitbuf & mask) c = right[c];
X		    else               c = left [c];
X		    mask >>= 1;
X		} while (c >= NT);
X	    }
X	    fillbuf((int) pt_len[c]);
X	    if (c <= 2) {
X		if      (c == 0) c = 1;
X		else if (c == 1) c = getbits(4) + 3;
X		else             c = getbits(CBIT) + 20;
X		while (--c >= 0) c_len[i++] = 0;
X	    } else c_len[i++] = c - 2;
X	}
X	while (i < NC) c_len[i++] = 0;
X	make_table(NC, c_len, 12, c_table);
X    }
X}
X
Xlocal unsigned decode_c()
X{
X    unsigned j, mask;
X
X    if (blocksize == 0) {
X	blocksize = getbits(16);
X	if (blocksize == 0) {
X	    return NC; /* end of file */
X	}
X	read_pt_len(NT, TBIT, 3);
X	read_c_len();
X	read_pt_len(NP, PBIT, -1);
X    }
X    blocksize--;
X    j = c_table[bitbuf >> (BITBUFSIZ - 12)];
X    if (j >= NC) {
X	mask = (unsigned) 1 << (BITBUFSIZ - 1 - 12);
X	do {
X	    if (bitbuf & mask) j = right[j];
X	    else               j = left [j];
X	    mask >>= 1;
X	} while (j >= NC);
X    }
X    fillbuf((int) c_len[j]);
X    return j;
X}
X
Xlocal unsigned decode_p()
X{
X    unsigned j, mask;
X
X    j = pt_table[bitbuf >> (BITBUFSIZ - 8)];
X    if (j >= NP) {
X	mask = (unsigned) 1 << (BITBUFSIZ - 1 - 8);
X	do {
X	    if (bitbuf & mask) j = right[j];
X	    else               j = left [j];
X	    mask >>= 1;
X	} while (j >= NP);
X    }
X    fillbuf((int) pt_len[j]);
X    if (j != 0) j = ((unsigned) 1 << (j - 1)) + getbits((int) (j - 1));
X    return j;
X}
X
Xlocal void huf_decode_start()
X{
X    init_getbits();  blocksize = 0;
X}
X
X/***********************************************************
X        decode.c
X***********************************************************/
X
Xlocal int j;    /* remaining bytes to copy */
Xlocal int done; /* set at end of input */
X
Xlocal void decode_start()
X{
X    huf_decode_start();
X    j = 0;
X    done = 0;
X}
X
X/* Decode the input and return the number of decoded bytes put in buffer
X */
Xlocal unsigned decode(count, buffer)
X    unsigned count;
X    uch buffer[];
X    /* The calling function must keep the number of
X       bytes to be processed.  This function decodes
X       either 'count' bytes or 'DICSIZ' bytes, whichever
X       is smaller, into the array 'buffer[]' of size
X       'DICSIZ' or more.
X       Call decode_start() once for each new file
X       before calling this function.
X     */
X{
X    local unsigned i;
X    unsigned r, c;
X
X    r = 0;
X    while (--j >= 0) {
X	buffer[r] = buffer[i];
X	i = (i + 1) & (DICSIZ - 1);
X	if (++r == count) return r;
X    }
X    for ( ; ; ) {
X	c = decode_c();
X	if (c == NC) {
X	    done = 1;
X	    return r;
X	}
X	if (c <= UCHAR_MAX) {
X	    buffer[r] = c;
X	    if (++r == count) return r;
X	} else {
X	    j = c - (UCHAR_MAX + 1 - THRESHOLD);
X	    i = (r - decode_p() - 1) & (DICSIZ - 1);
X	    while (--j >= 0) {
X		buffer[r] = buffer[i];
X		i = (i + 1) & (DICSIZ - 1);
X		if (++r == count) return r;
X	    }
X	}
X    }
X}
X
X
X/* ===========================================================================
X * Unlzh in to out. Return OK or ERROR.
X */
Xint unlzh(in, out)
X    int in;
X    int out;
X{
X    unsigned n;
X    ifd = in;
X    ofd = out;
X
X    decode_start();
X    while (!done) {
X	n = decode((unsigned) DICSIZ, window);
X	if (!test && n > 0) {
X	    write_buf(out, (char*)window, n);
X	}
X    }
X    return OK;
X}
END_OF_FILE
if test 8733 -ne `wc -c <'gzip-1.2.2/unlzh.c'`; then
    echo shar: \"'gzip-1.2.2/unlzh.c'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/unlzh.c'
fi
if test -f 'gzip-1.2.2/getopt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/getopt.c'\"
else
echo shar: Extracting \"'gzip-1.2.2/getopt.c'\" \(20177 characters\)
sed "s/^X//" >'gzip-1.2.2/getopt.c' <<'END_OF_FILE'
X/* Getopt for GNU.
X   NOTE: getopt is now part of the C library, so if you don't know what
X   "Keep this file name-space clean" means, talk to roland@gnu.ai.mit.edu
X   before changing it!
X
X   Copyright (C) 1987, 88, 89, 90, 91, 1992 Free Software Foundation, Inc.
X
X   This program is free software; you can redistribute it and/or modify it
X   under the terms of the GNU General Public License as published by the
X   Free Software Foundation; either version 2, or (at your option) any
X   later version.
X   
X   This program is distributed in the hope that it will be useful,
X   but WITHOUT ANY WARRANTY; without even the implied warranty of
X   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X   GNU General Public License for more details.
X   
X   You should have received a copy of the GNU General Public License
X   along with this program; if not, write to the Free Software
X   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
X
X/* AIX requires this to be the first thing in the file.  */
X#ifdef __GNUC__
X#define alloca __builtin_alloca
X#else /* not __GNUC__ */
X#if defined (HAVE_ALLOCA_H) || (defined(sparc) && (defined(sun) || (!defined(USG) && !defined(SVR4) && !defined(__svr4__))))
X#include <alloca.h>
X#else
X#ifdef _AIX
X #pragma alloca
X#else
Xchar *alloca ();
X#endif
X#endif /* alloca.h */
X#endif /* not __GNUC__ */
X
X/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.  */
X#ifndef _NO_PROTO
X#  define _NO_PROTO
X#endif
X
X#include <stdio.h>
X
X#if defined(USG) || defined(STDC_HEADERS) || defined(__GNU_LIBRARY__)
X#include <string.h>
X#endif
X
X/* This needs to come after some library #include
X   to get __GNU_LIBRARY__ defined.  */
X#ifdef	__GNU_LIBRARY__
X#undef	alloca
X/* Don't include stdlib.h for non-GNU C libraries because some of them
X   contain conflicting prototypes for getopt.  */
X#include <stdlib.h>
X#else	/* Not GNU C library.  */
X#define	__alloca	alloca
X#endif	/* GNU C library.  */
X
X#if !__STDC__
X#define const
X#endif
X
X/* If GETOPT_COMPAT is defined, `+' as well as `--' can introduce a
X   long-named option.  Because this is not POSIX.2 compliant, it is
X   being phased out.  */
X#define GETOPT_COMPAT
X
X/* This version of `getopt' appears to the caller like standard Unix `getopt'
X   but it behaves differently for the user, since it allows the user
X   to intersperse the options with the other arguments.
X
X   As `getopt' works, it permutes the elements of ARGV so that,
X   when it is done, all the options precede everything else.  Thus
X   all application programs are extended to handle flexible argument order.
X
X   Setting the environment variable POSIXLY_CORRECT disables permutation.
X   Then the behavior is completely standard.
X
X   GNU application programs can use a third alternative mode in which
X   they can distinguish the relative order of options and other arguments.  */
X
X#include "getopt.h"
X
X/* For communication from `getopt' to the caller.
X   When `getopt' finds an option that takes an argument,
X   the argument value is returned here.
X   Also, when `ordering' is RETURN_IN_ORDER,
X   each non-option ARGV-element is returned here.  */
X
Xchar *optarg = 0;
X
X/* Index in ARGV of the next element to be scanned.
X   This is used for communication to and from the caller
X   and for communication between successive calls to `getopt'.
X
X   On entry to `getopt', zero means this is the first call; initialize.
X
X   When `getopt' returns EOF, this is the index of the first of the
X   non-option elements that the caller should itself scan.
X
X   Otherwise, `optind' communicates from one call to the next
X   how much of ARGV has been scanned so far.  */
X
Xint optind = 0;
X
X/* The next char to be scanned in the option-element
X   in which the last option character we returned was found.
X   This allows us to pick up the scan where we left off.
X
X   If this is zero, or a null string, it means resume the scan
X   by advancing to the next ARGV-element.  */
X
Xstatic char *nextchar;
X
X/* Callers store zero here to inhibit the error message
X   for unrecognized options.  */
X
Xint opterr = 1;
X
X/* Describe how to deal with options that follow non-option ARGV-elements.
X
X   If the caller did not specify anything,
X   the default is REQUIRE_ORDER if the environment variable
X   POSIXLY_CORRECT is defined, PERMUTE otherwise.
X
X   REQUIRE_ORDER means don't recognize them as options;
X   stop option processing when the first non-option is seen.
X   This is what Unix does.
X   This mode of operation is selected by either setting the environment
X   variable POSIXLY_CORRECT, or using `+' as the first character
X   of the list of option characters.
X
X   PERMUTE is the default.  We permute the contents of ARGV as we scan,
X   so that eventually all the non-options are at the end.  This allows options
X   to be given in any order, even with programs that were not written to
X   expect this.
X
X   RETURN_IN_ORDER is an option available to programs that were written
X   to expect options and other ARGV-elements in any order and that care about
X   the ordering of the two.  We describe each non-option ARGV-element
X   as if it were the argument of an option with character code 1.
X   Using `-' as the first character of the list of option characters
X   selects this mode of operation.
X
X   The special argument `--' forces an end of option-scanning regardless
X   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
X   `--' can cause `getopt' to return EOF with `optind' != ARGC.  */
X
Xstatic enum
X{
X  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
X} ordering;
X
X#ifdef	__GNU_LIBRARY__
X#include <string.h>
X#define	my_index	strchr
X#define	my_bcopy(src, dst, n)	memcpy ((dst), (src), (n))
X#else
X
X/* Avoid depending on library functions or files
X   whose names are inconsistent.  */
X
Xchar *getenv ();
X
Xstatic char *
Xmy_index (string, chr)
X     char *string;
X     int chr;
X{
X  while (*string)
X    {
X      if (*string == chr)
X	return string;
X      string++;
X    }
X  return 0;
X}
X
Xstatic void
Xmy_bcopy (from, to, size)
X     char *from, *to;
X     int size;
X{
X  int i;
X  for (i = 0; i < size; i++)
X    to[i] = from[i];
X}
X#endif				/* GNU C library.  */
X
X/* Handle permutation of arguments.  */
X
X/* Describe the part of ARGV that contains non-options that have
X   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
X   `last_nonopt' is the index after the last of them.  */
X
Xstatic int first_nonopt;
Xstatic int last_nonopt;
X
X/* Exchange two adjacent subsequences of ARGV.
X   One subsequence is elements [first_nonopt,last_nonopt)
X   which contains all the non-options that have been skipped so far.
X   The other is elements [last_nonopt,optind), which contains all
X   the options processed since those non-options were skipped.
X
X   `first_nonopt' and `last_nonopt' are relocated so that they describe
X   the new indices of the non-options in ARGV after they are moved.  */
X
Xstatic void
Xexchange (argv)
X     char **argv;
X{
X  int nonopts_size = (last_nonopt - first_nonopt) * sizeof (char *);
X#ifdef _CRAY
X  char *temp[last_nonopt - first_nonopt];
X#else
X  char **temp = (char **) __alloca (nonopts_size);
X#endif
X
X  /* Interchange the two blocks of data in ARGV.  */
X
X  my_bcopy ((char *) &argv[first_nonopt], (char *) temp, nonopts_size);
X  my_bcopy ((char *) &argv[last_nonopt], (char *) &argv[first_nonopt],
X	    (optind - last_nonopt) * sizeof (char *));
X  my_bcopy ((char *) temp,
X	    (char *) &argv[first_nonopt + optind - last_nonopt],
X	    nonopts_size);
X
X  /* Update records for the slots the non-options now occupy.  */
X
X  first_nonopt += (optind - last_nonopt);
X  last_nonopt = optind;
X}
X
X/* Scan elements of ARGV (whose length is ARGC) for option characters
X   given in OPTSTRING.
X
X   If an element of ARGV starts with '-', and is not exactly "-" or "--",
X   then it is an option element.  The characters of this element
X   (aside from the initial '-') are option characters.  If `getopt'
X   is called repeatedly, it returns successively each of the option characters
X   from each of the option elements.
X
X   If `getopt' finds another option character, it returns that character,
X   updating `optind' and `nextchar' so that the next call to `getopt' can
X   resume the scan with the following option character or ARGV-element.
X
X   If there are no more option characters, `getopt' returns `EOF'.
X   Then `optind' is the index in ARGV of the first ARGV-element
X   that is not an option.  (The ARGV-elements have been permuted
X   so that those that are not options now come last.)
X
X   OPTSTRING is a string containing the legitimate option characters.
X   If an option character is seen that is not listed in OPTSTRING,
X   return '?' after printing an error message.  If you set `opterr' to
X   zero, the error message is suppressed but we still return '?'.
X
X   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
X   so the following text in the same ARGV-element, or the text of the following
X   ARGV-element, is returned in `optarg'.  Two colons mean an option that
X   wants an optional arg; if there is text in the current ARGV-element,
X   it is returned in `optarg', otherwise `optarg' is set to zero.
X
X   If OPTSTRING starts with `-' or `+', it requests different methods of
X   handling the non-option ARGV-elements.
X   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.
X
X   Long-named options begin with `--' instead of `-'.
X   Their names may be abbreviated as long as the abbreviation is unique
X   or is an exact match for some defined option.  If they have an
X   argument, it follows the option name in the same ARGV-element, separated
X   from the option name by a `=', or else the in next ARGV-element.
X   When `getopt' finds a long-named option, it returns 0 if that option's
X   `flag' field is nonzero, the value of the option's `val' field
X   if the `flag' field is zero.
X
X   The elements of ARGV aren't really const, because we permute them.
X   But we pretend they're const in the prototype to be compatible
X   with other systems.
X
X   LONGOPTS is a vector of `struct option' terminated by an
X   element containing a name which is zero.
X
X   LONGIND returns the index in LONGOPT of the long-named option found.
X   It is only valid when a long-named option has been found by the most
X   recent call.
X
X   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
X   long-named options.  */
X
Xint
X_getopt_internal (argc, argv, optstring, longopts, longind, long_only)
X     int argc;
X     char *const *argv;
X     const char *optstring;
X     const struct option *longopts;
X     int *longind;
X     int long_only;
X{
X  int option_index;
X
X  optarg = 0;
X
X  /* Initialize the internal data when the first call is made.
X     Start processing options with ARGV-element 1 (since ARGV-element 0
X     is the program name); the sequence of previously skipped
X     non-option ARGV-elements is empty.  */
X
X  if (optind == 0)
X    {
X      first_nonopt = last_nonopt = optind = 1;
X
X      nextchar = NULL;
X
X      /* Determine how to handle the ordering of options and nonoptions.  */
X
X      if (optstring[0] == '-')
X	{
X	  ordering = RETURN_IN_ORDER;
X	  ++optstring;
X	}
X      else if (optstring[0] == '+')
X	{
X	  ordering = REQUIRE_ORDER;
X	  ++optstring;
X	}
X      else if (getenv ("POSIXLY_CORRECT") != NULL)
X	ordering = REQUIRE_ORDER;
X      else
X	ordering = PERMUTE;
X    }
X
X  if (nextchar == NULL || *nextchar == '\0')
X    {
X      if (ordering == PERMUTE)
X	{
X	  /* If we have just processed some options following some non-options,
X	     exchange them so that the options come first.  */
X
X	  if (first_nonopt != last_nonopt && last_nonopt != optind)
X	    exchange ((char **) argv);
X	  else if (last_nonopt != optind)
X	    first_nonopt = optind;
X
X	  /* Now skip any additional non-options
X	     and extend the range of non-options previously skipped.  */
X
X	  while (optind < argc
X		 && (argv[optind][0] != '-' || argv[optind][1] == '\0')
X#ifdef GETOPT_COMPAT
X		 && (longopts == NULL
X		     || argv[optind][0] != '+' || argv[optind][1] == '\0')
X#endif				/* GETOPT_COMPAT */
X		 )
X	    optind++;
X	  last_nonopt = optind;
X	}
X
X      /* Special ARGV-element `--' means premature end of options.
X	 Skip it like a null option,
X	 then exchange with previous non-options as if it were an option,
X	 then skip everything else like a non-option.  */
X
X      if (optind != argc && !strcmp (argv[optind], "--"))
X	{
X	  optind++;
X
X	  if (first_nonopt != last_nonopt && last_nonopt != optind)
X	    exchange ((char **) argv);
X	  else if (first_nonopt == last_nonopt)
X	    first_nonopt = optind;
X	  last_nonopt = argc;
X
X	  optind = argc;
X	}
X
X      /* If we have done all the ARGV-elements, stop the scan
X	 and back over any non-options that we skipped and permuted.  */
X
X      if (optind == argc)
X	{
X	  /* Set the next-arg-index to point at the non-options
X	     that we previously skipped, so the caller will digest them.  */
X	  if (first_nonopt != last_nonopt)
X	    optind = first_nonopt;
X	  return EOF;
X	}
X
X      /* If we have come to a non-option and did not permute it,
X	 either stop the scan or describe it to the caller and pass it by.  */
X
X      if ((argv[optind][0] != '-' || argv[optind][1] == '\0')
X#ifdef GETOPT_COMPAT
X	  && (longopts == NULL
X	      || argv[optind][0] != '+' || argv[optind][1] == '\0')
X#endif				/* GETOPT_COMPAT */
X	  )
X	{
X	  if (ordering == REQUIRE_ORDER)
X	    return EOF;
X	  optarg = argv[optind++];
X	  return 1;
X	}
X
X      /* We have found another option-ARGV-element.
X	 Start decoding its characters.  */
X
X      nextchar = (argv[optind] + 1
X		  + (longopts != NULL && argv[optind][1] == '-'));
X    }
X
X  if (longopts != NULL
X      && ((argv[optind][0] == '-'
X	   && (argv[optind][1] == '-' || long_only))
X#ifdef GETOPT_COMPAT
X	  || argv[optind][0] == '+'
X#endif				/* GETOPT_COMPAT */
X	  ))
X    {
X      const struct option *p;
X      char *s = nextchar;
X      int exact = 0;
X      int ambig = 0;
X      const struct option *pfound = NULL;
X      int indfound = 0;
X
X      while (*s && *s != '=')
X	s++;
X
X      /* Test all options for either exact match or abbreviated matches.  */
X      for (p = longopts, option_index = 0; p->name;
X	   p++, option_index++)
X	if (!strncmp (p->name, nextchar, s - nextchar))
X	  {
X	    if (s - nextchar == strlen (p->name))
X	      {
X		/* Exact match found.  */
X		pfound = p;
X		indfound = option_index;
X		exact = 1;
X		break;
X	      }
X	    else if (pfound == NULL)
X	      {
X		/* First nonexact match found.  */
X		pfound = p;
X		indfound = option_index;
X	      }
X	    else
X	      /* Second nonexact match found.  */
X	      ambig = 1;
X	  }
X
X      if (ambig && !exact)
X	{
X	  if (opterr)
X	    fprintf (stderr, "%s: option `%s' is ambiguous\n",
X		     argv[0], argv[optind]);
X	  nextchar += strlen (nextchar);
X	  optind++;
X	  return '?';
X	}
X
X      if (pfound != NULL)
X	{
X	  option_index = indfound;
X	  optind++;
X	  if (*s)
X	    {
X	      /* Don't test has_arg with >, because some C compilers don't
X		 allow it to be used on enums.  */
X	      if (pfound->has_arg)
X		optarg = s + 1;
X	      else
X		{
X		  if (opterr)
X		    {
X		      if (argv[optind - 1][1] == '-')
X			/* --option */
X			fprintf (stderr,
X				 "%s: option `--%s' doesn't allow an argument\n",
X				 argv[0], pfound->name);
X		      else
X			/* +option or -option */
X			fprintf (stderr,
X			     "%s: option `%c%s' doesn't allow an argument\n",
X			     argv[0], argv[optind - 1][0], pfound->name);
X		    }
X		  nextchar += strlen (nextchar);
X		  return '?';
X		}
X	    }
X	  else if (pfound->has_arg == 1)
X	    {
X	      if (optind < argc)
X		optarg = argv[optind++];
X	      else
X		{
X		  if (opterr)
X		    fprintf (stderr, "%s: option `%s' requires an argument\n",
X			     argv[0], argv[optind - 1]);
X		  nextchar += strlen (nextchar);
X		  return '?';
X		}
X	    }
X	  nextchar += strlen (nextchar);
X	  if (longind != NULL)
X	    *longind = option_index;
X	  if (pfound->flag)
X	    {
X	      *(pfound->flag) = pfound->val;
X	      return 0;
X	    }
X	  return pfound->val;
X	}
X      /* Can't find it as a long option.  If this is not getopt_long_only,
X	 or the option starts with '--' or is not a valid short
X	 option, then it's an error.
X	 Otherwise interpret it as a short option.  */
X      if (!long_only || argv[optind][1] == '-'
X#ifdef GETOPT_COMPAT
X	  || argv[optind][0] == '+'
X#endif				/* GETOPT_COMPAT */
X	  || my_index ((char*)optstring, *nextchar) == NULL)
X	{
X	  if (opterr)
X	    {
X	      if (argv[optind][1] == '-')
X		/* --option */
X		fprintf (stderr, "%s: unrecognized option `--%s'\n",
X			 argv[0], nextchar);
X	      else
X		/* +option or -option */
X		fprintf (stderr, "%s: unrecognized option `%c%s'\n",
X			 argv[0], argv[optind][0], nextchar);
X	    }
X	  nextchar = (char *) "";
X	  optind++;
X	  return '?';
X	}
X    }
X
X  /* Look at and handle the next option-character.  */
X
X  {
X    char c = *nextchar++;
X    char *temp = my_index ((char*)optstring, c);
X
X    /* Increment `optind' when we start to process its last character.  */
X    if (*nextchar == '\0')
X      ++optind;
X
X    if (temp == NULL || c == ':')
X      {
X	if (opterr)
X	  {
X	    if (c < 040 || c >= 0177)
X	      fprintf (stderr, "%s: unrecognized option, character code 0%o\n",
X		       argv[0], c);
X	    else
X	      fprintf (stderr, "%s: unrecognized option `-%c'\n", argv[0], c);
X	  }
X	return '?';
X      }
X    if (temp[1] == ':')
X      {
X	if (temp[2] == ':')
X	  {
X	    /* This is an option that accepts an argument optionally.  */
X	    if (*nextchar != '\0')
X	      {
X		optarg = nextchar;
X		optind++;
X	      }
X	    else
X	      optarg = 0;
X	    nextchar = NULL;
X	  }
X	else
X	  {
X	    /* This is an option that requires an argument.  */
X	    if (*nextchar != '\0')
X	      {
X		optarg = nextchar;
X		/* If we end this ARGV-element by taking the rest as an arg,
X		   we must advance to the next element now.  */
X		optind++;
X	      }
X	    else if (optind == argc)
X	      {
X		if (opterr)
X		  fprintf (stderr, "%s: option `-%c' requires an argument\n",
X			   argv[0], c);
X		c = '?';
X	      }
X	    else
X	      /* We already incremented `optind' once;
X		 increment it again when taking next ARGV-elt as argument.  */
X	      optarg = argv[optind++];
X	    nextchar = NULL;
X	  }
X      }
X    return c;
X  }
X}
X
Xint
Xgetopt (argc, argv, optstring)
X     int argc;
X     char *const *argv;
X     const char *optstring;
X{
X  return _getopt_internal (argc, argv, optstring,
X			   (const struct option *) 0,
X			   (int *) 0,
X			   0);
X}
X
Xint
Xgetopt_long (argc, argv, options, long_options, opt_index)
X     int argc;
X     char *const *argv;
X     const char *options;
X     const struct option *long_options;
X     int *opt_index;
X{
X  return _getopt_internal (argc, argv, options, long_options, opt_index, 0);
X}
X
X/* Like getopt_long, but '-' as well as '--' can indicate a long option.
X   If an option that starts with '-' (not '--') doesn't match a long option,
X   but does match a short option, it is parsed as a short option
X   instead. */
X
Xint 
Xgetopt_long_only (argc, argv, options, long_options, opt_index)
X     int argc;
X     char *const *argv;
X     const char *options;
X     const struct option *long_options;
X     int *opt_index;
X{
X  return _getopt_internal (argc, argv, options, long_options, opt_index, 1);
X}
X
X
X#ifdef TEST
X
X/* Compile with -DTEST to make an executable for use in testing
X   the above definition of `getopt'.  */
X
Xint
Xmain (argc, argv)
X     int argc;
X     char **argv;
X{
X  int c;
X  int digit_optind = 0;
X
X  while (1)
X    {
X      int this_option_optind = optind ? optind : 1;
X
X      c = getopt (argc, argv, "abc:d:0123456789");
X      if (c == EOF)
X	break;
X
X      switch (c)
X	{
X	case '0':
X	case '1':
X	case '2':
X	case '3':
X	case '4':
X	case '5':
X	case '6':
X	case '7':
X	case '8':
X	case '9':
X	  if (digit_optind != 0 && digit_optind != this_option_optind)
X	    printf ("digits occur in two different argv-elements.\n");
X	  digit_optind = this_option_optind;
X	  printf ("option %c\n", c);
X	  break;
X
X	case 'a':
X	  printf ("option a\n");
X	  break;
X
X	case 'b':
X	  printf ("option b\n");
X	  break;
X
X	case 'c':
X	  printf ("option c with value `%s'\n", optarg);
X	  break;
X
X	case '?':
X	  break;
X
X	default:
X	  printf ("?? getopt returned character code 0%o ??\n", c);
X	}
X    }
X
X  if (optind < argc)
X    {
X      printf ("non-option ARGV-elements: ");
X      while (optind < argc)
X	printf ("%s ", argv[optind++]);
X      printf ("\n");
X    }
X
X  exit (0);
X}
X
X#endif /* TEST */
END_OF_FILE
if test 20177 -ne `wc -c <'gzip-1.2.2/getopt.c'`; then
    echo shar: \"'gzip-1.2.2/getopt.c'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/getopt.c'
fi
if test -f 'gzip-1.2.2/alloca.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/alloca.c'\"
else
echo shar: Extracting \"'gzip-1.2.2/alloca.c'\" \(5374 characters\)
sed "s/^X//" >'gzip-1.2.2/alloca.c' <<'END_OF_FILE'
X/*
X	alloca -- (mostly) portable public-domain implementation -- D A Gwyn
X
X	last edit:	86/05/30	rms
X	   include config.h, since on VMS it renames some symbols.
X	   Use xmalloc instead of malloc.
X
X	This implementation of the PWB library alloca() function,
X	which is used to allocate space off the run-time stack so
X	that it is automatically reclaimed upon procedure exit, 
X	was inspired by discussions with J. Q. Johnson of Cornell.
X
X	It should work under any C implementation that uses an
X	actual procedure stack (as opposed to a linked list of
X	frames).  There are some preprocessor constants that can
X	be defined when compiling for your specific system, for
X	improved efficiency; however, the defaults should be okay.
X
X	The general concept of this implementation is to keep
X	track of all alloca()-allocated blocks, and reclaim any
X	that are found to be deeper in the stack than the current
X	invocation.  This heuristic does not reclaim storage as
X	soon as it becomes invalid, but it will do so eventually.
X
X	As a special case, alloca(0) reclaims storage without
X	allocating any.  It is a good idea to use alloca(0) in
X	your main control loop, etc. to force garbage collection.
X*/
X#ifndef lint
Xstatic char	SCCSid[] = "@(#)alloca.c	1.1";	/* for the "what" utility */
X#endif
X
X#ifdef emacs
X#include "config.h"
X#ifdef static
X/* actually, only want this if static is defined as ""
X   -- this is for usg, in which emacs must undefine static
X   in order to make unexec workable
X   */
X#ifndef STACK_DIRECTION
Xyou
Xlose
X-- must know STACK_DIRECTION at compile-time
X#endif /* STACK_DIRECTION undefined */
X#endif /* static */
X#endif /* emacs */
X
X#if !defined(alloca) && !defined(__GNUC__)
X/* If compiling with GCC, this file's not needed.  */
X
X#ifdef __STDC__
Xtypedef void	*pointer;		/* generic pointer type */
X#else
Xtypedef char	*pointer;		/* generic pointer type */
X#endif
X
X#ifndef NULL
X#define	NULL	0			/* null pointer constant */
X#endif
X
Xextern void	free();
Xextern pointer	xmalloc();
X
X/*
X	Define STACK_DIRECTION if you know the direction of stack
X	growth for your system; otherwise it will be automatically
X	deduced at run-time.
X
X	STACK_DIRECTION > 0 => grows toward higher addresses
X	STACK_DIRECTION < 0 => grows toward lower addresses
X	STACK_DIRECTION = 0 => direction of growth unknown
X*/
X
X#ifndef STACK_DIRECTION
X#define	STACK_DIRECTION	0		/* direction unknown */
X#endif
X
X#if STACK_DIRECTION != 0
X
X#define	STACK_DIR	STACK_DIRECTION	/* known at compile-time */
X
X#else	/* STACK_DIRECTION == 0; need run-time code */
X
Xstatic int	stack_dir;		/* 1 or -1 once known */
X#define	STACK_DIR	stack_dir
X
Xstatic void
Xfind_stack_direction (/* void */)
X{
X  static char	*addr = NULL;	/* address of first
X				   `dummy', once known */
X  auto char	dummy;		/* to get stack address */
X
X  if (addr == NULL)
X    {				/* initial entry */
X      addr = &dummy;
X
X      find_stack_direction ();	/* recurse once */
X    }
X  else				/* second entry */
X    if (&dummy > addr)
X      stack_dir = 1;		/* stack grew upward */
X    else
X      stack_dir = -1;		/* stack grew downward */
X}
X
X#endif	/* STACK_DIRECTION == 0 */
X
X/*
X	An "alloca header" is used to:
X	(a) chain together all alloca()ed blocks;
X	(b) keep track of stack depth.
X
X	It is very important that sizeof(header) agree with malloc()
X	alignment chunk size.  The following default should work okay.
X*/
X
X#ifndef	ALIGN_SIZE
X#define	ALIGN_SIZE	sizeof(double)
X#endif
X
Xtypedef union hdr
X{
X  char	align[ALIGN_SIZE];	/* to force sizeof(header) */
X  struct
X    {
X      union hdr *next;		/* for chaining headers */
X      char *deep;		/* for stack depth measure */
X    } h;
X} header;
X
X/*
X	alloca( size ) returns a pointer to at least `size' bytes of
X	storage which will be automatically reclaimed upon exit from
X	the procedure that called alloca().  Originally, this space
X	was supposed to be taken from the current stack frame of the
X	caller, but that method cannot be made to work for some
X	implementations of C, for example under Gould's UTX/32.
X*/
X
Xstatic header *last_alloca_header = NULL; /* -> last alloca header */
X
Xpointer
Xalloca (size)			/* returns pointer to storage */
X     unsigned	size;		/* # bytes to allocate */
X{
X  auto char	probe;		/* probes stack depth: */
X  register char	*depth = &probe;
X
X#if STACK_DIRECTION == 0
X  if (STACK_DIR == 0)		/* unknown growth direction */
X    find_stack_direction ();
X#endif
X
X				/* Reclaim garbage, defined as all alloca()ed storage that
X				   was allocated from deeper in the stack than currently. */
X
X  {
X    register header	*hp;	/* traverses linked list */
X
X    for (hp = last_alloca_header; hp != NULL;)
X      if ((STACK_DIR > 0 && hp->h.deep > depth)
X	  || (STACK_DIR < 0 && hp->h.deep < depth))
X	{
X	  register header	*np = hp->h.next;
X
X	  free ((pointer) hp);	/* collect garbage */
X
X	  hp = np;		/* -> next header */
X	}
X      else
X	break;			/* rest are not deeper */
X
X    last_alloca_header = hp;	/* -> last valid storage */
X  }
X
X  if (size == 0)
X    return NULL;		/* no allocation required */
X
X  /* Allocate combined header + user data storage. */
X
X  {
X    register pointer	new = xmalloc (sizeof (header) + size);
X    /* address of header */
X
X    ((header *)new)->h.next = last_alloca_header;
X    ((header *)new)->h.deep = depth;
X
X    last_alloca_header = (header *)new;
X
X    /* User storage begins just after header. */
X
X    return (pointer)((char *)new + sizeof(header));
X  }
X}
X
X#endif /* no alloca */
END_OF_FILE
if test 5374 -ne `wc -c <'gzip-1.2.2/alloca.c'`; then
    echo shar: \"'gzip-1.2.2/alloca.c'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/alloca.c'
fi
if test -f 'gzip-1.2.2/match.S' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/match.S'\"
else
echo shar: Extracting \"'gzip-1.2.2/match.S'\" \(11764 characters\)
sed "s/^X//" >'gzip-1.2.2/match.S' <<'END_OF_FILE'
X/* match.s -- optional optimized asm version of longest match in deflate.c
X * Copyright (C) 1992-1993 Jean-loup Gailly
X * This is free software; you can redistribute it and/or modify it under the
X * terms of the GNU General Public License, see the file COPYING.
X *
X * The 68020 version has been written by Francesco Potorti` <pot@cnuce.cnr.it>
X * with adaptations by Carsten Steger <stegerc@informatik.tu-muenchen.de>,
X * Andreas Schwab <schwab@lamothe.informatik.uni-dortmund.de> and
X * Kristoffer Eriksson <ske@pkmab.se>
X */
X 
X/* $Id: match.S,v 0.14 1993/06/11 18:33:24 jloup Exp $ */
X
X/* Preprocess with -DNO_UNDERLINE if your C compiler does not prefix
X * external symbols with an underline character '_'.
X */
X#ifdef NO_UNDERLINE
X#  define _prev             prev
X#  define _window           window
X#  define _match_start	    match_start
X#  define _prev_length	    prev_length
X#  define _good_match	    good_match
X#  define _nice_match	    nice_match
X#  define _strstart	    strstart
X#  define _max_chain_length max_chain_length
X
X#  define _match_init       match_init
X#  define _longest_match    longest_match
X#endif
X
X#ifdef DYN_ALLOC
X  error: DYN_ALLOC not yet supported in match.s
X#endif
X
X#if defined(i386) || defined(_I386)
X
X/* This version is for 386 Unix or OS/2 in 32 bit mode.
X * Warning: it uses the AT&T syntax: mov source,dest
X * This file is only optional. If you want to force the C version,
X * add -DNO_ASM to CFLAGS in Makefile and set OBJA to an empty string.
X * If you have reduced WSIZE in gzip.h, then change its value below.
X * This version assumes static allocation of the arrays (-DDYN_ALLOC not used).
X */
X
X	.file   "match.S"
X
X#define MAX_MATCH	258
X#define MAX_MATCH2	$128 /* MAX_MATCH/2-1 */
X#define MIN_MATCH	3
X#define    WSIZE	$32768
X#define MAX_DIST	WSIZE - MAX_MATCH - MIN_MATCH - 1
X
X	.globl	_match_init
X	.globl  _longest_match
X
X	.text
X
X_match_init:
X	ret
X
X/*-----------------------------------------------------------------------
X * Set match_start to the longest match starting at the given string and
X * return its length. Matches shorter or equal to prev_length are discarded,
X * in which case the result is equal to prev_length and match_start is
X * garbage.
X * IN assertions: cur_match is the head of the hash chain for the current
X *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
X */
X
X_longest_match:	/* int longest_match(cur_match) */
X
X#define cur_match   20(%esp)
X     /* return address */               /* esp+16 */
X        push    %ebp                    /* esp+12 */
X        push    %edi                    /* esp+8  */
X	push	%esi                    /* esp+4  */
X	push    %ebx			/* esp    */
X
X/*
X *      match        equ esi
X *      scan         equ edi
X *      chain_length equ ebp
X *      best_len     equ ebx
X *      limit        equ edx
X */
X	mov 	cur_match,%esi
X        mov 	_max_chain_length,%ebp /* chain_length = max_chain_length */
X	mov 	_strstart,%edi
X	mov 	%edi,%edx
X	sub	MAX_DIST,%edx          /* limit = strstart-MAX_DIST */
X	jae	limit_ok
X	sub	%edx,%edx              /* limit = NIL */
Xlimit_ok:
X        add	$2+_window,%edi        /* edi = offset(window+strstart+2) */
X        mov	_prev_length,%ebx      /* best_len = prev_length */
X        movw 	-3(%ebx,%edi),%ax      /* ax = scan[best_len-1..best_len] */
X        movw 	-2(%edi),%cx           /* cx = scan[0..1] */
X	cmp	_good_match,%ebx       /* do we have a good match already? */
X        jb      do_scan
X	shr 	$2,%ebp                /* chain_length >>= 2 */
X        jmp     do_scan
X
X        .align  4
Xlong_loop:
X/* at this point, edi == scan+2, esi == cur_match */
X        movw	-3(%ebx,%edi),%ax       /* ax = scan[best_len-1..best_len] */
X        movw     -2(%edi),%cx           /* cx = scan[0..1] */
Xshort_loop:
X/*
X * at this point, di == scan+2, si == cur_match,
X * ax = scan[best_len-1..best_len] and cx = scan[0..1]
X */
X        and     WSIZE-1, %esi
X        movw    _prev(%esi,%esi),%si    /* cur_match = prev[cur_match] */
X                                        /* top word of esi is still 0 */
X        cmp     %edx,%esi		/* cur_match <= limit ? */
X        jbe     the_end
X        dec     %ebp                    /* --chain_length */
X        jz      the_end
Xdo_scan:
X        cmpw    _window-1(%ebx,%esi),%ax/* check match at best_len-1 */
X        jne     short_loop
X        cmpw    _window(%esi),%cx       /* check min_match_length match */
X        jne     short_loop
X
X        lea     _window+2(%esi),%esi    /* si = match */
X        mov     %edi,%eax               /* ax = scan+2 */
X        mov 	MAX_MATCH2,%ecx         /* scan for at most MAX_MATCH bytes */
X        rep;    cmpsw                   /* loop until mismatch */
X        je      maxmatch                /* match of length MAX_MATCH? */
Xmismatch:
X        movb    -2(%edi),%cl        /* mismatch on first or second byte? */
X        subb    -2(%esi),%cl        /* cl = 0 if first bytes equal */
X        xchg    %edi,%eax           /* edi = scan+2, eax = end of scan */
X        sub     %edi,%eax           /* eax = len */
X	sub	%eax,%esi           /* esi = cur_match + 2 + offset(window) */
X	sub	$2+_window,%esi     /* esi = cur_match */
X        subb    $1,%cl              /* set carry if cl == 0 (cannot use DEC) */
X        adc     $0,%eax             /* eax = carry ? len+1 : len */
X        cmp     %ebx,%eax           /* len > best_len ? */
X        jle     long_loop
X        mov     %esi,_match_start       /* match_start = cur_match */
X        mov     %eax,%ebx               /* ebx = best_len = len */
X        cmp     _nice_match,%eax        /* len >= nice_match ? */
X        jl      long_loop
Xthe_end:
X        mov     %ebx,%eax               /* result = eax = best_len */
X	pop     %ebx
X        pop     %esi
X        pop     %edi
X        pop     %ebp
X        ret
Xmaxmatch:
X        cmpsb
X        jmp     mismatch
X
X#else
X
X/* ======================== 680x0 version ================================= */
X
X#if defined(m68k)||defined(mc68k)||defined(__mc68000__)||defined(__MC68000__)
X#  ifndef mc68000
X#    define mc68000
X#  endif
X#endif
X
X#if defined(__mc68020__) || defined(__MC68020__) || defined(sysV68)
X#  ifndef mc68020
X#    define mc68020
X#  endif
X#endif
X
X#if defined(mc68020) || defined(mc68000)
X
X#if (defined(mc68020) || defined(NeXT)) && !defined(UNALIGNED_OK)
X#  define UNALIGNED_OK
X#endif
X
X#ifdef sysV68  /* Try Motorola Delta style */
X
X#  define GLOBAL(symbol)	global	symbol
X#  define TEXT			text
X#  define FILE(filename)	file	filename
X#  define invert_maybe(src,dst)	dst,src
X#  define imm(data)		&data
X#  define reg(register)		%register
X
X#  define addl			add.l
X#  define addql			addq.l
X#  define blos			blo.b
X#  define bhis			bhi.b
X#  define bras			bra.b
X#  define clrl			clr.l
X#  define cmpmb			cmpm.b
X#  define cmpw			cmp.w
X#  define cmpl			cmp.l
X#  define lslw			lsl.w
X#  define lsrl			lsr.l
X#  define movel			move.l
X#  define movew			move.w
X#  define moveb			move.b
X#  define moveml		movem.l
X#  define subl			sub.l
X#  define subw			sub.w
X#  define subql			subq.l
X
X#  define IndBase(bd,An)	(bd,An)
X#  define IndBaseNdxl(bd,An,Xn)	(bd,An,Xn.l)
X#  define IndBaseNdxw(bd,An,Xn)	(bd,An,Xn.w)
X#  define predec(An)		-(An)
X#  define postinc(An)		(An)+
X
X#else /* default style (Sun 3, NeXT, Amiga, Atari) */
X
X#  define GLOBAL(symbol)	.globl	symbol
X#  define TEXT			.text
X#  define FILE(filename)	.even
X#  define invert_maybe(src,dst)	src,dst
X#  if defined(sun) || defined(mc68k)
X#    define imm(data)		#data
X#  else
X#    define imm(data)		\#data
X#  endif
X#  define reg(register)		register
X
X#  define blos			bcss
X#  if defined(sun) || defined(mc68k)
X#    define movel		movl
X#    define movew		movw
X#    define moveb		movb
X#  endif
X#  define IndBase(bd,An)	An@(bd)
X#  define IndBaseNdxl(bd,An,Xn)	An@(bd,Xn:l)
X#  define IndBaseNdxw(bd,An,Xn)	An@(bd,Xn:w)
X#  define predec(An)		An@-
X#  define postinc(An)		An@+
X
X#endif	/* styles */
X
X#define Best_Len	reg(d0)		/* unsigned */
X#define Cur_Match	reg(d1)		/* Ipos */
X#define Loop_Counter	reg(d2)		/* int */
X#define Scan_Start	reg(d3)		/* unsigned short */
X#define Scan_End	reg(d4)		/* unsigned short */
X#define Limit		reg(d5)		/* IPos */
X#define Chain_Length	reg(d6)		/* unsigned */
X#define Scan_Test	reg(d7)
X#define Scan		reg(a0)		/* *uch */
X#define Match		reg(a1)		/* *uch */
X#define Prev_Address	reg(a2)		/* *Pos */
X#define Scan_Ini	reg(a3)		/* *uch */
X#define Match_Ini	reg(a4)		/* *uch */
X#define Stack_Pointer	reg(sp)
X
X#define MAX_MATCH 	258
X#define MIN_MATCH	3
X#define WSIZE		32768
X#define MAX_DIST 	(WSIZE - MAX_MATCH - MIN_MATCH - 1)
X
X	GLOBAL	(_match_init)
X	GLOBAL	(_longest_match)
X
X	TEXT
X
X	FILE	("match.S")
X
X_match_init:
X	rts
X
X/*-----------------------------------------------------------------------
X * Set match_start to the longest match starting at the given string and
X * return its length. Matches shorter or equal to prev_length are discarded,
X * in which case the result is equal to prev_length and match_start is
X * garbage.
X * IN assertions: cur_match is the head of the hash chain for the current
X *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
X */
X
X/* int longest_match (cur_match) */
X
X#ifdef UNALIGNED_OK
X#  define pushreg	15928		/* d2-d6/a2-a4 */
X#  define popreg	7292
X#else
X#  define pushreg	16184		/* d2-d7/a2-a4 */
X#  define popreg	7420
X#endif
X
X_longest_match:
X	movel	IndBase(4,Stack_Pointer),Cur_Match
X	moveml	imm(pushreg),predec(Stack_Pointer)
X	movel	_max_chain_length,Chain_Length
X	movel	_prev_length,Best_Len
X	movel	imm(_prev),Prev_Address
X	movel	imm(_window+MIN_MATCH),Match_Ini
X	movel	_strstart,Limit
X	movel	Match_Ini,Scan_Ini
X	addl	Limit,Scan_Ini
X	subw	imm(MAX_DIST),Limit
X	bhis	L__limit_ok
X	clrl	Limit
XL__limit_ok:
X	cmpl	invert_maybe(_good_match,Best_Len)
X	blos	L__length_ok
X	lsrl	imm(2),Chain_Length
XL__length_ok:
X	subql	imm(1),Chain_Length
X#ifdef UNALIGNED_OK
X	movew	IndBase(-MIN_MATCH,Scan_Ini),Scan_Start
X	movew	IndBaseNdxw(-MIN_MATCH-1,Scan_Ini,Best_Len),Scan_End
X#else
X	moveb	IndBase(-MIN_MATCH,Scan_Ini),Scan_Start
X	lslw	imm(8),Scan_Start
X	moveb	IndBase(-MIN_MATCH+1,Scan_Ini),Scan_Start
X	moveb	IndBaseNdxw(-MIN_MATCH-1,Scan_Ini,Best_Len),Scan_End
X	lslw	imm(8),Scan_End
X	moveb	IndBaseNdxw(-MIN_MATCH,Scan_Ini,Best_Len),Scan_End
X#endif
X	bras	L__do_scan
X
XL__long_loop:
X#ifdef UNALIGNED_OK
X	movew	IndBaseNdxw(-MIN_MATCH-1,Scan_Ini,Best_Len),Scan_End
X#else
X	moveb	IndBaseNdxw(-MIN_MATCH-1,Scan_Ini,Best_Len),Scan_End
X	lslw	imm(8),Scan_End
X	moveb	IndBaseNdxw(-MIN_MATCH,Scan_Ini,Best_Len),Scan_End
X#endif
X
XL__short_loop:
X	lslw	imm(1),Cur_Match
X	movew	IndBaseNdxl(0,Prev_Address,Cur_Match),Cur_Match
X	cmpw	invert_maybe(Limit,Cur_Match)
X	dbls	Chain_Length,L__do_scan
X	bras	L__return
X
XL__do_scan:
X	movel	Match_Ini,Match
X	addl	Cur_Match,Match
X#ifdef UNALIGNED_OK
X	cmpw	invert_maybe(IndBaseNdxw(-MIN_MATCH-1,Match,Best_Len),Scan_End)
X	bne	L__short_loop
X	cmpw	invert_maybe(IndBase(-MIN_MATCH,Match),Scan_Start)
X	bne	L__short_loop
X#else
X	moveb	IndBaseNdxw(-MIN_MATCH-1,Match,Best_Len),Scan_Test
X	lslw	imm(8),Scan_Test
X	moveb	IndBaseNdxw(-MIN_MATCH,Match,Best_Len),Scan_Test
X	cmpw	invert_maybe(Scan_Test,Scan_End)
X	bne	L__short_loop
X	moveb	IndBase(-MIN_MATCH,Match),Scan_Test
X	lslw	imm(8),Scan_Test
X	moveb	IndBase(-MIN_MATCH+1,Match),Scan_Test
X	cmpw	invert_maybe(Scan_Test,Scan_Start)
X	bne	L__short_loop
X#endif
X
X	movew	imm((MAX_MATCH-MIN_MATCH+1)-1),Loop_Counter
X	movel	Scan_Ini,Scan
XL__scan_loop:
X	cmpmb	postinc(Match),postinc(Scan)
X	dbne	Loop_Counter,L__scan_loop
X
X	subl	Scan_Ini,Scan
X	addql	imm(MIN_MATCH-1),Scan
X	cmpl	invert_maybe(Best_Len,Scan)
X	bls	L__short_loop
X	movel	Scan,Best_Len
X	movel	Cur_Match,_match_start
X	cmpl	invert_maybe(_nice_match,Best_Len)
X	blos	L__long_loop
XL__return:
X	moveml	postinc(Stack_Pointer),imm(popreg)
X	rts
X
X#else
X error: this asm version is for 386 or 680x0 only
X#endif /* mc68000 || mc68020 */
X#endif /* i386 || _I386   */
END_OF_FILE
if test 11764 -ne `wc -c <'gzip-1.2.2/match.S'`; then
    echo shar: \"'gzip-1.2.2/match.S'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/match.S'
fi
if test -f 'gzip-1.2.2/gzip.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/gzip.h'\"
else
echo shar: Extracting \"'gzip-1.2.2/gzip.h'\" \(10619 characters\)
sed "s/^X//" >'gzip-1.2.2/gzip.h' <<'END_OF_FILE'
X/* gzip.h -- common declarations for all gzip modules
X * Copyright (C) 1992-1993 Jean-loup Gailly.
X * This is free software; you can redistribute it and/or modify it under the
X * terms of the GNU General Public License, see the file COPYING.
X */
X
X#if defined(__STDC__) || defined(PROTO)
X#  define OF(args)  args
X#else
X#  define OF(args)  ()
X#endif
X
X#ifdef __STDC__
X   typedef void *voidp;
X#else
X   typedef char *voidp;
X#endif
X
X/* I don't like nested includes, but the string and io functions are used
X * too often
X */
X#include <stdio.h>
X#if !defined(NO_STRING_H) || defined(STDC_HEADERS)
X#  include <string.h>
X#  if !defined(STDC_HEADERS) && !defined(NO_MEMORY_H) && !defined(__GNUC__)
X#    include <memory.h>
X#  endif
X#  define memzero(s, n)     memset ((voidp)(s), 0, (n))
X#else
X#  include <strings.h>
X#  define strchr            index 
X#  define strrchr           rindex
X#  define memcpy(d, s, n)   bcopy((s), (d), (n)) 
X#  define memcmp(s1, s2, n) bcmp((s1), (s2), (n)) 
X#  define memzero(s, n)     bzero((s), (n))
X#endif
X
X#ifndef RETSIGTYPE
X#  define RETSIGTYPE void
X#endif
X
X#define local static
X
Xtypedef unsigned char  uch;
Xtypedef unsigned short ush;
Xtypedef unsigned long  ulg;
X
X/* Return codes from gzip */
X#define OK      0
X#define ERROR   1
X#define WARNING 2
X
X/* Compression methods (see algorithm.doc) */
X#define STORED      0
X#define COMPRESSED  1
X#define PACKED      2
X#define LZHED       3
X/* methods 4 to 7 reserved */
X#define DEFLATED    8
X#define MAX_METHODS 9
Xextern int method;         /* compression method */
X
X/* To save memory for 16 bit systems, some arrays are overlaid between
X * the various modules:
X * deflate:  prev+head   window      d_buf  l_buf  outbuf
X * unlzw:    tab_prefix  tab_suffix  stack  inbuf  outbuf
X * inflate:              window             inbuf
X * unpack:               window             inbuf  prefix_len
X * unlzh:    left+right  window      c_table inbuf c_len
X * For compression, input is done in window[]. For decompression, output
X * is done in window except for unlzw.
X */
X
X#ifndef	INBUFSIZ
X#  ifdef SMALL_MEM
X#    define INBUFSIZ  0x2000  /* input buffer size */
X#  else
X#    define INBUFSIZ  0x8000  /* input buffer size */
X#  endif
X#endif
X#define INBUF_EXTRA  64     /* required by unlzw() */
X
X#ifndef	OUTBUFSIZ
X#  ifdef SMALL_MEM
X#    define OUTBUFSIZ   8192  /* output buffer size */
X#  else
X#    define OUTBUFSIZ  16384  /* output buffer size */
X#  endif
X#endif
X#define OUTBUF_EXTRA 2048   /* required by unlzw() */
X
X#ifndef DIST_BUFSIZE
X#  ifdef SMALL_MEM
X#    define DIST_BUFSIZE 0x2000 /* buffer for distances, see trees.c */
X#  else
X#    define DIST_BUFSIZE 0x8000 /* buffer for distances, see trees.c */
X#  endif
X#endif
X
X#ifdef DYN_ALLOC
X#  define EXTERN(type, array)  extern type * near array
X#  define DECLARE(type, array, size)  type * near array
X#  define ALLOC(type, array, size) { \
X      array = (type*)fcalloc((size_t)(((size)+1L)/2), 2*sizeof(type)); \
X      if (array == NULL) error("insufficient memory"); \
X   }
X#  define FREE(array) {if (array != NULL) fcfree(array), array=NULL;}
X#else
X#  define EXTERN(type, array)  extern type array[]
X#  define DECLARE(type, array, size)  type array[size]
X#  define ALLOC(type, array, size)
X#  define FREE(array)
X#endif
X
XEXTERN(uch, inbuf);          /* input buffer */
XEXTERN(uch, outbuf);         /* output buffer */
XEXTERN(ush, d_buf);          /* buffer for distances, see trees.c */
XEXTERN(uch, window);         /* Sliding window and suffix table (unlzw) */
X#define tab_suffix window
X#ifndef MAXSEG_64K
X#  define tab_prefix prev    /* hash link (see deflate.c) */
X#  define head (prev+WSIZE)  /* hash head (see deflate.c) */
X   EXTERN(ush, tab_prefix);  /* prefix code (see unlzw.c) */
X#else
X#  define tab_prefix0 prev
X#  define head tab_prefix1
X   EXTERN(ush, tab_prefix0); /* prefix for even codes */
X   EXTERN(ush, tab_prefix1); /* prefix for odd  codes */
X#endif
X
Xextern unsigned insize; /* valid bytes in inbuf */
Xextern unsigned inptr;  /* index of next byte to be processed in inbuf */
Xextern unsigned outcnt; /* bytes in output buffer */
X
Xextern long bytes_in;   /* number of input bytes */
Xextern long bytes_out;  /* number of output bytes */
Xextern long header_bytes;/* number of bytes in gzip header */
X
X#define isize bytes_in
X/* for compatibility with old zip sources (to be cleaned) */
X
Xextern int  ifd;        /* input file descriptor */
Xextern int  ofd;        /* output file descriptor */
Xextern char ifname[];   /* input file name or "stdin" */
Xextern char ofname[];   /* output file name or "stdout" */
Xextern char *progname;  /* program name */
X
Xextern long time_stamp; /* original time stamp (modification time) */
Xextern long ifile_size; /* input file size, -1 for devices (debug only) */
X
Xtypedef int file_t;     /* Do not use stdio */
X#define NO_FILE  (-1)   /* in memory compression */
X
X
X#define	PACK_MAGIC     "\037\036" /* Magic header for packed files */
X#define	GZIP_MAGIC     "\037\213" /* Magic header for gzip files, 1F 8B */
X#define	OLD_GZIP_MAGIC "\037\236" /* Magic header for gzip 0.5 = freeze 1.x */
X#define	LZH_MAGIC      "\037\240" /* Magic header for SCO LZH Compress files*/
X#define PKZIP_MAGIC    "\120\113\003\004" /* Magic header for pkzip files */
X
X/* gzip flag byte */
X#define ASCII_FLAG   0x01 /* bit 0 set: file probably ascii text */
X#define CONTINUATION 0x02 /* bit 1 set: continuation of multi-part gzip file */
X#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */
X#define ORIG_NAME    0x08 /* bit 3 set: original file name present */
X#define COMMENT      0x10 /* bit 4 set: file comment present */
X#define ENCRYPTED    0x20 /* bit 5 set: file is encrypted */
X#define RESERVED     0xC0 /* bit 6,7:   reserved */
X
X/* internal file attribute */
X#define UNKNOWN 0xffff
X#define BINARY  0
X#define ASCII   1
X
X#ifndef WSIZE
X#  define WSIZE 0x8000     /* window size--must be a power of two, and */
X#endif                     /*  at least 32K for zip's deflate method */
X
X#define MIN_MATCH  3
X#define MAX_MATCH  258
X/* The minimum and maximum match lengths */
X
X#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
X/* Minimum amount of lookahead, except at the end of the input file.
X * See deflate.c for comments about the MIN_MATCH+1.
X */
X
X#define MAX_DIST  (WSIZE-MIN_LOOKAHEAD)
X/* In order to simplify the code, particularly on 16 bit machines, match
X * distances are limited to MAX_DIST instead of WSIZE.
X */
X
Xextern int decrypt;        /* flag to turn on decryption */
Xextern int exit_code;      /* program exit code */
Xextern int verbose;        /* be verbose (-v) */
Xextern int quiet;          /* be quiet (-q) */
Xextern int level;          /* compression level */
Xextern int test;           /* check .z file integrity */
Xextern int to_stdout;      /* output to stdout (-c) */
Xextern int save_orig_name; /* set if original name must be saved */
X
X#define get_byte()  (inptr < insize ? inbuf[inptr++] : fill_inbuf(0))
X#define try_byte()  (inptr < insize ? inbuf[inptr++] : fill_inbuf(1))
X
X/* put_byte is used for the compressed output, put_ubyte for the
X * uncompressed output. However unlzw() uses window for its
X * suffix table instead of its output buffer, so it does not use put_ubyte
X * (to be cleaned up).
X */
X#define put_byte(c) {outbuf[outcnt++]=(uch)(c); if (outcnt==OUTBUFSIZ)\
X   flush_outbuf();}
X#define put_ubyte(c) {window[outcnt++]=(uch)(c); if (outcnt==WSIZE)\
X   flush_window();}
X
X/* Output a 16 bit value, lsb first */
X#define put_short(w) \
X{ if (outcnt < OUTBUFSIZ-2) { \
X    outbuf[outcnt++] = (uch) ((w) & 0xff); \
X    outbuf[outcnt++] = (uch) ((ush)(w) >> 8); \
X  } else { \
X    put_byte((uch)((w) & 0xff)); \
X    put_byte((uch)((ush)(w) >> 8)); \
X  } \
X}
X
X/* Output a 32 bit value to the bit stream, lsb first */
X#define put_long(n) { \
X    put_short((n) & 0xffff); \
X    put_short(((ulg)(n)) >> 16); \
X}
X
X#define seekable()    0  /* force sequential output */
X#define translate_eol 0  /* no option -a yet */
X
X#define tolow(c)  (isupper(c) ? (c)-'A'+'a' : (c))    /* force to lower case */
X
X/* Macros for getting two-byte and four-byte header values */
X#define SH(p) ((ush)(uch)((p)[0]) | ((ush)(uch)((p)[1]) << 8))
X#define LG(p) ((ulg)(SH(p)) | ((ulg)(SH((p)+2)) << 16))
X
X/* Diagnostic functions */
X#ifdef DEBUG
X#  define Assert(cond,msg) {if(!(cond)) error(msg);}
X#  define Trace(x) fprintf x
X#  define Tracev(x) {if (verbose) fprintf x ;}
X#  define Tracevv(x) {if (verbose>1) fprintf x ;}
X#  define Tracec(c,x) {if (verbose && (c)) fprintf x ;}
X#  define Tracecv(c,x) {if (verbose>1 && (c)) fprintf x ;}
X#else
X#  define Assert(cond,msg)
X#  define Trace(x)
X#  define Tracev(x)
X#  define Tracevv(x)
X#  define Tracec(c,x)
X#  define Tracecv(c,x)
X#endif
X
X#define WARN(msg) {if (!quiet) fprintf msg ; \
X		   if (exit_code == OK) exit_code = WARNING;}
X
X	/* in zip.c: */
Xextern int zip        OF((int in, int out));
Xextern int file_read  OF((char *buf,  unsigned size));
X
X	/* in unzip.c */
Xextern int unzip      OF((int in, int out));
Xextern int check_zipfile OF((int in));
X
X	/* in unpack.c */
Xextern int unpack     OF((int in, int out));
X
X	/* in unlzh.c */
Xextern int unlzh      OF((int in, int out));
X
X	/* in gzip.c */
XRETSIGTYPE abort_gzip OF((void));
X
X        /* in deflate.c */
Xvoid lm_init OF((int pack_level, ush *flags));
Xulg  deflate OF((void));
X
X        /* in trees.c */
Xvoid ct_init     OF((ush *attr, int *method));
Xint  ct_tally    OF((int dist, int lc));
Xulg  flush_block OF((char *buf, ulg stored_len, int eof));
X
X        /* in bits.c */
Xvoid     bi_init    OF((file_t zipfile));
Xvoid     send_bits  OF((int value, int length));
Xunsigned bi_reverse OF((unsigned value, int length));
Xvoid     bi_windup  OF((void));
Xvoid     copy_block OF((char *buf, unsigned len, int header));
Xextern   int (*read_buf) OF((char *buf, unsigned size));
X
X	/* in util.c: */
Xextern int copy           OF((int in, int out));
Xextern ulg  updcrc        OF((uch *s, unsigned n));
Xextern void clear_bufs    OF((void));
Xextern int  fill_inbuf    OF((int eof_ok));
Xextern void flush_outbuf  OF((void));
Xextern void flush_window  OF((void));
Xextern void write_buf     OF((int fd, voidp buf, unsigned cnt));
Xextern char *strlwr       OF((char *s));
Xextern char *basename     OF((char *fname));
Xextern void make_simple_name OF((char *name));
Xextern char *add_envopt   OF((int *argcp, char ***argvp, char *env));
Xextern void error         OF((char *m));
Xextern void warn          OF((char *a, char *b));
Xextern void read_error    OF((void));
Xextern void write_error   OF((void));
Xextern void display_ratio OF((long num, long den, FILE *file));
Xextern voidp xmalloc      OF((unsigned int size));
X
X	/* in inflate.c */
Xextern int inflate OF((void));
END_OF_FILE
if test 10619 -ne `wc -c <'gzip-1.2.2/gzip.h'`; then
    echo shar: \"'gzip-1.2.2/gzip.h'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/gzip.h'
fi
if test -f 'gzip-1.2.2/lzw.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/lzw.h'\"
else
echo shar: Extracting \"'gzip-1.2.2/lzw.h'\" \(1481 characters\)
sed "s/^X//" >'gzip-1.2.2/lzw.h' <<'END_OF_FILE'
X/* lzw.h -- define the lzw functions.
X * Copyright (C) 1992-1993 Jean-loup Gailly.
X * This is free software; you can redistribute it and/or modify it under the
X * terms of the GNU General Public License, see the file COPYING.
X */
X
X#if !defined(OF) && defined(lint)
X#  include "gzip.h"
X#endif
X
X#ifndef BITS
X#  define BITS 16
X#endif
X#define INIT_BITS 9              /* Initial number of bits per code */
X
X#define	LZW_MAGIC  "\037\235"   /* Magic header for lzw files, 1F 9D */
X
X#define BIT_MASK    0x1f /* Mask for 'number of compression bits' */
X/* Mask 0x20 is reserved to mean a fourth header byte, and 0x40 is free.
X * It's a pity that old uncompress does not check bit 0x20. That makes
X * extension of the format actually undesirable because old compress
X * would just crash on the new format instead of giving a meaningful
X * error message. It does check the number of bits, but it's more
X * helpful to say "unsupported format, get a new version" than
X * "can only handle 16 bits".
X */
X
X#define BLOCK_MODE  0x80
X/* Block compression: if table is full and compression rate is dropping,
X * clear the dictionary.
X */
X
X#define LZW_RESERVED 0x60 /* reserved bits */
X
X#define	CLEAR  256       /* flush the dictionary */
X#define FIRST  (CLEAR+1) /* first free entry */
X
Xextern int maxbits;      /* max bits per code for LZW */
Xextern int block_mode;   /* block compress mode -C compatible with 2.0 */
X
Xextern int lzw    OF((int in, int out));
Xextern int unlzw  OF((int in, int out));
END_OF_FILE
if test 1481 -ne `wc -c <'gzip-1.2.2/lzw.h'`; then
    echo shar: \"'gzip-1.2.2/lzw.h'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/lzw.h'
fi
if test -f 'gzip-1.2.2/tailor.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/tailor.h'\"
else
echo shar: Extracting \"'gzip-1.2.2/tailor.h'\" \(6682 characters\)
sed "s/^X//" >'gzip-1.2.2/tailor.h' <<'END_OF_FILE'
X/* tailor.h -- target dependent definitions
X * Copyright (C) 1992-1993 Jean-loup Gailly.
X * This is free software; you can redistribute it and/or modify it under the
X * terms of the GNU General Public License, see the file COPYING.
X */
X
X/* The target dependent definitions should be defined here only.
X * The target dependent functions should be defined in tailor.c.
X */
X
X/* $Id: tailor.h,v 0.18 1993/06/14 19:32:20 jloup Exp $ */
X
X#if defined(__MSDOS__) && !defined(MSDOS)
X#  define MSDOS
X#endif
X
X#if defined(__OS2__) && !defined(OS2)
X#  define OS2
X#endif
X
X#if defined(OS2) && defined(MSDOS) /* MS C under OS/2 */
X#  undef MSDOS
X#endif
X
X#ifdef MSDOS
X#  ifdef __GNUC__
X     /* DJGPP version 1.09+ on MS-DOS.
X      * The DJGPP 1.09 stat() function must be upgraded before gzip will
X      * fully work.
X      * No need for DIRENT, since <unistd.h> defines POSIX_SOURCE which
X      * implies DIRENT.
X      */
X#    define near
X#  else
X#    define MAXSEG_64K
X#    ifdef __TURBOC__
X#      define NO_UTIME
X#      define NO_OFF_T
X#    else /* MSC */
X#      define HAVE_SYS_UTIME_H
X#      define NO_UTIME_H
X#    endif
X#  endif
X#  define PATH_SEP2 '\\'
X#  define PATH_SEP3 ':'
X#  define MAX_PATH_LEN  128
X#  define NO_MULTIPLE_DOTS
X#  define MAX_EXT_CHARS 3
X#  define Z_SUFFIX "z"
X#  define NO_CHOWN
X#  define PROTO
X#  define STDC_HEADERS
X#  define NO_SIZE_CHECK
X#  define casemap(c) tolow(c) /* Force file names to lower case */
X#  include <io.h>
X#  define OS_CODE  0x00
X#  define SET_BINARY_MODE(fd) setmode(fd, O_BINARY)
X#  if !defined(NO_ASM) && !defined(ASMV)
X#    define ASMV
X#  endif
X#else
X#  define near
X#endif
X
X#ifdef OS2
X#  define PATH_SEP2 '\\'
X#  define PATH_SEP3 ':'
X#  define MAX_PATH_LEN  260
X#  ifdef OS2FAT
X#    define NO_MULTIPLE_DOTS
X#    define MAX_EXT_CHARS 3
X#    define Z_SUFFIX "z"
X#  endif
X#  define NO_CHOWN
X#  define PROTO
X#  define STDC_HEADERS
X#  define casemap(c) tolow(c)
X#  include <io.h>
X#  define OS_CODE  0x06
X#  define SET_BINARY_MODE(fd) setmode(fd, O_BINARY)
X#  ifdef _MSC_VER
X#    define HAVE_SYS_UTIME_H
X#    define NO_UTIME_H
X#    define MAXSEG_64K
X#    undef near
X#    define near _near
X#  endif
X#  ifdef __EMX__
X#    define HAVE_SYS_UTIME_H
X#    define NO_UTIME_H
X#    define DIRENT
X#    define EXPAND(argc,argv) \
X       {_response(&argc, &argv); _wildcard(&argc, &argv);}
X#  endif
X#  ifdef __BORLANDC__
X#    define DIRENT
X#  endif
X#  ifdef __ZTC__
X#    define NO_DIR
X#    define NO_UTIME_H
X#    include <dos.h>
X#    define EXPAND(argc,argv) \
X       {response_expand(&argc, &argv);}
X#  endif
X#endif
X
X#ifdef MSDOS
X#  ifdef __TURBOC__
X#    include <alloc.h>
X#    define DYN_ALLOC
X     /* Turbo C 2.0 does not accept static allocations of large arrays */
X     void * fcalloc (unsigned items, unsigned size);
X     void fcfree (void *ptr);
X#  else /* MSC */
X#    include <malloc.h>
X#    define fcalloc(nitems,itemsize) halloc((long)(nitems),(itemsize))
X#    define fcfree(ptr) hfree(ptr)
X#  endif
X#else
X#  ifdef MAXSEG_64K
X#    define fcalloc(items,size) calloc((items),(size))
X#  else
X#    define fcalloc(items,size) malloc((size_t)(items)*(size_t)(size))
X#  endif
X#  define fcfree(ptr) free(ptr)
X#endif
X
X#if defined(VAXC) || defined(VMS)
X#  define PATH_SEP ']'
X#  define PATH_SEP2 ':'
X#  define SUFFIX_SEP ';'
X#  define NO_MULTIPLE_DOTS
X#  define Z_SUFFIX "-gz"
X#  define RECORD_IO 1
X#  define casemap(c) tolow(c)
X#  define OS_CODE  0x02
X#  define OPTIONS_VAR "GZIP_OPT"
X#  define STDC_HEADERS
X#  define NO_UTIME
X#  define EXPAND(argc,argv) vms_expand_args(&argc,&argv);
X#  include <file.h>
X#  define unlink delete
X#  ifdef VAXC
X#    define NO_FCNTL_H
X#    include <unixio.h>
X#  endif
X#endif
X
X#ifdef AMIGA
X#  define PATH_SEP2 ':'
X#  define STDC_HEADERS
X#  define casemap(c) tolow(c) /* Force file names to lower case */
X#  define OS_CODE  0x01
X#  define ASMV
X#  ifdef __GNUC__
X#    define DIRENT
X#    define HAVE_UNISTD_H
X#  else /* SASC */
X#    define NO_STDIN_FSTAT
X#    define SYSDIR
X#    define NO_SYMLINK
X#    define NO_CHOWN
X#    define NO_FCNTL_H
X#    include <fcntl.h> /* for read() and write() */
X#    define direct dirent
X     extern void _expand_args(int *argc, char ***argv);
X#    define EXPAND(argc,argv) _expand_args(&argc,&argv);
X#    undef  O_BINARY /* disable useless --ascii option */
X#  endif
X#endif
X
X#if defined(ATARI) || defined(atarist)
X#  ifndef STDC_HEADERS
X#    define STDC_HEADERS
X#    define HAVE_UNISTD_H
X#    define DIRENT
X#  endif
X#  define ASMV
X#  define OS_CODE  0x05
X#  ifdef TOSFS
X#    define NO_SYMLINK
X#    define NO_MULTIPLE_DOTS
X#    define MAX_EXT_CHARS 3
X#    define Z_SUFFIX "z"
X#    define NO_CHOWN
X#  endif
X#endif
X
X#ifdef MACOS
X#  define PATH_SEP ':'
X#  define DYN_ALLOC
X#  define PROTO
X#  define NO_STDIN_FSTAT
X#  define NO_CHOWN
X#  define NO_UTIME
X#  define chmod(file, mode) (0)
X#  define OPEN(name, flags, mode) open(name, flags)
X#  define OS_CODE  0x07
X#  ifdef MPW
X#    define isatty(fd) ((fd) <= 2)
X#  endif
X#endif
X
X#ifdef __50SERIES /* Prime/PRIMOS */
X#  define PATH_SEP '>'
X#  define STDC_HEADERS
X#  define NO_MEMORY_H
X#  define NO_UTIME_H
X#  define NO_UTIME
X#  define NO_CHOWN 
X#  define NO_STDIN_FSTAT 
X#  define NO_SIZE_CHECK 
X#  define NO_SYMLINK
X#  define RECORD_IO  1
X#  define casemap(c)  tolow(c) /* Force file names to lower case */
X#  define put_char(c) put_byte((c) & 0x7F)
X#  define get_char(c) ascii2pascii(get_byte())
X#  define OS_CODE  0x0F    /* temporary, subject to change */
X#  ifdef SIGTERM
X#    undef SIGTERM         /* We don't want a signal handler for SIGTERM */
X#  endif
X#endif
X
X#ifdef WIN32
X#  define OS_CODE  0x0b
X#endif
X
X#ifdef TOPS20
X#  define OS_CODE  0x0a
X#endif
X
X#ifndef unix
X#  define NO_ST_INO /* don't rely on inode numbers */
X#endif
X
X
X	/* Common defaults */
X
X#ifndef OS_CODE
X#  define OS_CODE  0x03  /* assume Unix */
X#endif
X
X#ifndef PATH_SEP
X#  define PATH_SEP '/'
X#endif
X
X#ifndef casemap
X#  define casemap(c) (c)
X#endif
X
X#ifndef OPTIONS_VAR
X#  define OPTIONS_VAR "GZIP"
X#endif
X
X#ifndef Z_SUFFIX
X#  define Z_SUFFIX ".gz"
X#endif
X
X#ifdef MAX_EXT_CHARS
X#  define MAX_SUFFIX  MAX_EXT_CHARS
X#else
X#  define MAX_SUFFIX  30
X#endif
X
X#ifndef MAKE_LEGAL_NAME
X#  ifdef NO_MULTIPLE_DOTS
X#    define MAKE_LEGAL_NAME(name)   make_simple_name(name)
X#  else
X#    define MAKE_LEGAL_NAME(name)
X#  endif
X#endif
X
X#ifndef MIN_PART
X#  define MIN_PART 3
X   /* keep at least MIN_PART chars between dots in a file name. */
X#endif
X
X#ifndef EXPAND
X#  define EXPAND(argc,argv)
X#endif
X
X#ifndef RECORD_IO
X#  define RECORD_IO 0
X#endif
X
X#ifndef SET_BINARY_MODE
X#  define SET_BINARY_MODE(fd)
X#endif
X
X#ifndef OPEN
X#  define OPEN(name, flags, mode) open(name, flags, mode)
X#endif
X
X#ifndef get_char
X#  define get_char() get_byte()
X#endif
X
X#ifndef put_char
X#  define put_char(c) put_byte(c)
X#endif
END_OF_FILE
if test 6682 -ne `wc -c <'gzip-1.2.2/tailor.h'`; then
    echo shar: \"'gzip-1.2.2/tailor.h'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/tailor.h'
fi
if test -f 'gzip-1.2.2/revision.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/revision.h'\"
else
echo shar: Extracting \"'gzip-1.2.2/revision.h'\" \(477 characters\)
sed "s/^X//" >'gzip-1.2.2/revision.h' <<'END_OF_FILE'
X/* revision.h -- define the version number
X * Copyright (C) 1992-1993 Jean-loup Gailly.
X * This is free software; you can redistribute it and/or modify it under the
X * terms of the GNU General Public License, see the file COPYING.
X */
X
X#define VERSION "1.2.2"
X#define PATCHLEVEL 0
X#define REVDATE "17 Jun 93"
X
X/* This version does not support compression into old compress format: */
X#ifdef LZW
X#  undef LZW
X#endif
X
X/* $Id: revision.h,v 0.23 1993/06/16 15:03:51 jloup Exp $ */
END_OF_FILE
if test 477 -ne `wc -c <'gzip-1.2.2/revision.h'`; then
    echo shar: \"'gzip-1.2.2/revision.h'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/revision.h'
fi
if test -f 'gzip-1.2.2/crypt.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/crypt.h'\"
else
echo shar: Extracting \"'gzip-1.2.2/crypt.h'\" \(256 characters\)
sed "s/^X//" >'gzip-1.2.2/crypt.h' <<'END_OF_FILE'
X/* crypt.h (dummy version) -- do not perform encryption
X * Hardly worth copyrighting :-)
X */
X
X#ifdef CRYPT
X#  undef CRYPT      /* dummy version */
X#endif
X
X#define RAND_HEAD_LEN  12  /* length of encryption random header */
X
X#define zencode
X#define zdecode
END_OF_FILE
if test 256 -ne `wc -c <'gzip-1.2.2/crypt.h'`; then
    echo shar: \"'gzip-1.2.2/crypt.h'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/crypt.h'
fi
if test -f 'gzip-1.2.2/getopt.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/getopt.h'\"
else
echo shar: Extracting \"'gzip-1.2.2/getopt.h'\" \(4293 characters\)
sed "s/^X//" >'gzip-1.2.2/getopt.h' <<'END_OF_FILE'
X/* Declarations for getopt.
X   Copyright (C) 1989, 1990, 1991, 1992 Free Software Foundation, Inc.
X
X   This program is free software; you can redistribute it and/or modify it
X   under the terms of the GNU General Public License as published by the
X   Free Software Foundation; either version 2, or (at your option) any
X   later version.
X   
X   This program is distributed in the hope that it will be useful,
X   but WITHOUT ANY WARRANTY; without even the implied warranty of
X   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X   GNU General Public License for more details.
X   
X   You should have received a copy of the GNU General Public License
X   along with this program; if not, write to the Free Software
X   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
X
X#ifndef _GETOPT_H
X#define _GETOPT_H 1
X
X#ifdef	__cplusplus
Xextern "C" {
X#endif
X
X/* For communication from `getopt' to the caller.
X   When `getopt' finds an option that takes an argument,
X   the argument value is returned here.
X   Also, when `ordering' is RETURN_IN_ORDER,
X   each non-option ARGV-element is returned here.  */
X
Xextern char *optarg;
X
X/* Index in ARGV of the next element to be scanned.
X   This is used for communication to and from the caller
X   and for communication between successive calls to `getopt'.
X
X   On entry to `getopt', zero means this is the first call; initialize.
X
X   When `getopt' returns EOF, this is the index of the first of the
X   non-option elements that the caller should itself scan.
X
X   Otherwise, `optind' communicates from one call to the next
X   how much of ARGV has been scanned so far.  */
X
Xextern int optind;
X
X/* Callers store zero here to inhibit the error message `getopt' prints
X   for unrecognized options.  */
X
Xextern int opterr;
X
X/* Describe the long-named options requested by the application.
X   The LONG_OPTIONS argument to getopt_long or getopt_long_only is a vector
X   of `struct option' terminated by an element containing a name which is
X   zero.
X
X   The field `has_arg' is:
X   no_argument		(or 0) if the option does not take an argument,
X   required_argument	(or 1) if the option requires an argument,
X   optional_argument 	(or 2) if the option takes an optional argument.
X
X   If the field `flag' is not NULL, it points to a variable that is set
X   to the value given in the field `val' when the option is found, but
X   left unchanged if the option is not found.
X
X   To have a long-named option do something other than set an `int' to
X   a compiled-in constant, such as set a value from `optarg', set the
X   option's `flag' field to zero and its `val' field to a nonzero
X   value (the equivalent single-letter option character, if there is
X   one).  For long options that have a zero `flag' field, `getopt'
X   returns the contents of the `val' field.  */
X
Xstruct option
X{
X#if	__STDC__
X  const char *name;
X#else
X  char *name;
X#endif
X  /* has_arg can't be an enum because some compilers complain about
X     type mismatches in all the code that assumes it is an int.  */
X  int has_arg;
X  int *flag;
X  int val;
X};
X
X/* Names for the values of the `has_arg' field of `struct option'.  */
X
Xenum _argtype
X{
X  no_argument,
X  required_argument,
X  optional_argument
X};
X
X#if __STDC__ || defined(PROTO)
X#if defined(__GNU_LIBRARY__)
X/* Many other libraries have conflicting prototypes for getopt, with
X   differences in the consts, in stdlib.h.  To avoid compilation
X   errors, only prototype getopt for the GNU C library.  */
Xextern int getopt (int argc, char *const *argv, const char *shortopts);
X#endif /* not __GNU_LIBRARY__ */
Xextern int getopt_long (int argc, char *const *argv, const char *shortopts,
X		        const struct option *longopts, int *longind);
Xextern int getopt_long_only (int argc, char *const *argv,
X			     const char *shortopts,
X		             const struct option *longopts, int *longind);
X
X/* Internal only.  Users should not call this directly.  */
Xextern int _getopt_internal (int argc, char *const *argv,
X			     const char *shortopts,
X		             const struct option *longopts, int *longind,
X			     int long_only);
X#else /* not __STDC__ */
Xextern int getopt ();
Xextern int getopt_long ();
Xextern int getopt_long_only ();
X
Xextern int _getopt_internal ();
X#endif /* not __STDC__ */
X
X#ifdef	__cplusplus
X}
X#endif
X
X#endif /* _GETOPT_H */
END_OF_FILE
if test 4293 -ne `wc -c <'gzip-1.2.2/getopt.h'`; then
    echo shar: \"'gzip-1.2.2/getopt.h'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/getopt.h'
fi
if test -f 'gzip-1.2.2/zmore.in' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/zmore.in'\"
else
echo shar: Extracting \"'gzip-1.2.2/zmore.in'\" \(1001 characters\)
sed "s/^X//" >'gzip-1.2.2/zmore.in' <<'END_OF_FILE'
X:
X#!/bin/sh
X
XPATH="BINDIR:$PATH"; export PATH
Xif test "`echo -n a`" = "-n a"; then
X  # looks like a SysV system:
X  n1=''; n2='\c'
Xelse
X  n1='-n'; n2=''
Xfi
Xoldtty=`stty -g 2>/dev/null`
Xif stty -cbreak 2>/dev/null; then
X  cb='cbreak'; ncb='-cbreak'
Xelse
X  # 'stty min 1' resets eof to ^a on both SunOS and SysV!
X  cb='min 1 -icanon'; ncb='icanon eof ^d'
Xfi
Xif test $? -eq 0 -a -n "$oldtty"; then
X   trap 'stty $oldtty 2>/dev/null; exit' 0 2 3 5 10 13 15
Xelse
X   trap 'stty $ncb echo 2>/dev/null; exit' 0 2 3 5 10 13 15
Xfi
X
Xif test $# = 0; then
X	gzip -cdfq | eval ${PAGER-more}
Xelse
X    FIRST=1
X    for FILE
X    do
X	if test $FIRST -eq 0; then
X		echo $n1 "--More--(Next file: $FILE)$n2"
X		stty $cb -echo 2>/dev/null
X		ANS=`dd bs=1 count=1 2>/dev/null` 
X		stty $ncb echo 2>/dev/null
X		echo " "
X		if test "$ANS" = 'e' -o "$ANS" = 'q'; then
X			exit
X		fi
X	fi
X	if test "$ANS" != 's'; then
X		echo "------> $FILE <------"
X		gzip -cdfq "$FILE" | eval ${PAGER-more}
X	fi
X	if test -t; then
X		FIRST=0
X	fi
X    done
Xfi
END_OF_FILE
if test 1001 -ne `wc -c <'gzip-1.2.2/zmore.in'`; then
    echo shar: \"'gzip-1.2.2/zmore.in'\" unpacked with wrong size!
fi
chmod +x 'gzip-1.2.2/zmore.in'
# end of 'gzip-1.2.2/zmore.in'
fi
if test -f 'gzip-1.2.2/znew.in' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/znew.in'\"
else
echo shar: Extracting \"'gzip-1.2.2/znew.in'\" \(3664 characters\)
sed "s/^X//" >'gzip-1.2.2/znew.in' <<'END_OF_FILE'
X:
X#!/bin/sh
X
XPATH="BINDIR:$PATH"; export PATH
Xcheck=0
Xpipe=0
Xopt=
Xfiles=
Xkeep=0
Xres=0
Xold=0
Xnew=0
Xblock=1024
X# block is the disk block size (best guess, need not be exact)
X
Xwarn="(does not preserve modes and timestamp)"
Xtmp=/tmp/zfoo.$$
Xecho hi > $tmp.1
Xecho hi > $tmp.2
Xif test -z "`(${CPMOD-cpmod} $tmp.1 $tmp.2) 2>&1`"; then
X  cpmod=${CPMOD-cpmod}
X  warn=""
Xfi
X
Xif test -z "$cpmod" && ${TOUCH-touch} -r $tmp.1 $tmp.2 2>/dev/null; then
X  cpmod="${TOUCH-touch}"
X  cpmodarg="-r"
X  warn="(does not preserve file modes)"
Xfi
X
X# check if GZIP env. variable uses -S or --suffix
Xgzip -q $tmp.1
Xext=`echo $tmp.1* | sed "s|$tmp.1||"`
Xrm -f $tmp.[12]*
Xif test -z "$ext"; then
X  echo znew: error determining gzip extension
X  exit 1
Xfi
Xif test "$ext" = ".Z"; then
X  echo znew: cannot use .Z as gzip extension.
X  exit 1
Xfi
X
XA=
Xfileno=0
X
Xfor arg
Xdo
X  case "$arg" in
X  -*)     opt="$opt $arg";;
X   *)     fileno=`expr $fileno + 1`
X          eval A$fileno=\$arg
X          A="$A \"\$A$fileno\""
X	  ;;
X  esac
Xdone
X
Xif test $fileno -eq 0; then
X  echo "recompress .Z files into $ext (gzip) files"
X  echo usage: `echo $0 | sed 's,^.*/,,'` "[-tv9KP]" file.Z...
X  echo "  -t tests the new files before deleting originals"
X  echo "  -v be verbose"
X  echo "  -9 use the slowest compression method (optimal compression)"
X  echo "  -K keep a .Z file when it is smaller than the $ext file"
X  echo "  -P use pipes for the conversion $warn"
X  exit 1
Xfi
X
Xeval set "$A"                # the files are now in $1, $2, ...
X
Xopt=`echo "$opt" | sed -e 's/ //g' -e 's/-//g'`
Xcase "$opt" in
X  *t*) check=1; opt=`echo "$opt" | sed 's/t//g'`
Xesac
Xcase "$opt" in
X  *K*) keep=1; opt=`echo "$opt" | sed 's/K//g'`
Xesac
Xcase "$opt" in
X  *P*) pipe=1; opt=`echo "$opt" | sed 's/P//g'`
Xesac
Xif test -n "$opt"; then
X  opt="-$opt"
Xfi
X
Xfor i do
X  n=`echo $i | sed 's/.Z$//'`
X  if test ! -f "$n.Z" ; then
X    echo $n.Z not found
X    res=1; continue
X  fi
X  test $keep -eq 1 && old=`wc -c < "$n.Z"`
X  if test $pipe -eq 1; then
X    if gzip -d < "$n.Z" | gzip $opt > "$n$ext"; then
X      # Copy file attributes from old file to new one, if possible.
X      test -n "$cpmod" && $cpmod $cpmodarg "$n.Z" "$n$ext" 2> /dev/null
X    else
X      echo error while recompressing $n.Z
X      res=1; continue
X    fi
X  else
X    if test $check -eq 1; then
X      if cp -p "$n.Z" "$n.$$" 2> /dev/null || cp "$n.Z" "$n.$$"; then
X	:
X      else
X	echo cannot backup "$n.Z"
X        res=1; continue
X      fi
X    fi
X    if gzip -d "$n.Z"; then
X      :
X    else
X      test $check -eq 1 && mv "$n.$$" "$n.Z"
X      echo error while uncompressing $n.Z
X      res=1; continue
X    fi
X    if gzip $opt "$n"; then
X      :
X    else
X      if test $check -eq 1; then
X	mv "$n.$$" "$n.Z" && rm -f "$n"
X        echo error while recompressing $n
X      else
X	# compress $n  (might be dangerous if disk full)
X        echo error while recompressing $n, left uncompressed
X      fi
X      res=1; continue
X    fi
X  fi
X  test $keep -eq 1 && new=`wc -c < "$n$ext"`
X  if test $keep -eq 1 -a `expr \( $old + $block - 1 \) / $block` -lt \
X                         `expr \( $new + $block - 1 \) / $block`; then
X    if test $pipe -eq 1; then
X      rm -f "$n$ext"
X    elif test $check -eq 1; then
X      mv "$n.$$" "$n.Z" && rm -f "$n$ext"
X    else
X      gzip -d "$n$ext" && compress "$n" && rm -f "$n$ext"
X    fi
X    echo "$n.Z smaller than $n$ext -- unchanged"
X
X  elif test $check -eq 1; then
X    if gzip -t "$n$ext" ; then
X      rm -f "$n.$$" "$n.Z"
X    else
X      test $pipe -eq 0 && mv "$n.$$" "$n.Z"
X      rm -f "$n$ext"
X      echo error while testing $n$ext, $n.Z unchanged
X      res=1; continue
X    fi
X  elif test $pipe -eq 1; then
X    rm -f "$n.Z"
X  fi
Xdone
Xexit $res
END_OF_FILE
if test 3664 -ne `wc -c <'gzip-1.2.2/znew.in'`; then
    echo shar: \"'gzip-1.2.2/znew.in'\" unpacked with wrong size!
fi
chmod +x 'gzip-1.2.2/znew.in'
# end of 'gzip-1.2.2/znew.in'
fi
if test -f 'gzip-1.2.2/zdiff.in' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/zdiff.in'\"
else
echo shar: Extracting \"'gzip-1.2.2/zdiff.in'\" \(1990 characters\)
sed "s/^X//" >'gzip-1.2.2/zdiff.in' <<'END_OF_FILE'
X:
X#!/bin/sh
X# sh is buggy on RS/6000 AIX 3.2. Replace above line with #!/bin/ksh
X
X# Zcmp and zdiff are used to invoke the cmp or the  diff  pro-
X# gram  on compressed files.  All options specified are passed
X# directly to cmp or diff.  If only 1 file is specified,  then
X# the  files  compared  are file1 and an uncompressed file1.gz.
X# If two files are specified, then they are  uncompressed  (if
X# necessary) and fed to cmp or diff.  The exit status from cmp
X# or diff is preserved.
X
XPATH="BINDIR:$PATH"; export PATH
Xprog=`echo $0 | sed 's|.*/||'`
Xcase "$prog" in
X  *cmp) comp=${CMP-cmp}   ;;
X  *)    comp=${DIFF-diff} ;;
Xesac
X
XOPTIONS=
XFILES=
Xfor ARG
Xdo
X    case "$ARG" in
X    -*)	OPTIONS="$OPTIONS $ARG";;
X     *)	if test -f "$ARG"; then
X            FILES="$FILES $ARG"
X        else
X            echo "${prog}: $ARG not found or not a regular file"
X	    exit 1
X        fi ;;
X    esac
Xdone
Xif test -z "$FILES"; then
X	echo "Usage: $prog [${comp}_options] file [file]"
X	exit 1
Xfi
Xset $FILES
Xif test $# -eq 1; then
X	FILE=`echo "$1" | sed 's/[-.][zZtga]*$//'`
X	gzip -cd "$1" | $comp $OPTIONS - "$FILE"
X	STAT="$?"
X
Xelif test $# -eq 2; then
X	case "$1" in
X        *[-.]gz | *[-.][zZ] | *.t[ga]z)
X                case "$2" in
X	        *[-.]gz | *[-.][zZ] | *.t[ga]z)
X			F=`echo "$2" | sed 's|.*/||;s|[-.][zZtga]*$||'`
X                        gzip -cd "$2" > /tmp/"$F".$$
X                        gzip -cd "$1" | $comp $OPTIONS - /tmp/"$F".$$
X                        STAT="$?"
X			/bin/rm -f /tmp/"$F".$$;;
X
X                *)      gzip -cd "$1" | $comp $OPTIONS - "$2"
X                        STAT="$?";;
X                esac;;
X        *)      case "$2" in
X	        *[-.]gz | *[-.][zZ] | *.t[ga]z)
X                        gzip -cd "$2" | $comp $OPTIONS "$1" -
X                        STAT="$?";;
X                *)      $comp $OPTIONS "$1" "$2"
X                        STAT="$?";;
X                esac;;
X	esac
X        exit "$STAT"
Xelse
X	echo "Usage: $prog [${comp}_options] file [file]"
X	exit 1
Xfi
END_OF_FILE
if test 1990 -ne `wc -c <'gzip-1.2.2/zdiff.in'`; then
    echo shar: \"'gzip-1.2.2/zdiff.in'\" unpacked with wrong size!
fi
chmod +x 'gzip-1.2.2/zdiff.in'
# end of 'gzip-1.2.2/zdiff.in'
fi
if test -f 'gzip-1.2.2/zgrep.in' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/zgrep.in'\"
else
echo shar: Extracting \"'gzip-1.2.2/zgrep.in'\" \(1487 characters\)
sed "s/^X//" >'gzip-1.2.2/zgrep.in' <<'END_OF_FILE'
X:
X#!/bin/sh
X
X# zgrep -- a wrapper around a grep program that decompresses files as needed
X# Adapted from a version sent by Charles Levert <charles@comm.polymtl.ca>
X
XPATH="BINDIR:$PATH"; export PATH
X
Xprog=`echo $0 | sed 's|.*/||'`
Xcase "$prog" in
X	*egrep)	grep=${EGREP-egrep}	;;
X	*fgrep)	grep=${FGREP-fgrep}	;;
X	*)	grep=${GREP-grep}	;;
Xesac
XA=
Xfileno=0
Xpat=""
Xwhile test $# -ne 0; do
X  case "$1" in
X  -e | -f) opt="$opt $1"; shift; pat="$1"
X           if test "$grep" = grep; then  # grep is buggy with -e on SVR4
X             grep=egrep
X           fi;;
X  -*)	   opt="$opt $1";;
X   *)      if test -z "$pat"; then
X	     pat="$1"
X	   else
X             fileno=`expr $fileno + 1`
X             eval A$fileno=\$1
X             A="$A \"\$A$fileno\""
X             fi
X	     ;;
X  esac
X  shift
Xdone
X
Xif test -z "$pat"; then
X  echo "grep through gzip files"
X  echo "usage: $prog [grep_options] pattern [files]"
X  exit 1
Xfi
X
Xlist=0
Xsilent=0
Xop=`echo "$opt" | sed -e 's/ //g' -e 's/-//g'`
Xcase "$op" in
X  *l*) list=1
Xesac
Xcase "$op" in
X  *h*) silent=1
Xesac
X
Xif test $fileno -eq 0; then
X  gzip -cdfq | $grep $opt "$pat"
X  exit $?
Xfi
Xeval set "$A" # files in $1, $2 ...
X
Xres=0
Xfor i do
X  if test $list -eq 1; then
X    gzip -cdfq "$i" | $grep $opt "$pat" > /dev/null && echo $i
X    r=$?
X  elif test $# -eq 1 -o $silent -eq 1; then
X    gzip -cdfq "$i" | $grep $opt "$pat"
X    r=$?
X  else
X    gzip -cdfq "$i" | $grep $opt "$pat" | sed "s|^|${i}:|"
X    r=$?
X  fi
X  test "$r" -ne 0 && res="$r"
Xdone
Xexit $res
END_OF_FILE
if test 1487 -ne `wc -c <'gzip-1.2.2/zgrep.in'`; then
    echo shar: \"'gzip-1.2.2/zgrep.in'\" unpacked with wrong size!
fi
chmod +x 'gzip-1.2.2/zgrep.in'
# end of 'gzip-1.2.2/zgrep.in'
fi
if test -f 'gzip-1.2.2/zforce.in' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/zforce.in'\"
else
echo shar: Extracting \"'gzip-1.2.2/zforce.in'\" \(1004 characters\)
sed "s/^X//" >'gzip-1.2.2/zforce.in' <<'END_OF_FILE'
X:
X#!/bin/sh
X# zforce: force a gz extension on all gzip files so that gzip will not
X# compress them twice.
X#
X# This can be useful for files with names truncated after a file transfer.
X# 12345678901234 is renamed to 12345678901.gz
X
XPATH="BINDIR:$PATH"; export PATH
Xx=`basename $0`
Xif test $# = 0; then
X  echo "force a '.gz' extension on all gzip files"
X  echo usage: $x files...
X  exit 1
Xfi
X
Xres=0
Xfor i do
X  if test ! -f "$i" ; then
X    echo ${x}: $i not a file
X    res=1
X    continue
X  fi
X  test `expr "$i" : '.*[.-]z$'` -eq 0 || continue
X  test `expr "$i" : '.*[.-]gz$'` -eq 0 || continue
X  test `expr "$i" : '.*[.]t[ag]z$'` -eq 0 || continue
X
X  if gzip -l < "$i" 2>/dev/null | grep '^defl' > /dev/null; then
X
X    if test `expr "$i" : '^............'` -eq 12; then
X      new=`expr "$i" : '\(.*\)...$`.gz
X    else
X      new="$i.gz"
X    fi
X    if mv "$i" "$new" 2>/dev/null; then
X      echo $i -- replaced with $new
X      continue
X    fi
X    res=1; echo ${x}: cannot rename $i to $new
X  fi
Xdone
Xexit $res
END_OF_FILE
if test 1004 -ne `wc -c <'gzip-1.2.2/zforce.in'`; then
    echo shar: \"'gzip-1.2.2/zforce.in'\" unpacked with wrong size!
fi
chmod +x 'gzip-1.2.2/zforce.in'
# end of 'gzip-1.2.2/zforce.in'
fi
if test -f 'gzip-1.2.2/gzexe.in' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/gzexe.in'\"
else
echo shar: Extracting \"'gzip-1.2.2/gzexe.in'\" \(3835 characters\)
sed "s/^X//" >'gzip-1.2.2/gzexe.in' <<'END_OF_FILE'
X:
X#!/bin/sh
X# gzexe: compressor for Unix executables.
X# Use this only for binaries that you do not use frequently.
X#
X# The compressed version is a shell script which decompresses itself after
X# skipping $skip lines of shell commands.  We try invoking the compressed
X# executable with the original name (for programs looking at their name).
X# We also try to retain the original file permissions on the compressed file.
X# For safety reasons, gzexe will not create setuid or setgid shell scripts.
X
X# WARNING: the first line of this file must be either : or #!/bin/sh
X# The : is required for some old versions of csh.
X# On Ultrix, /bin/sh is too buggy, change the first line to: #!/bin/sh5
X
Xx=`basename $0`
Xif test $# = 0; then
X  echo compress executables. original file foo is renamed to foo~
X  echo usage: ${x} [-d] files...
X  echo   "   -d  decompress the executables"
X  exit 1
Xfi
X
Xtmp=gz$$
Xtrap "rm -f $tmp; exit 1" 1 2 3 5 10 13 15
X
Xdecomp=0
Xres=0
Xtest "$x" = "ungzexe" && decomp=1
Xif test "x$1" = "x-d"; then
X  decomp=1
X  shift
Xfi
X
Xecho hi > zfoo1$$
Xecho hi > zfoo2$$
Xif test -z "`(${CPMOD-cpmod} zfoo1$$ zfoo2$$) 2>&1`"; then
X  cpmod=${CPMOD-cpmod}
Xfi
Xrm -f zfoo[12]$$
X
Xtail=""
XIFS="${IFS= 	}"; saveifs="$IFS"; IFS="${IFS}:"
Xfor dir in $PATH; do
X  test -z "$dir" && dir=.
X  if test -f $dir/tail; then
X    tail="$dir/tail"
X    break
X  fi
Xdone
XIFS="$saveifs"
Xif test -z "$tail"; then
X  echo cannot find tail
X  exit 1
Xfi
X
Xfor i do
X  if test ! -f "$i" ; then
X    echo ${x}: $i not a file
X    res=1
X    continue
X  fi
X  if test $decomp -eq 0; then
X    if sed -e 1d -e 2q "$i" | grep "^skip=[0-9]*$" >/dev/null; then
X      echo "${x}: $i is already gzexe'd"
X      continue
X    fi
X  fi
X  if ls -l "$i" | grep '^...[sS]' > /dev/null; then
X    echo "${x}: $i has setuid permission, unchanged"
X    continue
X  fi
X  if ls -l "$i" | grep '^......[sS]' > /dev/null; then
X    echo "${x}: $i has setgid permission, unchanged"
X    continue
X  fi
X  case "`basename $i`" in
X  gzip | tail | chmod | ln | sleep | rm)
X	echo "${x}: $i would depend on itself"; continue ;;
X  esac
X  if test -z "$cpmod"; then
X    cp -p "$i" $tmp 2>/dev/null || cp "$i" $tmp
X    if test -w $tmp 2>/dev/null; then
X      writable=1
X    else
X      writable=0
X      chmod u+w $tmp 2>/dev/null
X    fi
X  fi
X  if test $decomp -eq 0; then
X    sed 1q $0 > $tmp
X    sed "s|^if tail|if $tail|" >> $tmp <<'EOF'
Xskip=18
Xif tail +$skip $0 | "BINDIR"/gzip -cd > /tmp/gztmp$$; then
X  /bin/chmod 700 /tmp/gztmp$$
X  prog="`echo $0 | /bin/sed 's|^.*/||`"
X  if /bin/ln /tmp/gztmp$$ "/tmp/$prog" 2>/dev/null; then
X    trap '/bin/rm -f /tmp/gztmp$$ "/tmp/$prog"; exit $res' 0
X    (/bin/sleep 5; /bin/rm -f /tmp/gztmp$$ "/tmp/$prog") 2>/dev/null &
X    /tmp/"$prog" ${1+"$@"}; res=$?
X  else
X    trap '/bin/rm -f /tmp/gztmp$$; exit $res' 0
X    (/bin/sleep 5; /bin/rm -f /tmp/gztmp$$) 2>/dev/null &
X    /tmp/gztmp$$ ${1+"$@"}; res=$?
X  fi
Xelse
X  echo Cannot decompress $0; exit 1
Xfi; exit $res
XEOF
X    "BINDIR"/gzip -cv9 "$i" >> $tmp || {
X      /bin/rm -f $tmp
X      echo ${x}: compression not possible for $i, file unchanged.
X      res=1
X      continue
X    }
X
X  else
X    # decompression
X    skip=18
X    if sed -e 1d -e 2q "$i" | grep "^skip=[0-9]*$" >/dev/null; then
X      eval `sed -e 1d -e 2q "$i"`
X    fi
X    if tail +$skip "$i" | "BINDIR"/gzip -cd > $tmp; then
X      :
X    else
X      echo ${x}: $i probably not in gzexe format, file unchanged.
X      res=1
X      continue
X    fi
X  fi
X  rm -f "$i~"
X  mv "$i" "$i~" || {
X    echo ${x}: cannot backup $i as $i~
X    rm -f $tmp
X    res=1
X    continue
X  }
X  mv $tmp "$i" || cp -p $tmp "$i" 2>/dev/null || cp $tmp "$i" || {
X    echo ${x}: cannot create $i
X    rm -f $tmp
X    res=1
X    continue
X  }
X  rm -f $tmp
X  if test -n "$cpmod"; then
X    $cpmod "$i~" "$i" 2>/dev/null
X  elif test $writable -eq 0; then
X    chmod u-w $i 2>/dev/null
X  fi
Xdone
Xexit $res
END_OF_FILE
if test 3835 -ne `wc -c <'gzip-1.2.2/gzexe.in'`; then
    echo shar: \"'gzip-1.2.2/gzexe.in'\" unpacked with wrong size!
fi
chmod +x 'gzip-1.2.2/gzexe.in'
# end of 'gzip-1.2.2/gzexe.in'
fi
if test -f 'gzip-1.2.2/gzip.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/gzip.1'\"
else
echo shar: Extracting \"'gzip-1.2.2/gzip.1'\" \(12266 characters\)
sed "s/^X//" >'gzip-1.2.2/gzip.1' <<'END_OF_FILE'
X.PU
X.TH GZIP 1 local
X.SH NAME
Xgzip, gunzip, zcat \- compress or expand files
X.SH SYNOPSIS
X.ll +8
X.B gzip
X.RB [ " \-acdfhlLnrtvV19 " ]
X.RB [ \-S\ suffix ]
X[
X.I "name \&..."
X]
X.ll -8
X.br
X.B gunzip
X.RB [ " \-acfhlLnrtvV " ]
X.RB [ \-S\ suffix ]
X[
X.I "name \&..."
X]
X.br
X.B zcat
X.RB [ " \-fhLV " ]
X[
X.I "name \&..."
X]
X.SH DESCRIPTION
X.I Gzip
Xreduces the size of the named files using Lempel-Ziv coding (LZ77).
XWhenever possible,
Xeach file is replaced by one with the extension
X.B "\&.gz,"
Xwhile keeping the same ownership modes, access and modification times.
X(The default extension is
X.B "\-gz"
Xfor VMS,
X.B "z"
Xfor MSDOS, OS/2 FAT and Atari.)
XIf no files are specified, the standard input is compressed to the
Xstandard output.
X.I Gzip
Xwill only attempt to compress regular files.
XIn particular, it will ignore symbolic links.
X.PP
XIf the new file name is too long for its file system,
X.I gzip
Xtruncates it and keeps the original file name in the compressed file.
X.I Gzip
Xattempts to truncate only the parts of the file name longer than 3 characters.
X(A part is delimited by dots.) If the name consists of small parts only,
Xthe longest parts are truncated. For example, if file names are limited
Xto 14 characters, gzip.msdos.exe is compressed to gzi.msd.exe.gz.
XNames are not truncated on systems which do not have a limit on file name
Xlength.
X.PP
XCompressed files can be restored to their original form using
X.I gzip -d
Xor
X.I gunzip
Xor
X.I zcat.
XIf the original name saved in the compressed file is not suitable for its
Xfile system, a new name is constructed from the original one to make it
Xlegal.
X.PP
X.I gunzip
Xtakes a list of files on its command line and replaces each
Xfile whose name ends with .gz, -gz, .z, -z, _z or .Z
Xand which begins with the correct magic number with an uncompressed
Xfile without the original extension.
X.I gunzip
Xalso recognizes the special extensions
X.B "\&.tgz"
Xand
X.B "\&.taz"
Xas shorthands for
X.B "\&.tar.gz"
Xand
X.B "\&.tar.Z"
Xrespectively.
XWhen compressing,
X.I gzip
Xuses the
X.B "\&.tgz"
Xextension if necessary instead of truncating a file with a
X.B "\&.tar"
Xextension.
X.PP
X.I gunzip
Xcan currently decompress files created by
X.I gzip, zip, compress, compress -H
Xor
X.I pack.
XThe detection of the input format is automatic.  When using
Xthe first two formats,
X.I gunzip
Xchecks a 32 bit CRC. For
X.I pack, gunzip
Xchecks the uncompressed length. The standard
X.I compress
Xformat was not designed to allow consistency checks. However
X.I gunzip
Xis sometimes able to detect a bad .Z file. If you get an error
Xwhen uncompressing a .Z file, do not assume that the .Z file is
Xcorrect simply because the standard
X.I uncompress
Xdoes not complain. This generally means that the standard
X.I uncompress
Xdoes not check its input, and happily generates garbage output.
XThe SCO compress -H format (lzh compression method) does not include a CRC
Xbut also allows some consistency checks.
X.PP
XFiles created by
X.I zip
Xcan be uncompressed by gzip only if they have a single member compressed
Xwith the 'deflation' method. This feature is only intended to help
Xconversion of tar.zip files to the tar.gz format. To extract zip files
Xwith several members, use
X.I unzip
Xinstead of
X.I gunzip.
X.PP
X.I zcat
Xis identical to
X.I gunzip
X.B \-c.
X(On some systems,
X.I zcat
Xmay be installed as
X.I gzcat
Xto preserve the original link to
X.I compress.)
X.I zcat
Xuncompresses either a list of files on the command line or its
Xstandard input and writes the uncompressed data on standard output.
X.I zcat
Xwill uncompress files that have the correct magic number whether
Xthey have a
X.B "\&.gz"
Xsuffix or not.
X.PP
X.I Gzip
Xuses the Lempel-Ziv algorithm used in
X.I zip
Xand PKZIP.
XThe amount of compression obtained depends on the size of the
Xinput and the distribution of common substrings.
XTypically, text such as source code or English
Xis reduced by 60\-70%.
XCompression is generally much better than that achieved by
XLZW (as used in 
X.IR compress ),
XHuffman coding (as used in
X.IR pack ),
Xor adaptive Huffman coding
X.RI ( compact ).
X.PP
XCompression is always performed, even if the compressed file is
Xslightly larger than the original. The worst case expansion is
Xa few bytes for the gzip file header, plus 5 bytes every 32K block,
Xor an expansion ratio of 0.015% for large files. Note that the actual
Xnumber of used disk blocks almost never increases.
X.I gzip
Xpreserves the mode, ownership and timestamps of files when compressing
Xor decompressing.
X
X.SH OPTIONS
X.TP
X.B \-a --ascii
XAscii text mode: convert end-of-lines using local conventions. This option
Xis supported only on some non-Unix systems. For MSDOS, CR LF is converted
Xto LF when compressing, and LF is converted to CR LF when decompressing.
X.TP
X.B \-c --stdout --to-stdout
XWrite output on standard output; keep original files unchanged.
XIf there are several input files, the output consists of a sequence of
Xindependently compressed members. To obtain better compression,
Xconcatenate all input files before compressing them.
X.TP
X.B \-d --decompress --uncompress
XDecompress.
X.TP
X.B \-f --force
XForce compression or decompression even if the file has multiple links
Xor the corresponding file already exists, or if the compressed data
Xis read from or written to a terminal. If the input data is not in
Xa format recognized by
X.I gzip,
Xand if the option --stdout is also given, copy the input data without change
Xto the standard ouput: let
X.I zcat
Xbehave as
X.I cat.
XIf
X.B \-f
Xis not given,
Xand when not running in the background,
X.I gzip
Xprompts to verify whether an existing file should be overwritten.
X.TP
X.B \-h --help
XDisplay a help screen and quit.
X.TP
X.B \-l --list
XFor each compressed file, list the following fields:
X
X    compressed size: size of the compressed file
X    uncompressed size: size of the uncompressed file
X    ratio: compression ratio (0.0% if unknown)
X    uncompressed_name: name of the uncompressed file
X
XThe uncompressed size is given as -1 for files not in gzip format,
Xsuch as compressed .Z files. To get the uncompressed size for such a file,
Xyou can use:
X
X    zcat file.Z | wc -c
X
XIn combination with the --verbose option, the following fields are also
Xdisplayed:
X
X    method: compression method
X    crc: the 32-bit CRC of the uncompressed data
X    date & time: time stamp for the uncompressed file
X
XThe compression methods currently supported are deflate, compress, lzh
X(SCO compress -H) and pack.  The crc is given as ffffffff for a file
Xnot in gzip format.
X
XWith --verbose, the size totals and compression ratio for all files
Xis also displayed, unless some sizes are unknown. With --quiet,
Xthe title and totals lines are not displayed.
X.TP
X.B \-L --license
XDisplay the
X.I gzip
Xlicense and quit.
X.TP
X.B \-n --no-name
XWhen compressing, do not save the original file name by default. (The
Xoriginal name is always saved if the name had to be truncated.) When
Xdecompressing, do not restore the original file name if present: remove
Xonly the
X.I gzip
Xsuffix from the compressed file name.
X.TP
X.B \-q --quiet
XSuppress all warnings.
X.TP
X.B \-r --recurse
XTravel the directory structure recursively. If any of the file names
Xspecified on the command line are directories, 
X.I gzip
Xwill descend into the directory and compress all the files it finds there
X(or decompress them in the case of
X.I gunzip
X).
X.TP
X.B \-S .suf   --suffix .suf
XUse suffix .suf instead of .gz. Any suffix can be given, but suffixes
Xother than .z and .gz should be avoided to avoid confusion when files
Xare transferred to other.  A null suffix forces gunzip to  try
Xdecompression on all given files regardless of suffix, as in:
X
X    gunzip -S "" *       (*.* for MSDOS)
X
XPrevious versions of gzip used
Xthe .z suffix. This was changed to avoid a conflict with
X.IR pack "(1)".
X.TP
X.B \-t --test
XTest. Check the compressed file integrity.
X.TP
X.B \-v --verbose
XVerbose. Display the name and percentage reduction for each file compressed
Xor decompressed.
X.TP
X.B \-V --version
XVersion. Display the version number and compilation options then quit.
X.TP
X.B \-# --fast --best
XRegulate the speed of compression using the specified digit
X.IR # ,
Xwhere
X.B \-1
Xor
X.B \-\-fast
Xindicates the fastest compression method (less compression)
Xand
X.B \-9
Xor
X.B \-\-best
Xindicates the slowest compression method (optimal compression).
XThe default compression level is
X.BR \-6
X(that is, biased towards high compression at expense of speed).
X.SH "ADVANCED USAGE"
XMultiple compressed files can be concatenated. In this case,
X.I gunzip
Xwill extract all members at once. For example:
X
X      gzip -c file1  > foo.gz
X      gzip -c file2 >> foo.gz
X
XThen
X      gunzip -c foo
X
Xis equivalent to
X
X      cat file1 file2
X
XIn case of damage to one member of a .gz file, other members can
Xstill be recovered (if the damaged member is removed). However,
Xyou can get better compression by compressing all members at once:
X
X      cat file1 file2 | gzip > foo.gz
X
Xcompresses better than
X
X      gzip -c file1 file2 > foo.gz
X
XIf you want to recompress concatenated files to get better compression, do:
X
X      zcat old.gz | gzip > new.gz
X.SH "ENVIRONMENT"
XThe environment variable
X.B GZIP
Xcan hold a set of default options for
X.I gzip.
XThese options are interpreted first and can be overwritten by
Xexplicit command line parameters. For example:
X      for sh:    GZIP="-8 -v"; export GZIP
X      for csh:   setenv GZIP "-8 -v"
X      for MSDOS: set GZIP=-8 -v
X
XOn Vax/VMS, the name of the environment variable is GZIP_OPT, to
Xavoid a conflict with the symbol set for invocation of the program.
X.SH "SEE ALSO"
Xznew(1), zcmp(1), zmore(1), zforce(1), gzexe(1), zip(1), unzip(1), compress(1),
Xpack(1), compact(1)
X.SH "DIAGNOSTICS"
XExit status is normally 0;
Xif an error occurs, exit status is 1. If a warning occurs, exit status is 2.
X.PP
XUsage: gzip [-cdfhlLnrtvV19] [-S suffix] [file ...]
X.in +8
XInvalid options were specified on the command line.
X.in -8
X.IR file :
Xnot in gzip format
X.in +8
XThe file specified to
X.I gunzip
Xhas not been compressed.
X.in -8
X.IR file:
XCorrupt input. Use zcat to recover some data.
X.in +8
XThe compressed file has been damaged. The data up to the point of failure
Xcan be recovered using
X.in +8
Xzcat file > recover
X.in -16
X.IR file :
Xcompressed with 
X.I xx
Xbits, can only handle 
X.I yy
Xbits
X.in +8
X.I File
Xwas compressed (using LZW) by a program that could deal with
Xmore 
X.I bits
Xthan the decompress code on this machine.
XRecompress the file with gzip, which compresses better and uses
Xless memory.
X.in -8
X.IR file :
Xalready has .gz suffix -- no change
X.in +8
XThe file is assumed to be already compressed.
XRename the file and try again.
X.in -8
X.I file
Xalready exists; do you wish to overwrite (y or n)?
X.in +8
XRespond "y" if you want the output file to be replaced; "n" if not.
X.in -8
Xgunzip: corrupt input
X.in +8
XA SIGSEGV violation was detected which usually means that the input file has
Xbeen corrupted.
X.in -8
X.I "xx.x%"
X.in +8
XPercentage of the input saved by compression.
X(Relevant only for
X.BR \-v
Xand
X.BR \-l \.)
X.in -8
X-- not a regular file or directory: ignored
X.in +8
XWhen the input file is not a regular file or directory,
X(e.g. a symbolic link, socket, FIFO, device file), it is
Xleft unaltered.
X.in -8
X-- has 
X.I xx 
Xother links: unchanged
X.in +8
XThe input file has links; it is left unchanged.  See
X.IR ln "(1)"
Xfor more information. Use the
X.B \-f
Xflag to force compression of multiply-linked files.
X.in -8
X.SH CAVEATS
XWhen writing compressed data to a tape, it is generally necessary to
Xpad the output with zeroes up to a block boundary. When the data is
Xread and the whole block is passed to
X.I gunzip
Xfor decompression,
X.I gunzip
Xdetects that there is extra trailing garbage after the compressed data
Xand emits a warning by default. You have to use the --quiet option to
Xsuppress the warning. This option can be set in the
X.B GZIP
Xenvironment variable as in:
X    for sh:    GZIP="-q"  tar xfz /dev/rmt/datn
X    for csh:   (setenv GZIP "-q"; tar xfz /dev/rmt/datn)
X
XIn the above example, gzip is invoked implicitly by the -z option
Xof GNU tar. Make sure that the same block size (-b option of
Xtar) is used for reading and writing compressed data on tapes.
X.SH BUGS
XThe --list option reports incorrect sizes if they exceed 2 gigabytes.
XThe --list option reports sizes as -1 and crc as ffffffff if the
Xcompressed file is on a non seekable media.
END_OF_FILE
if test 12266 -ne `wc -c <'gzip-1.2.2/gzip.1'`; then
    echo shar: \"'gzip-1.2.2/gzip.1'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/gzip.1'
fi
if test -f 'gzip-1.2.2/zdiff.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/zdiff.1'\"
else
echo shar: Extracting \"'gzip-1.2.2/zdiff.1'\" \(802 characters\)
sed "s/^X//" >'gzip-1.2.2/zdiff.1' <<'END_OF_FILE'
X.TH ZDIFF 1
X.SH NAME
Xzcmp, zdiff \- compare compressed files
X.SH SYNOPSIS
X.B zcmp
X[ cmp_options ] file1
X[ file2 ]
X.br
X.B zdiff
X[ diff_options ] file1
X[ file2 ]
X.SH DESCRIPTION
X.I  Zcmp
Xand 
X.I zdiff
Xare used to invoke the
X.I cmp
Xor the
X.I diff
Xprogram on compressed files.  All options specified are passed directly to
X.I cmp
Xor
X.IR diff "."
XIf only 1 file is specified, then the files compared are
X.I file1
Xand an uncompressed
X.IR file1 ".gz."
XIf two files are specified, then they are uncompressed if necessary and fed to
X.I cmp
Xor
X.IR diff "."
XThe exit status from 
X.I cmp
Xor
X.I diff
Xis preserved.
X.SH "SEE ALSO"
Xcmp(1), diff(1), zmore(1), zgrep(1), znew(1), zforce(1), gzip(1), gzexe(1)
X.SH BUGS
XMessages from the
X.I cmp
Xor
X.I diff
Xprograms refer to temporary filenames instead of those specified.
END_OF_FILE
if test 802 -ne `wc -c <'gzip-1.2.2/zdiff.1'`; then
    echo shar: \"'gzip-1.2.2/zdiff.1'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/zdiff.1'
fi
if test -f 'gzip-1.2.2/zgrep.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/zgrep.1'\"
else
echo shar: Extracting \"'gzip-1.2.2/zgrep.1'\" \(958 characters\)
sed "s/^X//" >'gzip-1.2.2/zgrep.1' <<'END_OF_FILE'
X.TH ZGREP 1
X.SH NAME
Xzgrep \- search possibly compressed files for a regular expression
X.SH SYNOPSIS
X.B zgrep
X[ grep_options ]
X.BI  [\ -e\ ] " pattern"
X.IR filename ".\|.\|."
X.SH DESCRIPTION
X.IR  Zgrep
Xis used to invoke the
X.I grep
Xon compress'ed or gzip'ed files. All options specified are passed directly to
X.I grep.
XIf no file is specified, then the standard input is decompressed
Xif necessary and fed to grep.
XOtherwise the given files are uncompressed if necessary and fed to
X.I grep.
X.PP
XIf
X.I zgrep
Xis invoked as
X.I zegrep
Xor
X.I zfgrep
Xthen
X.I egrep
Xor
X.I fgrep
Xis used instead of
X.I grep.
XIf the GREP environment variable is set,
X.I zgrep
Xuses it as the
X.I grep
Xprogram to be invoked. For example:
X
X    for sh:  GREP=fgrep  zgrep string files
X    for csh: (setenv GREP fgrep; zgrep string files)
X.SH AUTHOR
XCharles Levert (charles@comm.polymtl.ca)
X.SH "SEE ALSO"
Xgrep(1), egrep(1), fgrep(1), zdiff(1), zmore(1), znew(1), zforce(1),
Xgzip(1), gzexe(1)
END_OF_FILE
if test 958 -ne `wc -c <'gzip-1.2.2/zgrep.1'`; then
    echo shar: \"'gzip-1.2.2/zgrep.1'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/zgrep.1'
fi
if test -f 'gzip-1.2.2/zmore.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/zmore.1'\"
else
echo shar: Extracting \"'gzip-1.2.2/zmore.1'\" \(4226 characters\)
sed "s/^X//" >'gzip-1.2.2/zmore.1' <<'END_OF_FILE'
X.TH ZMORE 1
X.SH NAME
Xzmore \- file perusal filter for crt viewing of compressed text
X.SH SYNOPSIS
X.B zmore
X[ name ...  ]
X.SH DESCRIPTION
X.I  Zmore
Xis a filter which allows examination of compressed or plain text files
Xone screenful at a time on a soft-copy terminal.
X.I zmore
Xworks on files compressed with
X.I compress, pack
Xor
X.I gzip,
Xand also on uncompressed files.
XIf a file does not exist,
X.I zmore
Xlooks for a file of the same name with the addition of a .gz, .z or .Z suffix.
X.PP
X.I Zmore
Xnormally pauses after each screenful, printing --More--
Xat the bottom of the screen.
XIf the user then types a carriage return, one more line is displayed.
XIf the user hits a space,
Xanother screenful is displayed.  Other possibilities are enumerated later.
X.PP
X.I Zmore
Xlooks in the file
X.I /etc/termcap
Xto determine terminal characteristics,
Xand to determine the default window size.
XOn a terminal capable of displaying 24 lines,
Xthe default window size is 22 lines.
XTo use a pager other than the default
X.I more,
Xset environment variable PAGER to the name of the desired program, such as
X.I less.
X.PP
XOther sequences which may be typed when
X.I zmore
Xpauses, and their effects, are as follows (\fIi\fP is an optional integer
Xargument, defaulting to 1) :
X.PP
X.IP \fIi\|\fP<space>
Xdisplay
X.I i
Xmore lines, (or another screenful if no argument is given)
X.PP
X.IP ^D
Xdisplay 11 more lines (a ``scroll'').
XIf
X.I i
Xis given, then the scroll size is set to \fIi\|\fP.
X.PP
X.IP d
Xsame as ^D (control-D)
X.PP
X.IP \fIi\|\fPz
Xsame as typing a space except that \fIi\|\fP, if present, becomes the new
Xwindow size.  Note that the window size reverts back to the default at the
Xend of the current file.
X.PP
X.IP \fIi\|\fPs
Xskip \fIi\|\fP lines and print a screenful of lines
X.PP
X.IP \fIi\|\fPf
Xskip \fIi\fP screenfuls and print a screenful of lines
X.PP
X.IP "q or Q"
Xquit reading the current file; go on to the next (if any)
X.PP
X.IP "e or q"
XWhen the prompt --More--(Next file: 
X.IR file )
Xis printed, this command causes zmore to exit.
X.PP
X.IP s
XWhen the prompt --More--(Next file: 
X.IR file )
Xis printed, this command causes zmore to skip the next file and continue.
X.PP 
X.IP =
XDisplay the current line number.
X.PP
X.IP \fIi\|\fP/expr
Xsearch for the \fIi\|\fP-th occurrence of the regular expression \fIexpr.\fP
XIf the pattern is not found,
X.I zmore
Xgoes on to the next file (if any).
XOtherwise, a screenful is displayed, starting two lines before the place
Xwhere the expression was found.
XThe user's erase and kill characters may be used to edit the regular
Xexpression.
XErasing back past the first column cancels the search command.
X.PP
X.IP \fIi\|\fPn
Xsearch for the \fIi\|\fP-th occurrence of the last regular expression entered.
X.PP
X.IP !command
Xinvoke a shell with \fIcommand\|\fP. 
XThe character `!' in "command" are replaced with the
Xprevious shell command.  The sequence "\\!" is replaced by "!".
X.PP
X.IP ":q or :Q"
Xquit reading the current file; go on to the next (if any)
X(same as q or Q).
X.PP
X.IP .
X(dot) repeat the previous command.
X.PP
XThe commands take effect immediately, i.e., it is not necessary to
Xtype a carriage return.
XUp to the time when the command character itself is given,
Xthe user may hit the line kill character to cancel the numerical
Xargument being formed.
XIn addition, the user may hit the erase character to redisplay the
X--More-- message.
X.PP
XAt any time when output is being sent to the terminal, the user can
Xhit the quit key (normally control\-\\).
X.I Zmore
Xwill stop sending output, and will display the usual --More--
Xprompt.
XThe user may then enter one of the above commands in the normal manner.
XUnfortunately, some output is lost when this is done, due to the
Xfact that any characters waiting in the terminal's output queue
Xare flushed when the quit signal occurs.
X.PP
XThe terminal is set to
X.I noecho
Xmode by this program so that the output can be continuous.
XWhat you type will thus not show on your terminal, except for the / and !
Xcommands.
X.PP
XIf the standard output is not a teletype, then
X.I zmore
Xacts just like
X.I zcat,
Xexcept that a header is printed before each file.
X.SH FILES
X.DT
X/etc/termcap		Terminal data base
X.SH "SEE ALSO"
Xmore(1), gzip(1), zdiff(1), zgrep(1), znew(1), zforce(1), gzexe(1)
END_OF_FILE
if test 4226 -ne `wc -c <'gzip-1.2.2/zmore.1'`; then
    echo shar: \"'gzip-1.2.2/zmore.1'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/zmore.1'
fi
if test -f 'gzip-1.2.2/znew.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/znew.1'\"
else
echo shar: Extracting \"'gzip-1.2.2/znew.1'\" \(885 characters\)
sed "s/^X//" >'gzip-1.2.2/znew.1' <<'END_OF_FILE'
X.TH ZNEW 1
X.SH NAME
Xznew \-   recompress .Z files to .gz files
X.SH SYNOPSIS
X.B znew
X[ -ftv9PK] [ name.Z ...  ]
X.SH DESCRIPTION
X.I  Znew
Xrecompresses files from .Z (compress) format to .gz (gzip) format.
X.SH OPTIONS
X.TP
X.B \-f
XForce recompression from .Z to .gz format even if a .gz file already exists.
X.TP
X.B \-t
XTests the new files before deleting originals.
X.TP
X.B \-v
XVerbose. Display the name and percentage reduction for each file compressed.
X.TP
X.B \-9
XUse the slowest compression method (optimal compression).
X.TP
X.B \-P
XUse pipes for the conversion to reduce disk space usage.
X.TP
X.B \-K
XKeep a .Z file when it is smaller than the .gz file
X.SH "SEE ALSO"
Xgzip(1), zmore(1), zdiff(1), zgrep(1), zforce(1), gzexe(1), compress(1)
X.SH BUGS
X.I Znew
Xdoes not maintain the time stamp with the -P option if
X.I cpmod(1)
Xis not available and
X.I touch(1)
Xdoes not support the -r option.
END_OF_FILE
if test 885 -ne `wc -c <'gzip-1.2.2/znew.1'`; then
    echo shar: \"'gzip-1.2.2/znew.1'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/znew.1'
fi
if test -f 'gzip-1.2.2/gzexe.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/gzexe.1'\"
else
echo shar: Extracting \"'gzip-1.2.2/gzexe.1'\" \(1296 characters\)
sed "s/^X//" >'gzip-1.2.2/gzexe.1' <<'END_OF_FILE'
X.TH GZEXE 1
X.SH NAME
Xgzexe \- compress executable files in place
X.SH SYNOPSIS
X.B gzexe
X[ name ...  ]
X.SH DESCRIPTION
XThe
X.I  gzexe
Xutility allows you to compress executables in place and have them
Xautomatically uncompress and execute when you run them (at a penalty
Xin performance).  For example if you execute ``gzexe /bin/cat'' it
Xwill create the following two files:
X.nf
X.br
X    -r-xr-xr-x  1 root  bin   9644 Feb 11 11:16 /bin/cat
X    -r-xr-xr-x  1 bin   bin  24576 Nov 23 13:21 /bin/cat~
X.fi
X/bin/cat~ is the original file and /bin/cat is the self-uncompressing
Xexecutable file.  You can remove /bin/cat~ once you are sure that
X/bin/cat works properly.
X.PP
XThis utility is most useful on systems with very small disks.
X.SH OPTIONS
X.TP
X.B \-d
XDecompress the given executables instead of compressing them.
X.SH "SEE ALSO"
Xgzip(1), znew(1), zmore(1), zcmp(1), zforce(1)
X.SH CAVEATS
XThe compressed executable is a shell script. This may create some
Xsecurity holes. In particular, the compressed executable relies
Xon the PATH environment variable to find
X.I gzip
Xand some other utilities
X.I (tail, chmod, ln, sleep).
X.SH "BUGS"
X.I gzexe 
Xattempts to retain the original file attributes on the compressed executable,
Xbut you may have to fix them manually in some cases, using
X.I chmod
Xor
X.I chown.
END_OF_FILE
if test 1296 -ne `wc -c <'gzip-1.2.2/gzexe.1'`; then
    echo shar: \"'gzip-1.2.2/gzexe.1'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/gzexe.1'
fi
if test -f 'gzip-1.2.2/zforce.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/zforce.1'\"
else
echo shar: Extracting \"'gzip-1.2.2/zforce.1'\" \(591 characters\)
sed "s/^X//" >'gzip-1.2.2/zforce.1' <<'END_OF_FILE'
X.TH ZFORCE 1
X.SH NAME
Xzforce \- force a '.gz' extension on all gzip files
X.SH SYNOPSIS
X.B zforce
X[ name ...  ]
X.SH DESCRIPTION
X.I  zforce
Xforces a .gz extension on all
X.I gzip
Xfiles so that
X.I gzip
Xwill not compress them twice.
XThis can be useful for files with names truncated after a file transfer.
XOn systems with a 14 char limitation on file names, the original name
Xis truncated to make room for the .gz suffix. For example,
X12345678901234 is renamed to 12345678901.gz. A file name such as foo.tgz
Xis left intact.
X.SH "SEE ALSO"
Xgzip(1), znew(1), zmore(1), zgrep(1), zdiff(1), gzexe(1)
END_OF_FILE
if test 591 -ne `wc -c <'gzip-1.2.2/zforce.1'`; then
    echo shar: \"'gzip-1.2.2/zforce.1'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/zforce.1'
fi
if test -f 'gzip-1.2.2/gzip.doc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/gzip.doc'\"
else
echo shar: Extracting \"'gzip-1.2.2/gzip.doc'\" \(13790 characters\)
sed "s/^X//" >'gzip-1.2.2/gzip.doc' <<'END_OF_FILE'
X
XGZIP(1)                  USER COMMANDS                    GZIP(1)
X
XNAME
X     gzip, gunzip, zcat - compress or expand files
X
XSYNOPSIS
X     gzip [ -acdfhlLnrtvV19 ] [-S suffix] [ name ... ]
X     gunzip [ -acfhlLnrtvV ] [-S suffix] [ name ... ]
X     zcat [ -fhLV ] [ name ... ]
X
XDESCRIPTION
X     Gzip reduces the size of the named  files  using  Lempel-Ziv
X     coding  (LZ77).  Whenever possible, each file is replaced by
X     one with the extension .gz, while keeping the same ownership
X     modes,  access  and modification times.  (The default exten-
X     sion is -gz for VMS, z for MSDOS, OS/2 FAT and Atari.) If no
X     files are specified, the standard input is compressed to the
X     standard output.  Gzip will only attempt to compress regular
X     files.  In particular, it will ignore symbolic links.
X
X     If the new file name is too long for its file  system,  gzip
X     truncates  it  and  keeps  the  original  file  name  in the
X     compressed file.  Gzip attempts to truncate only  the  parts
X     of  the file name longer than 3 characters.  (A part is del-
X     imited by dots.) If the name consists of small  parts  only,
X     the  longest parts are truncated. For example, if file names
X     are limited to 14 characters, gzip.msdos.exe  is  compressed
X     to gzi.msd.exe.gz.  Names are not truncated on systems which
X     do not have a limit on file name length.
X
X     Compressed files can be  restored  to  their  original  form
X     using  gzip -d or gunzip or zcat. If the original name saved
X     in the compressed file is not suitable for its file  system,
X     a  new  name is constructed from the original one to make it
X     legal.
X
X     gunzip takes a  list  of  files  on  its  command  line  and
X     replaces each file whose name ends with .gz, -gz, .z, -z, _z
X     or .Z and which begins with the correct magic number with an
X     uncompressed  file  without  the original extension.  gunzip
X     also recognizes the special  extensions  .tgz  and  .taz  as
X     shorthands   for  .tar.gz  and  .tar.Z  respectively.   When
X     compressing, gzip  uses  the  .tgz  extension  if  necessary
X     instead of truncating a file with a .tar extension.
X
X     gunzip can currently decompress files created by gzip,  zip,
X     compress,  compress  -H  or pack. The detection of the input
X     format is automatic.  When using the first two formats, gun-
X     zip  checks  a  32  bit  CRC.  For  pack,  gunzip checks the
X     uncompressed length. The standard compress  format  was  not
X     designed  to  allow  consistency  checks.  However gunzip is
X     sometimes able to detect a bad .Z file. If you get an  error
X     when uncompressing a .Z file, do not assume that the .Z file
X     is correct simply because the standard uncompress  does  not
X     complain.  This generally means that the standard uncompress
X     does not check its input, and happily generates garbage out-
X     put.   The  SCO  compress -H format (lzh compression method)
X     does not include a CRC  but  also  allows  some  consistency
X     checks.
X
X     Files created by zip can be uncompressed  by  gzip  only  if
X     they  have  a  single member compressed with the 'deflation'
X     method. This feature is only intended to help conversion  of
X     tar.zip  files  to  the  tar.gz format. To extract zip files
X     with several members, use unzip instead of gunzip.
X
X     zcat is identical to gunzip -c. (On some systems,  zcat  may
X     be  installed  as  gzcat  to  preserve  the original link to
X     compress.) zcat uncompresses either a list of files  on  the
X     command   line   or   its  standard  input  and  writes  the
X     uncompressed data on standard output.  zcat will  uncompress
X     files that have the correct magic number whether they have a
X     .gz suffix or not.
X
X     Gzip uses the Lempel-Ziv algorithm used in  zip  and  PKZIP.
X     The  amount  of  compression obtained depends on the size of
X     the input and the distribution of common substrings.   Typi-
X     cally,  text  such  as  source code or English is reduced by
X     60-70%.  Compression is  generally  much  better  than  that
X     achieved  by  LZW  (as used in compress), Huffman coding (as
X     used in pack), or adaptive Huffman coding (compact).
X
X     Compression is always performed, even if the compressed file
X     is  slightly larger than the original. The worst case expan-
X     sion is a few bytes for the gzip file header, plus  5  bytes
X     every  32K  block, or an expansion ratio of 0.015% for large
X     files. Note that the  actual  number  of  used  disk  blocks
X     almost  never increases.  gzip preserves the mode, ownership
X     and timestamps of files when compressing or decompressing.
X
XOPTIONS
X     -a --ascii
X          Ascii text mode: convert end-of-lines using local  con-
X          ventions.  This  option  is supported only on some non-
X          Unix systems. For MSDOS, CR LF is converted to LF  when
X          compressing,   and  LF  is  converted  to  CR  LF  when
X          decompressing.
X
X     -c --stdout --to-stdout
X          Write output on standard output;  keep  original  files
X          unchanged.   If there are several input files, the out-
X          put consists of a sequence of independently  compressed
X          members.  To obtain better compression, concatenate all
X          input files before compressing them.
X
X     -d --decompress --uncompress
X          Decompress.
X
X     -f --force
X          Force compression or decompression even if the file has
X          multiple   links  or  the  corresponding  file  already
X          exists, or if the compressed data is read from or writ-
X          ten to a terminal. If the input data is not in a format
X          recognized by gzip, and if the option --stdout is  also
X          given,  copy the input data without change to the stan-
X          dard ouput: let zcat behave as cat. If -f is not given,
X          and when not running in the background, gzip prompts to
X          verify whether an existing file should be overwritten.
X
X     -h --help
X          Display a help screen and quit.
X
X     -l --list
X          For each compressed file, list the following fields:
X
X              compressed size: size of the compressed file
X              uncompressed size: size of the uncompressed file
X              ratio: compression ratio (0.0% if unknown)
X              uncompressed_name: name of the uncompressed file
X
X          The uncompressed size is given as -1 for files  not  in
X          gzip  format,  such  as compressed .Z files. To get the
X          uncompressed size for such a file, you can use:
X
X              zcat file.Z | wc -c
X
X          In combination with the --verbose option, the following
X          fields are also displayed:
X
X              method: compression method
X              crc: the 32-bit CRC of the uncompressed data
X              date & time: time stamp for the uncompressed file
X
X          The  compression  methods   currently   supported   are
X          deflate, compress, lzh (SCO compress -H) and pack.  The
X          crc is given as ffffffff for a file not in gzip format.
X
X          With --verbose, the size totals and  compression  ratio
X          for  all files is also displayed, unless some sizes are
X          unknown. With --quiet, the title and totals  lines  are
X          not displayed.
X
X     -L --license
X          Display the gzip license and quit.
X
X     -n --no-name
X          When compressing, do not save the original file name by
X          default. (The original name is always saved if the name
X          had  to  be  truncated.)  When  decompressing,  do  not
X          restore  the original file name if present: remove only
X          the gzip suffix from the compressed file name.
X
X     -q --quiet
X          Suppress all warnings.
X
X     -r --recurse
X          Travel the directory structure recursively. If  any  of
X          the file names specified on the command line are direc-
X          tories,  gzip  will  descend  into  the  directory  and
X          compress  all  the  files it finds there (or decompress
X          them in the case of gunzip ).
X
X     -S .suf --suffix .suf
X          Use suffix .suf instead  of  .gz.  Any  suffix  can  be
X          given,  but  suffixes  other  than .z and .gz should be
X          avoided to avoid confusion when files  are  transferred
X          to   other.   A  null  suffix  forces  gunzip  to   try
X          decompression on all given files regardless of  suffix,
X          as in:
X
X              gunzip -S "" *       (*.* for MSDOS)
X
X          Previous versions of gzip used the .z suffix. This  was
X          changed to avoid a conflict with pack(1).
X
X     -t --test
X          Test. Check the compressed file integrity.
X
X     -v --verbose
X          Verbose. Display the name and percentage reduction  for
X          each file compressed or decompressed.
X
X     -V --version
X          Version. Display the  version  number  and  compilation
X          options then quit.
X
X     -# --fast --best
X          Regulate the speed of compression using  the  specified
X          digit  #,  where  -1  or  --fast  indicates the fastest
X          compression method (less compression) and -9 or  --best
X          indicates   the  slowest  compression  method  (optimal
X          compression).  The  default  compression  level  is  -6
X          (that is, biased towards high compression at expense of
X          speed).
X
XADVANCED USAGE
X     Multiple compressed files can be concatenated. In this case,
X     gunzip will extract all members at once. For example:
X
X           gzip -c file1  > foo.gz
X           gzip -c file2 >> foo.gz
X
X     Then
X           gunzip -c foo
X
X     is equivalent to
X
X           cat file1 file2
X
X     In case of damage to one member of a .gz file, other members
X     can  still  be recovered (if the damaged member is removed).
X     However, you can get better compression by  compressing  all
X     members at once:
X
X           cat file1 file2 | gzip > foo.gz
X
X     compresses better than
X
X           gzip -c file1 file2 > foo.gz
X
X     If you want to recompress concatenated files to  get  better
X     compression, do:
X
X           zcat old.gz | gzip > new.gz
X
XENVIRONMENT
X     The environment variable GZIP can  hold  a  set  of  default
X     options  for  gzip.  These options are interpreted first and
X     can be overwritten by explicit command line parameters.  For
X     example:
X           for sh:    GZIP="-8 -v"; export GZIP
X           for csh:   setenv GZIP "-8 -v"
X           for MSDOS: set GZIP=-8 -v
X
X     On  Vax/VMS,  the  name  of  the  environment  variable   is
X     GZIP_OPT,  to avoid a conflict with the symbol set for invo-
X     cation of the program.
X
XSEE ALSO
X     znew(1), zcmp(1),  zmore(1),  zforce(1),  gzexe(1),  zip(1),
X     unzip(1), compress(1), pack(1), compact(1)
X
XDIAGNOSTICS
X     Exit status is normally 0; if an error occurs,  exit  status
X     is 1. If a warning occurs, exit status is 2.
X
X     Usage: gzip [-cdfhlLnrtvV19] [-S suffix] [file ...]
X             Invalid options were specified on the command line.
X     file: not in gzip format
X             The  file  specified  to   gunzip   has   not   been
X             compressed.
X     file: Corrupt input. Use zcat to recover some data.
X             The compressed file has been damaged. The data up to
X             the point of failure can be recovered using
X                     zcat file > recover
X     file: compressed with xx bits, can only handle yy bits
X             File was compressed (using LZW) by  a  program  that
X             could  deal  with more bits than the decompress code
X             on this machine.  Recompress  the  file  with  gzip,
X             which compresses better and uses less memory.
X     file: already has .gz suffix -- no change
X             The  file  is  assumed  to  be  already  compressed.
X             Rename the file and try again.
X     file already exists; do you wish to overwrite (y or n)?
X             Respond "y" if  you  want  the  output  file  to  be
X             replaced; "n" if not.
X     gunzip: corrupt input
X             A SIGSEGV violation was detected which usually means
X             that the input file has been corrupted.
X     xx.x%
X             Percentage  of  the  input  saved  by   compression.
X             (Relevant only for -v and -l.)
X     -- not a regular file or directory: ignored
X             When the input file is not a regular file or  direc-
X             tory,  (e.g.  a  symbolic link, socket, FIFO, device
X             file), it is left unaltered.
X     -- has xx other links: unchanged
X             The input file has links; it is left unchanged.  See
X             ln(1) for more information. Use the -f flag to force
X             compression of multiply-linked files.
X
XCAVEATS
X     When writing compressed data to  a  tape,  it  is  generally
X     necessary  to pad the output with zeroes up to a block boun-
X     dary. When the data is read and the whole block is passed to
X     gunzip for decompression, gunzip detects that there is extra
X     trailing garbage after the compressed data and emits a warn-
X     ing  by  default.  You  have  to  use  the --quiet option to
X     suppress the warning. This option can be  set  in  the  GZIP
X     environment variable as in:
X         for sh:    GZIP="-q"  tar xfz /dev/rmt/datn
X         for csh:   (setenv GZIP "-q"; tar xfz /dev/rmt/datn)
X
X     In the above example, gzip is invoked implicitly by  the  -z
X     option  of  GNU  tar. Make sure that the same block size (-b
X     option of tar) is used for reading  and  writing  compressed
X     data on tapes.
X
XBUGS
X     The --list option reports incorrect sizes if they  exceed  2
X     gigabytes.  The --list option reports sizes as -1 and crc as
X     ffffffff if the compressed file is on a non seekable media.
END_OF_FILE
if test 13790 -ne `wc -c <'gzip-1.2.2/gzip.doc'`; then
    echo shar: \"'gzip-1.2.2/gzip.doc'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/gzip.doc'
fi
if test -f 'gzip-1.2.2/algorithm.doc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/algorithm.doc'\"
else
echo shar: Extracting \"'gzip-1.2.2/algorithm.doc'\" \(7724 characters\)
sed "s/^X//" >'gzip-1.2.2/algorithm.doc' <<'END_OF_FILE'
X1. Algorithm
X
XThe deflation algorithm used by zip and gzip is a variation of LZ77
X(Lempel-Ziv 1977, see reference below). It finds duplicated strings in
Xthe input data.  The second occurrence of a string is replaced by a
Xpointer to the previous string, in the form of a pair (distance,
Xlength).  Distances are limited to 32K bytes, and lengths are limited
Xto 258 bytes. When a string does not occur anywhere in the previous
X32K bytes, it is emitted as a sequence of literal bytes.  (In this
Xdescription, 'string' must be taken as an arbitrary sequence of bytes,
Xand is not restricted to printable characters.)
X
XLiterals or match lengths are compressed with one Huffman tree, and
Xmatch distances are compressed with another tree. The trees are stored
Xin a compact form at the start of each block. The blocks can have any
Xsize (except that the compressed data for one block must fit in
Xavailable memory). A block is terminated when zip determines that it
Xwould be useful to start another block with fresh trees. (This is
Xsomewhat similar to compress.)
X
XDuplicated strings are found using a hash table. All input strings of
Xlength 3 are inserted in the hash table. A hash index is computed for
Xthe next 3 bytes. If the hash chain for this index is not empty, all
Xstrings in the chain are compared with the current input string, and
Xthe longest match is selected.
X
XThe hash chains are searched starting with the most recent strings, to
Xfavor small distances and thus take advantage of the Huffman encoding.
XThe hash chains are singly linked. There are no deletions from the
Xhash chains, the algorithm simply discards matches that are too old.
X
XTo avoid a worst-case situation, very long hash chains are arbitrarily
Xtruncated at a certain length, determined by a runtime option (zip -1
Xto -9). So zip does not always find the longest possible match but
Xgenerally finds a match which is long enough.
X
Xzip also defers the selection of matches with a lazy evaluation
Xmechanism. After a match of length N has been found, zip searches for a
Xlonger match at the next input byte. If a longer match is found, the
Xprevious match is truncated to a length of one (thus producing a single
Xliteral byte) and the longer match is emitted afterwards.  Otherwise,
Xthe original match is kept, and the next match search is attempted only
XN steps later.
X
XThe lazy match evaluation is also subject to a runtime parameter. If
Xthe current match is long enough, zip reduces the search for a longer
Xmatch, thus speeding up the whole process. If compression ratio is more
Ximportant than speed, zip attempts a complete second search even if
Xthe first match is already long enough.
X
XThe lazy match evaluation is no performed for the fastest compression
Xmodes (speed options -1 to -3). For these fast modes, new strings
Xare inserted in the hash table only when no match was found, or
Xwhen the match is not too long. This degrades the compression ratio
Xbut saves time since there are both fewer insertions and fewer searches.
X
X
X2. gzip file format
X
XThe pkzip format imposes a lot of overhead in various headers, which
Xare useful for an archiver but not necessary when only one file is
Xcompressed. gzip uses a much simpler structure. Numbers are in little
Xendian format, and bit 0 is the least significant bit.
XA gzip file is a sequence of compressed members. Each member has the
Xfollowing structure:
X
X2 bytes  magic header  0x1f, 0x8b (\037 \213)  
X1 byte   compression method (0..7 reserved, 8 = deflate)
X1 byte   flags
X            bit 0 set: file probably ascii text
X            bit 1 set: continuation of multi-part gzip file
X            bit 2 set: extra field present
X            bit 3 set: original file name present
X            bit 4 set: file comment present
X            bit 5 set: file is encrypted
X            bit 6,7:   reserved
X4 bytes  file modification time in Unix format
X1 byte   extra flags (depend on compression method)
X1 byte   operating system on which compression took place
X
X2 bytes  optional part number (second part=1)
X2 bytes  optional extra field length
X? bytes  optional extra field
X? bytes  optional original file name, zero terminated
X? bytes  optional file comment, zero terminated
X12 bytes optional encryption header
X? bytes  compressed data
X4 bytes  crc32
X4 bytes  uncompressed input size modulo 2^32
X
XThe format was designed to allow single pass compression without any
Xbackwards seek, and without a priori knowledge of the uncompressed
Xinput size or the available size on the output media. If input does
Xnot come from a regular disk file, the file modification time is set
Xto the time at which compression started.
X
XThe time stamp is useful mainly when one gzip file is transferred over
Xa network. In this case it would not help to keep ownership
Xattributes. In the local case, the ownership attributes are preserved
Xby gzip when compressing/decompressing the file. A time stamp of zero
Xis ignored.
X
XBit 0 in the flags is only an optional indication, which can be set by
Xa small lookahead in the input data. In case of doubt, the flag is
Xcleared indicating binary data. For systems which have different
Xfile formats for ascii text and binary data, the decompressor can
Xuse the flag to choose the appropriate format.
X
XThe extra field, if present, must consist of one or more subfields,
Xeach with the following format:
X
X  subfield id   : 2 bytes
X  subfield size : 2 bytes  (little-endian format)
X  subfield data
X
XThe subfield id can consist of two letters with some mnemonic value.
XPlease send any such id to jloup@chorus.fr. Ids with a zero second
Xbyte are reserved for future use. The following ids are defined:
X
X  Ap (0x41, 0x70) : Apollo file type information
X
XThe subfield size is the size of the subfield data and does not
Xinclude the id and the size itself. The field 'extra field length' is
Xthe total size of the extra field, including subfield ids and sizes.
X
XIt must be possible to detect the end of the compressed data with any
Xcompression format, regardless of the actual size of the compressed
Xdata. If the compressed data cannot fit in one file (in particular for
Xdiskettes), each part starts with a header as described above, but
Xonly the last part has the crc32 and uncompressed size. A decompressor
Xmay prompt for additional data for multipart compressed files. It is
Xdesirable but not mandatory that multiple parts be extractable
Xindependently so that partial data can be recovered if one of the
Xparts is damaged. This is possible only if no compression state is
Xkept from one part to the other. The compression-type dependent flags
Xcan indicate this.
X
XIf the file being compressed is on a file system with case insensitive
Xnames, the original name field must be forced to lower case. There is
Xno original file name if the data was compressed from standard input.
X
XCompression is always performed, even if the compressed file is
Xslightly larger than the original. The worst case expansion is
Xa few bytes for the gzip file header, plus 5 bytes every 32K block,
Xor an expansion ratio of 0.015% for large files. Note that the actual
Xnumber of used disk blocks almost never increases.
X
XThe encryption is that of zip 1.9. For the encryption check, the
Xlast byte of the decoded encryption header must be zero. The time
Xstamp of an encrypted file might be set to zero to avoid giving a clue
Xabout the construction of the random header.
X
XJean-loup Gailly
Xjloup@chorus.fr
X
XReferences:
X
X[LZ77] Ziv J., Lempel A., "A Universal Algorithm for Sequential Data
XCompression", IEEE Transactions on Information Theory", Vol. 23, No. 3,
Xpp. 337-343.
X
XAPPNOTE.TXT documentation file in PKZIP 1.93a. It is available by
Xftp in ftp.cso.uiuc.edu:/pc/exec-pc/pkz193a.exe [128.174.5.59]
XUse "unzip pkz193a.exe APPNOTE.TXT" to extract.
END_OF_FILE
if test 7724 -ne `wc -c <'gzip-1.2.2/algorithm.doc'`; then
    echo shar: \"'gzip-1.2.2/algorithm.doc'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/algorithm.doc'
fi
if test -f 'gzip-1.2.2/gzip.texi' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/gzip.texi'\"
else
echo shar: Extracting \"'gzip-1.2.2/gzip.texi'\" \(15692 characters\)
sed "s/^X//" >'gzip-1.2.2/gzip.texi' <<'END_OF_FILE'
X\input texinfo @c -*-texinfo-*-
X@c %**start of header
X@setfilename gzip.info
X@settitle Gzip User's Manual
X@finalout
X@setchapternewpage odd
X@c %**end of header
X
X@ifinfo
XThis file documents the the GNU @code{gzip} command for compressing files.
X
XCopyright (C) 1992-1993 Jean-loup Gailly
X
XPermission is granted to make and distribute verbatim copies of
Xthis manual provided the copyright notice and this permission notice
Xare preserved on all copies.
X
X@ignore
XPermission is granted to process this file through TeX and print the
Xresults, provided the printed document carries copying permission
Xnotice identical to this one except for the removal of this paragraph
X(this paragraph not being relevant to the printed manual).
X
X@end ignore
XPermission is granted to copy and distribute modified versions of this
Xmanual under the conditions for verbatim copying, provided that the entire
Xresulting derived work is distributed under the terms of a permission
Xnotice identical to this one.
X
XPermission is granted to copy and distribute translations of this manual
Xinto another language, under the above conditions for modified versions,
Xexcept that this permission notice may be stated in a translation approved
Xby the Foundation.
X@end ifinfo
X
X@titlepage
X@title gzip
X@subtitle The data compression program
X@subtitle Edition 1.2.2, for Gzip Version 1.2.2
X@subtitle June 1993
X@author by Jean-loup Gailly
X
X@page
X@vskip 0pt plus 1filll
XCopyright @copyright{} 1992-1993 Jean-loup Gailly
X
XPermission is granted to make and distribute verbatim copies of
Xthis manual provided the copyright notice and this permission notice
Xare preserved on all copies.
X
XPermission is granted to copy and distribute modified versions of this
Xmanual under the conditions for verbatim copying, provided that the entire
Xresulting derived work is distributed under the terms of a permission
Xnotice identical to this one.
X
XPermission is granted to copy and distribute translations of this manual
Xinto another language, under the above conditions for modified versions,
Xexcept that this permission notice may be stated in a translation approved
Xby the Foundation.
X@end titlepage
X
X@node Top, , , (dir)
X
X@ifinfo
XThis file documents the @code{gzip} command to compress files.
X@end ifinfo
X
X@menu
X* Copying::		How you can copy and share @code{gzip}.
X* Overview::		Preliminary information.
X* Sample::		Sample output from @code{gzip}.
X* Invoking gzip::	How to run @code{gzip}.
X* Advanced usage::	Concatenated files.
X* Environment::		The @code{GZIP} environment variable
X* Tapes::               Using @code{gzip} on tapes.
X* Problems::		Reporting bugs.
X* Concept Index::	Index of concepts.
X@end menu
X
X@node Copying, Overview, , Top
X@include gpl.texinfo
X
X@node Overview, Sample, Copying, Top
X@chapter Overview
X@cindex overview
X
X@code{gzip} reduces the size of the named files using Lempel-Ziv coding
X(LZ77).  Whenever possible, each file is replaced by one with the
Xextension @samp{.gz}, while keeping the same ownership modes, access and
Xmodification times.  (The default extension is @samp{-gz} for VMS, @samp{z}
Xfor MSDOS, OS/2 FAT and Atari.)  If no files are specified, the standard
Xinput is compressed to the standard output.  @code{gzip} will only
Xattempt to compress regular files.  In particular, it will ignore
Xsymbolic links.
X
XIf the new file name is too long for its file system, @code{gzip}
Xtruncates it and keeps the original file name in the compressed file.
X@code{gzip} attempts to truncate only the parts of the file name longer
Xthan 3 characters.  (A part is delimited by dots.) If the name consists
Xof small parts only, the longest parts are truncated. For example, if
Xfile names are limited to 14 characters, gzip.msdos.exe is compressed to
Xgzi.msd.exe.gz.  Names are not truncated on systems which do not have a
Xlimit on file name length.
X
XCompressed files can be restored to their original form using @samp{gzip -d}
Xor @code{gunzip} or @code{zcat}.  If the original name saved in the
Xcompressed file is not suitable for its file system, a new name is
Xconstructed from the original one to make it legal.
X
X@code{gunzip} takes a list of files on its command line and replaces
Xeach file whose name ends with @samp{.gz}, @samp{.z}, @samp{.Z},
X@samp{-gz}, @samp{-z} or @samp{_z} and which begins with the correct
Xmagic number with an uncompressed file without the original extension.
X@code{gunzip} also recognizes the special extensions @samp{.tgz} and
X@samp{.taz} as shorthands for @samp{.tar.gz} and @samp{.tar.Z}
Xrespectively. When compressing, @code{gzip} uses the @samp{.tgz}
Xextension if necessary instead of truncating a file with a @samp{.tar}
Xextension.
X
X@code{gunzip} can currently decompress files created by @code{gzip},
X@code{zip}, @code{compress} or @code{pack}. The detection of the input
Xformat is automatic.  When using the first two formats, @code{gunzip}
Xchecks a 32 bit CRC (cyclic redundancy check). For @code{pack},
X@code{gunzip} checks the uncompressed length. The @code{compress} format
Xwas not designed to allow consistency checks. However @code{gunzip} is
Xsometimes able to detect a bad @samp{.Z} file. If you get an error when
Xuncompressing a @samp{.Z} file, do not assume that the @samp{.Z} file is
Xcorrect simply because the standard @code{uncompress} does not complain.
XThis generally means that the standard @code{uncompress} does not check
Xits input, and happily generates garbage output.  The SCO @samp{compress
X-H} format (@code{lzh} compression method) does not include a CRC but
Xalso allows some consistency checks.
X
XFiles created by @code{zip} can be uncompressed by @code{gzip} only if
Xthey have a single member compressed with the 'deflation' method. This
Xfeature is only intended to help conversion of @code{tar.zip} files to
Xthe @code{tar.gz} format. To extract @code{zip} files with several
Xmembers, use @code{unzip} instead of @code{gunzip}.
X
X@code{zcat} is identical to @samp{gunzip -c}.  @code{zcat}
Xuncompresses either a list of files on the command line or its standard
Xinput and writes the uncompressed data on standard output.  @code{zcat}
Xwill uncompress files that have the correct magic number whether they
Xhave a @samp{.gz} suffix or not.
X
X@code{gzip} uses the Lempel-Ziv algorithm used in @code{zip} and PKZIP.
XThe amount of compression obtained depends on the size of the input and
Xthe distribution of common substrings.  Typically, text such as source
Xcode or English is reduced by 60-70%.  Compression is generally much
Xbetter than that achieved by LZW (as used in @code{compress}), Huffman
Xcoding (as used in @code{pack}), or adaptive Huffman coding
X(@code{compact}).
X
XCompression is always performed, even if the compressed file is slightly
Xlarger than the original. The worst case expansion is a few bytes for
Xthe @code{gzip} file header, plus 5 bytes every 32K block, or an expansion
Xratio of 0.015% for large files. Note that the actual number of used
Xdisk blocks almost never increases. @code{gzip} preserves the mode,
Xownership and timestamps of files when compressing or decompressing.
X
X@node Sample, Invoking gzip, Overview, Top
X@chapter Sample Output
X@cindex sample
X
XHere are some realistic examples of running @code{gzip}.
X
XThis is the output of the command @samp{gzip}:
X
X@example
Xusage: gzip [-cdfhLrv19] [file ...]
XFor more help, type: gzip -h
X@end example
X
XThis is the output of the command @samp{gzip -h}:
X
X@example
Xgzip 1.2.2 (17 Jun 93)
Xusage: gzip [-cdfhlLnrtvV19] [-S suffix] [file ...]
X -c --stdout      write on standard output, keep original files unchanged
X -d --decompress  decompress
X -f --force       force overwrite of output file and compress links
X -h --help        give this help
X -l --list        list .gz file contents
X -L --license     display software license
X -n --no-name     do not save or restore the original name
X -q --quiet       suppress all warnings
X -r --recurse     recurse through directories
X -S .suf  --suffix .suf     use suffix .suf instead of .gz
X -t --test        test compressed file integrity
X -v --verbose     verbose mode
X -V --version     display version number
X -1 --fast        compress faster
X -9 --best        compress better
X file...          files to (de)compress. If none given, use standard input.
X@end example
X
XThis is the output of the command @samp{gzip -v texinfo.tex}:
X
X@example
Xtexinfo.tex:             71.6% -- replaced with texinfo.tex.gz
X@end example
X
X@node Invoking gzip, Advanced usage, Sample, Top
X@chapter Invoking @code{gzip}
X@cindex invoking
X@cindex options
X
XThe format for running the @code{gzip} program is:
X
X@example
Xgzip @var{option} @dots{}
X@end example
X
X@code{gzip} supports the following options:
X
X@table @samp
X@item --stdout
X@itemx --to-stdout
X@itemx -c
XWrite output on standard output; keep original files unchanged.
XIf there are several input files, the output consists of a sequence of
Xindependently compressed members. To obtain better compression,
Xconcatenate all input files before compressing them.
X
X@item --decompress
X@itemx --uncompress
X@itemx -d
XDecompress.
X
X@item --force
X@itemx -f
XForce compression or decompression even if the file has multiple links
Xor the corresponding file already exists, or if the compressed data
Xis read from or written to a terminal. If the input data is not in
Xa format recognized by @code{gzip}, and if the option --stdout is also
Xgiven, copy the input data without change to the standard ouput: let
X@code{zcat} behave as @code{cat}. If @samp{-f} is not given, and
Xwhen not running in the background, @code{gzip} prompts to verify
Xwhether an existing file should be overwritten.
X
X@item --help
X@itemx -h
XPrint an informative help message describing the options then quit.
X
X@item --list
X@itemx -l
XFor each compressed file, list the following fields:
X
X@example
Xcompressed size: size of the compressed file
Xuncompressed size: size of the uncompressed file
Xratio: compression ratio (0.0% if unknown)
Xuncompressed_name: name of the uncompressed file
X@end example
X
XThe uncompressed size is given as @samp{-1} for files not in @code{gzip}
Xformat, such as compressed @samp{.Z} files. To get the uncompressed size for
Xsuch a file, you can use:
X
X@example
Xzcat file.Z | wc -c
X@end example
X
XIn combination with the --verbose option, the following fields are also
Xdisplayed:
X
X@example
Xmethod: compression method (deflate,compress,lzh,pack)
Xcrc: the 32-bit CRC of the uncompressed data
Xdate & time: time stamp for the uncompressed file
X@end example
X
XThe crc is given as ffffffff for a file not in gzip format.
X
XWith --verbose, the size totals and compression ratio for all files
Xis also displayed, unless some sizes are unknown. With --quiet,
Xthe title and totals lines are not displayed.
X
X@item --license
X@itemx -L
XDisplay the @code{gzip} license then quit.
X
X@item --no-name
X@itemx -n
XWhen compressing, do not save the original file name by default. (The
Xoriginal name is always saved if the name had to be truncated.) When
Xdecompressing, do not restore the original file name if present: remove
Xonly the @code{gzip} suffix from the compressed file name.
X
X@item --quiet
X@itemx -q
XSuppress all warning messages.
X
X@item --recurse
X@itemx -r
XTravel the directory structure recursively. If any of the file names
Xspecified on the command line are directories, @code{gzip} will descend
Xinto the directory and compress all the files it finds there (or
Xdecompress them in the case of @code{gunzip}).
X
X@item --suffix @var{suf}
X@itemx -S @var{suf}
XUse suffix @samp{@var{suf}} instead of @samp{.gz}. Any suffix can be
Xgiven, but suffixes other than @samp{.z} and @samp{.gz} should be
Xavoided to avoid confusion when files are transferred to other systems.
XA null suffix forces gunzip to try decompression on all given files
Xregardless of suffix, as in:
X
X@example
Xgunzip -S "" *        (*.* for MSDOS)
X@end example
X
XPrevious versions of gzip used the @samp{.z} suffix. This was changed to
Xavoid a conflict with @code{pack}.
X
X@item --test
X@itemx -t
XTest. Check the compressed file integrity.
X
X@item --verbose
X@itemx -v
XVerbose. Display the name and percentage reduction for each file compressed.
X
X@item --version
X@itemx -V
XVersion. Display the version number and compilation options, then quit.
X
X@item --fast
X@itemx --best
X@itemx -@var{n}
XRegulate the speed of compression using the specified digit @var{n},
Xwhere @samp{-1} or @samp{--fast} indicates the fastest compression
Xmethod (less compression) and @samp{--best} or @samp{-9} indicates the
Xslowest compression method (optimal compression).  The default
Xcompression level is @samp{-6} (that is, biased towards high compression at
Xexpense of speed).
X@end table
X
X@node Advanced usage, Environment, Invoking gzip, Top
X@chapter Advanced usage
X@cindex concatenated files
X
XMultiple compressed files can be concatenated. In this case,
X@code{gunzip} will extract all members at once. If one member is
Xdamaged, other members might still be recovered after removal of the
Xdamaged member. Better compression can be usually obtained if all
Xmembers are decompressed and then recompressed in a single step.
X
XThis is an example of concatenating @code{gzip} files:
X
X@example
Xgzip -c file1  > foo.gz
Xgzip -c file2 >> foo.gz
X@end example
X
XThen
X
X@example
Xgunzip -c foo
X@end example
X
Xis equivalent to
X
X@example
Xcat file1 file2
X@end example
X
XIn case of damage to one member of a @samp{.gz} file, other members can
Xstill be recovered (if the damaged member is removed). However,
Xyou can get better compression by compressing all members at once:
X
X@example
Xcat file1 file2 | gzip > foo.gz
X@end example
X
Xcompresses better than
X
X@example
Xgzip -c file1 file2 > foo.gz
X@end example
X
XIf you want to recompress concatenated files to get better compression, do:
X
X@example
Xzcat old.gz | gzip > new.gz
X@end example
X
X@node Environment, Tapes, Advanced usage, Top
X@chapter Environment
X@cindex Environment
X
XThe environment variable @code{GZIP} can hold a set of default options for
X@code{gzip}.  These options are interpreted first and can be overwritten by
Xexplicit command line parameters.  For example:
X
X@example
Xfor sh:    GZIP="-8 -v"; export GZIP
Xfor csh:   setenv GZIP "-8 -v"
Xfor MSDOS: set GZIP=-8 -v
X@end example
X
XOn Vax/VMS, the name of the environment variable is @code{GZIP_OPT}, to
Xavoid a conflict with the symbol set for invocation of the program.
X
X@node Tapes, Problems, Environment, Top
X@chapter Using @code{gzip} on tapes
X@cindex tapes
X
XWhen writing compressed data to a tape, it is generally necessary to pad
Xthe output with zeroes up to a block boundary. When the data is read and
Xthe whole block is passed to @code{gunzip} for decompression,
X@code{gunzip} detects that there is extra trailing garbage after the
Xcompressed data and emits a warning by default. You have to use the
X@samp{--quiet} option to suppress the warning. This option can be set in the
X@code{GZIP} environment variable, as in:
X
X@example
Xfor sh:    GZIP="-q"  tar xfz /dev/rmt/datn
Xfor csh:   (setenv GZIP "-q"; tar xfz /dev/rmt/datn)
X@end example
X
XMake sure that the same block size (@samp{-b} option of @code{tar}) is used for
Xreading and writing compressed data on tapes.
X(This example assumes you are using the GNU version of @code{tar}.)
X
X@node Problems, Concept Index, Tapes, Top
X@chapter Reporting Bugs
X@cindex bugs
X
XIf you find a bug in @code{gzip}, please send electronic mail to
X@w{@samp{jloup@@chorus.fr}} or, if this fails, to
X@w{@samp{bug-gnu-utils@@prep.ai.mit.edu}}.  Include the version number,
Xwhich you can find by running @w{@samp{gzip -V}}.  Also include in your
Xmessage the hardware and operating system, the compiler used to compile
X@code{gzip},
Xa description of the bug behavior, and the input to @code{gzip} that triggered
Xthe bug.@refill
X
X@node Concept Index, , Problems, Top
X@unnumbered Concept Index
X
X@printindex cp
X
X@contents
X@bye
END_OF_FILE
if test 15692 -ne `wc -c <'gzip-1.2.2/gzip.texi'`; then
    echo shar: \"'gzip-1.2.2/gzip.texi'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/gzip.texi'
fi
if test -f 'gzip-1.2.2/texinfo.tex' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/texinfo.tex'\"
else
echo shar: Extracting \"'gzip-1.2.2/texinfo.tex'\" \(108872 characters\)
sed "s/^X//" >'gzip-1.2.2/texinfo.tex' <<'END_OF_FILE'
X%% TeX macros to handle texinfo files
X
X%   Copyright (C) 1985, 1986, 1988, 1990, 1991 Free Software Foundation, Inc.
X
X%This texinfo.tex file is free software; you can redistribute it and/or
X%modify it under the terms of the GNU General Public License as
X%published by the Free Software Foundation; either version 2, or (at
X%your option) any later version.
X
X%This texinfo.tex file is distributed in the hope that it will be
X%useful, but WITHOUT ANY WARRANTY; without even the implied warranty
X%of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
X%General Public License for more details.
X
X%You should have received a copy of the GNU General Public License
X%along with this texinfo.tex file; see the file COPYING.  If not, write
X%to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139,
X%USA.
X
X
X%In other words, you are welcome to use, share and improve this program.
X%You are forbidden to forbid anyone else to use, share and improve
X%what you give them.   Help stamp out software-hoarding!
X
X\def\texinfoversion{2.73}
X\message{Loading texinfo package [Version \texinfoversion]:}
X\message{}
X
X% Print the version number if in a .fmt file.
X\everyjob{\message{[Texinfo version \texinfoversion]}\message{}}
X
X% Save some parts of plain tex whose names we will redefine.
X
X\let\ptexlbrace=\{
X\let\ptexrbrace=\}
X\let\ptexdots=\dots
X\let\ptexdot=\.
X\let\ptexstar=\*
X\let\ptexend=\end
X\let\ptexbullet=\bullet
X\let\ptexb=\b
X\let\ptexc=\c
X\let\ptexi=\i
X\let\ptext=\t
X\let\ptexl=\l
X\let\ptexL=\L
X
X\def\tie{\penalty 10000\ }     % Save plain tex definition of ~.
X
X\message{Basics,}
X\chardef\other=12
X
X% If this character appears in an error message or help string, it
X% starts a new line in the output.
X\newlinechar = `^^J
X
X\hyphenation{ap-pen-dix}
X\hyphenation{mini-buf-fer mini-buf-fers}
X\hyphenation{eshell}
X
X% Margin to add to right of even pages, to left of odd pages.
X\newdimen \bindingoffset  \bindingoffset=0pt
X\newdimen \normaloffset   \normaloffset=\hoffset
X\newdimen\pagewidth \newdimen\pageheight
X\pagewidth=\hsize \pageheight=\vsize
X
X% Sometimes it is convenient to have everything in the transcript file
X% and nothing on the terminal.  We don't just call \tracingall here,
X% since that produces some useless output on the terminal.
X%
X\def\gloggingall{\begingroup \globaldefs = 1 \loggingall \endgroup}%
X\def\loggingall{\tracingcommands2 \tracingstats2 
X   \tracingpages1 \tracingoutput1 \tracinglostchars1 
X   \tracingmacros2 \tracingparagraphs1 \tracingrestores1 
X   \showboxbreadth\maxdimen\showboxdepth\maxdimen
X}%
X
X%---------------------Begin change-----------------------
X%
X%%%% For @cropmarks command.
X% Dimensions to add cropmarks at corners Added by P. A. MacKay, 12 Nov. 1986
X%
X\newdimen\cornerlong \newdimen\cornerthick
X\newdimen \topandbottommargin
X\newdimen \outerhsize \newdimen \outervsize
X\cornerlong=1pc\cornerthick=.3pt	% These set size of cropmarks
X\outerhsize=7in
X%\outervsize=9.5in
X% Alternative @smallbook page size is 9.25in
X\outervsize=9.25in
X\topandbottommargin=.75in
X%
X%---------------------End change-----------------------
X
X% \onepageout takes a vbox as an argument.  Note that \pagecontents
X% does insertions itself, but you have to call it yourself.
X\chardef\PAGE=255  \output={\onepageout{\pagecontents\PAGE}}
X\def\onepageout#1{\hoffset=\normaloffset
X\ifodd\pageno  \advance\hoffset by \bindingoffset
X\else \advance\hoffset by -\bindingoffset\fi
X{\escapechar=`\\\relax % makes sure backslash is used in output files.
X\shipout\vbox{{\let\hsize=\pagewidth \makeheadline} \pagebody{#1}%
X{\let\hsize=\pagewidth \makefootline}}}%
X\advancepageno \ifnum\outputpenalty>-20000 \else\dosupereject\fi}
X
X%%%% For @cropmarks command %%%%
X
X% Here is a modification of the main output routine for Near East Publications
X% This provides right-angle cropmarks at all four corners.
X% The contents of the page are centerlined into the cropmarks,
X% and any desired binding offset is added as an \hskip on either
X% site of the centerlined box.  (P. A. MacKay, 12 November, 1986)
X%
X\def\croppageout#1{\hoffset=0pt % make sure this doesn't mess things up
X		 \shipout
X		 \vbox to \outervsize{\hsize=\outerhsize
X                 \vbox{\line{\ewtop\hfill\ewtop}}
X                 \nointerlineskip
X                 \line{\vbox{\moveleft\cornerthick\nstop}
X                       \hfill
X                       \vbox{\moveright\cornerthick\nstop}}
X                 \vskip \topandbottommargin
X                 \centerline{\ifodd\pageno\hskip\bindingoffset\fi
X			\vbox{
X			{\let\hsize=\pagewidth \makeheadline}
X			\pagebody{#1}
X			{\let\hsize=\pagewidth \makefootline}}
X			\ifodd\pageno\else\hskip\bindingoffset\fi}
X		 \vskip \topandbottommargin plus1fill minus1fill
X                 \boxmaxdepth\cornerthick
X                 \line{\vbox{\moveleft\cornerthick\nsbot}
X                       \hfill
X                       \vbox{\moveright\cornerthick\nsbot}}
X                 \nointerlineskip
X                 \vbox{\line{\ewbot\hfill\ewbot}}
X	}
X  \advancepageno 
X  \ifnum\outputpenalty>-20000 \else\dosupereject\fi}
X%
X% Do @cropmarks to get crop marks
X\def\cropmarks{\let\onepageout=\croppageout }
X
X\def\pagebody#1{\vbox to\pageheight{\boxmaxdepth=\maxdepth #1}}
X{\catcode`\@ =11
X\gdef\pagecontents#1{\ifvoid\topins\else\unvbox\topins\fi
X\dimen@=\dp#1 \unvbox#1
X\ifvoid\footins\else\vskip\skip\footins\footnoterule \unvbox\footins\fi
X\ifr@ggedbottom \kern-\dimen@ \vfil \fi}
X}
X
X%
X% Here are the rules for the cropmarks.  Note that they are
X% offset so that the space between them is truly \outerhsize or \outervsize
X% (P. A. MacKay, 12 November, 1986)
X%
X\def\ewtop{\vrule height\cornerthick depth0pt width\cornerlong}
X\def\nstop{\vbox
X  {\hrule height\cornerthick depth\cornerlong width\cornerthick}}
X\def\ewbot{\vrule height0pt depth\cornerthick width\cornerlong}
X\def\nsbot{\vbox
X  {\hrule height\cornerlong depth\cornerthick width\cornerthick}}
X
X% Parse an argument, then pass it to #1.
X% The argument can be delimited with [...] or with "..." or braces
X% or it can be a whole line.
X% #1 should be a macro which expects
X% an ordinary undelimited TeX argument.
X
X\def\parsearg #1{\let\next=#1\begingroup\obeylines\futurelet\temp\parseargx}
X
X\def\parseargx{%
X\ifx \obeyedspace\temp \aftergroup\parseargdiscardspace \else%
X\aftergroup \parseargline %
X\fi \endgroup}
X
X{\obeyspaces %
X\gdef\parseargdiscardspace {\begingroup\obeylines\futurelet\temp\parseargx}}
X
X\gdef\obeyedspace{\ }
X
X\def\parseargline{\begingroup \obeylines \parsearglinex}
X{\obeylines %
X\gdef\parsearglinex #1^^M{\endgroup \next {#1}}}
X
X\def\flushcr{\ifx\par\lisppar \def\next##1{}\else \let\next=\relax \fi \next}
X
X%% These are used to keep @begin/@end levels from running away
X%% Call \inENV within environments (after a \begingroup)
X\newif\ifENV \ENVfalse \def\inENV{\ifENV\relax\else\ENVtrue\fi}
X\def\ENVcheck{%
X\ifENV\errmessage{Still within an environment.  Type Return to continue.}
X\endgroup\fi} % This is not perfect, but it should reduce lossage
X
X% @begin foo  is the same as @foo, for now.
X\newhelp\EMsimple{Type <Return> to continue}
X
X\outer\def\begin{\parsearg\beginxxx}
X
X\def\beginxxx #1{%
X\expandafter\ifx\csname #1\endcsname\relax
X{\errhelp=\EMsimple \errmessage{Undefined command @begin #1}}\else
X\csname #1\endcsname\fi}
X
X%% @end foo executes the definition of \Efoo.
X%% foo can be delimited by doublequotes or brackets.
X
X\def\end{\parsearg\endxxx}
X
X\def\endxxx #1{%
X\expandafter\ifx\csname E#1\endcsname\relax
X\expandafter\ifx\csname #1\endcsname\relax
X\errmessage{Undefined command @end #1}\else
X\errorE{#1}\fi\fi
X\csname E#1\endcsname}
X\def\errorE#1{
X{\errhelp=\EMsimple \errmessage{@end #1 not within #1 environment}}}
X
X% Single-spacing is done by various environments.
X
X\newskip\singlespaceskip \singlespaceskip = \baselineskip
X\def\singlespace{%
X{\advance \baselineskip by -\singlespaceskip
X\kern \baselineskip}%
X\baselineskip=\singlespaceskip
X}
X
X%% Simple single-character @ commands
X
X% @@ prints an @
X% Kludge this until the fonts are right (grr).
X\def\@{{\tt \char '100}}
X
X% Define @` and @' to be the same as ` and '
X% but suppressing ligatures.
X\def\`{{`}}
X\def\'{{'}}
X
X% Used to generate quoted braces.
X
X\def\mylbrace {{\tt \char '173}}
X\def\myrbrace {{\tt \char '175}}
X\let\{=\mylbrace
X\let\}=\myrbrace
X
X% @: forces normal size whitespace following.
X\def\:{\spacefactor=1000 }
X
X% @* forces a line break.
X\def\*{\hfil\break\hbox{}\ignorespaces}
X
X% @. is an end-of-sentence period.
X\def\.{.\spacefactor=3000 }
X
X% @w prevents a word break.  Without the \leavevmode, @w at the
X% beginning of a paragraph, when TeX is still in vertical mode, would
X% produce a whole line of output instead of starting the paragraph.
X\def\w#1{\leavevmode\hbox{#1}}
X
X% @group ... @end group forces ... to be all on one page, by enclosing
X% it in a TeX vbox.  We use \vtop instead of \vbox to construct the box
X% to keep its height that of a normal line.  According to the rules for
X% \topskip (p.114 of the TeXbook), the glue inserted is
X% max (\topskip - \ht (first item), 0).  If that height is large,
X% therefore, no glue is inserted, and the space between the headline and
X% the text is small, which looks bad.
X% 
X\def\group{\begingroup
X  \ifnum\catcode13=\active \else
X    \errhelp = \groupinvalidhelp
X    \errmessage{@group invalid in context where filling is enabled}%
X  \fi
X  \def\Egroup{\egroup\endgroup}%
X  \vtop\bgroup
X}
X%
X% TeX puts in an \escapechar (i.e., `@') at the beginning of the help
X% message, so this ends up printing `@group can only ...'.
X% 
X\newhelp\groupinvalidhelp{%
Xgroup can only be used in environments such as @example,^^J%
Xwhere each line of input produces a line of output.}
X
X% @need space-in-mils
X% forces a page break if there is not space-in-mils remaining.
X
X\newdimen\mil  \mil=0.001in
X
X\def\need{\parsearg\needx}
X
X% Old definition--didn't work.
X%\def\needx #1{\par %
X%% This method tries to make TeX break the page naturally
X%% if the depth of the box does not fit.
X%{\baselineskip=0pt%
X%\vtop to #1\mil{\vfil}\kern -#1\mil\penalty 10000
X%\prevdepth=-1000pt
X%}}
X
X\def\needx#1{%
X  % Go into vertical mode, so we don't make a big box in the middle of a
X  % paragraph.
X  \par
X  %
X  % Don't add any leading before our big empty box, but allow a page
X  % break, since the best break might be right here.
X  \allowbreak
X  \nointerlineskip
X  \vtop to #1\mil{\vfil}%
X  % 
X  % TeX does not even consider page breaks if a penalty added to the
X  % main vertical list is 10000 or more.  But in order to see if the
X  % empty box we just added fits on the page, we must make it consider
X  % page breaks.  On the other hand, we don't want to actually break the
X  % page after the empty box.  So we use a penalty of 9999.
X  % 
X  % There is an extremely small chance that TeX will actually break the
X  % page at this \penalty, if there are no other feasible breakpoints in
X  % sight.  (If the user is using lots of big @group commands, which
X  % almost-but-not-quite fill up a page, TeX will have a hard time doing
X  % good page breaking, for example.)  However, I could not construct an
X  % example where a page broke at this \penalty; if it happens in a real
X  % document, then we can reconsider our strategy.
X  \penalty9999
X  %
X  % Back up by the size of the box, whether we did a page break or not.
X  \kern -#1\mil
X  %
X  % Do not allow a page break right after this kern.
X  \nobreak
X}
X
X% @br   forces paragraph break
X
X\let\br = \par
X
X% @dots{}  output some dots
X
X\def\dots{$\ldots$}
X
X% @page    forces the start of a new page
X
X\def\page{\par\vfill\supereject}
X
X% @exdent text....
X% outputs text on separate line in roman font, starting at standard page margin
X
X% This records the amount of indent in the innermost environment.
X% That's how much \exdent should take out.
X\newskip\exdentamount
X
X% This defn is used inside fill environments such as @defun.
X\def\exdent{\parsearg\exdentyyy}
X\def\exdentyyy #1{{\hfil\break\hbox{\kern -\exdentamount{\rm#1}}\hfil\break}}
X
X% This defn is used inside nofill environments such as @example.
X\def\nofillexdent{\parsearg\nofillexdentyyy}
X\def\nofillexdentyyy #1{{\advance \leftskip by -\exdentamount
X\leftline{\hskip\leftskip{\rm#1}}}}
X
X%\hbox{{\rm#1}}\hfil\break}}
X
X% @include file    insert text of that file as input.
X
X\def\include{\parsearg\includezzz}
X\def\includezzz #1{{\def\thisfile{#1}\input #1
X}}
X
X\def\thisfile{}
X
X% @center line   outputs that line, centered
X
X\def\center{\parsearg\centerzzz}
X\def\centerzzz #1{{\advance\hsize by -\leftskip
X\advance\hsize by -\rightskip
X\centerline{#1}}}
X
X% @sp n   outputs n lines of vertical space
X
X\def\sp{\parsearg\spxxx}
X\def\spxxx #1{\par \vskip #1\baselineskip}
X
X% @comment ...line which is ignored...
X% @c is the same as @comment
X% @ignore ... @end ignore  is another way to write a comment
X
X\def\comment{\catcode 64=\other \catcode 123=\other \catcode 125=\other%
X\parsearg \commentxxx}
X
X\def\commentxxx #1{\catcode 64=0 \catcode 123=1 \catcode 125=2 }
X
X\let\c=\comment
X
X% Prevent errors for section commands.
X% Used in @ignore and in failing conditionals.
X\def\ignoresections{%
X\let\chapter=\relax
X\let\unnumbered=\relax
X\let\top=\relax
X\let\unnumberedsec=\relax
X\let\unnumberedsection=\relax
X\let\unnumberedsubsec=\relax
X\let\unnumberedsubsection=\relax
X\let\unnumberedsubsubsec=\relax
X\let\unnumberedsubsubsection=\relax
X\let\section=\relax
X\let\subsec=\relax
X\let\subsubsec=\relax
X\let\subsection=\relax
X\let\subsubsection=\relax
X\let\appendix=\relax
X\let\appendixsec=\relax
X\let\appendixsection=\relax
X\let\appendixsubsec=\relax
X\let\appendixsubsection=\relax
X\let\appendixsubsubsec=\relax
X\let\appendixsubsubsection=\relax
X\let\contents=\relax
X\let\smallbook=\relax
X\let\titlepage=\relax
X}
X
X\def\ignore{\begingroup\ignoresections
X% Make sure that spaces turn into tokens that match what \ignorexxx wants.
X\catcode32=10
X\ignorexxx}
X\long\def\ignorexxx #1\end ignore{\endgroup\ignorespaces}
X
X\def\direntry{\begingroup\direntryxxx}
X\long\def\direntryxxx #1\end direntry{\endgroup\ignorespaces}
X
X% Conditionals to test whether a flag is set.
X
X\def\ifset{\begingroup\ignoresections\parsearg\ifsetxxx}
X
X\def\ifsetxxx #1{\endgroup
X\expandafter\ifx\csname IF#1\endcsname\relax \let\temp=\ifsetfail
X\else \let\temp=\relax \fi
X\temp}
X\def\Eifset{}
X\def\ifsetfail{\begingroup\ignoresections\ifsetfailxxx}
X\long\def\ifsetfailxxx #1\end ifset{\endgroup\ignorespaces}
X
X\def\ifclear{\begingroup\ignoresections\parsearg\ifclearxxx}
X
X\def\ifclearxxx #1{\endgroup
X\expandafter\ifx\csname IF#1\endcsname\relax \let\temp=\relax
X\else \let\temp=\ifclearfail \fi
X\temp}
X\def\Eifclear{}
X\def\ifclearfail{\begingroup\ignoresections\ifclearfailxxx}
X\long\def\ifclearfailxxx #1\end ifclear{\endgroup\ignorespaces}
X
X% @set foo     to set the flag named foo.
X% @clear foo   to clear the flag named foo.
X\def\set{\parsearg\setxxx}
X\def\setxxx #1{
X\expandafter\let\csname IF#1\endcsname=\set}
X
X\def\clear{\parsearg\clearxxx}
X\def\clearxxx #1{
X\expandafter\let\csname IF#1\endcsname=\relax}
X
X% Some texinfo constructs that are trivial in tex
X
X\def\iftex{}
X\def\Eiftex{}
X\def\ifinfo{\begingroup\ignoresections\ifinfoxxx}
X\long\def\ifinfoxxx #1\end ifinfo{\endgroup\ignorespaces}
X
X\long\def\menu #1\end menu{}
X\def\asis#1{#1}
X
X% @math means output in math mode.
X% We don't use $'s directly in the definition of \math because control
X% sequences like \math are expanded when the toc file is written.  Then,
X% we read the toc file back, the $'s will be normal characters (as they
X% should be, according to the definition of Texinfo).  So we must use a
X% control sequence to switch into and out of math mode.
X% 
X% This isn't quite enough for @math to work properly in indices, but it
X% seems unlikely it will ever be needed there.
X% 
X\let\implicitmath = $
X\def\math#1{\implicitmath #1\implicitmath}
X
X\def\node{\ENVcheck\parsearg\nodezzz}
X\def\nodezzz#1{\nodexxx [#1,]}
X\def\nodexxx[#1,#2]{\gdef\lastnode{#1}}
X\let\lastnode=\relax
X
X\def\donoderef{\ifx\lastnode\relax\else
X\expandafter\expandafter\expandafter\setref{\lastnode}\fi
X\let\lastnode=\relax}
X
X\def\unnumbnoderef{\ifx\lastnode\relax\else
X\expandafter\expandafter\expandafter\unnumbsetref{\lastnode}\fi
X\let\lastnode=\relax}
X
X\def\appendixnoderef{\ifx\lastnode\relax\else
X\expandafter\expandafter\expandafter\appendixsetref{\lastnode}\fi
X\let\lastnode=\relax}
X
X\let\refill=\relax
X  
X% @setfilename is done at the beginning of every texinfo file.
X% So open here the files we need to have open while reading the input.
X% This makes it possible to make a .fmt file for texinfo.
X\def\setfilename{%
X   \readauxfile
X   \opencontents
X   \openindices
X   \fixbackslash  % Turn off hack to swallow `\input texinfo'.
X   \global\let\setfilename=\comment % Ignore extra @setfilename cmds.
X   \comment % Ignore the actual filename.
X}
X
X\outer\def\bye{\pagealignmacro\tracingstats=1\ptexend}
X
X\def\inforef #1{\inforefzzz #1,,,,**}
X\def\inforefzzz #1,#2,#3,#4**{See Info file \file{\losespace#3{}},
X  node \samp{\losespace#1{}}}
X\def\losespace #1{#1}
X
X\message{fonts,}
X
X% Font-change commands.
X
X% Texinfo supports the sans serif font style, which plain TeX does not.
X% So we set up a \sf analogous to plain's \rm, etc.
X\newfam\sffam
X\def\sf{\fam=\sffam \tensf}
X\let\li = \sf % Sometimes we call it \li, not \sf.
X
X%% Try out Computer Modern fonts at \magstephalf
X\let\mainmagstep=\magstephalf
X
X\ifx\bigger\relax
X\let\mainmagstep=\magstep1
X\font\textrm=cmr12
X\font\texttt=cmtt12
X\else
X\font\textrm=cmr10 scaled \mainmagstep
X\font\texttt=cmtt10 scaled \mainmagstep
X\fi
X% Instead of cmb10, you many want to use cmbx10.
X% cmbx10 is a prettier font on its own, but cmb10
X% looks better when embedded in a line with cmr10.
X\font\textbf=cmb10 scaled \mainmagstep 
X\font\textit=cmti10 scaled \mainmagstep
X\font\textsl=cmsl10 scaled \mainmagstep
X\font\textsf=cmss10 scaled \mainmagstep
X\font\textsc=cmcsc10 scaled \mainmagstep
X\font\texti=cmmi10 scaled \mainmagstep
X\font\textsy=cmsy10 scaled \mainmagstep
X
X% A few fonts for @defun, etc.
X\font\defbf=cmbx10 scaled \magstep1 %was 1314
X\font\deftt=cmtt10 scaled \magstep1
X\def\df{\let\tentt=\deftt \let\tenbf = \defbf \bf}
X
X% Fonts for indices and small examples.
X% We actually use the slanted font rather than the italic, 
X% because texinfo normally uses the slanted fonts for that.
X% Do not make many font distinctions in general in the index, since they
X% aren't very useful.
X\font\ninett=cmtt9
X\font\indrm=cmr9
X\font\indit=cmsl9
X\let\indsl=\indit
X\let\indtt=\ninett
X\let\indsf=\indrm
X\let\indbf=\indrm
X\let\indsc=\indrm
X\font\indi=cmmi9
X\font\indsy=cmsy9
X
X% Fonts for headings
X\font\chaprm=cmbx12 scaled \magstep2
X\font\chapit=cmti12 scaled \magstep2
X\font\chapsl=cmsl12 scaled \magstep2
X\font\chaptt=cmtt12 scaled \magstep2
X\font\chapsf=cmss12 scaled \magstep2
X\let\chapbf=\chaprm
X\font\chapsc=cmcsc10 scaled\magstep3
X\font\chapi=cmmi12 scaled \magstep2
X\font\chapsy=cmsy10 scaled \magstep3
X
X\font\secrm=cmbx12 scaled \magstep1
X\font\secit=cmti12 scaled \magstep1
X\font\secsl=cmsl12 scaled \magstep1
X\font\sectt=cmtt12 scaled \magstep1
X\font\secsf=cmss12 scaled \magstep1
X\font\secbf=cmbx12 scaled \magstep1
X\font\secsc=cmcsc10 scaled\magstep2
X\font\seci=cmmi12 scaled \magstep1
X\font\secsy=cmsy10 scaled \magstep2
X
X% \font\ssecrm=cmbx10 scaled \magstep1    % This size an font looked bad.
X% \font\ssecit=cmti10 scaled \magstep1    % The letters were too crowded.
X% \font\ssecsl=cmsl10 scaled \magstep1
X% \font\ssectt=cmtt10 scaled \magstep1
X% \font\ssecsf=cmss10 scaled \magstep1
X
X%\font\ssecrm=cmb10 scaled 1315	% Note the use of cmb rather than cmbx.
X%\font\ssecit=cmti10 scaled 1315	% Also, the size is a little larger than
X%\font\ssecsl=cmsl10 scaled 1315	% being scaled magstep1.
X%\font\ssectt=cmtt10 scaled 1315
X%\font\ssecsf=cmss10 scaled 1315
X
X%\let\ssecbf=\ssecrm
X
X\font\ssecrm=cmbx12 scaled \magstephalf
X\font\ssecit=cmti12 scaled \magstephalf
X\font\ssecsl=cmsl12 scaled \magstephalf
X\font\ssectt=cmtt12 scaled \magstephalf
X\font\ssecsf=cmss12 scaled \magstephalf
X\font\ssecbf=cmbx12 scaled \magstephalf
X\font\ssecsc=cmcsc10 scaled \magstep1 
X\font\sseci=cmmi12 scaled \magstephalf
X\font\ssecsy=cmsy10 scaled \magstep1
X% The smallcaps and symbol fonts should actually be scaled \magstep1.5,
X% but that is not a standard magnification.
X
X% Fonts for title page:
X\font\titlerm = cmbx12 scaled \magstep3
X\let\authorrm = \secrm
X
X% In order for the font changes to affect most math symbols and letters,
X% we have to define the \textfont of the standard families.  Since
X% texinfo doesn't allow for producing subscripts and superscripts, we
X% don't bother to reset \scriptfont and \scriptscriptfont (which would
X% also require loading a lot more fonts).
X% 
X\def\resetmathfonts{%
X  \textfont0 = \tenrm \textfont1 = \teni \textfont2 = \tensy
X  \textfont\itfam = \tenit \textfont\slfam = \tensl \textfont\bffam = \tenbf
X  \textfont\ttfam = \tentt \textfont\sffam = \tensf
X}
X
X
X% The font-changing commands redefine the meanings of \tenSTYLE, instead
X% of just \STYLE.  We do this so that font changes will continue to work
X% in math mode, where it is the current \fam that is relevant in most
X% cases, not the current.  Plain TeX does, for example,
X% \def\bf{\fam=\bffam \tenbf}  By redefining \tenbf, we obviate the need
X% to redefine \bf itself.  
X\def\textfonts{%
X  \let\tenrm=\textrm \let\tenit=\textit \let\tensl=\textsl
X  \let\tenbf=\textbf \let\tentt=\texttt \let\smallcaps=\textsc
X  \let\tensf=\textsf \let\teni=\texti \let\tensy=\textsy
X  \resetmathfonts}
X\def\chapfonts{%
X  \let\tenrm=\chaprm \let\tenit=\chapit \let\tensl=\chapsl 
X  \let\tenbf=\chapbf \let\tentt=\chaptt \let\smallcaps=\chapsc
X  \let\tensf=\chapsf \let\teni=\chapi \let\tensy=\chapsy
X  \resetmathfonts}
X\def\secfonts{%
X  \let\tenrm=\secrm \let\tenit=\secit \let\tensl=\secsl
X  \let\tenbf=\secbf \let\tentt=\sectt \let\smallcaps=\secsc
X  \let\tensf=\secsf \let\teni=\seci \let\tensy=\secsy
X  \resetmathfonts}
X\def\subsecfonts{%
X  \let\tenrm=\ssecrm \let\tenit=\ssecit \let\tensl=\ssecsl
X  \let\tenbf=\ssecbf \let\tentt=\ssectt \let\smallcaps=\ssecsc
X  \let\tensf=\ssecsf \let\teni=\sseci \let\tensy=\ssecsy
X  \resetmathfonts}
X\def\indexfonts{%
X  \let\tenrm=\indrm \let\tenit=\indit \let\tensl=\indsl
X  \let\tenbf=\indbf \let\tentt=\indtt \let\smallcaps=\indsc
X  \let\tensf=\indsf \let\teni=\indi \let\tensy=\indsy
X  \resetmathfonts}
X
X% Set up the default fonts, so we can use them for creating boxes.
X% 
X\textfonts
X
X% Count depth in font-changes, for error checks
X\newcount\fontdepth \fontdepth=0
X
X% Fonts for short table of contents.
X\font\shortcontrm=cmr12
X\font\shortcontbf=cmbx12
X\font\shortcontsl=cmsl12
X
X%% Add scribe-like font environments, plus @l for inline lisp (usually sans
X%% serif) and @ii for TeX italic
X
X% \smartitalic{ARG} outputs arg in italics, followed by an italic correction
X% unless the following character is such as not to need one.
X\def\smartitalicx{\ifx\next,\else\ifx\next-\else\ifx\next.\else\/\fi\fi\fi}
X\def\smartitalic#1{{\sl #1}\futurelet\next\smartitalicx}
X
X\let\i=\smartitalic
X\let\var=\smartitalic
X\let\dfn=\smartitalic
X\let\emph=\smartitalic
X\let\cite=\smartitalic
X
X\def\b#1{{\bf #1}}
X\let\strong=\b
X
X\def\t#1{{\tt \exhyphenpenalty=10000\rawbackslash \frenchspacing #1}\null}
X\let\ttfont = \t
X%\def\samp #1{`{\tt \rawbackslash \frenchspacing #1}'\null}
X\def\samp #1{`\tclose{#1}'\null}
X\def\key #1{{\tt \exhyphenpenalty=10000\uppercase{#1}}\null}
X\def\ctrl #1{{\tt \rawbackslash \hat}#1}
X
X\let\file=\samp
X
X% @code is a modification of @t,
X% which makes spaces the same size as normal in the surrounding text.
X\newdimen\tclosesave
X\newdimen\tcloserm
X\def\tclose#1{{\rm \tcloserm=\fontdimen2\font \tt \tclosesave=\fontdimen2\font
X\fontdimen2\font=\tcloserm
X% prevent breaking lines at hyphens.
X\exhyphenpenalty=10000
X\def\ {{\fontdimen2\font=\tclosesave{} }}%
X \rawbackslash \frenchspacing #1\fontdimen2\font=\tclosesave}\null}
X\let\code=\tclose
X%\let\exp=\tclose  %Was temporary
X
X% @kbd is like @code, except that if the argument is just one @key command, 
X% then @kbd has no effect.
X
X\def\xkey{\key}
X\def\kbdfoo#1#2#3\par{\def\one{#1}\def\three{#3}\def\threex{??}%
X\ifx\one\xkey\ifx\threex\three \key{#2}%
X\else\tclose{\look}\fi
X\else\tclose{\look}\fi}
X
X% Typeset a dimension, e.g., `in' or `pt'.  The only reason for the
X% argument is to make the input look right: @dmn{pt} instead of
X% @dmn{}pt.
X% 
X\def\dmn#1{\thinspace #1}
X
X\def\kbd#1{\def\look{#1}\expandafter\kbdfoo\look??\par}
X
X\def\l#1{{\li #1}\null}		% 
X
X\def\r#1{{\rm #1}}		% roman font
X% Use of \lowercase was suggested.
X\def\sc#1{{\smallcaps#1}}	% smallcaps font
X\def\ii#1{{\it #1}}		% italic font
X
X\message{page headings,}
X
X\newskip\titlepagetopglue \titlepagetopglue = 1.5in
X\newskip\titlepagebottomglue \titlepagebottomglue = 2pc
X
X% First the title page.  Must do @settitle before @titlepage.
X\def\titlefont#1{{\titlerm #1}}
X
X\newtoks\realeverypar
X\newif\ifseenauthor
X\newif\iffinishedtitlepage
X
X\def\titlepage{\begingroup \parindent=0pt \textfonts
X   \let\subtitlerm=\tenrm
X% I deinstalled the following change because \cmr12 is undefined.
X% This change was not in the ChangeLog anyway.  --rms.
X%   \let\subtitlerm=\cmr12
X   \def\subtitlefont{\subtitlerm \normalbaselineskip = 13pt \normalbaselines}%
X   %
X   \def\authorfont{\authorrm \normalbaselineskip = 16pt \normalbaselines}%
X   %
X   % Leave some space at the very top of the page.
X   \vglue\titlepagetopglue
X   %
X   % Now you can print the title using @title.
X   \def\title{\parsearg\titlezzz}%
X   \def\titlezzz##1{\leftline{\titlefont{##1}}
X		    % print a rule at the page bottom also.
X		    \finishedtitlepagefalse
X		    \vskip4pt \hrule height 4pt \vskip4pt}%
X   % No rule at page bottom unless we print one at the top with @title.
X   \finishedtitlepagetrue
X   %
X   % Now you can put text using @subtitle.
X   \def\subtitle{\parsearg\subtitlezzz}%
X   \def\subtitlezzz##1{{\subtitlefont \rightline{##1}}}%
X   %
X   % @author should come last, but may come many times.
X   \def\author{\parsearg\authorzzz}%
X   \def\authorzzz##1{\ifseenauthor\else\vskip 0pt plus 1filll\seenauthortrue\fi
X      {\authorfont \leftline{##1}}}%
X   %  
X   % Most title ``pages'' are actually two pages long, with space
X   % at the top of the second.  We don't want the ragged left on the second.
X   \let\oldpage = \page
X   \def\page{%
X      \iffinishedtitlepage\else
X	 \finishtitlepage
X      \fi
X      \oldpage
X      \let\page = \oldpage
X      \hbox{}}%
X%   \def\page{\oldpage \hbox{}}
X}
X
X\def\Etitlepage{%
X   \iffinishedtitlepage\else
X      \finishtitlepage
X   \fi
X   % It is important to do the page break before ending the group,
X   % because the headline and footline are only empty inside the group.
X   % If we use the new definition of \page, we always get a blank page
X   % after the title page, which we certainly don't want.
X   \oldpage
X   \endgroup
X   \HEADINGSon
X}
X
X\def\finishtitlepage{%
X   \vskip4pt \hrule height 2pt
X   \vskip\titlepagebottomglue
X   \finishedtitlepagetrue
X}
X
X%%% Set up page headings and footings.
X
X\let\thispage=\folio
X
X\newtoks \evenheadline    % Token sequence for heading line of even pages
X\newtoks \oddheadline     % Token sequence for heading line of odd pages
X\newtoks \evenfootline    % Token sequence for footing line of even pages
X\newtoks \oddfootline     % Token sequence for footing line of odd pages
X
X% Now make Tex use those variables
X\headline={{\textfonts\rm \ifodd\pageno \the\oddheadline
X                            \else \the\evenheadline \fi}}
X\footline={{\textfonts\rm \ifodd\pageno \the\oddfootline
X                            \else \the\evenfootline \fi}\HEADINGShook}
X\let\HEADINGShook=\relax
X
X% Commands to set those variables.
X% For example, this is what  @headings on  does
X% @evenheading @thistitle|@thispage|@thischapter
X% @oddheading @thischapter|@thispage|@thistitle
X% @evenfooting @thisfile||
X% @oddfooting ||@thisfile
X
X\def\evenheading{\parsearg\evenheadingxxx}
X\def\oddheading{\parsearg\oddheadingxxx}
X\def\everyheading{\parsearg\everyheadingxxx}
X
X\def\evenfooting{\parsearg\evenfootingxxx}
X\def\oddfooting{\parsearg\oddfootingxxx}
X\def\everyfooting{\parsearg\everyfootingxxx}
X
X{\catcode`\@=0 %
X
X\gdef\evenheadingxxx #1{\evenheadingyyy #1@|@|@|@|\finish}
X\gdef\evenheadingyyy #1@|#2@|#3@|#4\finish{%
X\global\evenheadline={\rlap{\centerline{#2}}\line{#1\hfil#3}}}
X
X\gdef\oddheadingxxx #1{\oddheadingyyy #1@|@|@|@|\finish}
X\gdef\oddheadingyyy #1@|#2@|#3@|#4\finish{%
X\global\oddheadline={\rlap{\centerline{#2}}\line{#1\hfil#3}}}
X
X\gdef\everyheadingxxx #1{\everyheadingyyy #1@|@|@|@|\finish}
X\gdef\everyheadingyyy #1@|#2@|#3@|#4\finish{%
X\global\evenheadline={\rlap{\centerline{#2}}\line{#1\hfil#3}}
X\global\oddheadline={\rlap{\centerline{#2}}\line{#1\hfil#3}}}
X
X\gdef\evenfootingxxx #1{\evenfootingyyy #1@|@|@|@|\finish}
X\gdef\evenfootingyyy #1@|#2@|#3@|#4\finish{%
X\global\evenfootline={\rlap{\centerline{#2}}\line{#1\hfil#3}}}
X
X\gdef\oddfootingxxx #1{\oddfootingyyy #1@|@|@|@|\finish}
X\gdef\oddfootingyyy #1@|#2@|#3@|#4\finish{%
X\global\oddfootline={\rlap{\centerline{#2}}\line{#1\hfil#3}}}
X
X\gdef\everyfootingxxx #1{\everyfootingyyy #1@|@|@|@|\finish}
X\gdef\everyfootingyyy #1@|#2@|#3@|#4\finish{%
X\global\evenfootline={\rlap{\centerline{#2}}\line{#1\hfil#3}}
X\global\oddfootline={\rlap{\centerline{#2}}\line{#1\hfil#3}}}
X%
X}% unbind the catcode of @.
X
X% @headings double	turns headings on for double-sided printing.
X% @headings single	turns headings on for single-sided printing.
X% @headings off		turns them off.
X% @headings on		same as @headings double, retained for compatibility.
X% @headings after	turns on double-sided headings after this page.
X% @headings doubleafter	turns on double-sided headings after this page.
X% @headings singleafter turns on single-sided headings after this page.
X% By default, they are off.
X
X\def\headings #1 {\csname HEADINGS#1\endcsname}
X
X\def\HEADINGSoff{
X\global\evenheadline={\hfil} \global\evenfootline={\hfil}
X\global\oddheadline={\hfil} \global\oddfootline={\hfil}}
X\HEADINGSoff
X% When we turn headings on, set the page number to 1.
X% For double-sided printing, put current file name in lower left corner,
X% chapter name on inside top of right hand pages, document
X% title on inside top of left hand pages, and page numbers on outside top
X% edge of all pages.
X\def\HEADINGSdouble{
X%\pagealignmacro
X\global\pageno=1
X\global\evenfootline={\hfil}
X\global\oddfootline={\hfil}
X\global\evenheadline={\line{\folio\hfil\thistitle}}
X\global\oddheadline={\line{\thischapter\hfil\folio}}
X}
X% For single-sided printing, chapter title goes across top left of page,
X% page number on top right.
X\def\HEADINGSsingle{
X%\pagealignmacro
X\global\pageno=1
X\global\evenfootline={\hfil}
X\global\oddfootline={\hfil}
X\global\evenheadline={\line{\thischapter\hfil\folio}}
X\global\oddheadline={\line{\thischapter\hfil\folio}}
X}
X\def\HEADINGSon{\HEADINGSdouble}
X
X\def\HEADINGSafter{\let\HEADINGShook=\HEADINGSdoublex}
X\let\HEADINGSdoubleafter=\HEADINGSafter
X\def\HEADINGSdoublex{%
X\global\evenfootline={\hfil}
X\global\oddfootline={\hfil}
X\global\evenheadline={\line{\folio\hfil\thistitle}}
X\global\oddheadline={\line{\thischapter\hfil\folio}}
X}
X
X\def\HEADINGSsingleafter{\let\HEADINGShook=\HEADINGSsinglex}
X\def\HEADINGSsinglex{%
X\global\evenfootline={\hfil}
X\global\oddfootline={\hfil}
X\global\evenheadline={\line{\thischapter\hfil\folio}}
X\global\oddheadline={\line{\thischapter\hfil\folio}}
X}
X
X% Subroutines used in generating headings
X% Produces Day Month Year style of output.
X\def\today{\number\day\space
X\ifcase\month\or
XJanuary\or February\or March\or April\or May\or June\or
XJuly\or August\or September\or October\or November\or December\fi
X\space\number\year}
X
X% Use this if you want the Month Day, Year style of output.
X%\def\today{\ifcase\month\or
X%January\or February\or March\or April\or May\or June\or
X%July\or August\or September\or October\or November\or December\fi
X%\space\number\day, \number\year}
X
X% @settitle line...  specifies the title of the document, for headings
X% It generates no output of its own
X
X\def\thistitle{No Title}
X\def\settitle{\parsearg\settitlezzz}
X\def\settitlezzz #1{\gdef\thistitle{#1}}
X
X\message{tables,}
X
X% @tabs -- simple alignment
X
X% These don't work.  For one thing, \+ is defined as outer.
X% So these macros cannot even be defined.
X
X%\def\tabs{\parsearg\tabszzz}
X%\def\tabszzz #1{\settabs\+#1\cr}
X%\def\tabline{\parsearg\tablinezzz}
X%\def\tablinezzz #1{\+#1\cr}
X%\def\&{&}
X
X% Tables -- @table, @ftable, @vtable, @item(x), @kitem(x), @xitem(x).
X
X% default indentation of table text
X\newdimen\tableindent \tableindent=.8in
X% default indentation of @itemize and @enumerate text
X\newdimen\itemindent  \itemindent=.3in
X% margin between end of table item and start of table text.
X\newdimen\itemmargin  \itemmargin=.1in
X
X% used internally for \itemindent minus \itemmargin
X\newdimen\itemmax
X
X% Note @table, @vtable, and @vtable define @item, @itemx, etc., with
X% these defs.
X% They also define \itemindex
X% to index the item name in whatever manner is desired (perhaps none).
X
X\def\internalBitem{\smallbreak \parsearg\itemzzz}
X\def\internalBitemx{\par \parsearg\itemzzz}
X
X\def\internalBxitem "#1"{\def\xitemsubtopix{#1} \smallbreak \parsearg\xitemzzz}
X\def\internalBxitemx "#1"{\def\xitemsubtopix{#1} \par \parsearg\xitemzzz}
X
X\def\internalBkitem{\smallbreak \parsearg\kitemzzz}
X\def\internalBkitemx{\par \parsearg\kitemzzz}
X
X\def\kitemzzz #1{\dosubind {kw}{\code{#1}}{for {\bf \lastfunction}}%
X                 \itemzzz {#1}}
X
X\def\xitemzzz #1{\dosubind {kw}{\code{#1}}{for {\bf \xitemsubtopic}}%
X                 \itemzzz {#1}}
X
X\def\itemzzz #1{\begingroup %
X  \advance\hsize by -\rightskip
X  \advance\hsize by -\tableindent
X  \setbox0=\hbox{\itemfont{#1}}%
X  \itemindex{#1}%
X  \nobreak % This prevents a break before @itemx.
X  %
X  % Be sure we are not still in the middle of a paragraph.
X  \parskip=0in
X  \par
X  %
X  % If the item text does not fit in the space we have, put it on a line
X  % by itself, and do not allow a page break either before or after that
X  % line.  We do not start a paragraph here because then if the next
X  % command is, e.g., @kindex, the whatsit would get put into the
X  % horizontal list on a line by itself, resulting in extra blank space.
X  \ifdim \wd0>\itemmax
X    \setbox0=\hbox{\hskip \leftskip \hskip -\tableindent \unhbox0}\box0
X    \nobreak
X  \else
X    % The item text fits into the space.  Start a paragraph, so that the
X    % following text (if any) will end up on the same line.  Since that
X    % text will be indented by \tableindent, we make the item text be in
X    % a zero-width box.
X    \noindent
X    \rlap{\hskip -\tableindent\box0}%
X  \fi
X  \endgroup
X}
X
X\def\item{\errmessage{@item while not in a table}}
X\def\itemx{\errmessage{@itemx while not in a table}}
X\def\kitem{\errmessage{@kitem while not in a table}}
X\def\kitemx{\errmessage{@kitemx while not in a table}}
X\def\xitem{\errmessage{@xitem while not in a table}}
X\def\xitemx{\errmessage{@xitemx while not in a table}}
X
X%% Contains a kludge to get @end[description] to work
X\def\description{\tablez{\dontindex}{1}{}{}{}{}}
X
X\def\table{\begingroup\inENV\obeylines\obeyspaces\tablex}
X{\obeylines\obeyspaces%
X\gdef\tablex #1^^M{%
X\tabley\dontindex#1        \endtabley}}
X
X\def\ftable{\begingroup\inENV\obeylines\obeyspaces\ftablex}
X{\obeylines\obeyspaces%
X\gdef\ftablex #1^^M{%
X\tabley\fnitemindex#1        \endtabley
X\def\Eftable{\endgraf\endgroup\afterenvbreak}%
X\let\Etable=\relax}}
X
X\def\vtable{\begingroup\inENV\obeylines\obeyspaces\vtablex}
X{\obeylines\obeyspaces%
X\gdef\vtablex #1^^M{%
X\tabley\vritemindex#1        \endtabley
X\def\Evtable{\endgraf\endgroup\afterenvbreak}%
X\let\Etable=\relax}}
X
X\def\dontindex #1{}
X\def\fnitemindex #1{\doind {fn}{\code{#1}}}%
X\def\vritemindex #1{\doind {vr}{\code{#1}}}%
X
X{\obeyspaces %
X\gdef\tabley#1#2 #3 #4 #5 #6 #7\endtabley{\endgroup%
X\tablez{#1}{#2}{#3}{#4}{#5}{#6}}}
X
X\def\tablez #1#2#3#4#5#6{%
X\aboveenvbreak %
X\begingroup %
X\def\Edescription{\Etable}% Neccessary kludge.
X\let\itemindex=#1%
X\ifnum 0#3>0 \advance \leftskip by #3\mil \fi %
X\ifnum 0#4>0 \tableindent=#4\mil \fi %
X\ifnum 0#5>0 \advance \rightskip by #5\mil \fi %
X\def\itemfont{#2}%
X\itemmax=\tableindent %
X\advance \itemmax by -\itemmargin %
X\advance \leftskip by \tableindent %
X\exdentamount=\tableindent
X\parindent = 0pt
X\parskip = \smallskipamount
X\ifdim \parskip=0pt \parskip=2pt \fi%
X\def\Etable{\endgraf\endgroup\afterenvbreak}%
X\let\item = \internalBitem %
X\let\itemx = \internalBitemx %
X\let\kitem = \internalBkitem %
X\let\kitemx = \internalBkitemx %
X\let\xitem = \internalBxitem %
X\let\xitemx = \internalBxitemx %
X}
X
X% This is the counter used by @enumerate, which is really @itemize
X
X\newcount \itemno
X
X\def\itemize{\parsearg\itemizezzz}
X
X\def\itemizezzz #1{%
X  \begingroup % ended by the @end itemsize
X  \itemizey {#1}{\Eitemize}
X}
X
X\def\itemizey #1#2{%
X\aboveenvbreak %
X\itemmax=\itemindent %
X\advance \itemmax by -\itemmargin %
X\advance \leftskip by \itemindent %
X\exdentamount=\itemindent
X\parindent = 0pt %
X\parskip = \smallskipamount %
X\ifdim \parskip=0pt \parskip=2pt \fi%
X\def#2{\endgraf\endgroup\afterenvbreak}%
X\def\itemcontents{#1}%
X\let\item=\itemizeitem}
X
X\def\bullet{$\ptexbullet$}
X\def\minus{$-$}
X
X% Set sfcode to normal for the chars that usually have another value.
X% These are `.?!:;,'
X\def\frenchspacing{\sfcode46=1000 \sfcode63=1000 \sfcode33=1000
X  \sfcode58=1000 \sfcode59=1000 \sfcode44=1000 }
X
X% \splitoff TOKENS\endmark defines \first to be the first token in
X% TOKENS, and \rest to be the remainder.
X% 
X\def\splitoff#1#2\endmark{\def\first{#1}\def\rest{#2}}%
X
X% Allow an optional argument of an uppercase letter, lowercase letter,
X% or number, to specify the first label in the enumerated list.  No
X% argument is the same as `1'.
X% 
X\def\enumerate{\parsearg\enumeratezzz}
X\def\enumeratezzz #1{\enumeratey #1  \endenumeratey}
X\def\enumeratey #1 #2\endenumeratey{%
X  \begingroup % ended by the @end enumerate
X  %
X  % If we were given no argument, pretend we were given `1'.
X  \def\thearg{#1}%
X  \ifx\thearg\empty \def\thearg{1}\fi
X  %
X  % Detect if the argument is a single token.  If so, it might be a
X  % letter.  Otherwise, the only valid thing it can be is a number.
X  % (We will always have one token, because of the test we just made.
X  % This is a good thing, since \splitoff doesn't work given nothing at
X  % all -- the first parameter is undelimited.)
X  \expandafter\splitoff\thearg\endmark
X  \ifx\rest\empty
X    % Only one token in the argument.  It could still be anything.
X    % A ``lowercase letter'' is one whose \lccode is nonzero.
X    % An ``uppercase letter'' is one whose \lccode is both nonzero, and
X    %   not equal to itself.
X    % Otherwise, we assume it's a number.
X    % 
X    % We need the \relax at the end of the \ifnum lines to stop TeX from
X    % continuing to look for a <number>.
X    % 
X    \ifnum\lccode\expandafter`\thearg=0\relax 
X      \numericenumerate % a number (we hope)
X    \else
X      % It's a letter.
X      \ifnum\lccode\expandafter`\thearg=\expandafter`\thearg\relax
X        \lowercaseenumerate % lowercase letter
X      \else
X        \uppercaseenumerate % uppercase letter
X      \fi
X    \fi
X  \else
X    % Multiple tokens in the argument.  We hope it's a number.
X    \numericenumerate
X  \fi
X}
X
X% An @enumerate whose labels are integers.  The starting integer is
X% given in \thearg.
X% 
X\def\numericenumerate{%
X  \itemno = \thearg
X  \startenumeration{\the\itemno}%
X}
X
X% The starting (lowercase) letter is in \thearg.
X\def\lowercaseenumerate{%
X  \itemno = \expandafter`\thearg
X  \startenumeration{%
X    % Be sure we're not beyond the end of the alphabet.
X    \ifnum\itemno=0
X      \errmessage{No more lowercase letters in @enumerate; get a bigger
X                  alphabet}%
X    \fi
X    \char\lccode\itemno
X  }%
X}
X
X% The starting (uppercase) letter is in \thearg.
X\def\uppercaseenumerate{%
X  \itemno = \expandafter`\thearg
X  \startenumeration{%
X    % Be sure we're not beyond the end of the alphabet.
X    \ifnum\itemno=0
X      \errmessage{No more uppercase letters in @enumerate; get a bigger
X                  alphabet}
X    \fi
X    \char\uccode\itemno
X  }%
X}
X
X% Call itemizey, adding a period to the first argument and supplying the
X% common last two arguments.  Also subtract one from the initial value in
X% \itemno, since @item increments \itemno.
X% 
X\def\startenumeration#1{%
X  \advance\itemno by -1
X  \itemizey{#1.}\Eenumerate\flushcr
X}
X
X% @alphaenumerate and @capsenumerate are abbreviations for giving an arg
X% to @enumerate.
X% 
X\def\alphaenumerate{\enumerate{a}}
X\def\capsenumerate{\enumerate{A}}
X\def\Ealphaenumerate{\Eenumerate}
X\def\Ecapsenumerate{\Eenumerate}
X
X% Definition of @item while inside @itemize.
X
X\def\itemizeitem{%
X\advance\itemno by 1
X{\let\par=\endgraf \smallbreak}%
X\ifhmode \errmessage{\in hmode at itemizeitem}\fi
X{\parskip=0in \hskip 0pt
X\hbox to 0pt{\hss \itemcontents\hskip \itemmargin}%
X\vadjust{\penalty 1200}}%
X\flushcr}
X
X\message{indexing,}
X% Index generation facilities
X
X% Define \newwrite to be identical to plain tex's \newwrite
X% except not \outer, so it can be used within \newindex.
X{\catcode`\@=11
X\gdef\newwrite{\alloc@7\write\chardef\sixt@@n}}
X
X% \newindex {foo} defines an index named foo.
X% It automatically defines \fooindex such that
X% \fooindex ...rest of line... puts an entry in the index foo.
X% It also defines \fooindfile to be the number of the output channel for
X% the file that	accumulates this index.  The file's extension is foo.
X% The name of an index should be no more than 2 characters long
X% for the sake of vms.
X
X\def\newindex #1{
X\expandafter\newwrite \csname#1indfile\endcsname% Define number for output file
X\openout \csname#1indfile\endcsname \jobname.#1	% Open the file
X\expandafter\xdef\csname#1index\endcsname{%	% Define \xxxindex
X\noexpand\doindex {#1}}
X}
X
X% @defindex foo  ==  \newindex{foo}
X
X\def\defindex{\parsearg\newindex}
X
X% Define @defcodeindex, like @defindex except put all entries in @code.
X
X\def\newcodeindex #1{
X\expandafter\newwrite \csname#1indfile\endcsname% Define number for output file
X\openout \csname#1indfile\endcsname \jobname.#1	% Open the file
X\expandafter\xdef\csname#1index\endcsname{%	% Define \xxxindex
X\noexpand\docodeindex {#1}}
X}
X
X\def\defcodeindex{\parsearg\newcodeindex}
X
X% @synindex foo bar    makes index foo feed into index bar.
X% Do this instead of @defindex foo if you don't want it as a separate index.
X\def\synindex #1 #2 {%
X\expandafter\let\expandafter\synindexfoo\expandafter=\csname#2indfile\endcsname
X\expandafter\let\csname#1indfile\endcsname=\synindexfoo
X\expandafter\xdef\csname#1index\endcsname{%	% Define \xxxindex
X\noexpand\doindex {#2}}%
X}
X
X% @syncodeindex foo bar   similar, but put all entries made for index foo
X% inside @code.
X\def\syncodeindex #1 #2 {%
X\expandafter\let\expandafter\synindexfoo\expandafter=\csname#2indfile\endcsname
X\expandafter\let\csname#1indfile\endcsname=\synindexfoo
X\expandafter\xdef\csname#1index\endcsname{%	% Define \xxxindex
X\noexpand\docodeindex {#2}}%
X}
X
X% Define \doindex, the driver for all \fooindex macros.
X% Argument #1 is generated by the calling \fooindex macro,
X%  and it is "foo", the name of the index.
X
X% \doindex just uses \parsearg; it calls \doind for the actual work.
X% This is because \doind is more useful to call from other macros.
X
X% There is also \dosubind {index}{topic}{subtopic}
X% which makes an entry in a two-level index such as the operation index.
X
X\def\doindex#1{\edef\indexname{#1}\parsearg\singleindexer}
X\def\singleindexer #1{\doind{\indexname}{#1}}
X
X% like the previous two, but they put @code around the argument.
X\def\docodeindex#1{\edef\indexname{#1}\parsearg\singlecodeindexer}
X\def\singlecodeindexer #1{\doind{\indexname}{\code{#1}}}
X
X\def\indexdummies{%
X\def\_{{\realbackslash _}}%
X\def\w{\realbackslash w }%
X\def\bf{\realbackslash bf }%
X\def\rm{\realbackslash rm }%
X\def\sl{\realbackslash sl }%
X\def\sf{\realbackslash sf}%
X\def\tt{\realbackslash tt}%
X\def\gtr{\realbackslash gtr}%
X\def\less{\realbackslash less}%
X\def\hat{\realbackslash hat}%
X\def\char{\realbackslash char}%
X\def\TeX{\realbackslash TeX}%
X\def\dots{\realbackslash dots }%
X\def\copyright{\realbackslash copyright }%
X\def\tclose##1{\realbackslash tclose {##1}}%
X\def\code##1{\realbackslash code {##1}}%
X\def\samp##1{\realbackslash samp {##1}}%
X\def\t##1{\realbackslash r {##1}}%
X\def\r##1{\realbackslash r {##1}}%
X\def\i##1{\realbackslash i {##1}}%
X\def\b##1{\realbackslash b {##1}}%
X\def\cite##1{\realbackslash cite {##1}}%
X\def\key##1{\realbackslash key {##1}}%
X\def\file##1{\realbackslash file {##1}}%
X\def\var##1{\realbackslash var {##1}}%
X\def\kbd##1{\realbackslash kbd {##1}}%
X}
X
X% \indexnofonts no-ops all font-change commands.
X% This is used when outputting the strings to sort the index by.
X\def\indexdummyfont#1{#1}
X\def\indexdummytex{TeX}
X\def\indexdummydots{...}
X
X\def\indexnofonts{%
X\let\w=\indexdummyfont
X\let\t=\indexdummyfont
X\let\r=\indexdummyfont
X\let\i=\indexdummyfont
X\let\b=\indexdummyfont
X\let\emph=\indexdummyfont
X\let\strong=\indexdummyfont
X\let\cite=\indexdummyfont
X\let\sc=\indexdummyfont
X%Don't no-op \tt, since it isn't a user-level command
X% and is used in the definitions of the active chars like <, >, |...
X%\let\tt=\indexdummyfont
X\let\tclose=\indexdummyfont
X\let\code=\indexdummyfont
X\let\file=\indexdummyfont
X\let\samp=\indexdummyfont
X\let\kbd=\indexdummyfont
X\let\key=\indexdummyfont
X\let\var=\indexdummyfont
X\let\TeX=\indexdummytex
X\let\dots=\indexdummydots
X}
X
X% To define \realbackslash, we must make \ not be an escape.
X% We must first make another character (@) an escape
X% so we do not become unable to do a definition.
X
X{\catcode`\@=0 \catcode`\\=\other
X@gdef@realbackslash{\}}
X
X\let\indexbackslash=0  %overridden during \printindex.
X
X\def\doind #1#2{%
X{\count10=\lastpenalty %
X{\indexdummies % Must do this here, since \bf, etc expand at this stage
X\escapechar=`\\%
X{\let\folio=0% Expand all macros now EXCEPT \folio
X\def\rawbackslashxx{\indexbackslash}% \indexbackslash isn't defined now
X% so it will be output as is; and it will print as backslash in the indx.
X%
X% Now process the index-string once, with all font commands turned off,
X% to get the string to sort the index by.
X{\indexnofonts
X\xdef\temp1{#2}%
X}%
X% Now produce the complete index entry.  We process the index-string again,
X% this time with font commands expanded, to get what to print in the index.
X\edef\temp{%
X\write \csname#1indfile\endcsname{%
X\realbackslash entry {\temp1}{\folio}{#2}}}%
X\temp }%
X}\penalty\count10}}
X
X\def\dosubind #1#2#3{%
X{\count10=\lastpenalty %
X{\indexdummies % Must do this here, since \bf, etc expand at this stage
X\escapechar=`\\%
X{\let\folio=0%
X\def\rawbackslashxx{\indexbackslash}%
X%
X% Now process the index-string once, with all font commands turned off,
X% to get the string to sort the index by.
X{\indexnofonts
X\xdef\temp1{#2 #3}%
X}%
X% Now produce the complete index entry.  We process the index-string again,
X% this time with font commands expanded, to get what to print in the index.
X\edef\temp{%
X\write \csname#1indfile\endcsname{%
X\realbackslash entry {\temp1}{\folio}{#2}{#3}}}%
X\temp }%
X}\penalty\count10}}
X
X% The index entry written in the file actually looks like
X%  \entry {sortstring}{page}{topic}
X% or
X%  \entry {sortstring}{page}{topic}{subtopic}
X% The texindex program reads in these files and writes files
X% containing these kinds of lines:
X%  \initial {c}
X%     before the first topic whose initial is c
X%  \entry {topic}{pagelist}
X%     for a topic that is used without subtopics
X%  \primary {topic}
X%     for the beginning of a topic that is used with subtopics
X%  \secondary {subtopic}{pagelist}
X%     for each subtopic.
X
X% Define the user-accessible indexing commands 
X% @findex, @vindex, @kindex, @cindex.
X
X\def\findex {\fnindex}
X\def\kindex {\kyindex}
X\def\cindex {\cpindex}
X\def\vindex {\vrindex}
X\def\tindex {\tpindex}
X\def\pindex {\pgindex}
X
X\def\cindexsub {\begingroup\obeylines\cindexsub}
X{\obeylines %
X\gdef\cindexsub "#1" #2^^M{\endgroup %
X\dosubind{cp}{#2}{#1}}}
X
X% Define the macros used in formatting output of the sorted index material.
X
X% This is what you call to cause a particular index to get printed.
X% Write
X% @unnumbered Function Index
X% @printindex fn
X
X\def\printindex{\parsearg\doprintindex}
X
X\def\doprintindex#1{%
X  \tex
X  \dobreak \chapheadingskip {10000}
X  \catcode`\%=\other\catcode`\&=\other\catcode`\#=\other
X  \catcode`\$=\other\catcode`\_=\other
X  \catcode`\~=\other
X  %
X  % The following don't help, since the chars were translated
X  % when the raw index was written, and their fonts were discarded
X  % due to \indexnofonts.
X  %\catcode`\"=\active
X  %\catcode`\^=\active
X  %\catcode`\_=\active
X  %\catcode`\|=\active
X  %\catcode`\<=\active
X  %\catcode`\>=\active
X  % %
X  \def\indexbackslash{\rawbackslashxx}
X  \indexfonts\rm \tolerance=9500 \advance\baselineskip -1pt
X  \begindoublecolumns
X  %
X  % See if the index file exists and is nonempty.
X  \openin 1 \jobname.#1s
X  \ifeof 1 
X    % \enddoublecolumns gets confused if there is no text in the index,
X    % and it loses the chapter title and the aux file entries for the
X    % index.  The easiest way to prevent this problem is to make sure
X    % there is some text.
X    (Index is nonexistent)
X    \else
X    %
X    % If the index file exists but is empty, then \openin leaves \ifeof
X    % false.  We have to make TeX try to read something from the file, so
X    % it can discover if there is anything in it.
X    \read 1 to \temp
X    \ifeof 1
X      (Index is empty)
X    \else
X      \input \jobname.#1s
X    \fi
X  \fi
X  \closein 1
X  \enddoublecolumns
X  \Etex
X}
X
X% These macros are used by the sorted index file itself.
X% Change them to control the appearance of the index.
X
X% Same as \bigskipamount except no shrink.
X% \balancecolumns gets confused if there is any shrink.
X\newskip\initialskipamount \initialskipamount 12pt plus4pt
X
X\def\initial #1{%
X{\let\tentt=\sectt \let\tt=\sectt \let\sf=\sectt
X\ifdim\lastskip<\initialskipamount
X\removelastskip \penalty-200 \vskip \initialskipamount\fi
X\line{\secbf#1\hfill}\kern 2pt\penalty10000}}
X
X\def\entry #1#2{\begingroup
X  \parfillskip=0in \parskip=0in \parindent=0in
X  %
X  % \hangindent is only relevant when the page number and the entry text
X  % don't fit on one line.  In that case, bob suggests starting the dots
X  % pretty far over on the line.
X  % \hangafter is reset to 1 at the start of each paragraph.
X  \hangindent=.75\hsize
X  \noindent
X  %
X  % Don't break the text of the index entry.
X  \hbox{#1}%
X  %
X  % If we must, put the page number on a line of its own, and fill out
X  % this line with blank space.  (The \hfil is overwhelmed with the
X  % fill leaders glue in \indexdotfill if the page number does fit.)
X  \hfil\penalty50
X  \null\nobreak\indexdotfill % Have leaders before the page number.
X  %
X  % The `\ ' here is removed by the implicit \unskip that TeX does as
X  % part of (the primitive) \par.  Without, a spurious underfull \hbox ensues.
X  \ #2% The page number ends the paragraph.
X  \par
X\endgroup}
X
X% Like \dotfill except takes at least 1 em.
X\def\indexdotfill{\cleaders
X  \hbox{$\mathsurround=0pt \mkern1.5mu . \mkern1.5mu$}\hskip 1em plus 1fill}
X
X\def\primary #1{\line{#1\hfil}}
X
X\newskip\secondaryindent \secondaryindent=0.5cm
X
X\def\secondary #1#2{
X{\parfillskip=0in \parskip=0in
X\hangindent =1in \hangafter=1
X\noindent\hskip\secondaryindent\hbox{#1}\indexdotfill #2\par
X}}
X
X%% Define two-column mode, which is used in indexes.
X%% Adapted from the TeXBook, page 416
X\catcode `\@=11
X
X\newbox\partialpage
X
X\newdimen\doublecolumnhsize  \doublecolumnhsize = 3.11in
X\newdimen\doublecolumnvsize  \doublecolumnvsize = 19.1in
X\newdimen\availdimen@
X
X\def\begindoublecolumns{\begingroup
X  \output={\global\setbox\partialpage=
X    \vbox{\unvbox255\kern -\topskip \kern \baselineskip}}\eject
X  \output={\doublecolumnout}%
X  \hsize=\doublecolumnhsize \vsize=\doublecolumnvsize}
X\def\enddoublecolumns{\output={\balancecolumns}\eject
X  \endgroup \pagegoal=\vsize}
X
X\def\doublecolumnout{\splittopskip=\topskip \splitmaxdepth=\maxdepth
X  \dimen@=\pageheight \advance\dimen@ by-\ht\partialpage
X  \setbox0=\vsplit255 to\dimen@ \setbox2=\vsplit255 to\dimen@
X  \onepageout\pagesofar \unvbox255 \penalty\outputpenalty}
X\def\pagesofar{\unvbox\partialpage %
X  \hsize=\doublecolumnhsize % have to restore this since output routine
X%	      changes it to set cropmarks (P. A. MacKay, 12 Nov. 1986)
X  \wd0=\hsize \wd2=\hsize \hbox to\pagewidth{\box0\hfil\box2}}
X\def\balancecolumns{%
X% Unset the glue.
X  \setbox255=\vbox{\unvbox255}
X  \dimen@=\ht255
X  \advance\dimen@ by\topskip \advance\dimen@ by-\baselineskip
X  \divide\dimen@ by2
X  \availdimen@=\pageheight \advance\availdimen@ by-\ht\partialpage
X% If the remaining data is too big for one page,
X% output one page normally, then work with what remains.
X  \ifdim \dimen@>\availdimen@
X   {
X     \splittopskip=\topskip \splitmaxdepth=\maxdepth
X     \dimen@=\pageheight \advance\dimen@ by-\ht\partialpage
X     \setbox0=\vsplit255 to\dimen@ \setbox2=\vsplit255 to\dimen@
X     \onepageout\pagesofar
X   }
X% Recompute size of what remains, in case we just output some of it.
X  \dimen@=\ht255
X  \advance\dimen@ by\topskip \advance\dimen@ by-\baselineskip
X  \divide\dimen@ by2
X  \fi
X  \setbox0=\vbox{\unvbox255}
X  \splittopskip=\topskip
X  {\vbadness=10000 \loop \global\setbox3=\copy0
X    \global\setbox1=\vsplit3 to\dimen@
X    \ifdim\ht3>\dimen@ \global\advance\dimen@ by1pt \repeat}
X  \setbox0=\vbox to\dimen@{\unvbox1}  \setbox2=\vbox to\dimen@{\unvbox3}
X  \pagesofar}
X
X\catcode `\@=\other
X\message{sectioning,}
X% Define chapters, sections, etc.
X
X\newcount \chapno
X\newcount \secno        \secno=0
X\newcount \subsecno     \subsecno=0
X\newcount \subsubsecno  \subsubsecno=0
X
X% This counter is funny since it counts through charcodes of letters A, B, ...
X\newcount \appendixno  \appendixno = `\@
X\def\appendixletter{\char\the\appendixno}
X
X\newwrite \contentsfile
X% This is called from \setfilename.
X\def\opencontents{\openout \contentsfile = \jobname.toc}
X
X% Each @chapter defines this as the name of the chapter.
X% page headings and footings can use it.  @section does likewise
X
X\def\thischapter{} \def\thissection{}
X\def\seccheck#1{\if \pageno<0 %
X\errmessage{@#1 not allowed after generating table of contents}\fi
X%
X}
X
X\def\chapternofonts{%
X\let\rawbackslash=\relax%
X\let\frenchspacing=\relax%
X\def\result{\realbackslash result}
X\def\equiv{\realbackslash equiv}
X\def\expansion{\realbackslash expansion}
X\def\print{\realbackslash print}
X\def\TeX{\realbackslash TeX}
X\def\dots{\realbackslash dots}
X\def\copyright{\realbackslash copyright}
X\def\tt{\realbackslash tt}
X\def\bf{\realbackslash bf }
X\def\w{\realbackslash w}
X\def\less{\realbackslash less}
X\def\gtr{\realbackslash gtr}
X\def\hat{\realbackslash hat}
X\def\char{\realbackslash char}
X\def\tclose##1{\realbackslash tclose {##1}}
X\def\code##1{\realbackslash code {##1}}
X\def\samp##1{\realbackslash samp {##1}}
X\def\r##1{\realbackslash r {##1}}
X\def\b##1{\realbackslash b {##1}}
X\def\key##1{\realbackslash key {##1}}
X\def\file##1{\realbackslash file {##1}}
X\def\kbd##1{\realbackslash kbd {##1}}
X% These are redefined because @smartitalic wouldn't work inside xdef.
X\def\i##1{\realbackslash i {##1}}
X\def\cite##1{\realbackslash cite {##1}}
X\def\var##1{\realbackslash var {##1}}
X\def\emph##1{\realbackslash emph {##1}}
X\def\dfn##1{\realbackslash dfn {##1}}
X}
X
X\def\thischaptername{No Chapter Title}
X\outer\def\chapter{\parsearg\chapterzzz}
X\def\chapterzzz #1{\seccheck{chapter}%
X\secno=0 \subsecno=0 \subsubsecno=0
X\global\advance \chapno by 1 \message{Chapter \the\chapno}%
X\chapmacro {#1}{\the\chapno}%
X\gdef\thissection{#1}%
X\gdef\thischaptername{#1}%
X% We don't substitute the actual chapter name into \thischapter
X% because we don't want its macros evaluated now.
X\xdef\thischapter{Chapter \the\chapno: \noexpand\thischaptername}%
X{\chapternofonts%
X\edef\temp{{\realbackslash chapentry {#1}{\the\chapno}{\noexpand\folio}}}%
X\escapechar=`\\%
X\write \contentsfile \temp  %
X\donoderef %
X\global\let\section = \numberedsec
X\global\let\subsection = \numberedsubsec
X\global\let\subsubsection = \numberedsubsubsec
X}}
X
X\outer\def\appendix{\parsearg\appendixzzz}
X\def\appendixzzz #1{\seccheck{appendix}%
X\secno=0 \subsecno=0 \subsubsecno=0
X\global\advance \appendixno by 1 \message{Appendix \appendixletter}%
X\chapmacro {#1}{Appendix \appendixletter}%
X\gdef\thissection{#1}%
X\gdef\thischaptername{#1}%
X\xdef\thischapter{Appendix \appendixletter: \noexpand\thischaptername}%
X{\chapternofonts%
X\edef\temp{{\realbackslash chapentry 
X  {#1}{Appendix \appendixletter}{\noexpand\folio}}}%
X\escapechar=`\\%
X\write \contentsfile \temp  %
X\appendixnoderef %
X\global\let\section = \appendixsec
X\global\let\subsection = \appendixsubsec
X\global\let\subsubsection = \appendixsubsubsec
X}}
X
X\outer\def\top{\parsearg\unnumberedzzz}
X\outer\def\unnumbered{\parsearg\unnumberedzzz}
X\def\unnumberedzzz #1{\seccheck{unnumbered}%
X\secno=0 \subsecno=0 \subsubsecno=0 \message{(#1)}
X\unnumbchapmacro {#1}%
X\gdef\thischapter{#1}\gdef\thissection{#1}%
X{\chapternofonts%
X\edef\temp{{\realbackslash unnumbchapentry {#1}{\noexpand\folio}}}%
X\escapechar=`\\%
X\write \contentsfile \temp  %
X\unnumbnoderef %
X\global\let\section = \unnumberedsec
X\global\let\subsection = \unnumberedsubsec
X\global\let\subsubsection = \unnumberedsubsubsec
X}}
X
X\outer\def\numberedsec{\parsearg\seczzz}
X\def\seczzz #1{\seccheck{section}%
X\subsecno=0 \subsubsecno=0 \global\advance \secno by 1 %
X\gdef\thissection{#1}\secheading {#1}{\the\chapno}{\the\secno}%
X{\chapternofonts%
X\edef\temp{{\realbackslash secentry %
X{#1}{\the\chapno}{\the\secno}{\noexpand\folio}}}%
X\escapechar=`\\%
X\write \contentsfile \temp %
X\donoderef %
X\penalty 10000 %
X}}
X
X\outer\def\appendixsection{\parsearg\appendixsectionzzz}
X\outer\def\appendixsec{\parsearg\appendixsectionzzz}
X\def\appendixsectionzzz #1{\seccheck{appendixsection}%
X\subsecno=0 \subsubsecno=0 \global\advance \secno by 1 %
X\gdef\thissection{#1}\secheading {#1}{\appendixletter}{\the\secno}%
X{\chapternofonts%
X\edef\temp{{\realbackslash secentry %
X{#1}{\appendixletter}{\the\secno}{\noexpand\folio}}}%
X\escapechar=`\\%
X\write \contentsfile \temp %
X\appendixnoderef %
X\penalty 10000 %
X}}
X
X\outer\def\unnumberedsec{\parsearg\unnumberedseczzz}
X\def\unnumberedseczzz #1{\seccheck{unnumberedsec}%
X\plainsecheading {#1}\gdef\thissection{#1}%
X{\chapternofonts%
X\edef\temp{{\realbackslash unnumbsecentry{#1}{\noexpand\folio}}}%
X\escapechar=`\\%
X\write \contentsfile \temp %
X\unnumbnoderef %
X\penalty 10000 %
X}}
X
X\outer\def\numberedsubsec{\parsearg\numberedsubseczzz}
X\def\numberedsubseczzz #1{\seccheck{subsection}%
X\gdef\thissection{#1}\subsubsecno=0 \global\advance \subsecno by 1 %
X\subsecheading {#1}{\the\chapno}{\the\secno}{\the\subsecno}%
X{\chapternofonts%
X\edef\temp{{\realbackslash subsecentry %
X{#1}{\the\chapno}{\the\secno}{\the\subsecno}{\noexpand\folio}}}%
X\escapechar=`\\%
X\write \contentsfile \temp %
X\donoderef %
X\penalty 10000 %
X}}
X
X\outer\def\appendixsubsec{\parsearg\appendixsubseczzz}
X\def\appendixsubseczzz #1{\seccheck{appendixsubsec}%
X\gdef\thissection{#1}\subsubsecno=0 \global\advance \subsecno by 1 %
X\subsecheading {#1}{\appendixletter}{\the\secno}{\the\subsecno}%
X{\chapternofonts%
X\edef\temp{{\realbackslash subsecentry %
X{#1}{\appendixletter}{\the\secno}{\the\subsecno}{\noexpand\folio}}}%
X\escapechar=`\\%
X\write \contentsfile \temp %
X\appendixnoderef %
X\penalty 10000 %
X}}
X
X\outer\def\unnumberedsubsec{\parsearg\unnumberedsubseczzz}
X\def\unnumberedsubseczzz #1{\seccheck{unnumberedsubsec}%
X\plainsecheading {#1}\gdef\thissection{#1}%
X{\chapternofonts%
X\edef\temp{{\realbackslash unnumbsubsecentry{#1}{\noexpand\folio}}}%
X\escapechar=`\\%
X\write \contentsfile \temp %
X\unnumbnoderef %
X\penalty 10000 %
X}}
X
X\outer\def\numberedsubsubsec{\parsearg\numberedsubsubseczzz}
X\def\numberedsubsubseczzz #1{\seccheck{subsubsection}%
X\gdef\thissection{#1}\global\advance \subsubsecno by 1 %
X\subsubsecheading {#1}
X  {\the\chapno}{\the\secno}{\the\subsecno}{\the\subsubsecno}%
X{\chapternofonts%
X\edef\temp{{\realbackslash subsubsecentry %
X  {#1}
X  {\the\chapno}{\the\secno}{\the\subsecno}{\the\subsubsecno}
X  {\noexpand\folio}}}%
X\escapechar=`\\%
X\write \contentsfile \temp %
X\donoderef %
X\penalty 10000 %
X}}
X
X\outer\def\appendixsubsubsec{\parsearg\appendixsubsubseczzz}
X\def\appendixsubsubseczzz #1{\seccheck{appendixsubsubsec}%
X\gdef\thissection{#1}\global\advance \subsubsecno by 1 %
X\subsubsecheading {#1}
X  {\appendixletter}{\the\secno}{\the\subsecno}{\the\subsubsecno}%
X{\chapternofonts%
X\edef\temp{{\realbackslash subsubsecentry{#1}%
X  {\appendixletter}
X  {\the\secno}{\the\subsecno}{\the\subsubsecno}{\noexpand\folio}}}%
X\escapechar=`\\%
X\write \contentsfile \temp %
X\appendixnoderef %
X\penalty 10000 %
X}}
X
X\outer\def\unnumberedsubsubsec{\parsearg\unnumberedsubsubseczzz}
X\def\unnumberedsubsubseczzz #1{\seccheck{unnumberedsubsubsec}%
X\plainsecheading {#1}\gdef\thissection{#1}%
X{\chapternofonts%
X\edef\temp{{\realbackslash unnumbsubsubsecentry{#1}{\noexpand\folio}}}%
X\escapechar=`\\%
X\write \contentsfile \temp %
X\unnumbnoderef %
X\penalty 10000 %
X}}
X
X% These are variants which are not "outer", so they can appear in @ifinfo.
X% Actually, they should now be obsolete; ordinary section commands should work.
X\def\infotop{\parsearg\unnumberedzzz}
X\def\infounnumbered{\parsearg\unnumberedzzz}
X\def\infounnumberedsec{\parsearg\unnumberedseczzz}
X\def\infounnumberedsubsec{\parsearg\unnumberedsubseczzz}
X\def\infounnumberedsubsubsec{\parsearg\unnumberedsubsubseczzz}
X
X\def\infoappendix{\parsearg\appendixzzz}
X\def\infoappendixsec{\parsearg\appendixseczzz}
X\def\infoappendixsubsec{\parsearg\appendixsubseczzz}
X\def\infoappendixsubsubsec{\parsearg\appendixsubsubseczzz}
X
X\def\infochapter{\parsearg\chapterzzz}
X\def\infosection{\parsearg\sectionzzz}
X\def\infosubsection{\parsearg\subsectionzzz}
X\def\infosubsubsection{\parsearg\subsubsectionzzz}
X
X% These macros control what the section commands do, according
X% to what kind of chapter we are in (ordinary, appendix, or unnumbered).
X% Define them by default for a numbered chapter.
X\global\let\section = \numberedsec
X\global\let\subsection = \numberedsubsec
X\global\let\subsubsection = \numberedsubsubsec
X
X% Define @majorheading, @heading and @subheading
X
X% NOTE on use of \vbox for chapter headings, section headings, and
X% such:
X%	1) We use \vbox rather than the earlier \line to permit
X%	   overlong headings to fold.
X%	2) \hyphenpenalty is set to 10000 because hyphenation in a
X%	   heading is obnoxious; this forbids it.
X%       3) Likewise, headings look best if no \parindent is used, and
X%          if justification is not attempted.  Hence \raggedright.
X
X
X\def\majorheading{\parsearg\majorheadingzzz}
X\def\majorheadingzzz #1{%
X{\advance\chapheadingskip by 10pt \chapbreak }%
X{\chapfonts \vbox{\hyphenpenalty=10000\tolerance=5000
X                  \parindent=0pt\raggedright
X                  \rm #1\hfill}}\bigskip \par\penalty 200}
X
X\def\chapheading{\parsearg\chapheadingzzz}
X\def\chapheadingzzz #1{\chapbreak %
X{\chapfonts \vbox{\hyphenpenalty=10000\tolerance=5000
X                  \parindent=0pt\raggedright
X                  \rm #1\hfill}}\bigskip \par\penalty 200}
X
X\def\heading{\parsearg\secheadingi}
X
X\def\subheading{\parsearg\subsecheadingi}
X
X\def\subsubheading{\parsearg\subsubsecheadingi}
X
X% These macros generate a chapter, section, etc. heading only
X% (including whitespace, linebreaking, etc. around it),
X% given all the information in convenient, parsed form.
X
X%%% Args are the skip and penalty (usually negative)
X\def\dobreak#1#2{\par\ifdim\lastskip<#1\removelastskip\penalty#2\vskip#1\fi}
X
X\def\setchapterstyle #1 {\csname CHAPF#1\endcsname}
X
X%%% Define plain chapter starts, and page on/off switching for it
X% Parameter controlling skip before chapter headings (if needed)
X
X\newskip \chapheadingskip \chapheadingskip = 30pt plus 8pt minus 4pt
X
X\def\chapbreak{\dobreak \chapheadingskip {-4000}}
X\def\chappager{\par\vfill\supereject}
X\def\chapoddpage{\chappager \ifodd\pageno \else \hbox to 0pt{} \chappager\fi}
X
X\def\setchapternewpage #1 {\csname CHAPPAG#1\endcsname}
X
X\def\CHAPPAGoff{
X\global\let\pchapsepmacro=\chapbreak
X\global\let\pagealignmacro=\chappager}
X
X\def\CHAPPAGon{
X\global\let\pchapsepmacro=\chappager
X\global\let\pagealignmacro=\chappager
X\global\def\HEADINGSon{\HEADINGSsingle}}
X
X\def\CHAPPAGodd{
X\global\let\pchapsepmacro=\chapoddpage
X\global\let\pagealignmacro=\chapoddpage
X\global\def\HEADINGSon{\HEADINGSdouble}}
X
X\CHAPPAGon
X
X\def\CHAPFplain{
X\global\let\chapmacro=\chfplain
X\global\let\unnumbchapmacro=\unnchfplain}
X
X\def\chfplain #1#2{%
X  \pchapsepmacro
X  {%
X    \chapfonts \vbox{\hyphenpenalty=10000\tolerance=5000
X                     \parindent=0pt\raggedright
X                     \rm #2\enspace #1}%
X  }%
X  \bigskip
X  \penalty5000
X}
X
X\def\unnchfplain #1{%
X\pchapsepmacro %
X{\chapfonts \vbox{\hyphenpenalty=10000\tolerance=5000
X                  \parindent=0pt\raggedright
X                  \rm #1\hfill}}\bigskip \par\penalty 10000 %
X}
X\CHAPFplain % The default
X
X\def\unnchfopen #1{%
X\chapoddpage {\chapfonts \vbox{\hyphenpenalty=10000\tolerance=5000
X                       \parindent=0pt\raggedright
X                       \rm #1\hfill}}\bigskip \par\penalty 10000 %
X}
X
X\def\chfopen #1#2{\chapoddpage {\chapfonts
X\vbox to 3in{\vfil \hbox to\hsize{\hfil #2} \hbox to\hsize{\hfil #1} \vfil}}%
X\par\penalty 5000 %
X}
X
X\def\CHAPFopen{
X\global\let\chapmacro=\chfopen
X\global\let\unnumbchapmacro=\unnchfopen}
X
X% Parameter controlling skip before section headings.
X
X\newskip \subsecheadingskip  \subsecheadingskip = 17pt plus 8pt minus 4pt
X\def\subsecheadingbreak{\dobreak \subsecheadingskip {-500}}
X
X\newskip \secheadingskip  \secheadingskip = 21pt plus 8pt minus 4pt
X\def\secheadingbreak{\dobreak \secheadingskip {-1000}}
X
X% @paragraphindent  is defined for the Info formatting commands only.
X\let\paragraphindent=\comment
X
X% Section fonts are the base font at magstep2, which produces
X% a size a bit more than 14 points in the default situation.	
X
X\def\secheading #1#2#3{\secheadingi {#2.#3\enspace #1}}
X\def\plainsecheading #1{\secheadingi {#1}}
X\def\secheadingi #1{{\advance \secheadingskip by \parskip %
X\secheadingbreak}%
X{\secfonts \vbox{\hyphenpenalty=10000\tolerance=5000
X                 \parindent=0pt\raggedright
X                 \rm #1\hfill}}%
X\ifdim \parskip<10pt \kern 10pt\kern -\parskip\fi \penalty 10000 }
X
X
X% Subsection fonts are the base font at magstep1, 
X% which produces a size of 12 points.
X
X\def\subsecheading #1#2#3#4{\subsecheadingi {#2.#3.#4\enspace #1}}
X\def\subsecheadingi #1{{\advance \subsecheadingskip by \parskip %
X\subsecheadingbreak}%
X{\subsecfonts \vbox{\hyphenpenalty=10000\tolerance=5000
X                     \parindent=0pt\raggedright
X                     \rm #1\hfill}}%
X\ifdim \parskip<10pt \kern 10pt\kern -\parskip\fi \penalty 10000 }
X
X\def\subsubsecfonts{\subsecfonts} % Maybe this should change:
X				  % Perhaps make sssec fonts scaled
X				  % magstep half
X\def\subsubsecheading #1#2#3#4#5{\subsubsecheadingi {#2.#3.#4.#5\enspace #1}}
X\def\subsubsecheadingi #1{{\advance \subsecheadingskip by \parskip %
X\subsecheadingbreak}%
X{\subsubsecfonts \vbox{\hyphenpenalty=10000\tolerance=5000
X                       \parindent=0pt\raggedright
X                       \rm #1\hfill}}%
X\ifdim \parskip<10pt \kern 10pt\kern -\parskip\fi \penalty 10000}
X
X
X\message{toc printing,}
X
X% Finish up the main text and prepare to read what we've written
X% to \contentsfile.
X
X\newskip\contentsrightmargin \contentsrightmargin=1in
X\def\startcontents#1{%
X   \pagealignmacro
X   \immediate\closeout \contentsfile
X   \ifnum \pageno>0
X      \pageno = -1		% Request roman numbered pages.
X   \fi
X   % Don't need to put `Contents' or `Short Contents' in the headline. 
X   % It is abundantly clear what they are.
X   \unnumbchapmacro{#1}\def\thischapter{}%
X   \begingroup   		% Set up to handle contents files properly.
X      \catcode`\\=0  \catcode`\{=1  \catcode`\}=2  \catcode`\@=11
X      \raggedbottom             % Worry more about breakpoints than the bottom.
X      \advance\hsize by -\contentsrightmargin % Don't use the full line length.
X}
X
X  
X% Normal (long) toc.
X\outer\def\contents{%
X   \startcontents{Table of Contents}%
X      \input \jobname.toc
X   \endgroup
X   \vfill \eject
X}
X
X% And just the chapters.
X\outer\def\summarycontents{%
X   \startcontents{Short Contents}%
X      %
X      \let\chapentry = \shortchapentry
X      \let\unnumbchapentry = \shortunnumberedentry
X      % We want a true roman here for the page numbers.
X      \secfonts
X      \let\rm=\shortcontrm \let\bf=\shortcontbf \let\sl=\shortcontsl
X      \rm
X      \advance\baselineskip by 1pt % Open it up a little.
X      \def\secentry ##1##2##3##4{}
X      \def\unnumbsecentry ##1##2{}
X      \def\subsecentry ##1##2##3##4##5{}
X      \def\unnumbsubsecentry ##1##2{}
X      \def\subsubsecentry ##1##2##3##4##5##6{}
X      \def\unnumbsubsubsecentry ##1##2{}
X      \input \jobname.toc
X   \endgroup
X   \vfill \eject
X}
X\let\shortcontents = \summarycontents
X
X% These macros generate individual entries in the table of contents.
X% The first argument is the chapter or section name.
X% The last argument is the page number.
X% The arguments in between are the chapter number, section number, ...
X
X% Chapter-level things, for both the long and short contents.
X\def\chapentry#1#2#3{\dochapentry{#2\labelspace#1}{#3}}
X
X% See comments in \dochapentry re vbox and related settings
X\def\shortchapentry#1#2#3{%
X   \vbox{\hyphenpenalty=10000\tolerance=5000
X    \parindent=0pt\strut\raggedright
X    {#2\labelspace #1}\dotfill\doshortpageno{#3}}%
X}
X
X\def\unnumbchapentry#1#2{\dochapentry{#1}{#2}}
X\def\shortunnumberedentry#1#2{%
X   \vbox{\hyphenpenalty=10000\tolerance=5000
X    \parindent=0pt\strut\raggedright
X    #1\dotfill\doshortpageno{#2}}%
X}
X
X% Sections.
X\def\secentry#1#2#3#4{\dosecentry{#2.#3\labelspace#1}{#4}}
X\def\unnumbsecentry#1#2{\dosecentry{#1}{#2}}
X
X% Subsections.
X\def\subsecentry#1#2#3#4#5{\dosubsecentry{#2.#3.#4\labelspace#1}{#5}}
X\def\unnumbsubsecentry#1#2{\dosubsecentry{#1}{#2}}
X
X% And subsubsections.
X\def\subsubsecentry#1#2#3#4#5#6{%
X  \dosubsubsecentry{#2.#3.#4.#5\labelspace#1}{#6}}
X\def\unnumbsubsubsecentry#1#2{\dosubsubsecentry{#1}{#2}}
X
X
X% This parameter controls the indentation of the various levels.
X\newdimen\tocindent \tocindent = 3pc
X
X% Now for the actual typesetting. In all these, #1 is the text and #2 is the 
X% page number.
X%
X% If the toc has to be broken over pages, we would want to be at chapters 
X% if at all possible; hence the \penalty.
X\def\dochapentry#1#2{%
X   \penalty-300 \vskip\baselineskip
X   % This \vbox (and similar ones in dosecentry etc.) used to be a
X   % \line; changed to permit linebreaks for long headings.  See
X   % comments above \majorheading.  Here we also use \strut to
X   % keep the top end of the vbox from jamming up against the previous
X   % entry in the table of contents.
X   \vbox{\chapentryfonts
X     \hyphenpenalty=10000\tolerance=5000 % this line and next introduced
X     \parindent=0pt\strut\raggedright    % with \line -> \vbox change
X     #1\dotfill
X     \dopageno{#2}}%
X   \nobreak\vskip .25\baselineskip
X}
X
X\def\dosecentry#1#2{%
X   \vbox{\secentryfonts \leftskip=\tocindent
X    \hyphenpenalty=10000\tolerance=5000
X    \parindent=0pt\strut\raggedright #1\dotfill
X    \dopageno{#2}}%
X}
X
X\def\dosubsecentry#1#2{%
X   \vbox{\subsecentryfonts \leftskip=2\tocindent
X    \hyphenpenalty=10000\tolerance=5000
X    \parindent=0pt\strut\raggedright #1\dotfill
X    \dopageno{#2}}%
X}
X
X\def\dosubsubsecentry#1#2{%
X   \vbox{\subsubsecentryfonts \leftskip=3\tocindent
X    \hyphenpenalty=10000\tolerance=5000
X    \parindent=0pt\strut\raggedright #1\dotfill
X    \dopageno{#2}}%
X}
X
X% Space between chapter (or whatever) number and the title.
X\def\labelspace{\hskip1em \relax}
X
X\def\dopageno#1{{\rm #1}}
X\def\doshortpageno#1{{\rm #1}}
X
X\def\chapentryfonts{\secfonts \rm}
X\def\secentryfonts{\textfonts}
X\let\subsecentryfonts = \textfonts
X\let\subsubsecentryfonts = \textfonts
X
X
X\message{environments,}
X
X% Since these characters are used in examples, it should be an even number of 
X% \tt widths. Each \tt character is 1en, so two makes it 1em.
X% Furthermore, these definitions must come after we define our fonts.
X\newbox\dblarrowbox    \newbox\longdblarrowbox
X\newbox\pushcharbox    \newbox\bullbox
X\newbox\equivbox       \newbox\errorbox
X
X\let\ptexequiv = \equiv
X
X%{\tentt
X%\global\setbox\dblarrowbox = \hbox to 1em{\hfil$\Rightarrow$\hfil}
X%\global\setbox\longdblarrowbox = \hbox to 1em{\hfil$\mapsto$\hfil}
X%\global\setbox\pushcharbox = \hbox to 1em{\hfil$\dashv$\hfil}
X%\global\setbox\equivbox = \hbox to 1em{\hfil$\ptexequiv$\hfil}
X% Adapted from the manmac format (p.420 of TeXbook)
X%\global\setbox\bullbox = \hbox to 1em{\kern.15em\vrule height .75ex width .85ex
X%                                      depth .1ex\hfil}
X%}
X
X\def\point{$\star$}
X
X\def\result{\leavevmode\raise.15ex\hbox to 1em{\hfil$\Rightarrow$\hfil}}
X\def\expansion{\leavevmode\raise.1ex\hbox to 1em{\hfil$\mapsto$\hfil}}
X\def\print{\leavevmode\lower.1ex\hbox to 1em{\hfil$\dashv$\hfil}}
X
X\def\equiv{\leavevmode\lower.1ex\hbox to 1em{\hfil$\ptexequiv$\hfil}}
X
X% Adapted from the TeXbook's \boxit.
X{\tentt \global\dimen0 = 3em}% Width of the box.
X\dimen2 = .55pt % Thickness of rules
X% The text. (`r' is open on the right, `e' somewhat less so on the left.)
X\setbox0 = \hbox{\kern-.75pt \tensf error\kern-1.5pt}
X
X\global\setbox\errorbox=\hbox to \dimen0{\hfil
X   \hsize = \dimen0 \advance\hsize by -5.8pt % Space to left+right.
X   \advance\hsize by -2\dimen2 % Rules.
X   \vbox{
X      \hrule height\dimen2
X      \hbox{\vrule width\dimen2 \kern3pt          % Space to left of text.
X         \vtop{\kern2.4pt \box0 \kern2.4pt}% Space above/below.
X         \kern3pt\vrule width\dimen2}% Space to right.
X      \hrule height\dimen2}
X    \hfil}
X
X% The @error{} command.
X\def\error{\leavevmode\lower.7ex\copy\errorbox}
X
X% @tex ... @end tex    escapes into raw Tex temporarily.
X% One exception: @ is still an escape character, so that @end tex works.
X% But \@ or @@ will get a plain tex @ character.
X
X\def\tex{\begingroup
X\catcode `\\=0 \catcode `\{=1 \catcode `\}=2
X\catcode `\$=3 \catcode `\&=4 \catcode `\#=6
X\catcode `\^=7 \catcode `\_=8 \catcode `\~=13 \let~=\tie
X\catcode `\%=14
X\catcode 43=12
X\catcode`\"=12
X\catcode`\==12
X\catcode`\|=12
X\catcode`\<=12
X\catcode`\>=12
X\escapechar=`\\
X%
X\let\{=\ptexlbrace
X\let\}=\ptexrbrace
X\let\.=\ptexdot
X\let\*=\ptexstar
X\let\dots=\ptexdots
X\def\@{@}%
X\let\bullet=\ptexbullet
X\let\b=\ptexb \let\c=\ptexc \let\i=\ptexi \let\t=\ptext \let\l=\ptexl
X\let\L=\ptexL
X%
X\let\Etex=\endgroup}
X
X% Define @lisp ... @endlisp.
X% @lisp does a \begingroup so it can rebind things,
X% including the definition of @endlisp (which normally is erroneous).
X
X% Amount to narrow the margins by for @lisp.
X\newskip\lispnarrowing \lispnarrowing=0.4in
X
X% This is the definition that ^M gets inside @lisp
X% phr: changed space to \null, to avoid overfull hbox problems.
X{\obeyspaces%
X\gdef\lisppar{\null\endgraf}}
X
X% Cause \obeyspaces to make each Space cause a word-separation
X% rather than the default which is that it acts punctuation.
X% This is because space in tt font looks funny.
X{\obeyspaces %
X\gdef\sepspaces{\def {\ }}}
X
X\newskip\aboveenvskipamount \aboveenvskipamount= 0pt
X\def\aboveenvbreak{{\advance\aboveenvskipamount by \parskip
X\endgraf \ifdim\lastskip<\aboveenvskipamount
X\removelastskip \penalty-50 \vskip\aboveenvskipamount \fi}}
X
X\def\afterenvbreak{\endgraf \ifdim\lastskip<\aboveenvskipamount
X\removelastskip \penalty-50 \vskip\aboveenvskipamount \fi}
X
X% \nonarrowing is a flag.  If "set", @lisp etc don't narrow margins.
X\let\nonarrowing=\relax
X
X%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
X% \cartouche: draw rectangle w/rounded corners around argument
X\font\circle=lcircle10
X\newdimen\circthick
X\newdimen\cartouter\newdimen\cartinner
X\newskip\normbskip\newskip\normpskip\newskip\normlskip
X\circthick=\fontdimen8\circle
X%
X\def\ctl{{\circle\char'013\hskip -6pt}}% 6pt from pl file: 1/2charwidth
X\def\ctr{{\hskip 6pt\circle\char'010}}
X\def\cbl{{\circle\char'012\hskip -6pt}}
X\def\cbr{{\hskip 6pt\circle\char'011}}
X\def\carttop{\hbox to \cartouter{\hskip\lskip
X	\ctl\leaders\hrule height\circthick\hfil\ctr
X	\hskip\rskip}}
X\def\cartbot{\hbox to \cartouter{\hskip\lskip
X	\cbl\leaders\hrule height\circthick\hfil\cbr
X	\hskip\rskip}}
X%
X\newskip\lskip\newskip\rskip
X
X\long\def\cartouche{%
X\begingroup
X	\lskip=\leftskip \rskip=\rightskip
X	\leftskip=0pt\rightskip=0pt %we want these *outside*.
X	\cartinner=\hsize \advance\cartinner by-\lskip 
X		 	  \advance\cartinner by-\rskip
X	\cartouter=\hsize
X	\advance\cartouter by 18pt % allow for 3pt kerns on either
X%				     side, and for 6pt waste from
X%				     each corner char
X	\normbskip=\baselineskip \normpskip=\parskip \normlskip=\lineskip
X	% Flag to tell @lisp, etc., not to narrow margin.
X	\let\nonarrowing=\comment
X	\vbox\bgroup
X		\baselineskip=0pt\parskip=0pt\lineskip=0pt
X		\carttop
X		\hbox\bgroup
X			\hskip\lskip
X			\vrule\kern3pt
X			\vbox\bgroup
X				\hsize=\cartinner
X				\kern3pt
X				\begingroup
X					\baselineskip=\normbskip
X					\lineskip=\normlskip
X					\parskip=\normpskip
X					\vskip -\parskip
X\def\Ecartouche{%
X				\endgroup
X				\kern3pt
X			\egroup
X			\kern3pt\vrule
X			\hskip\rskip
X		\egroup
X		\cartbot
X	\egroup
X\endgroup
X}}	
X
X\def\lisp{\aboveenvbreak
X\begingroup\inENV % This group ends at the end of the @lisp body
X\hfuzz=12truept % Don't be fussy
X% Make spaces be word-separators rather than space tokens.
X\sepspaces %
X% Single space lines
X\singlespace %
X% The following causes blank lines not to be ignored
X% by adding a space to the end of each line.
X\let\par=\lisppar
X\def\Elisp{\endgroup\afterenvbreak}%
X\parskip=0pt
X% @cartouche defines \nonarrowing to inhibit narrowing
X% at next level down.
X\ifx\nonarrowing\relax
X\advance \leftskip by \lispnarrowing
X\exdentamount=\lispnarrowing
X\let\exdent=\nofillexdent
X\let\nonarrowing=\relax
X\fi
X\parindent=0pt
X\obeyspaces \obeylines \tt \rawbackslash
X\def\next##1{}\next}
X
X
X\let\example=\lisp
X\def\Eexample{\Elisp}
X
X\let\smallexample=\lisp
X\def\Esmallexample{\Elisp}
X
X% Macro for 9 pt. examples, necessary to print with 5" lines.
X% From Pavel@xerox.  This is not really used unless the
X% @smallbook command is given.
X
X\def\smalllispx{\aboveenvbreak\begingroup\inENV
X%			This group ends at the end of the @lisp body
X\hfuzz=12truept % Don't be fussy
X% Make spaces be word-separators rather than space tokens.
X\sepspaces %
X% Single space lines
X\singlespace %
X% The following causes blank lines not to be ignored
X% by adding a space to the end of each line.
X\let\par=\lisppar
X\def\Esmalllisp{\endgroup\afterenvbreak}%
X%%%% Smaller baseline skip for small examples.
X\baselineskip 10pt
X\parskip=0pt
X% @cartouche defines \nonarrowing to inhibit narrowing
X% at next level down.
X\ifx\nonarrowing\relax
X\advance \leftskip by \lispnarrowing
X\exdentamount=\lispnarrowing
X\let\exdent=\nofillexdent
X\let\nonarrowing=\relax
X\fi
X\parindent=0pt
X\obeyspaces \obeylines \ninett \indexfonts \rawbackslash
X\def\next##1{}\next}
X
X% This is @display; same as @lisp except use roman font.
X
X\def\display{\begingroup\inENV %This group ends at the end of the @display body
X\aboveenvbreak
X% Make spaces be word-separators rather than space tokens.
X\sepspaces %
X% Single space lines
X\singlespace %
X% The following causes blank lines not to be ignored
X% by adding a space to the end of each line.
X\let\par=\lisppar
X\def\Edisplay{\endgroup\afterenvbreak}%
X\parskip=0pt
X% @cartouche defines \nonarrowing to inhibit narrowing
X% at next level down.
X\ifx\nonarrowing\relax
X\advance \leftskip by \lispnarrowing
X\exdentamount=\lispnarrowing
X\let\exdent=\nofillexdent
X\let\nonarrowing=\relax
X\fi
X\parindent=0pt
X\obeyspaces \obeylines
X\def\next##1{}\next}
X
X% This is @format; same as @lisp except use roman font and don't narrow margins
X
X\def\format{\begingroup\inENV %This group ends at the end of the @format body
X\aboveenvbreak
X% Make spaces be word-separators rather than space tokens.
X\sepspaces %
X\singlespace %
X% The following causes blank lines not to be ignored
X% by adding a space to the end of each line.
X\let\par=\lisppar
X\def\Eformat{\endgroup\afterenvbreak}
X\parskip=0pt \parindent=0pt
X\obeyspaces \obeylines
X\def\next##1{}\next}
X
X% @flushleft and @flushright
X
X\def\flushleft{%
X\begingroup\inENV %This group ends at the end of the @format body
X\aboveenvbreak
X% Make spaces be word-separators rather than space tokens.
X\sepspaces %
X% The following causes blank lines not to be ignored
X% by adding a space to the end of each line.
X% This also causes @ to work when the directive name
X% is terminated by end of line.
X\let\par=\lisppar
X\def\Eflushleft{\endgroup\afterenvbreak}%
X\parskip=0pt \parindent=0pt
X\obeyspaces \obeylines
X\def\next##1{}\next}
X
X\def\flushright{%
X\begingroup\inENV %This group ends at the end of the @format body
X\aboveenvbreak
X% Make spaces be word-separators rather than space tokens.
X\sepspaces %
X% The following causes blank lines not to be ignored
X% by adding a space to the end of each line.
X% This also causes @ to work when the directive name
X% is terminated by end of line.
X\let\par=\lisppar
X\def\Eflushright{\endgroup\afterenvbreak}%
X\parskip=0pt \parindent=0pt
X\advance \leftskip by 0pt plus 1fill
X\obeyspaces \obeylines
X\def\next##1{}\next}
X
X% @quotation - narrow the margins.
X
X\def\quotation{%
X\begingroup\inENV %This group ends at the end of the @quotation body
X{\parskip=0pt  % because we will skip by \parskip too, later
X\aboveenvbreak}%
X\singlespace
X\parindent=0pt
X\def\Equotation{\par\endgroup\afterenvbreak}%
X% @cartouche defines \nonarrowing to inhibit narrowing
X% at next level down.
X\ifx\nonarrowing\relax
X\advance \leftskip by \lispnarrowing
X\advance \rightskip by \lispnarrowing
X\exdentamount=\lispnarrowing
X\let\nonarrowing=\relax
X\fi}
X
X\message{defuns,}
X% Define formatter for defuns
X% First, allow user to change definition object font (\df) internally
X\def\setdeffont #1 {\csname DEF#1\endcsname}
X
X\newskip\defbodyindent \defbodyindent=.4in
X\newskip\defargsindent \defargsindent=50pt
X\newskip\deftypemargin \deftypemargin=12pt
X\newskip\deflastargmargin \deflastargmargin=18pt
X
X\newcount\parencount
X% define \functionparens, which makes ( and ) and & do special things.
X% \functionparens affects the group it is contained in.
X\def\activeparens{%
X\catcode`\(=\active \catcode`\)=\active \catcode`\&=\active
X\catcode`\[=\active \catcode`\]=\active}
X{\activeparens % Now, smart parens don't turn on until &foo (see \amprm)
X\gdef\functionparens{\boldbrax\let&=\amprm\parencount=0 }
X\gdef\boldbrax{\let(=\opnr\let)=\clnr\let[=\lbrb\let]=\rbrb}
X
X% Definitions of (, ) and & used in args for functions.
X% This is the definition of ( outside of all parentheses.
X\gdef\oprm#1 {{\rm\char`\(}#1 \bf \let(=\opnested %
X\global\advance\parencount by 1 }
X%
X% This is the definition of ( when already inside a level of parens.
X\gdef\opnested{\char`\(\global\advance\parencount by 1 }
X%
X\gdef\clrm{% Print a paren in roman if it is taking us back to depth of 0.
X% also in that case restore the outer-level definition of (.
X\ifnum \parencount=1 {\rm \char `\)}\sl \let(=\oprm \else \char `\) \fi
X\global\advance \parencount by -1 }
X% If we encounter &foo, then turn on ()-hacking afterwards
X\gdef\amprm#1 {{\rm\&#1}\let(=\oprm \let)=\clrm\ }
X%
X\gdef\normalparens{\boldbrax\let&=\ampnr}
X} % End of definition inside \activeparens
X%% These parens (in \boldbrax) actually are a little bolder than the
X%% contained text.  This is especially needed for [ and ]
X\def\opnr{{\sf\char`\(}} \def\clnr{{\sf\char`\)}} \def\ampnr{\&}
X\def\lbrb{{\bf\char`\[}} \def\rbrb{{\bf\char`\]}}
X
X% First, defname, which formats the header line itself.
X% #1 should be the function name.
X% #2 should be the type of definition, such as "Function".
X
X\def\defname #1#2{%
X% Get the values of \leftskip and \rightskip as they were
X% outside the @def...
X\dimen2=\leftskip
X\advance\dimen2 by -\defbodyindent
X\dimen3=\rightskip
X\advance\dimen3 by -\defbodyindent
X\noindent        %
X\setbox0=\hbox{\hskip \deflastargmargin{\rm #2}\hskip \deftypemargin}%
X\dimen0=\hsize \advance \dimen0 by -\wd0 % compute size for first line
X\dimen1=\hsize \advance \dimen1 by -\defargsindent %size for continuations
X\parshape 2 0in \dimen0 \defargsindent \dimen1     %
X% Now output arg 2 ("Function" or some such)
X% ending at \deftypemargin from the right margin,
X% but stuck inside a box of width 0 so it does not interfere with linebreaking
X{% Adjust \hsize to exclude the ambient margins,
X% so that \rightline will obey them.
X\advance \hsize by -\dimen2 \advance \hsize by -\dimen3
X\rlap{\rightline{{\rm #2}\hskip \deftypemargin}}}%
X% Make all lines underfull and no complaints:
X\tolerance=10000 \hbadness=10000    
X\advance\leftskip by -\defbodyindent
X\exdentamount=\defbodyindent
X{\df #1}\enskip        % Generate function name
X}
X
X% Actually process the body of a definition
X% #1 should be the terminating control sequence, such as \Edefun.
X% #2 should be the "another name" control sequence, such as \defunx.
X% #3 should be the control sequence that actually processes the header,
X%    such as \defunheader.
X
X\def\defparsebody #1#2#3{\begingroup\inENV% Environment for definitionbody
X\medbreak %
X% Define the end token that this defining construct specifies
X% so that it will exit this group.
X\def#1{\endgraf\endgroup\medbreak}%
X\def#2{\begingroup\obeylines\activeparens\spacesplit#3}%
X\parindent=0in
X\advance\leftskip by \defbodyindent \advance \rightskip by \defbodyindent
X\exdentamount=\defbodyindent
X\begingroup %
X\catcode 61=\active %
X\obeylines\activeparens\spacesplit#3}
X
X\def\defmethparsebody #1#2#3#4 {\begingroup\inENV %
X\medbreak %
X% Define the end token that this defining construct specifies
X% so that it will exit this group.
X\def#1{\endgraf\endgroup\medbreak}%
X\def#2##1 {\begingroup\obeylines\activeparens\spacesplit{#3{##1}}}%
X\parindent=0in
X\advance\leftskip by \defbodyindent \advance \rightskip by \defbodyindent
X\exdentamount=\defbodyindent
X\begingroup\obeylines\activeparens\spacesplit{#3{#4}}}
X
X\def\defopparsebody #1#2#3#4#5 {\begingroup\inENV %
X\medbreak %
X% Define the end token that this defining construct specifies
X% so that it will exit this group.
X\def#1{\endgraf\endgroup\medbreak}%
X\def#2##1 ##2 {\def#4{##1}%
X\begingroup\obeylines\activeparens\spacesplit{#3{##2}}}%
X\parindent=0in
X\advance\leftskip by \defbodyindent \advance \rightskip by \defbodyindent
X\exdentamount=\defbodyindent
X\begingroup\obeylines\activeparens\spacesplit{#3{#5}}}
X
X% These parsing functions are similar to the preceding ones
X% except that they do not make parens into active characters.
X% These are used for "variables" since they have no arguments.
X
X\def\defvarparsebody #1#2#3{\begingroup\inENV% Environment for definitionbody
X\medbreak %
X% Define the end token that this defining construct specifies
X% so that it will exit this group.
X\def#1{\endgraf\endgroup\medbreak}%
X\def#2{\begingroup\obeylines\spacesplit#3}%
X\parindent=0in
X\advance\leftskip by \defbodyindent \advance \rightskip by \defbodyindent
X\exdentamount=\defbodyindent
X\begingroup %
X\catcode 61=\active %
X\obeylines\spacesplit#3}
X
X\def\defvrparsebody #1#2#3#4 {\begingroup\inENV %
X\medbreak %
X% Define the end token that this defining construct specifies
X% so that it will exit this group.
X\def#1{\endgraf\endgroup\medbreak}%
X\def#2##1 {\begingroup\obeylines\spacesplit{#3{##1}}}%
X\parindent=0in
X\advance\leftskip by \defbodyindent \advance \rightskip by \defbodyindent
X\exdentamount=\defbodyindent
X\begingroup\obeylines\spacesplit{#3{#4}}}
X
X\def\defopvarparsebody #1#2#3#4#5 {\begingroup\inENV %
X\medbreak %
X% Define the end token that this defining construct specifies
X% so that it will exit this group.
X\def#1{\endgraf\endgroup\medbreak}%
X\def#2##1 ##2 {\def#4{##1}%
X\begingroup\obeylines\spacesplit{#3{##2}}}%
X\parindent=0in
X\advance\leftskip by \defbodyindent \advance \rightskip by \defbodyindent
X\exdentamount=\defbodyindent
X\begingroup\obeylines\spacesplit{#3{#5}}}
X
X% Split up #2 at the first space token.
X% call #1 with two arguments:
X%  the first is all of #2 before the space token,
X%  the second is all of #2 after that space token.
X% If #2 contains no space token, all of it is passed as the first arg
X% and the second is passed as empty.
X
X{\obeylines
X\gdef\spacesplit#1#2^^M{\endgroup\spacesplitfoo{#1}#2 \relax\spacesplitfoo}%
X\long\gdef\spacesplitfoo#1#2 #3#4\spacesplitfoo{%
X\ifx\relax #3%
X#1{#2}{}\else #1{#2}{#3#4}\fi}}
X
X% So much for the things common to all kinds of definitions.
X
X% Define @defun.
X
X% First, define the processing that is wanted for arguments of \defun
X% Use this to expand the args and terminate the paragraph they make up
X
X\def\defunargs #1{\functionparens \sl
X% Expand, preventing hyphenation at `-' chars.
X% Note that groups don't affect changes in \hyphenchar.
X\hyphenchar\tensl=0
X#1%
X\hyphenchar\tensl=45
X\ifnum\parencount=0 \else \errmessage{unbalanced parens in @def arguments}\fi%
X\interlinepenalty=10000
X\advance\rightskip by 0pt plus 1fil
X\endgraf\penalty 10000\vskip -\parskip\penalty 10000%
X}
X
X\def\deftypefunargs #1{%
X% Expand, preventing hyphenation at `-' chars.
X% Note that groups don't affect changes in \hyphenchar.
X\functionparens
X\code{#1}%
X\interlinepenalty=10000
X\advance\rightskip by 0pt plus 1fil
X\endgraf\penalty 10000\vskip -\parskip\penalty 10000%
X}
X
X% Do complete processing of one @defun or @defunx line already parsed.
X
X% @deffn Command forward-char nchars
X
X\def\deffn{\defmethparsebody\Edeffn\deffnx\deffnheader}
X
X\def\deffnheader #1#2#3{\doind {fn}{\code{#2}}%
X\begingroup\defname {#2}{#1}\defunargs{#3}\endgroup %
X\catcode 61=\other % Turn off change made in \defparsebody
X}
X
X% @defun == @deffn Function
X
X\def\defun{\defparsebody\Edefun\defunx\defunheader}
X
X\def\defunheader #1#2{\doind {fn}{\code{#1}}% Make entry in function index
X\begingroup\defname {#1}{Function}%
X\defunargs {#2}\endgroup %
X\catcode 61=\other % Turn off change made in \defparsebody
X}
X
X% @deftypefun int foobar (int @var{foo}, float @var{bar})
X
X\def\deftypefun{\defparsebody\Edeftypefun\deftypefunx\deftypefunheader}
X
X% #1 is the data type.  #2 is the name and args.
X\def\deftypefunheader #1#2{\deftypefunheaderx{#1}#2 \relax}
X% #1 is the data type, #2 the name, #3 the args.
X\def\deftypefunheaderx #1#2 #3\relax{%
X\doind {fn}{\code{#2}}% Make entry in function index
X\begingroup\defname {\code{#1} #2}{Function}%
X\deftypefunargs {#3}\endgroup %
X\catcode 61=\other % Turn off change made in \defparsebody
X}
X
X% @deftypefn {Library Function} int foobar (int @var{foo}, float @var{bar})
X
X\def\deftypefn{\defmethparsebody\Edeftypefn\deftypefnx\deftypefnheader}
X
X% #1 is the classification.  #2 is the data type.  #3 is the name and args.
X\def\deftypefnheader #1#2#3{\deftypefnheaderx{#1}{#2}#3 \relax}
X% #1 is the classification, #2 the data type, #3 the name, #4 the args.
X\def\deftypefnheaderx #1#2#3 #4\relax{%
X\doind {fn}{\code{#3}}% Make entry in function index
X\begingroup\defname {\code{#2} #3}{#1}%
X\deftypefunargs {#4}\endgroup %
X\catcode 61=\other % Turn off change made in \defparsebody
X}
X
X% @defmac == @deffn Macro
X
X\def\defmac{\defparsebody\Edefmac\defmacx\defmacheader}
X
X\def\defmacheader #1#2{\doind {fn}{\code{#1}}% Make entry in function index
X\begingroup\defname {#1}{Macro}%
X\defunargs {#2}\endgroup %
X\catcode 61=\other % Turn off change made in \defparsebody
X}
X
X% @defspec == @deffn Special Form
X
X\def\defspec{\defparsebody\Edefspec\defspecx\defspecheader}
X
X\def\defspecheader #1#2{\doind {fn}{\code{#1}}% Make entry in function index
X\begingroup\defname {#1}{Special Form}%
X\defunargs {#2}\endgroup %
X\catcode 61=\other % Turn off change made in \defparsebody
X}
X
X% This definition is run if you use @defunx
X% anywhere other than immediately after a @defun or @defunx.
X
X\def\deffnx #1 {\errmessage{@deffnx in invalid context}}
X\def\defunx #1 {\errmessage{@defunx in invalid context}}
X\def\defmacx #1 {\errmessage{@defmacx in invalid context}}
X\def\defspecx #1 {\errmessage{@defspecx in invalid context}}
X\def\deftypefnx #1 {\errmessage{@deftypefnx in invalid context}}
X\def\deftypeunx #1 {\errmessage{@deftypeunx in invalid context}}
X
X% @defmethod, and so on
X
X% @defop {Funny Method} foo-class frobnicate argument
X
X\def\defop #1 {\def\defoptype{#1}%
X\defopparsebody\Edefop\defopx\defopheader\defoptype}
X
X\def\defopheader #1#2#3{%
X\dosubind {fn}{\code{#2}}{on #1}% Make entry in function index
X\begingroup\defname {#2}{\defoptype{} on #1}%
X\defunargs {#3}\endgroup %
X}
X
X% @defmethod == @defop Method
X
X\def\defmethod{\defmethparsebody\Edefmethod\defmethodx\defmethodheader}
X
X\def\defmethodheader #1#2#3{%
X\dosubind {fn}{\code{#2}}{on #1}% entry in function index
X\begingroup\defname {#2}{Method on #1}%
X\defunargs {#3}\endgroup %
X}
X
X% @defcv {Class Option} foo-class foo-flag
X
X\def\defcv #1 {\def\defcvtype{#1}%
X\defopvarparsebody\Edefcv\defcvx\defcvarheader\defcvtype}
X
X\def\defcvarheader #1#2#3{%
X\dosubind {vr}{\code{#2}}{of #1}% Make entry in var index
X\begingroup\defname {#2}{\defcvtype{} of #1}%
X\defvarargs {#3}\endgroup %
X}
X
X% @defivar == @defcv {Instance Variable}
X
X\def\defivar{\defvrparsebody\Edefivar\defivarx\defivarheader}
X
X\def\defivarheader #1#2#3{%
X\dosubind {vr}{\code{#2}}{of #1}% Make entry in var index
X\begingroup\defname {#2}{Instance Variable of #1}%
X\defvarargs {#3}\endgroup %
X}
X
X% These definitions are run if you use @defmethodx, etc.,
X% anywhere other than immediately after a @defmethod, etc.
X
X\def\defopx #1 {\errmessage{@defopx in invalid context}}
X\def\defmethodx #1 {\errmessage{@defmethodx in invalid context}}
X\def\defcvx #1 {\errmessage{@defcvx in invalid context}}
X\def\defivarx #1 {\errmessage{@defivarx in invalid context}}
X
X% Now @defvar
X
X% First, define the processing that is wanted for arguments of @defvar.
X% This is actually simple: just print them in roman.
X% This must expand the args and terminate the paragraph they make up
X\def\defvarargs #1{\normalparens #1%
X\interlinepenalty=10000
X\endgraf\penalty 10000\vskip -\parskip\penalty 10000}
X
X% @defvr Counter foo-count
X
X\def\defvr{\defvrparsebody\Edefvr\defvrx\defvrheader}
X
X\def\defvrheader #1#2#3{\doind {vr}{\code{#2}}%
X\begingroup\defname {#2}{#1}\defvarargs{#3}\endgroup}
X
X% @defvar == @defvr Variable
X
X\def\defvar{\defvarparsebody\Edefvar\defvarx\defvarheader}
X
X\def\defvarheader #1#2{\doind {vr}{\code{#1}}% Make entry in var index
X\begingroup\defname {#1}{Variable}%
X\defvarargs {#2}\endgroup %
X}
X
X% @defopt == @defvr {User Option}
X
X\def\defopt{\defvarparsebody\Edefopt\defoptx\defoptheader}
X
X\def\defoptheader #1#2{\doind {vr}{\code{#1}}% Make entry in var index
X\begingroup\defname {#1}{User Option}%
X\defvarargs {#2}\endgroup %
X}
X
X% @deftypevar int foobar
X
X\def\deftypevar{\defvarparsebody\Edeftypevar\deftypevarx\deftypevarheader}
X
X% #1 is the data type.  #2 is the name.
X\def\deftypevarheader #1#2{%
X\doind {vr}{\code{#2}}% Make entry in variables index
X\begingroup\defname {\code{#1} #2}{Variable}%
X\interlinepenalty=10000
X\endgraf\penalty 10000\vskip -\parskip\penalty 10000
X\endgroup}
X
X% @deftypevr {Global Flag} int enable
X
X\def\deftypevr{\defvrparsebody\Edeftypevr\deftypevrx\deftypevrheader}
X
X\def\deftypevrheader #1#2#3{\doind {vr}{\code{#3}}%
X\begingroup\defname {\code{#2} #3}{#1}
X\interlinepenalty=10000
X\endgraf\penalty 10000\vskip -\parskip\penalty 10000
X\endgroup}
X
X% This definition is run if you use @defvarx
X% anywhere other than immediately after a @defvar or @defvarx.
X
X\def\defvrx #1 {\errmessage{@defvrx in invalid context}}
X\def\defvarx #1 {\errmessage{@defvarx in invalid context}}
X\def\defoptx #1 {\errmessage{@defoptx in invalid context}}
X\def\deftypevarx #1 {\errmessage{@deftypevarx in invalid context}}
X\def\deftypevrx #1 {\errmessage{@deftypevrx in invalid context}}
X
X% Now define @deftp
X% Args are printed in bold, a slight difference from @defvar.
X
X\def\deftpargs #1{\bf \defvarargs{#1}}
X
X% @deftp Class window height width ...
X
X\def\deftp{\defvrparsebody\Edeftp\deftpx\deftpheader}
X
X\def\deftpheader #1#2#3{\doind {tp}{\code{#2}}%
X\begingroup\defname {#2}{#1}\deftpargs{#3}\endgroup}
X
X% This definition is run if you use @deftpx, etc
X% anywhere other than immediately after a @deftp, etc.
X
X\def\deftpx #1 {\errmessage{@deftpx in invalid context}}
X
X\message{cross reference,}
X% Define cross-reference macros
X\newwrite \auxfile
X
X\newif\ifhavexrefs  % True if xref values are known.
X\newif\ifwarnedxrefs  % True if we warned once that they aren't known.
X
X% \setref{foo} defines a cross-reference point named foo.
X
X\def\setref#1{%
X%\dosetq{#1-title}{Ytitle}%
X\dosetq{#1-pg}{Ypagenumber}%
X\dosetq{#1-snt}{Ysectionnumberandtype}}
X
X\def\unnumbsetref#1{%
X%\dosetq{#1-title}{Ytitle}%
X\dosetq{#1-pg}{Ypagenumber}%
X\dosetq{#1-snt}{Ynothing}}
X
X\def\appendixsetref#1{%
X%\dosetq{#1-title}{Ytitle}%
X\dosetq{#1-pg}{Ypagenumber}%
X\dosetq{#1-snt}{Yappendixletterandtype}}
X
X% \xref, \pxref, and \ref generate cross-references to specified points.
X% For \xrefX, #1 is the node name, #2 the name of the Info
X% cross-reference, #3 the printed node name, #4 the name of the Info
X% file, #5 the name of the printed manual.  All but the node name can be
X% omitted.
X% 
X\def\pxref#1{see \xrefX[#1,,,,,,,]}
X\def\xref#1{See \xrefX[#1,,,,,,,]}
X\def\ref#1{\xrefX[#1,,,,,,,]}
X\def\xrefX[#1,#2,#3,#4,#5,#6]{\begingroup%
X\def\printedmanual{\ignorespaces #5}%
X\def\printednodename{\ignorespaces #3}%
X%
X\setbox1=\hbox{\printedmanual}%
X\setbox0=\hbox{\printednodename}%
X\ifdim \wd0=0pt%
X\def\printednodename{\ignorespaces #1}%
X%%% Uncommment the following line to make the actual chapter or section title
X%%% appear inside the square brackets.
X%\def\printednodename{#1-title}%
X\fi%
X%
X%
X% If we use \unhbox0 and \unhbox1 to print the node names, TeX does
X% not insert empty discretionaries after hyphens, which means that it
X% will not find a line break at a hyphen in a node names.  Since some
X% manuals are best written with fairly long node names, containing
X% hyphens, this is a loss.  Therefore, we simply give the text of
X% the node name again, so it is as if TeX is seeing it for the first
X% time.
X\ifdim \wd1>0pt
Xsection ``\printednodename'' in \cite{\printedmanual}%
X\else%
X\turnoffactive%
X\refx{#1-snt}{} [\printednodename], page\tie\refx{#1-pg}{}%
X\fi
X\endgroup}
X
X% \dosetq is the interface for calls from other macros
X
X% Use \turnoffactive so that punctuation chars such as underscore
X% work in node names.
X\def\dosetq #1#2{{\let\folio=0 \turnoffactive%
X\edef\next{\write\auxfile{\internalsetq {#1}{#2}}}%
X\next}}
X
X% \internalsetq {foo}{page} expands into
X% CHARACTERS 'xrdef {foo}{...expansion of \Ypage...}
X% When the aux file is read, ' is the escape character
X
X\def\internalsetq #1#2{'xrdef {#1}{\csname #2\endcsname}}
X
X% Things to be expanded by \internalsetq
X
X\def\Ypagenumber{\folio}
X
X\def\Ytitle{\thischapter}
X
X\def\Ynothing{}
X
X\def\Ysectionnumberandtype{%
X\ifnum\secno=0 Chapter\xreftie\the\chapno %
X\else \ifnum \subsecno=0 Section\xreftie\the\chapno.\the\secno %
X\else \ifnum \subsubsecno=0 %
XSection\xreftie\the\chapno.\the\secno.\the\subsecno %
X\else %
XSection\xreftie\the\chapno.\the\secno.\the\subsecno.\the\subsubsecno %
X\fi \fi \fi }
X
X\def\Yappendixletterandtype{%
X\ifnum\secno=0 Appendix\xreftie'char\the\appendixno{}%
X\else \ifnum \subsecno=0 Section\xreftie'char\the\appendixno.\the\secno %
X\else \ifnum \subsubsecno=0 %
XSection\xreftie'char\the\appendixno.\the\secno.\the\subsecno %
X\else %
XSection\xreftie'char\the\appendixno.\the\secno.\the\subsecno.\the\subsubsecno %
X\fi \fi \fi }
X
X\gdef\xreftie{'tie}
X
X% Use TeX 3.0's \inputlineno to get the line number, for better error
X% messages, but if we're using an old version of TeX, don't do anything.
X% 
X\ifx\inputlineno\thisisundefined
X  \let\linenumber = \empty % Non-3.0.
X\else
X  \def\linenumber{\the\inputlineno:\space}
X\fi
X
X% Define \refx{NAME}{SUFFIX} to reference a cross-reference string named NAME.
X% If its value is nonempty, SUFFIX is output afterward.
X
X\def\refx#1#2{%
X  \expandafter\ifx\csname X#1\endcsname\relax
X    % If not defined, say something at least.
X    $\langle$un\-de\-fined$\rangle$%
X    \ifhavexrefs
X      \message{\linenumber Undefined cross reference `#1'.}%
X    \else
X      \ifwarnedxrefs\else
X        \global\warnedxrefstrue
X        \message{Cross reference values unknown; you must run TeX again.}%
X      \fi
X    \fi
X  \else
X    % It's defined, so just use it.
X    \csname X#1\endcsname
X  \fi
X  #2% Output the suffix in any case.
X}
X
X% Read the last existing aux file, if any.  No error if none exists.
X
X% This is the macro invoked by entries in the aux file.
X\def\xrdef #1#2{
X{\catcode`\'=\other\expandafter \gdef \csname X#1\endcsname {#2}}}
X
X\def\readauxfile{%
X\begingroup
X\catcode `\^^@=\other
X\catcode `\=\other
X\catcode `\=\other
X\catcode `\^^C=\other
X\catcode `\^^D=\other
X\catcode `\^^E=\other
X\catcode `\^^F=\other
X\catcode `\^^G=\other
X\catcode `\^^H=\other
X\catcode `\=\other
X\catcode `\^^L=\other
X\catcode `\=\other
X\catcode `\=\other
X\catcode `\=\other
X\catcode `\=\other
X\catcode `\=\other
X\catcode `\=\other
X\catcode `\=\other
X\catcode `\=\other
X\catcode `\=\other
X\catcode `\=\other
X\catcode `\=\other
X\catcode `\=\other
X\catcode 26=\other
X\catcode `\^^[=\other
X\catcode `\^^\=\other
X\catcode `\^^]=\other
X\catcode `\^^^=\other
X\catcode `\^^_=\other
X\catcode `\@=\other
X\catcode `\^=\other
X\catcode `\~=\other
X\catcode `\[=\other
X\catcode `\]=\other
X\catcode`\"=\other
X\catcode`\_=\other
X\catcode`\|=\other
X\catcode`\<=\other
X\catcode`\>=\other
X\catcode `\$=\other
X\catcode `\#=\other
X\catcode `\&=\other
X% the aux file uses ' as the escape.
X% Turn off \ as an escape so we do not lose on
X% entries which were dumped with control sequences in their names.
X% For example, 'xrdef {$\leq $-fun}{page ...} made by @defun ^^
X% Reference to such entries still does not work the way one would wish,
X% but at least they do not bomb out when the aux file is read in.
X\catcode `\{=1 \catcode `\}=2
X\catcode `\%=\other
X\catcode `\'=0
X\catcode `\\=\other
X\openin 1 \jobname.aux
X\ifeof 1 \else \closein 1 \input \jobname.aux \global\havexrefstrue
X\fi
X% Open the new aux file.  Tex will close it automatically at exit.
X\openout \auxfile=\jobname.aux
X\endgroup}
X
X
X% Footnotes.
X
X\newcount \footnoteno
X
X% The trailing space in the following definition for supereject is
X% vital for proper filling; pages come out unaligned when you do a
X% pagealignmacro call if that space before the closing brace is
X% removed.
X\def\supereject{\par\penalty -20000\footnoteno =0 }
X
X% @footnotestyle is meaningful for info output only..
X\let\footnotestyle=\comment
X
X\let\ptexfootnote=\footnote
X
X{\catcode `\@=11
X\long\gdef\footnote #1{\global\advance \footnoteno by \@ne
X\unskip
X\edef\thisfootno{$^{\the\footnoteno}$}%
X\let\@sf\empty
X\ifhmode\edef\@sf{\spacefactor\the\spacefactor}\/\fi
X\thisfootno\@sf \footnotezzz{#1}}
X% \parsearg\footnotezzz}
X
X\long\gdef\footnotezzz #1{\insert\footins{
X\interlinepenalty\interfootnotelinepenalty
X\splittopskip\ht\strutbox % top baseline for broken footnotes
X\splitmaxdepth\dp\strutbox \floatingpenalty\@MM
X\leftskip\z@skip \rightskip\z@skip \spaceskip\z@skip \xspaceskip\z@skip
X\footstrut\parindent=\defaultparindent\hang\textindent{\thisfootno}#1\strut}}
X
X}%end \catcode `\@=11
X
X% End of control word definitions.
X
X\message{and turning on texinfo input format.}
X
X\def\openindices{%
X   \newindex{cp}%
X   \newcodeindex{fn}%
X   \newcodeindex{vr}%
X   \newcodeindex{tp}%
X   \newcodeindex{ky}%
X   \newcodeindex{pg}%
X}
X
X% Set some numeric style parameters, for 8.5 x 11 format.
X
X%\hsize = 6.5in
X\newdimen\defaultparindent \defaultparindent = 15pt
X\parindent = \defaultparindent
X\parskip 18pt plus 1pt
X\baselineskip 15pt
X\advance\topskip by 1.2cm
X
X% Prevent underfull vbox error messages.
X\vbadness=10000
X
X% Following George Bush, just get rid of widows and orphans.
X\widowpenalty=10000
X\clubpenalty=10000
X
X% Use TeX 3.0's \emergencystretch to help line breaking, but if we're
X% using an old version of TeX, don't do anything.  We want the amount of
X% stretch added to depend on the line length, hence the dependence on
X% \hsize.  This makes it come to about 9pt for the 8.5x11 format.
X% 
X\ifx\emergencystretch\thisisundefined \else
X  \emergencystretch = \hsize
X  \divide\emergencystretch by 45
X\fi
X
X% Use @smallbook to reset parameters for 7x9.5 format  (or else 7x9.25)
X\def\smallbook{
X\global\lispnarrowing = 0.3in
X\global\baselineskip 12pt
X\advance\topskip by -1cm
X\global\parskip 3pt plus 1pt
X\global\hsize = 5in
X\global\doublecolumnhsize=2.4in \global\doublecolumnvsize=15.0in
X\global\vsize=7.5in
X\global\tolerance=700
X\global\hfuzz=1pt
X\global\contentsrightmargin=0pt
X
X\global\pagewidth=\hsize
X\global\pageheight=\vsize
X
X\global\let\smalllisp=\smalllispx
X\global\let\smallexample=\smalllispx
X\global\def\Esmallexample{\Esmalllisp}
X}
X
X% Use @afourpaper to print on European A4 paper.
X\def\afourpaper{
X\global\tolerance=700
X\global\hfuzz=1pt
X\global\baselineskip=12pt
X\global\parskip 15pt plus 1pt
X
X\global\vsize= 53\baselineskip
X\advance\vsize by \topskip
X%\global\hsize=   5.85in     % A4 wide 10pt
X\global\hsize=  6.5in
X\global\outerhsize=\hsize
X\global\advance\outerhsize by 0.5in
X\global\outervsize=\vsize
X\global\advance\outervsize by 0.6in
X\global\doublecolumnhsize=\hsize
X\global\divide\doublecolumnhsize by 2
X\global\advance\doublecolumnhsize by -0.1in
X\global\doublecolumnvsize=\vsize
X\global\multiply\doublecolumnvsize by 2
X\global\advance\doublecolumnvsize by 0.1in
X
X\global\pagewidth=\hsize
X\global\pageheight=\vsize
X}
X
X%% For a final copy, take out the rectangles
X%% that mark overfull boxes (in case you have decided
X%% that the text looks ok even though it passes the margin).
X\def\finalout{\overfullrule=0pt}
X
X% Define macros to output various characters with catcode for normal text.
X\catcode`\"=\other
X\catcode`\~=\other
X\catcode`\^=\other
X\catcode`\_=\other
X\catcode`\|=\other
X\catcode`\<=\other
X\catcode`\>=\other
X\catcode`\+=\other
X\def\normaldoublequote{"}
X\def\normaltilde{~}
X\def\normalcaret{^}
X\def\normalunderscore{_}
X\def\normalverticalbar{|}
X\def\normalless{<}
X\def\normalgreater{>}
X\def\normalplus{+}
X
X% This macro is used to make a character print one way in ttfont
X% where it can probably just be output, and another way in other fonts,
X% where something hairier probably needs to be done.
X%
X% #1 is what to print if we are indeed using \tt; #2 is what to print
X% otherwise.  Since all the Computer Modern typewriter fonts have zero
X% interword stretch (and shrink), and it is reasonable to expect all
X% typewriter fonts to have this, we can check that font parameter.
X% 
X\def\ifusingtt#1#2{\ifdim \fontdimen3\the\font=0pt #1\else #2\fi}
X
X% Turn off all special characters except @
X% (and those which the user can use as if they were ordinary).
X% Most of these we simply print from the \tt font, but for some, we can
X% use math or other variants that look better in normal text.
X
X\catcode`\"=\active
X\def\activedoublequote{{\tt \char '042}}
X\let"=\activedoublequote
X\catcode`\~=\active
X\def~{{\tt \char '176}}
X\chardef\hat=`\^
X\catcode`\^=\active
X\def^{{\tt \hat}}
X
X\catcode`\_=\active
X\def_{\ifusingtt\normalunderscore\_}
X% Subroutine for the previous macro.
X\def\_{\lvvmode \kern.06em \vbox{\hrule width.3em height.1ex}}
X
X% \lvvmode is equivalent in function to \leavevmode.
X% Using \leavevmode runs into trouble when written out to
X% an index file due to the expansion of \leavevmode into ``\unhbox
X% \voidb@x'' ---which looks to TeX like ``\unhbox \voidb\x'' due to our
X% magic tricks with @.
X\def\lvvmode{\vbox to 0pt{}}
X
X\catcode`\|=\active
X\def|{{\tt \char '174}}
X\chardef \less=`\<
X\catcode`\<=\active
X\def<{{\tt \less}}
X\chardef \gtr=`\>
X\catcode`\>=\active
X\def>{{\tt \gtr}}
X\catcode`\+=\active
X\def+{{\tt \char 43}}
X%\catcode 27=\active
X%\def^^[{$\diamondsuit$}
X
X% Used sometimes to turn off (effectively) the active characters
X% even after parsing them.
X\def\turnoffactive{\let"=\normaldoublequote
X\let~=\normaltilde
X\let^=\normalcaret
X\let_=\normalunderscore
X\let|=\normalverticalbar
X\let<=\normalless
X\let>=\normalgreater
X\let+=\normalplus}
X
X% Set up an active definition for =, but don't enable it most of the time.
X{\catcode`\==\active
X\global\def={{\tt \char 61}}}
X
X\catcode`\@=0
X
X% \rawbackslashxx output one backslash character in current font
X\global\chardef\rawbackslashxx=`\\
X%{\catcode`\\=\other
X%@gdef@rawbackslashxx{\}}
X
X% \rawbackslash redefines \ as input to do \rawbackslashxx.
X{\catcode`\\=\active
X@gdef@rawbackslash{@let\=@rawbackslashxx }}
X
X% \normalbackslash outputs one backslash in fixed width font.
X\def\normalbackslash{{\tt\rawbackslashxx}}
X
X% Say @foo, not \foo, in error messages.
X\escapechar=`\@
X
X% \catcode 17=0   % Define control-q
X\catcode`\\=\active
X
X% If a .fmt file is being used, we don't want the `\input texinfo' to show up.
X% That is what \eatinput is for; after that, the `\' should revert to printing 
X% a backslash.
X%
X@gdef@eatinput input texinfo{@fixbackslash}
X@global@let\ = @eatinput
X
X% On the other hand, perhaps the file did not have a `\input texinfo'. Then
X% the first `\{ in the file would cause an error. This macro tries to fix 
X% that, assuming it is called before the first `\' could plausibly occur.
X% 
X@gdef@fixbackslash{@ifx\@eatinput @let\ = @normalbackslash @fi}
X
X%% These look ok in all fonts, so just make them not special.  The @rm below
X%% makes sure that the current font starts out as the newly loaded cmr10
X@catcode`@$=@other @catcode`@%=@other @catcode`@&=@other @catcode`@#=@other
X
X@textfonts
X@rm
X
X@c Local variables:
X@c page-delimiter: "^\\\\message"
X@c End:
END_OF_FILE
echo shar: 14 control characters may be missing from \"'gzip-1.2.2/texinfo.tex'\"
if test 108872 -ne `wc -c <'gzip-1.2.2/texinfo.tex'`; then
    echo shar: \"'gzip-1.2.2/texinfo.tex'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/texinfo.tex'
fi
if test -f 'gzip-1.2.2/gpl.texinfo' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/gpl.texinfo'\"
else
echo shar: Extracting \"'gzip-1.2.2/gpl.texinfo'\" \(18317 characters\)
sed "s/^X//" >'gzip-1.2.2/gpl.texinfo' <<'END_OF_FILE'
X@setfilename gpl.info
X
X@unnumbered GNU GENERAL PUBLIC LICENSE
X@center Version 2, June 1991
X
X@display
XCopyright @copyright{} 1989, 1991 Free Software Foundation, Inc.
X675 Mass Ave, Cambridge, MA 02139, USA
X
XEveryone is permitted to copy and distribute verbatim copies
Xof this license document, but changing it is not allowed.
X@end display
X
X@unnumberedsec Preamble
X
X  The licenses for most software are designed to take away your
Xfreedom to share and change it.  By contrast, the GNU General Public
XLicense is intended to guarantee your freedom to share and change free
Xsoftware---to make sure the software is free for all its users.  This
XGeneral Public License applies to most of the Free Software
XFoundation's software and to any other program whose authors commit to
Xusing it.  (Some other Free Software Foundation software is covered by
Xthe GNU Library General Public License instead.)  You can apply it to
Xyour programs, too.
X
X  When we speak of free software, we are referring to freedom, not
Xprice.  Our General Public Licenses are designed to make sure that you
Xhave the freedom to distribute copies of free software (and charge for
Xthis service if you wish), that you receive source code or can get it
Xif you want it, that you can change the software or use pieces of it
Xin new free programs; and that you know you can do these things.
X
X  To protect your rights, we need to make restrictions that forbid
Xanyone to deny you these rights or to ask you to surrender the rights.
XThese restrictions translate to certain responsibilities for you if you
Xdistribute copies of the software, or if you modify it.
X
X  For example, if you distribute copies of such a program, whether
Xgratis or for a fee, you must give the recipients all the rights that
Xyou have.  You must make sure that they, too, receive or can get the
Xsource code.  And you must show them these terms so they know their
Xrights.
X
X  We protect your rights with two steps: (1) copyright the software, and
X(2) offer you this license which gives you legal permission to copy,
Xdistribute and/or modify the software.
X
X  Also, for each author's protection and ours, we want to make certain
Xthat everyone understands that there is no warranty for this free
Xsoftware.  If the software is modified by someone else and passed on, we
Xwant its recipients to know that what they have is not the original, so
Xthat any problems introduced by others will not reflect on the original
Xauthors' reputations.
X
X  Finally, any free program is threatened constantly by software
Xpatents.  We wish to avoid the danger that redistributors of a free
Xprogram will individually obtain patent licenses, in effect making the
Xprogram proprietary.  To prevent this, we have made it clear that any
Xpatent must be licensed for everyone's free use or not licensed at all.
X
X  The precise terms and conditions for copying, distribution and
Xmodification follow.
X
X@iftex
X@unnumberedsec TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
X@end iftex
X@ifinfo
X@center TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
X@end ifinfo
X
X@enumerate
X@item
XThis License applies to any program or other work which contains
Xa notice placed by the copyright holder saying it may be distributed
Xunder the terms of this General Public License.  The ``Program'', below,
Xrefers to any such program or work, and a ``work based on the Program''
Xmeans either the Program or any derivative work under copyright law:
Xthat is to say, a work containing the Program or a portion of it,
Xeither verbatim or with modifications and/or translated into another
Xlanguage.  (Hereinafter, translation is included without limitation in
Xthe term ``modification''.)  Each licensee is addressed as ``you''.
X
XActivities other than copying, distribution and modification are not
Xcovered by this License; they are outside its scope.  The act of
Xrunning the Program is not restricted, and the output from the Program
Xis covered only if its contents constitute a work based on the
XProgram (independent of having been made by running the Program).
XWhether that is true depends on what the Program does.
X
X@item
XYou may copy and distribute verbatim copies of the Program's
Xsource code as you receive it, in any medium, provided that you
Xconspicuously and appropriately publish on each copy an appropriate
Xcopyright notice and disclaimer of warranty; keep intact all the
Xnotices that refer to this License and to the absence of any warranty;
Xand give any other recipients of the Program a copy of this License
Xalong with the Program.
X
XYou may charge a fee for the physical act of transferring a copy, and
Xyou may at your option offer warranty protection in exchange for a fee.
X
X@item
XYou may modify your copy or copies of the Program or any portion
Xof it, thus forming a work based on the Program, and copy and
Xdistribute such modifications or work under the terms of Section 1
Xabove, provided that you also meet all of these conditions:
X
X@enumerate a
X@item
XYou must cause the modified files to carry prominent notices
Xstating that you changed the files and the date of any change.
X
X@item
XYou must cause any work that you distribute or publish, that in
Xwhole or in part contains or is derived from the Program or any
Xpart thereof, to be licensed as a whole at no charge to all third
Xparties under the terms of this License.
X
X@item
XIf the modified program normally reads commands interactively
Xwhen run, you must cause it, when started running for such
Xinteractive use in the most ordinary way, to print or display an
Xannouncement including an appropriate copyright notice and a
Xnotice that there is no warranty (or else, saying that you provide
Xa warranty) and that users may redistribute the program under
Xthese conditions, and telling the user how to view a copy of this
XLicense.  (Exception: if the Program itself is interactive but
Xdoes not normally print such an announcement, your work based on
Xthe Program is not required to print an announcement.)
X@end enumerate
X
XThese requirements apply to the modified work as a whole.  If
Xidentifiable sections of that work are not derived from the Program,
Xand can be reasonably considered independent and separate works in
Xthemselves, then this License, and its terms, do not apply to those
Xsections when you distribute them as separate works.  But when you
Xdistribute the same sections as part of a whole which is a work based
Xon the Program, the distribution of the whole must be on the terms of
Xthis License, whose permissions for other licensees extend to the
Xentire whole, and thus to each and every part regardless of who wrote it.
X
XThus, it is not the intent of this section to claim rights or contest
Xyour rights to work written entirely by you; rather, the intent is to
Xexercise the right to control the distribution of derivative or
Xcollective works based on the Program.
X
XIn addition, mere aggregation of another work not based on the Program
Xwith the Program (or with a work based on the Program) on a volume of
Xa storage or distribution medium does not bring the other work under
Xthe scope of this License.
X
X@item
XYou may copy and distribute the Program (or a work based on it,
Xunder Section 2) in object code or executable form under the terms of
XSections 1 and 2 above provided that you also do one of the following:
X
X@enumerate a
X@item
XAccompany it with the complete corresponding machine-readable
Xsource code, which must be distributed under the terms of Sections
X1 and 2 above on a medium customarily used for software interchange; or,
X
X@item
XAccompany it with a written offer, valid for at least three
Xyears, to give any third party, for a charge no more than your
Xcost of physically performing source distribution, a complete
Xmachine-readable copy of the corresponding source code, to be
Xdistributed under the terms of Sections 1 and 2 above on a medium
Xcustomarily used for software interchange; or,
X
X@item
XAccompany it with the information you received as to the offer
Xto distribute corresponding source code.  (This alternative is
Xallowed only for noncommercial distribution and only if you
Xreceived the program in object code or executable form with such
Xan offer, in accord with Subsection b above.)
X@end enumerate
X
XThe source code for a work means the preferred form of the work for
Xmaking modifications to it.  For an executable work, complete source
Xcode means all the source code for all modules it contains, plus any
Xassociated interface definition files, plus the scripts used to
Xcontrol compilation and installation of the executable.  However, as a
Xspecial exception, the source code distributed need not include
Xanything that is normally distributed (in either source or binary
Xform) with the major components (compiler, kernel, and so on) of the
Xoperating system on which the executable runs, unless that component
Xitself accompanies the executable.
X
XIf distribution of executable or object code is made by offering
Xaccess to copy from a designated place, then offering equivalent
Xaccess to copy the source code from the same place counts as
Xdistribution of the source code, even though third parties are not
Xcompelled to copy the source along with the object code.
X
X@item
XYou may not copy, modify, sublicense, or distribute the Program
Xexcept as expressly provided under this License.  Any attempt
Xotherwise to copy, modify, sublicense or distribute the Program is
Xvoid, and will automatically terminate your rights under this License.
XHowever, parties who have received copies, or rights, from you under
Xthis License will not have their licenses terminated so long as such
Xparties remain in full compliance.
X
X@item
XYou are not required to accept this License, since you have not
Xsigned it.  However, nothing else grants you permission to modify or
Xdistribute the Program or its derivative works.  These actions are
Xprohibited by law if you do not accept this License.  Therefore, by
Xmodifying or distributing the Program (or any work based on the
XProgram), you indicate your acceptance of this License to do so, and
Xall its terms and conditions for copying, distributing or modifying
Xthe Program or works based on it.
X
X@item
XEach time you redistribute the Program (or any work based on the
XProgram), the recipient automatically receives a license from the
Xoriginal licensor to copy, distribute or modify the Program subject to
Xthese terms and conditions.  You may not impose any further
Xrestrictions on the recipients' exercise of the rights granted herein.
XYou are not responsible for enforcing compliance by third parties to
Xthis License.
X
X@item
XIf, as a consequence of a court judgment or allegation of patent
Xinfringement or for any other reason (not limited to patent issues),
Xconditions are imposed on you (whether by court order, agreement or
Xotherwise) that contradict the conditions of this License, they do not
Xexcuse you from the conditions of this License.  If you cannot
Xdistribute so as to satisfy simultaneously your obligations under this
XLicense and any other pertinent obligations, then as a consequence you
Xmay not distribute the Program at all.  For example, if a patent
Xlicense would not permit royalty-free redistribution of the Program by
Xall those who receive copies directly or indirectly through you, then
Xthe only way you could satisfy both it and this License would be to
Xrefrain entirely from distribution of the Program.
X
XIf any portion of this section is held invalid or unenforceable under
Xany particular circumstance, the balance of the section is intended to
Xapply and the section as a whole is intended to apply in other
Xcircumstances.
X
XIt is not the purpose of this section to induce you to infringe any
Xpatents or other property right claims or to contest validity of any
Xsuch claims; this section has the sole purpose of protecting the
Xintegrity of the free software distribution system, which is
Ximplemented by public license practices.  Many people have made
Xgenerous contributions to the wide range of software distributed
Xthrough that system in reliance on consistent application of that
Xsystem; it is up to the author/donor to decide if he or she is willing
Xto distribute software through any other system and a licensee cannot
Ximpose that choice.
X
XThis section is intended to make thoroughly clear what is believed to
Xbe a consequence of the rest of this License.
X
X@item
XIf the distribution and/or use of the Program is restricted in
Xcertain countries either by patents or by copyrighted interfaces, the
Xoriginal copyright holder who places the Program under this License
Xmay add an explicit geographical distribution limitation excluding
Xthose countries, so that distribution is permitted only in or among
Xcountries not thus excluded.  In such case, this License incorporates
Xthe limitation as if written in the body of this License.
X
X@item
XThe Free Software Foundation may publish revised and/or new versions
Xof the General Public License from time to time.  Such new versions will
Xbe similar in spirit to the present version, but may differ in detail to
Xaddress new problems or concerns.
X
XEach version is given a distinguishing version number.  If the Program
Xspecifies a version number of this License which applies to it and ``any
Xlater version'', you have the option of following the terms and conditions
Xeither of that version or of any later version published by the Free
XSoftware Foundation.  If the Program does not specify a version number of
Xthis License, you may choose any version ever published by the Free Software
XFoundation.
X
X@item
XIf you wish to incorporate parts of the Program into other free
Xprograms whose distribution conditions are different, write to the author
Xto ask for permission.  For software which is copyrighted by the Free
XSoftware Foundation, write to the Free Software Foundation; we sometimes
Xmake exceptions for this.  Our decision will be guided by the two goals
Xof preserving the free status of all derivatives of our free software and
Xof promoting the sharing and reuse of software generally.
X
X@iftex
X@heading NO WARRANTY
X@end iftex
X@ifinfo
X@center NO WARRANTY
X@end ifinfo
X
X@item
XBECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
XFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
XOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
XPROVIDE THE PROGRAM ``AS IS'' WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
XOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
XMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
XTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
XPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
XREPAIR OR CORRECTION.
X
X@item
XIN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
XWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
XREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
XINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
XOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
XTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
XYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
XPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
XPOSSIBILITY OF SUCH DAMAGES.
X@end enumerate
X
X@iftex
X@heading END OF TERMS AND CONDITIONS
X@end iftex
X@ifinfo
X@center END OF TERMS AND CONDITIONS
X@end ifinfo
X
X@page
X@unnumberedsec How to Apply These Terms to Your New Programs
X
X  If you develop a new program, and you want it to be of the greatest
Xpossible use to the public, the best way to achieve this is to make it
Xfree software which everyone can redistribute and change under these terms.
X
X  To do so, attach the following notices to the program.  It is safest
Xto attach them to the start of each source file to most effectively
Xconvey the exclusion of warranty; and each file should have at least
Xthe ``copyright'' line and a pointer to where the full notice is found.
X
X@smallexample
X@var{one line to give the program's name and an idea of what it does.}
XCopyright (C) 19@var{yy}  @var{name of author}
X
XThis program is free software; you can redistribute it and/or
Xmodify it under the terms of the GNU General Public License
Xas published by the Free Software Foundation; either version 2
Xof the License, or (at your option) any later version.
X
XThis program is distributed in the hope that it will be useful,
Xbut WITHOUT ANY WARRANTY; without even the implied warranty of
XMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
XGNU General Public License for more details.
X
XYou should have received a copy of the GNU General Public License
Xalong with this program; if not, write to the Free Software
XFoundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X@end smallexample
X
XAlso add information on how to contact you by electronic and paper mail.
X
XIf the program is interactive, make it output a short notice like this
Xwhen it starts in an interactive mode:
X
X@smallexample
XGnomovision version 69, Copyright (C) 19@var{yy} @var{name of author}
XGnomovision comes with ABSOLUTELY NO WARRANTY; for details
Xtype `show w'.  This is free software, and you are welcome
Xto redistribute it under certain conditions; type `show c' 
Xfor details.
X@end smallexample
X
XThe hypothetical commands @samp{show w} and @samp{show c} should show
Xthe appropriate parts of the General Public License.  Of course, the
Xcommands you use may be called something other than @samp{show w} and
X@samp{show c}; they could even be mouse-clicks or menu items---whatever
Xsuits your program.
X
XYou should also get your employer (if you work as a programmer) or your
Xschool, if any, to sign a ``copyright disclaimer'' for the program, if
Xnecessary.  Here is a sample; alter the names:
X
X@example
XYoyodyne, Inc., hereby disclaims all copyright
Xinterest in the program `Gnomovision'
X(which makes passes at compilers) written 
Xby James Hacker.
X
X@var{signature of Ty Coon}, 1 April 1989
XTy Coon, President of Vice
X@end example
X
XThis General Public License does not permit incorporating your program into
Xproprietary programs.  If your program is a subroutine library, you may
Xconsider it more useful to permit linking proprietary applications with the
Xlibrary.  If this is what you want to do, use the GNU Library General
XPublic License instead of this License.
END_OF_FILE
if test 18317 -ne `wc -c <'gzip-1.2.2/gpl.texinfo'`; then
    echo shar: \"'gzip-1.2.2/gpl.texinfo'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/gpl.texinfo'
fi
if test -f 'gzip-1.2.2/gzip.info' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/gzip.info'\"
else
echo shar: Extracting \"'gzip-1.2.2/gzip.info'\" \(33945 characters\)
sed "s/^X//" >'gzip-1.2.2/gzip.info' <<'END_OF_FILE'
XInfo file gzip.info, produced by Makeinfo, -*- Text -*- from input
Xfile gzip.texi.
X
X   This file documents the the GNU `gzip' command for compressing
Xfiles.
X
X   Copyright (C) 1992-1993 Jean-loup Gailly
X
X   Permission is granted to make and distribute verbatim copies of
Xthis manual provided the copyright notice and this permission notice
Xare preserved on all copies.
X
X   Permission is granted to copy and distribute modified versions of
Xthis manual under the conditions for verbatim copying, provided that
Xthe entire resulting derived work is distributed under the terms of a
Xpermission notice identical to this one.
X
X   Permission is granted to copy and distribute translations of this
Xmanual into another language, under the above conditions for modified
Xversions, except that this permission notice may be stated in a
Xtranslation approved by the Foundation.
X
X
XFile: gzip.info,  Node: Top,  Up: (dir)
X
X   This file documents the `gzip' command to compress files.
X
X* Menu:
X
X* Copying::		How you can copy and share `gzip'.
X* Overview::		Preliminary information.
X* Sample::		Sample output from `gzip'.
X* Invoking gzip::	How to run `gzip'.
X* Advanced usage::	Concatenated files.
X* Environment::		The `GZIP' environment variable
X* Tapes::               Using `gzip' on tapes.
X* Problems::		Reporting bugs.
X* Concept Index::	Index of concepts.
X
X
XFile: gzip.info,  Node: Copying,  Next: Overview,  Up: Top
X
XGNU GENERAL PUBLIC LICENSE
X**************************
X
X                             Version 2, June 1991
X
X     Copyright (C) 1989, 1991 Free Software Foundation, Inc.
X     675 Mass Ave, Cambridge, MA 02139, USA
X     
X     Everyone is permitted to copy and distribute verbatim copies
X     of this license document, but changing it is not allowed.
X
XPreamble
X========
X
X   The licenses for most software are designed to take away your
Xfreedom to share and change it.  By contrast, the GNU General Public
XLicense is intended to guarantee your freedom to share and change free
Xsoftware--to make sure the software is free for all its users.  This
XGeneral Public License applies to most of the Free Software
XFoundation's software and to any other program whose authors commit to
Xusing it.  (Some other Free Software Foundation software is covered by
Xthe GNU Library General Public License instead.)  You can apply it to
Xyour programs, too.
X
X   When we speak of free software, we are referring to freedom, not
Xprice.  Our General Public Licenses are designed to make sure that you
Xhave the freedom to distribute copies of free software (and charge for
Xthis service if you wish), that you receive source code or can get it
Xif you want it, that you can change the software or use pieces of it
Xin new free programs; and that you know you can do these things.
X
X   To protect your rights, we need to make restrictions that forbid
Xanyone to deny you these rights or to ask you to surrender the rights. 
XThese restrictions translate to certain responsibilities for you if you
Xdistribute copies of the software, or if you modify it.
X
X   For example, if you distribute copies of such a program, whether
Xgratis or for a fee, you must give the recipients all the rights that
Xyou have.  You must make sure that they, too, receive or can get the
Xsource code.  And you must show them these terms so they know their
Xrights.
X
X   We protect your rights with two steps: (1) copyright the software,
Xand (2) offer you this license which gives you legal permission to
Xcopy, distribute and/or modify the software.
X
X   Also, for each author's protection and ours, we want to make certain
Xthat everyone understands that there is no warranty for this free
Xsoftware.  If the software is modified by someone else and passed on,
Xwe want its recipients to know that what they have is not the
Xoriginal, so that any problems introduced by others will not reflect
Xon the original authors' reputations.
X
X   Finally, any free program is threatened constantly by software
Xpatents.  We wish to avoid the danger that redistributors of a free
Xprogram will individually obtain patent licenses, in effect making the
Xprogram proprietary.  To prevent this, we have made it clear that any
Xpatent must be licensed for everyone's free use or not licensed at all.
X
X   The precise terms and conditions for copying, distribution and
Xmodification follow.
X
X       TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
X
X  1. This License applies to any program or other work which contains
X     a notice placed by the copyright holder saying it may be
X     distributed under the terms of this General Public License.  The
X     "Program", below, refers to any such program or work, and a "work
X     based on the Program" means either the Program or any derivative
X     work under copyright law: that is to say, a work containing the
X     Program or a portion of it, either verbatim or with modifications
X     and/or translated into another language.  (Hereinafter,
X     translation is included without limitation in the term
X     "modification".)  Each licensee is addressed as "you".
X
X        Activities other than copying, distribution and modification
X     are not covered by this License; they are outside its scope.  The
X     act of running the Program is not restricted, and the output from
X     the Program is covered only if its contents constitute a work
X     based on the Program (independent of having been made by running
X     the Program).  Whether that is true depends on what the Program
X     does.
X
X  2. You may copy and distribute verbatim copies of the Program's
X     source code as you receive it, in any medium, provided that you
X     conspicuously and appropriately publish on each copy an
X     appropriate copyright notice and disclaimer of warranty; keep
X     intact all the notices that refer to this License and to the
X     absence of any warranty; and give any other recipients of the
X     Program a copy of this License along with the Program.
X
X        You may charge a fee for the physical act of transferring a
X     copy, and you may at your option offer warranty protection in
X     exchange for a fee.
X
X  3. You may modify your copy or copies of the Program or any portion
X     of it, thus forming a work based on the Program, and copy and
X     distribute such modifications or work under the terms of Section 1
X     above, provided that you also meet all of these conditions:
X
X       1. You must cause the modified files to carry prominent notices
X          stating that you changed the files and the date of any
X          change.
X
X       2. You must cause any work that you distribute or publish, that
X          in whole or in part contains or is derived from the Program
X          or any part thereof, to be licensed as a whole at no charge
X          to all third parties under the terms of this License.
X
X       3. If the modified program normally reads commands interactively
X          when run, you must cause it, when started running for such
X          interactive use in the most ordinary way, to print or
X          display an announcement including an appropriate copyright
X          notice and a notice that there is no warranty (or else,
X          saying that you provide a warranty) and that users may
X          redistribute the program under these conditions, and telling
X          the user how to view a copy of this License.  (Exception: if
X          the Program itself is interactive but does not normally
X          print such an announcement, your work based on the Program
X          is not required to print an announcement.)
X
X             These requirements apply to the modified work as a whole.  If
X     identifiable sections of that work are not derived from the
X     Program, and can be reasonably considered independent and
X     separate works in themselves, then this License, and its terms,
X     do not apply to those sections when you distribute them as
X     separate works.  But when you distribute the same sections as
X     part of a whole which is a work based on the Program, the
X     distribution of the whole must be on the terms of this License,
X     whose permissions for other licensees extend to the entire whole,
X     and thus to each and every part regardless of who wrote it.
X
X        Thus, it is not the intent of this section to claim rights or
X     contest your rights to work written entirely by you; rather, the
X     intent is to exercise the right to control the distribution of
X     derivative or collective works based on the Program.
X
X        In addition, mere aggregation of another work not based on the
X     Program with the Program (or with a work based on the Program) on
X     a volume of a storage or distribution medium does not bring the
X     other work under the scope of this License.
X
X  4. You may copy and distribute the Program (or a work based on it,
X     under Section 2) in object code or executable form under the
X     terms of Sections 1 and 2 above provided that you also do one of
X     the following:
X
X       1. Accompany it with the complete corresponding machine-readable
X          source code, which must be distributed under the terms of
X          Sections 1 and 2 above on a medium customarily used for
X          software interchange; or,
X
X       2. Accompany it with a written offer, valid for at least three
X          years, to give any third party, for a charge no more than
X          your cost of physically performing source distribution, a
X          complete machine-readable copy of the corresponding source
X          code, to be distributed under the terms of Sections 1 and 2
X          above on a medium customarily used for software interchange;
X          or,
X
X       3. Accompany it with the information you received as to the
X          offer to distribute corresponding source code.  (This
X          alternative is allowed only for noncommercial distribution
X          and only if you received the program in object code or
X          executable form with such an offer, in accord with
X          Subsection b above.)
X
X             The source code for a work means the preferred form of the
X     work for making modifications to it.  For an executable work,
X     complete source code means all the source code for all modules it
X     contains, plus any associated interface definition files, plus
X     the scripts used to control compilation and installation of the
X     executable.  However, as a special exception, the source code
X     distributed need not include anything that is normally
X     distributed (in either source or binary form) with the major
X     components (compiler, kernel, and so on) of the operating system
X     on which the executable runs, unless that component itself
X     accompanies the executable.
X
X        If distribution of executable or object code is made by
X     offering access to copy from a designated place, then offering
X     equivalent access to copy the source code from the same place
X     counts as distribution of the source code, even though third
X     parties are not compelled to copy the source along with the
X     object code.
X
X  5. You may not copy, modify, sublicense, or distribute the Program
X     except as expressly provided under this License.  Any attempt
X     otherwise to copy, modify, sublicense or distribute the Program is
X     void, and will automatically terminate your rights under this
X     License.  However, parties who have received copies, or rights,
X     from you under this License will not have their licenses
X     terminated so long as such parties remain in full compliance.
X
X  6. You are not required to accept this License, since you have not
X     signed it.  However, nothing else grants you permission to modify
X     or distribute the Program or its derivative works.  These actions
X     are prohibited by law if you do not accept this License. 
X     Therefore, by modifying or distributing the Program (or any work
X     based on the Program), you indicate your acceptance of this
X     License to do so, and all its terms and conditions for copying,
X     distributing or modifying the Program or works based on it.
X
X  7. Each time you redistribute the Program (or any work based on the
X     Program), the recipient automatically receives a license from the
X     original licensor to copy, distribute or modify the Program
X     subject to these terms and conditions.  You may not impose any
X     further restrictions on the recipients' exercise of the rights
X     granted herein.  You are not responsible for enforcing compliance
X     by third parties to this License.
X
X  8. If, as a consequence of a court judgment or allegation of patent
X     infringement or for any other reason (not limited to patent
X     issues), conditions are imposed on you (whether by court order,
X     agreement or otherwise) that contradict the conditions of this
X     License, they do not excuse you from the conditions of this
X     License.  If you cannot distribute so as to satisfy
X     simultaneously your obligations under this License and any other
X     pertinent obligations, then as a consequence you may not
X     distribute the Program at all.  For example, if a patent license
X     would not permit royalty-free redistribution of the Program by
X     all those who receive copies directly or indirectly through you,
X     then the only way you could satisfy both it and this License
X     would be to refrain entirely from distribution of the Program.
X
X        If any portion of this section is held invalid or
X     unenforceable under any particular circumstance, the balance of
X     the section is intended to apply and the section as a whole is
X     intended to apply in other circumstances.
X
X        It is not the purpose of this section to induce you to
X     infringe any patents or other property right claims or to contest
X     validity of any such claims; this section has the sole purpose of
X     protecting the integrity of the free software distribution
X     system, which is implemented by public license practices.  Many
X     people have made generous contributions to the wide range of
X     software distributed through that system in reliance on
X     consistent application of that system; it is up to the
X     author/donor to decide if he or she is willing to distribute
X     software through any other system and a licensee cannot impose
X     that choice.
X
X        This section is intended to make thoroughly clear what is
X     believed to be a consequence of the rest of this License.
X
X  9. If the distribution and/or use of the Program is restricted in
X     certain countries either by patents or by copyrighted interfaces,
X     the original copyright holder who places the Program under this
X     License may add an explicit geographical distribution limitation
X     excluding those countries, so that distribution is permitted only
X     in or among countries not thus excluded.  In such case, this
X     License incorporates the limitation as if written in the body of
X     this License.
X
X 10. The Free Software Foundation may publish revised and/or new
X     versions of the General Public License from time to time.  Such
X     new versions will be similar in spirit to the present version,
X     but may differ in detail to address new problems or concerns.
X
X        Each version is given a distinguishing version number.  If the
X     Program specifies a version number of this License which applies
X     to it and "any later version", you have the option of following
X     the terms and conditions either of that version or of any later
X     version published by the Free Software Foundation.  If the
X     Program does not specify a version number of this License, you
X     may choose any version ever published by the Free Software
X     Foundation.
X
X 11. If you wish to incorporate parts of the Program into other free
X     programs whose distribution conditions are different, write to
X     the author to ask for permission.  For software which is
X     copyrighted by the Free Software Foundation, write to the Free
X     Software Foundation; we sometimes make exceptions for this.  Our
X     decision will be guided by the two goals of preserving the free
X     status of all derivatives of our free software and of promoting
X     the sharing and reuse of software generally.
X
X                                      NO WARRANTY
X
X 12. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO
X     WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE
X     LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
X     HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT
X     WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT
X     NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
X     FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE
X     QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
X     PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY
X     SERVICING, REPAIR OR CORRECTION.
X
X 13. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
X     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY
X     MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE
X     LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL,
X     INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
X     INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS
X     OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
X     YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH
X     ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN
X     ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
X
X                         END OF TERMS AND CONDITIONS
X
XHow to Apply These Terms to Your New Programs
X=============================================
X
X   If you develop a new program, and you want it to be of the greatest
Xpossible use to the public, the best way to achieve this is to make it
Xfree software which everyone can redistribute and change under these
Xterms.
X
X   To do so, attach the following notices to the program.  It is safest
Xto attach them to the start of each source file to most effectively
Xconvey the exclusion of warranty; and each file should have at least
Xthe "copyright" line and a pointer to where the full notice is found.
X
X     ONE LINE TO GIVE THE PROGRAM'S NAME AND AN IDEA OF WHAT IT DOES.
X     Copyright (C) 19YY  NAME OF AUTHOR
X     
X     This program is free software; you can redistribute it and/or
X     modify it under the terms of the GNU General Public License
X     as published by the Free Software Foundation; either version 2
X     of the License, or (at your option) any later version.
X     
X     This program is distributed in the hope that it will be useful,
X     but WITHOUT ANY WARRANTY; without even the implied warranty of
X     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X     GNU General Public License for more details.
X     
X     You should have received a copy of the GNU General Public License
X     along with this program; if not, write to the Free Software
X     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
X   Also add information on how to contact you by electronic and paper
Xmail.
X
X   If the program is interactive, make it output a short notice like
Xthis when it starts in an interactive mode:
X
X     Gnomovision version 69, Copyright (C) 19YY NAME OF AUTHOR
X     Gnomovision comes with ABSOLUTELY NO WARRANTY; for details
X     type `show w'.  This is free software, and you are welcome
X     to redistribute it under certain conditions; type `show c' 
X     for details.
X
X   The hypothetical commands `show w' and `show c' should show the
Xappropriate parts of the General Public License.  Of course, the
Xcommands you use may be called something other than `show w' and `show
Xc'; they could even be mouse-clicks or menu items--whatever suits your
Xprogram.
X
X   You should also get your employer (if you work as a programmer) or
Xyour school, if any, to sign a "copyright disclaimer" for the program,
Xif necessary.  Here is a sample; alter the names:
X
X     Yoyodyne, Inc., hereby disclaims all copyright
X     interest in the program `Gnomovision'
X     (which makes passes at compilers) written 
X     by James Hacker.
X     
X     SIGNATURE OF TY COON, 1 April 1989
X     Ty Coon, President of Vice
X
X   This General Public License does not permit incorporating your
Xprogram into proprietary programs.  If your program is a subroutine
Xlibrary, you may consider it more useful to permit linking proprietary
Xapplications with the library.  If this is what you want to do, use
Xthe GNU Library General Public License instead of this License.
X
X
XFile: gzip.info,  Node: Overview,  Next: Sample,  Prev: Copying,  Up: Top
X
XOverview
X********
X
X   `gzip' reduces the size of the named files using Lempel-Ziv coding
X(LZ77).  Whenever possible, each file is replaced by one with the
Xextension `.gz', while keeping the same ownership modes, access and
Xmodification times.  (The default extension is `-gz' for VMS, `z' for
XMSDOS, OS/2 FAT and Atari.)  If no files are specified, the standard
Xinput is compressed to the standard output.  `gzip' will only attempt
Xto compress regular files.  In particular, it will ignore symbolic
Xlinks.
X
X   If the new file name is too long for its file system, `gzip'
Xtruncates it and keeps the original file name in the compressed file. 
X`gzip' attempts to truncate only the parts of the file name longer
Xthan 3 characters.  (A part is delimited by dots.) If the name consists
Xof small parts only, the longest parts are truncated. For example, if
Xfile names are limited to 14 characters, gzip.msdos.exe is compressed
Xto gzi.msd.exe.gz.  Names are not truncated on systems which do not
Xhave a limit on file name length.
X
X   Compressed files can be restored to their original form using `gzip
X-d' or `gunzip' or `zcat'.  If the original name saved in the
Xcompressed file is not suitable for its file system, a new name is
Xconstructed from the original one to make it legal.
X
X   `gunzip' takes a list of files on its command line and replaces
Xeach file whose name ends with `.gz', `.z', `.Z', `-gz', `-z' or `_z'
Xand which begins with the correct magic number with an uncompressed
Xfile without the original extension.  `gunzip' also recognizes the
Xspecial extensions `.tgz' and `.taz' as shorthands for `.tar.gz' and
X`.tar.Z' respectively. When compressing, `gzip' uses the `.tgz'
Xextension if necessary instead of truncating a file with a `.tar'
Xextension.
X
X   `gunzip' can currently decompress files created by `gzip', `zip',
X`compress' or `pack'. The detection of the input format is automatic. 
XWhen using the first two formats, `gunzip' checks a 32 bit CRC (cyclic
Xredundancy check). For `pack', `gunzip' checks the uncompressed
Xlength. The `compress' format was not designed to allow consistency
Xchecks. However `gunzip' is sometimes able to detect a bad `.Z' file.
XIf you get an error when uncompressing a `.Z' file, do not assume that
Xthe `.Z' file is correct simply because the standard `uncompress' does
Xnot complain.  This generally means that the standard `uncompress'
Xdoes not check its input, and happily generates garbage output.  The
XSCO `compress -H' format (`lzh' compression method) does not include a
XCRC but also allows some consistency checks.
X
X   Files created by `zip' can be uncompressed by `gzip' only if they
Xhave a single member compressed with the 'deflation' method. This
Xfeature is only intended to help conversion of `tar.zip' files to the
X`tar.gz' format. To extract `zip' files with several members, use
X`unzip' instead of `gunzip'.
X
X   `zcat' is identical to `gunzip -c'.  `zcat' uncompresses either a
Xlist of files on the command line or its standard input and writes the
Xuncompressed data on standard output.  `zcat' will uncompress files
Xthat have the correct magic number whether they have a `.gz' suffix or
Xnot.
X
X   `gzip' uses the Lempel-Ziv algorithm used in `zip' and PKZIP.  The
Xamount of compression obtained depends on the size of the input and
Xthe distribution of common substrings.  Typically, text such as source
Xcode or English is reduced by 60-70%.  Compression is generally much
Xbetter than that achieved by LZW (as used in `compress'), Huffman
Xcoding (as used in `pack'), or adaptive Huffman coding (`compact').
X
X   Compression is always performed, even if the compressed file is
Xslightly larger than the original. The worst case expansion is a few
Xbytes for the `gzip' file header, plus 5 bytes every 32K block, or an
Xexpansion ratio of 0.015% for large files. Note that the actual number
Xof used disk blocks almost never increases. `gzip' preserves the mode,
Xownership and timestamps of files when compressing or decompressing.
X
X
XFile: gzip.info,  Node: Sample,  Next: Invoking gzip,  Prev: Overview,  Up: Top
X
XSample Output
X*************
X
X   Here are some realistic examples of running `gzip'.
X
X   This is the output of the command `gzip':
X
X     usage: gzip [-cdfhLrv19] [file ...]
X     For more help, type: gzip -h
X
X   This is the output of the command `gzip -h':
X
X     gzip 1.2.2 (17 Jun 93)
X     usage: gzip [-cdfhlLnrtvV19] [-S suffix] [file ...]
X      -c --stdout      write on standard output, keep original files unchanged
X      -d --decompress  decompress
X      -f --force       force overwrite of output file and compress links
X      -h --help        give this help
X      -l --list        list .gz file contents
X      -L --license     display software license
X      -n --no-name     do not save or restore the original name
X      -q --quiet       suppress all warnings
X      -r --recurse     recurse through directories
X      -S .suf  --suffix .suf     use suffix .suf instead of .gz
X      -t --test        test compressed file integrity
X      -v --verbose     verbose mode
X      -V --version     display version number
X      -1 --fast        compress faster
X      -9 --best        compress better
X      file...          files to (de)compress. If none given, use standard input.
X
X   This is the output of the command `gzip -v texinfo.tex':
X
X     texinfo.tex:             71.6% -- replaced with texinfo.tex.gz
X
X
XFile: gzip.info,  Node: Invoking gzip,  Next: Advanced usage,  Prev: Sample,  Up: Top
X
XInvoking `gzip'
X***************
X
X   The format for running the `gzip' program is:
X
X     gzip OPTION ...
X
X   `gzip' supports the following options:
X
X`--stdout'
X`--to-stdout'
X`-c'
X     Write output on standard output; keep original files unchanged. 
X     If there are several input files, the output consists of a
X     sequence of independently compressed members. To obtain better
X     compression, concatenate all input files before compressing them.
X
X`--decompress'
X`--uncompress'
X`-d'
X     Decompress.
X
X`--force'
X`-f'
X     Force compression or decompression even if the file has multiple
X     links or the corresponding file already exists, or if the
X     compressed data is read from or written to a terminal. If the
X     input data is not in a format recognized by `gzip', and if the
X     option --stdout is also given, copy the input data without change
X     to the standard ouput: let `zcat' behave as `cat'. If `-f' is not
X     given, and when not running in the background, `gzip' prompts to
X     verify whether an existing file should be overwritten.
X
X`--help'
X`-h'
X     Print an informative help message describing the options then
X     quit.
X
X`--list'
X`-l'
X     For each compressed file, list the following fields:
X
X          compressed size: size of the compressed file
X          uncompressed size: size of the uncompressed file
X          ratio: compression ratio (0.0% if unknown)
X          uncompressed_name: name of the uncompressed file
X
X          The uncompressed size is given as `-1' for files not in `gzip'
X     format, such as compressed `.Z' files. To get the uncompressed
X     size for such a file, you can use:
X
X          zcat file.Z | wc -c
X
X          In combination with the --verbose option, the following fields
X     are also displayed:
X
X          method: compression method (deflate,compress,lzh,pack)
X          crc: the 32-bit CRC of the uncompressed data
X          date & time: time stamp for the uncompressed file
X
X          The crc is given as ffffffff for a file not in gzip format.
X
X     With --verbose, the size totals and compression ratio for all
X     files is also displayed, unless some sizes are unknown. With
X     --quiet, the title and totals lines are not displayed.
X
X`--license'
X`-L'
X     Display the `gzip' license then quit.
X
X`--no-name'
X`-n'
X     When compressing, do not save the original file name by default.
X     (The original name is always saved if the name had to be
X     truncated.) When decompressing, do not restore the original file
X     name if present: remove only the `gzip' suffix from the
X     compressed file name.
X
X`--quiet'
X`-q'
X     Suppress all warning messages.
X
X`--recurse'
X`-r'
X     Travel the directory structure recursively. If any of the file
X     names specified on the command line are directories, `gzip' will
X     descend into the directory and compress all the files it finds
X     there (or decompress them in the case of `gunzip').
X
X`--suffix SUF'
X`-S SUF'
X     Use suffix `SUF' instead of `.gz'. Any suffix can be given, but
X     suffixes other than `.z' and `.gz' should be avoided to avoid
X     confusion when files are transferred to other systems.  A null
X     suffix forces gunzip to try decompression on all given files
X     regardless of suffix, as in:
X
X          gunzip -S "" *        (*.* for MSDOS)
X
X          Previous versions of gzip used the `.z' suffix. This was changed
X     to avoid a conflict with `pack'.
X
X`--test'
X`-t'
X     Test. Check the compressed file integrity.
X
X`--verbose'
X`-v'
X     Verbose. Display the name and percentage reduction for each file
X     compressed.
X
X`--version'
X`-V'
X     Version. Display the version number and compilation options, then
X     quit.
X
X`--fast'
X`--best'
X`-N'
X     Regulate the speed of compression using the specified digit N,
X     where `-1' or `--fast' indicates the fastest compression method
X     (less compression) and `--best' or `-9' indicates the slowest
X     compression method (optimal compression).  The default
X     compression level is `-6' (that is, biased towards high
X     compression at expense of speed).
X
X
XFile: gzip.info,  Node: Advanced usage,  Next: Environment,  Prev: Invoking gzip,  Up: Top
X
XAdvanced usage
X**************
X
X   Multiple compressed files can be concatenated. In this case,
X`gunzip' will extract all members at once. If one member is damaged,
Xother members might still be recovered after removal of the damaged
Xmember. Better compression can be usually obtained if all members are
Xdecompressed and then recompressed in a single step.
X
X   This is an example of concatenating `gzip' files:
X
X     gzip -c file1  > foo.gz
X     gzip -c file2 >> foo.gz
X
X   Then
X
X     gunzip -c foo
X
X   is equivalent to
X
X     cat file1 file2
X
X   In case of damage to one member of a `.gz' file, other members can
Xstill be recovered (if the damaged member is removed). However, you
Xcan get better compression by compressing all members at once:
X
X     cat file1 file2 | gzip > foo.gz
X
X   compresses better than
X
X     gzip -c file1 file2 > foo.gz
X
X   If you want to recompress concatenated files to get better
Xcompression, do:
X
X     zcat old.gz | gzip > new.gz
X
X
XFile: gzip.info,  Node: Environment,  Next: Tapes,  Prev: Advanced usage,  Up: Top
X
XEnvironment
X***********
X
X   The environment variable `GZIP' can hold a set of default options
Xfor `gzip'.  These options are interpreted first and can be
Xoverwritten by explicit command line parameters.  For example:
X
X     for sh:    GZIP="-8 -v"; export GZIP
X     for csh:   setenv GZIP "-8 -v"
X     for MSDOS: set GZIP=-8 -v
X
X   On Vax/VMS, the name of the environment variable is `GZIP_OPT', to
Xavoid a conflict with the symbol set for invocation of the program.
X
X
XFile: gzip.info,  Node: Tapes,  Next: Problems,  Prev: Environment,  Up: Top
X
XUsing `gzip' on tapes
X*********************
X
X   When writing compressed data to a tape, it is generally necessary
Xto pad the output with zeroes up to a block boundary. When the data is
Xread and the whole block is passed to `gunzip' for decompression,
X`gunzip' detects that there is extra trailing garbage after the
Xcompressed data and emits a warning by default. You have to use the
X`--quiet' option to suppress the warning. This option can be set in the
X`GZIP' environment variable, as in:
X
X     for sh:    GZIP="-q"  tar xfz /dev/rmt/datn
X     for csh:   (setenv GZIP "-q"; tar xfz /dev/rmt/datn)
X
X   Make sure that the same block size (`-b' option of `tar') is used
Xfor reading and writing compressed data on tapes.  (This example
Xassumes you are using the GNU version of `tar'.)
X
X
XFile: gzip.info,  Node: Problems,  Next: Concept Index,  Prev: Tapes,  Up: Top
X
XReporting Bugs
X**************
X
X   If you find a bug in `gzip', please send electronic mail to
X`jloup@chorus.fr' or, if this fails, to
X`bug-gnu-utils@prep.ai.mit.edu'.  Include the version number, which
Xyou can find by running `gzip -V'.  Also include in your message the
Xhardware and operating system, the compiler used to compile `gzip', a
Xdescription of the bug behavior, and the input to `gzip' that triggered
Xthe bug.
X
X
XFile: gzip.info,  Node: Concept Index,  Prev: Problems,  Up: Top
X
XConcept Index
X*************
X
X* Menu:
X
X* Environment:                          Environment.
X* bugs:                                 Problems.
X* concatenated files:                   Advanced usage.
X* invoking:                             Invoking gzip.
X* options:                              Invoking gzip.
X* overview:                             Overview.
X* sample:                               Sample.
X* tapes:                                Tapes.
X
X
X
XTag Table:
XNode: Top864
XNode: Copying1344
XNode: Overview20602
XNode: Sample24664
XNode: Invoking gzip26056
XNode: Advanced usage30207
XNode: Environment31258
XNode: Tapes31811
XNode: Problems32675
XNode: Concept Index33180
X
XEnd Tag Table
END_OF_FILE
echo shar: 22 control characters may be missing from \"'gzip-1.2.2/gzip.info'\"
if test 33945 -ne `wc -c <'gzip-1.2.2/gzip.info'`; then
    echo shar: \"'gzip-1.2.2/gzip.info'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/gzip.info'
fi
if test ! -d 'gzip-1.2.2/sample' ; then
    echo shar: Creating directory \"'gzip-1.2.2/sample'\"
    mkdir 'gzip-1.2.2/sample'
fi
if test -f 'gzip-1.2.2/sample/makecrc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/sample/makecrc.c'\"
else
echo shar: Extracting \"'gzip-1.2.2/sample/makecrc.c'\" \(2569 characters\)
sed "s/^X//" >'gzip-1.2.2/sample/makecrc.c' <<'END_OF_FILE'
X/* Not copyrighted 1990 Mark Adler */
X
X#ifndef lint
Xstatic char rcsid[] = "$Id: makecrc.c,v 0.6 1993/05/28 07:42:59 jloup Exp $";
X#endif
X
X#include <stdio.h>
X
Xmain()
X/*
X  Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
X  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
X
X  Polynomials over GF(2) are represented in binary, one bit per coefficient,
X  with the lowest powers in the most significant bit.  Then adding polynomials
X  is just exclusive-or, and multiplying a polynomial by x is a right shift by
X  one.  If we call the above polynomial p, and represent a byte as the
X  polynomial q, also with the lowest power in the most significant bit (so the
X  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
X  where a mod b means the remainder after dividing a by b.
X
X  This calculation is done using the shift-register method of multiplying and
X  taking the remainder.  The register is initialized to zero, and for each
X  incoming bit, x^32 is added mod p to the register if the bit is a one (where
X  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
X  x (which is shifting right by one and adding x^32 mod p if the bit shifted
X  out is a one).  We start with the highest power (least significant bit) of
X  q and repeat for all eight bits of q.
X
X  The table is simply the CRC of all possible eight bit values.  This is all
X  the information needed to generate CRC's on data a byte at a time for all
X  combinations of CRC register values and incoming bytes.  The table is
X  written to stdout as 256 long hexadecimal values in C language format.
X*/
X{
X  unsigned long c;      /* crc shift register */
X  unsigned long e;      /* polynomial exclusive-or pattern */
X  int i;                /* counter for all possible eight bit values */
X  int k;                /* byte being shifted into crc apparatus */
X
X  /* terms of polynomial defining this crc (except x^32): */
X  static int p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};
X
X  /* Make exclusive-or pattern from polynomial (0xedb88320) */
X  e = 0;
X  for (i = 0; i < sizeof(p)/sizeof(int); i++)
X    e |= 1L << (31 - p[i]);
X
X  /* Compute and print table of CRC's, five per line */
X  printf("  0x00000000L");
X  for (i = 1; i < 256; i++)
X  {
X    c = i;
X    /* The idea to initialize the register with the byte instead of
X     * zero was stolen from Haruhiko Okumura's ar002
X     */
X    for (k = 8; k; k--)
X      c = c & 1 ? (c >> 1) ^ e : c >> 1;
X    printf(i % 5 ? ", 0x%08lxL" : ",\n  0x%08lxL", c);
X  }
X  putchar('\n');
X  return 0;
X}
END_OF_FILE
if test 2569 -ne `wc -c <'gzip-1.2.2/sample/makecrc.c'`; then
    echo shar: \"'gzip-1.2.2/sample/makecrc.c'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/sample/makecrc.c'
fi
if test -f 'gzip-1.2.2/sample/zread.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/sample/zread.c'\"
else
echo shar: Extracting \"'gzip-1.2.2/sample/zread.c'\" \(1312 characters\)
sed "s/^X//" >'gzip-1.2.2/sample/zread.c' <<'END_OF_FILE'
X#include <stdio.h>
X
X/* Trivial example of reading a gzip'ed file or gzip'ed standard input
X * using stdio functions fread(), getc(), etc... fseek() is not supported.
X * Modify according to your needs. You can easily construct the symmetric
X * zwrite program.
X *
X * Usage: zread [file[.z]]
X * This programs assumes that gzip is somewhere in your path.
X */
Xint main(argc, argv)
X    int argc;
X    char **argv;
X{
X    FILE *infile;
X    char cmd[256];
X    char buf[BUFSIZ];
X    int n;
X
X    if (argc < 1 || argc > 2) {
X	fprintf(stderr, "usage: %s [file[.z]]\n", argv[0]);
X	exit(1);
X    }
X    strcpy(cmd, "gzip -dc ");  /* use "gzip -c" for zwrite */
X    if (argc == 2) {
X	strncat(cmd, argv[1], sizeof(cmd)-strlen(cmd));
X    }
X    infile = popen(cmd, "r");  /* use "w" for zwrite */
X    if (infile == NULL) {
X	fprintf(stderr, "%s: popen('%s', 'r') failed\n", argv[0], cmd);
X	exit(1);
X    }
X    /* Read one byte using getc: */
X    n = getc(infile);
X    if (n == EOF) {
X	pclose(infile);
X	exit(0);
X    }
X    putchar(n);
X
X    /* Read the rest using fread: */
X    for (;;) {
X	n = fread(buf, 1, BUFSIZ, infile);
X	if (n <= 0) break;
X	fwrite(buf, 1, n, stdout);
X    }
X    if (pclose(infile) != 0) {
X	fprintf(stderr, "%s: pclose failed\n", argv[0]);
X	exit(1);
X    }
X    exit(0);
X    return 0; /* just to make compiler happy */
X}
END_OF_FILE
if test 1312 -ne `wc -c <'gzip-1.2.2/sample/zread.c'`; then
    echo shar: \"'gzip-1.2.2/sample/zread.c'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/sample/zread.c'
fi
if test -f 'gzip-1.2.2/sample/add.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/sample/add.c'\"
else
echo shar: Extracting \"'gzip-1.2.2/sample/add.c'\" \(1444 characters\)
sed "s/^X//" >'gzip-1.2.2/sample/add.c' <<'END_OF_FILE'
X/* add.c   not copyrighted (n) 1993 by Mark Adler */
X/* version 1.1   11 Jun 1993 */
X
X/* This filter reverses the effect of the sub filter.  It requires no
X   arguments, since sub puts the information necessary for extraction
X   in the stream.  See sub.c for what the filtering is and what it's
X   good for. */
X
X#include <stdio.h>
X
X#define MAGIC1    'S' /* sub data */
X#define MAGIC2    26  /* ^Z */
X#define MAX_DIST  16384
X
Xchar a[MAX_DIST];	/* last byte buffer for up to MAX_DIST differences */
X
Xint main()
X{
X  int n;		/* number of differences */
X  int i;		/* difference counter */
X  int c;		/* byte from input */
X
X  /* check magic word */
X  if (getchar() != MAGIC1 || getchar() != MAGIC2)
X  {
X    fputs("add: input stream not made by sub\n", stderr);
X    exit(1);
X  }
X
X  /* get number of differences from data */
X  if ((n = getchar()) == EOF || (i = getchar()) == EOF) {
X    fputs("add: unexpected end of file\n", stderr);
X    exit(1);
X  }
X  n += (i<<8);
X  if (n <= 0 || n > MAX_DIST) {
X    fprintf(stderr, "add: incorrect distance %d\n", n);
X    exit(1);
X  }
X
X  /* initialize last byte */
X  i = n;
X  do {
X    a[--i] = 0;
X  } while (i);
X
X  /* read differenced data and restore original */
X  while ((c = getchar()) != EOF)
X  {
X    c = (a[i++] += c) & 0xff;	/* restore data, save last byte */
X    putchar(c);			/* write original */
X    if (i == n)			/* cycle on n differences */
X      i = 0;
X  }
X  exit(0);
X  return 0;			/* avoid warning */
X}
END_OF_FILE
if test 1444 -ne `wc -c <'gzip-1.2.2/sample/add.c'`; then
    echo shar: \"'gzip-1.2.2/sample/add.c'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/sample/add.c'
fi
if test -f 'gzip-1.2.2/sample/sub.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/sample/sub.c'\"
else
echo shar: Extracting \"'gzip-1.2.2/sample/sub.c'\" \(2721 characters\)
sed "s/^X//" >'gzip-1.2.2/sample/sub.c' <<'END_OF_FILE'
X/* sub.c   not copyrighted (n) 1993 by Mark Adler */
X/* version 1.1   11 Jun 1993 */
X
X/* sub is a simple filter to preprocess a data file before compression.
X   It can increase compression for data whose points tend to be close to
X   the last point.  The output is the difference of successive bytes of
X   the input.  The add filter is used to undo what sub does.  This could
X   be used on 8-bit sound or graphics data.
X
X   sub can also take an argument to apply this to interleaved sets of
X   bytes.  For example, if the data are 16-bit sound samples, then you
X   can use "sub 2" to take differences on the low-byte stream and the
X   high-byte stream.  (This gives nearly the same effect as subtracting
X   the 16-bit values, but avoids the complexities of endianess of the
X   data.)  The concept extends to RGB image data (sub 3), 16-bit stereo
X   data (sub 4), floating point data (sub 4 or sub 8), etc.
X
X   add takes no options, since the number of interleaved byte streams
X   is put in the first two bytes of the output stream for add to use
X   (in little-endian format).
X
X   Examples:
X
X      sub < graph.vga | gzip -9 > graph.vga.sgz
X      sub < phone.snd | gzip -9 > phone.snd.sgz
X      sub 2 < audio.snd | gzip -9 > audio.snd.sgz
X      sub 3 < picture.rgb | gzip -9 > picture.rgb.sgz
X      sub 4 < stereo.snd | gzip -9 > stereo.snd.sgz
X      sub 8 < double.data | gzip -9 > double.data.sgz
X
X   To expand, use the reverse operation, as in:
X
X      gunzip < double.data.sgz | add > double.data
X*/
X
X#include <stdio.h>
X
X#define MAGIC1    'S' /* sub data */
X#define MAGIC2    26  /* ^Z */
X#define MAX_DIST  16384
X
Xchar a[MAX_DIST];	/* last byte buffer for up to MAX_DIST differences */
X
Xint main(argc, argv)
X  int argc;
X  char **argv;
X{
X  int n = 1;		/* number of differences */
X  int i;		/* difference counter */
X  int c;		/* byte from input */
X  int atoi();		/* (avoid including stdlib for portability) */
X
X  /* process arguments */
X  if (argc > 2)
X  {
X    fputs("sub: only one argument needed--# of differences\n", stderr);
X    exit(1);
X  }
X  if (argc > 1)
X    n = atoi(argv[1]);
X
X  if (n < 0) n = -n;	/* tolerate "sub -2" */
X  if (n == 0 || n > MAX_DIST) {
X    fputs("sub: incorrect distance\n", stderr);
X    exit(1);
X  }
X
X  /* initialize last byte */
X  i = n;
X  do {
X    a[--i] = 0;
X  } while (i);
X
X  /* write differenced data */
X  putchar(MAGIC1);  putchar(MAGIC2);	/* magic word for add */
X  putchar(n & 0xff);			/* so add knows what to do */
X  putchar((n>>8) & 0xff);
X
X  while ((c = getchar()) != EOF)
X  {
X    putchar((c - a[i]) & 0xff);		/* write difference */
X    a[i++] = c;				/* save last byte */
X    if (i == n)				/* cycle on n differences */
X      i = 0;
X  }
X  exit(0);
X  return 0; /* avoid warning */
X}
END_OF_FILE
if test 2721 -ne `wc -c <'gzip-1.2.2/sample/sub.c'`; then
    echo shar: \"'gzip-1.2.2/sample/sub.c'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/sample/sub.c'
fi
if test -f 'gzip-1.2.2/sample/ztouch' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/sample/ztouch'\"
else
echo shar: Extracting \"'gzip-1.2.2/sample/ztouch'\" \(384 characters\)
sed "s/^X//" >'gzip-1.2.2/sample/ztouch' <<'END_OF_FILE'
X#! /usr/local/bin/perl
X# Set the time stamp of a gzip'ed file from that stored in the file.
X# usage: ztouch files...
X
Xforeach $file (@ARGV) {
X    open (FILE, $file);
X    read (FILE, $_, 8);
X    ($magic, $method, $flags, $time) = unpack ("A2C2V", $_);
X    if ($magic eq "\037\213") {
X	utime ($time, $time, $file);
X    }
X    else {
X	warn "$file is not compressed with gzip!\n";
X    }
X}
END_OF_FILE
if test 384 -ne `wc -c <'gzip-1.2.2/sample/ztouch'`; then
    echo shar: \"'gzip-1.2.2/sample/ztouch'\" unpacked with wrong size!
fi
chmod +x 'gzip-1.2.2/sample/ztouch'
# end of 'gzip-1.2.2/sample/ztouch'
fi
if test ! -d 'gzip-1.2.2/msdos' ; then
    echo shar: Creating directory \"'gzip-1.2.2/msdos'\"
    mkdir 'gzip-1.2.2/msdos'
fi
if test -f 'gzip-1.2.2/msdos/tailor.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/msdos/tailor.c'\"
else
echo shar: Extracting \"'gzip-1.2.2/msdos/tailor.c'\" \(1638 characters\)
sed "s/^X//" >'gzip-1.2.2/msdos/tailor.c' <<'END_OF_FILE'
X/* tailor.c -- target dependent functions
X * Copyright (C) 1992-1993 Jean-loup Gailly
X * This is free software; you can redistribute it and/or modify it under the
X * terms of the GNU General Public License, see the file COPYING.
X */
X
X/* tailor.c is a bunch of non portable routines.
X * It should be kept to a minimum.
X */
X
X#include "tailor.h"
X#include "gzip.h"
X
X#ifndef lint
Xstatic char rcsid[] = "$Id: tailor.c,v 0.9 1993/05/27 14:18:31 jloup Exp $";
X#endif
X
X#ifdef __TURBOC__
X
X/************************/
X/*  Function fcalloc()  */
X/************************/
X
X/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
X * and farmalloc(64K) returns a pointer with an offset of 8, so we
X * must fix the pointer. Warning: the pointer must be put back to its
X * original form in order to free it, use fcfree().
X * For MSC, use halloc instead of this function (see tailor.h).
X */
Xstatic ush ptr_offset = 0;
X
Xvoid * fcalloc(items, size)
X    unsigned items; /* number of items */
X    unsigned size;  /* item size */
X{
X    void * buf = farmalloc((ulg)items*size + 16L);
X    /* Normalize the pointer to seg:0 */
X    if (ptr_offset == 0) {
X	ptr_offset = (ush)((uch*)buf-0);
X    } else if (ptr_offset != (ush)((uch*)buf-0)) {
X	error("inconsistent ptr_offset");
X    }
X    *((ush*)&buf+1) += (ptr_offset + 15) >> 4;
X    *(ush*)&buf = 0;
X    return buf; /* buf stays NULL if alloc failed */
X}
X
Xvoid fcfree(ptr)
X    void *ptr; /* region allocated with fcalloc() */
X{
X    /* Put the pointer back to its original form: */
X    *((ush*)&ptr+1) -= (ptr_offset + 15) >> 4;
X    *(ush*)&ptr = ptr_offset;
X    farfree(ptr);
X }
X
X#endif /* __TURBOC__ */
END_OF_FILE
if test 1638 -ne `wc -c <'gzip-1.2.2/msdos/tailor.c'`; then
    echo shar: \"'gzip-1.2.2/msdos/tailor.c'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/msdos/tailor.c'
fi
if test -f 'gzip-1.2.2/msdos/match.asm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/msdos/match.asm'\"
else
echo shar: Extracting \"'gzip-1.2.2/msdos/match.asm'\" \(8248 characters\)
sed "s/^X//" >'gzip-1.2.2/msdos/match.asm' <<'END_OF_FILE'
X; match.asm -- optional optimized asm version of longest match in deflate.c
X; Copyright (C) 1992-1993 Jean-loup Gailly
X; This is free software; you can redistribute it and/or modify it under the
X; terms of the GNU General Public License, see the file COPYING.
X;
X; Must be assembled with masm -ml. To be used only with C compact model
X; or large model. (For large model, assemble with -D__LARGE__).
X; This file is only optional. If you don't have masm or tasm, use the
X; C version (add -DNO_ASM to CFLAGS in makefile.msc and remove match.obj
X; from OBJI). If you have reduced WSIZE in zip.h, then change its value
X; below.
X;
X; Turbo C 2.0 does not support static allocation of more than 64K bytes per
X; file, and does not have SS == DS. So TC and BC++ users must use:
X;   tasm -ml -DDYN_ALLOC -DSS_NEQ_DS match;
X;
X; To simplify the code, the option -DDYN_ALLOC is supported for OS/2
X; only if the arrays are guaranteed to have zero offset (allocated by
X; halloc). We also require SS==DS. This is satisfied for MSC but not Turbo C.
X
X; $Id: match.asm,v 0.6 1993/01/21 18:49:05 jloup Exp $
X
X        name    match
X
Xifndef DYN_ALLOC
X        extrn   _prev         : word
X        extrn   _window       : byte
X        prev    equ  _prev    ; offset part
X        window  equ  _window
Xendif
X
X_DATA    segment  word public 'DATA'
X        extrn   _nice_match   : word
X        extrn   _match_start  : word
X        extrn   _prev_length  : word
X        extrn   _good_match   : word
X        extrn   _strstart     : word
X        extrn   _max_chain_length : word
Xifdef DYN_ALLOC
X        extrn   _prev         : word
X        extrn   _window       : word
X        prev    equ 0         ; offset forced to zero
X        window  equ 0
X        window_seg equ _window[2]
X	window_off equ 0
Xelse
X	wseg    dw seg _window
X        window_seg equ wseg
X	window_off equ offset _window
Xendif
X_DATA    ends
X
XDGROUP  group _DATA
X
X_TEXT   segment word public 'CODE'
X        assume  cs: _TEXT, ds: DGROUP
X
X	public _match_init
X        public _longest_match
X
X	MIN_MATCH     equ 3
X        MAX_MATCH     equ 258
X	WSIZE         equ 32768		; keep in sync with zip.h !
X	MIN_LOOKAHEAD equ (MAX_MATCH+MIN_MATCH+1)
X	MAX_DIST      equ (WSIZE-MIN_LOOKAHEAD)
X
Xprev_ptr    dw  seg _prev		; pointer to the prev array
Xifdef SS_NEQ_DS
X    match_start dw  0			; copy of _match_start if SS != DS
X    nice_match  dw  0			; copy of _nice_match  if SS != DS
Xendif
X
X; initialize or check the variables used in match.asm.
X
Xifdef __LARGE__
X_match_init proc far			; 'proc far' for large model
Xelse
X_match_init proc near			; 'proc near' for compact model
Xendif
Xifdef SS_NEQ_DS
X        ma_start equ cs:match_start	; does not work on OS/2
X        nice     equ cs:nice_match
X	mov	ax,_nice_match
X	mov     cs:nice_match,ax       	; ugly write to code, crash on OS/2
Xelse
X	assume ss: DGROUP
X        ma_start equ ss:_match_start
X        nice     equ ss:_nice_match
X        mov     ax,ds
X        mov     bx,ss
X        cmp     ax,bx                   ; SS == DS?
X        jne     error
Xendif
Xifdef DYN_ALLOC
X	cmp	_prev[0],0		; verify zero offset
X	jne	error
X	cmp	_window[0],0
X	jne	error
X  ifdef SS_NEQ_DS
X	mov	ax,_prev[2]		; segment value
X	mov     cs:prev_ptr,ax		; ugly write to code, crash on OS/2
X        prev_seg  equ cs:prev_ptr
X  else
X        prev_seg  equ ss:_prev[2]	; works on OS/2 if SS == DS
X  endif
Xelse
X        prev_seg  equ cs:prev_ptr
Xendif
X	ret
Xifdef __LARGE__
X	extrn   _exit : far		; 'far' for large model
Xelse
X	extrn   _exit : near		; 'near' for compact model
Xendif
Xerror:  call    _exit
X
X_match_init endp
X
X; -----------------------------------------------------------------------
X; Set match_start to the longest match starting at the given string and
X; return its length. Matches shorter or equal to prev_length are discarded,
X; in which case the result is equal to prev_length and match_start is
X; garbage.
X; IN assertions: cur_match is the head of the hash chain for the current
X;   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
X
X; int longest_match(cur_match)
X
Xifdef __LARGE__
X_longest_match  proc far		 ; 'proc far' for large model
Xelse
X_longest_match  proc near		 ; 'proc near' for compact model
Xendif
X        push    bp
X        mov     bp,sp
X        push    di
X	push	si
X	push	ds
X
Xifdef __LARGE__
X        cur_match    equ word ptr [bp+6] ; [bp+6] for large model
Xelse
X        cur_match    equ word ptr [bp+4] ; [bp+4] for compact model
Xendif
X
X;       window	     equ es:window (es:0 for DYN_ALLOC)
X;       prev	     equ ds:prev
X;       match        equ es:si
X;       scan         equ es:di
X;       chain_length equ bp
X;       best_len     equ bx
X;       limit        equ dx
X
X	mov	si,cur_match            ; use bp before it is destroyed
X        mov     bp,_max_chain_length    ; chain_length = max_chain_length
X	mov	di,_strstart
X	mov	dx,di
X	sub	dx,MAX_DIST             ; limit = strstart-MAX_DIST
X	jae	limit_ok
X	sub	dx,dx			; limit = NIL
Xlimit_ok:
X        add     di,2+window_off         ; di = offset(window + strstart + 2)
X        mov     bx,_prev_length         ; best_len = prev_length
X	mov     es,window_seg
X        mov     ax,es:[bx+di-3]         ; ax = scan[best_len-1..best_len]
X        mov     cx,es:[di-2]            ; cx = scan[0..1]
X	cmp	bx,_good_match		; do we have a good match already?
X        mov     ds,prev_seg    		; (does not destroy the flags)
X        assume  ds: nothing
X        jb      do_scan			; good match?
X	shr	bp,1			; chain_length >>= 2
X	shr	bp,1
X        jmp     short do_scan
X
X        even                            ; align destination of branch
Xlong_loop:
X; at this point, ds:di == scan+2, ds:si == cur_match
X        mov     ax,[bx+di-3]            ; ax = scan[best_len-1..best_len]
X        mov     cx,[di-2]               ; cx = scan[0..1]
X        mov     ds,prev_seg    		; reset ds to address the prev array
Xshort_loop:
X; at this point, di == scan+2, si = cur_match,
X; ax = scan[best_len-1..best_len] and cx = scan[0..1]
Xif (WSIZE-32768)
X        and     si,WSIZE-1              ; not needed if WSIZE=32768
Xendif
X        shl     si,1                    ; cur_match as word index
X        mov     si,prev[si]             ; cur_match = prev[cur_match]
X        cmp     si,dx			; cur_match <= limit ?
X        jbe     the_end
X        dec     bp                      ; --chain_length
X        jz      the_end
Xdo_scan:
X        cmp     ax,word ptr es:window[bx+si-1] ; check match at best_len-1
X        jne     short_loop
X        cmp     cx,word ptr es:window[si]      ; check min_match_length match
X        jne     short_loop
X
X        lea     si,window[si+2]         ; si = match
X        mov     ax,di                   ; ax = scan+2
X        mov     cx,es
X        mov     ds,cx			; ds = es = window
X        mov     cx,(MAX_MATCH-2)/2      ; scan for at most MAX_MATCH bytes
X        repe    cmpsw                   ; loop until mismatch
X        je      maxmatch                ; match of length MAX_MATCH?
Xmismatch:
X        mov     cl,[di-2]               ; mismatch on first or second byte?
X        sub     cl,[si-2]               ; cl = 0 if first bytes equal
X        xchg    ax,di                   ; di = scan+2, ax = end of scan
X        sub     ax,di                   ; ax = len
X	sub	si,ax			; si = cur_match + 2 + offset(window)
X	sub	si,2+window_off         ; si = cur_match
X        sub     cl,1                    ; set carry if cl == 0 (can't use DEC)
X        adc     ax,0                    ; ax = carry ? len+1 : len
X        cmp     ax,bx                   ; len > best_len ?
X        jle     long_loop
X        mov     ma_start,si             ; match_start = cur_match
X        mov     bx,ax                   ; bx = best_len = len
X        cmp     ax,nice                 ; len >= nice_match ?
X        jl      long_loop
Xthe_end:
X	pop	ds
X        assume  ds: DGROUP
Xifdef SS_NEQ_DS
X	mov	ax,ma_start		; garbage if no match found
X	mov	ds:_match_start,ax
Xendif
X        pop     si
X        pop     di
X        pop     bp
X        mov     ax,bx                   ; result = ax = best_len
X        ret
Xmaxmatch:                               ; come here if maximum match
X        cmpsb                           ; increment si and di
X        jmp     mismatch                ; force match_length = MAX_LENGTH
X        
X_longest_match  endp
X
X_TEXT   ends
Xend
END_OF_FILE
if test 8248 -ne `wc -c <'gzip-1.2.2/msdos/match.asm'`; then
    echo shar: \"'gzip-1.2.2/msdos/match.asm'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/msdos/match.asm'
fi
if test -f 'gzip-1.2.2/msdos/gzip.prj' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/msdos/gzip.prj'\"
else
echo shar: Extracting \"'gzip-1.2.2/msdos/gzip.prj'\" \(561 characters\)
sed "s/^X//" >'gzip-1.2.2/msdos/gzip.prj' <<'END_OF_FILE'
Xgzip.c       (gzip.h tailor.h crypt.h revision.h lzw.h)
Xzip.c        (gzip.h tailor.h crypt.h)
Xdeflate.c    (gzip.h tailor.h)
Xtrees.c      (gzip.h tailor.h)
Xbits.c       (gzip.h tailor.h crypt.h)
Xunzip.c      (gzip.h tailor.h crypt.h)
Xinflate.c    (gzip.h tailor.h)
Xutil.c       (gzip.h tailor.h crypt.h)
Xcrypt.c      (gzip.h tailor.h crypt.h)
Xlzw.c        (gzip.h tailor.h)
Xunlzw.c      (gzip.h tailor.h lzw.h)
Xunpack.c     (gzip.h tailor.h)
Xunlzh.c      (gzip.h tailor.h)
Xtailor.c     (gzip.h tailor.h)
Xgetopt.c     (getopt.h)
Xalloca.c
Xmatch.obj
Xwildargs.obj
END_OF_FILE
if test 561 -ne `wc -c <'gzip-1.2.2/msdos/gzip.prj'`; then
    echo shar: \"'gzip-1.2.2/msdos/gzip.prj'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/msdos/gzip.prj'
fi
if test -f 'gzip-1.2.2/msdos/doturboc.bat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/msdos/doturboc.bat'\"
else
echo shar: Extracting \"'gzip-1.2.2/msdos/doturboc.bat'\" \(830 characters\)
sed "s/^X//" >'gzip-1.2.2/msdos/doturboc.bat' <<'END_OF_FILE'
X: This file is a complement to gzip.prj for Turbo C 2.0 users.
X: To construct gzip, first transform all files to msdos CR LF format.
X: (Use utilities such as flip or do file transfers in ascii mode.)
X: Then invoke this file. Then enter Turbo C, set the the
X: compilation model to compact, and the project file to gzip.prj.
X: Change the compilation flags if you wish (add SMALL_MEM
X: to reduce the memory requirements), and press F9...
X: WARNING: you must use the compact or large model in this version.
X: To use the large model, add -D__LARGE__ in the tasm command below.
X: To get the file wildargs.obj, do:
X:
X:   pkunpak \tcc\startup wildargs.obj
X:
X: pkunpak is available in wuarchive.wustl.edu:/mirrors/msdos/starter/pk361.exe
X:
X: After compiling gzip.exe, do: copy gzip.exe gunzip.exe
X:
Xtasm -ml -DDYN_ALLOC -DSS_NEQ_DS match;
END_OF_FILE
if test 830 -ne `wc -c <'gzip-1.2.2/msdos/doturboc.bat'`; then
    echo shar: \"'gzip-1.2.2/msdos/doturboc.bat'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/msdos/doturboc.bat'
fi
if test -f 'gzip-1.2.2/msdos/Makefile.msc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/msdos/Makefile.msc'\"
else
echo shar: Extracting \"'gzip-1.2.2/msdos/Makefile.msc'\" \(2898 characters\)
sed "s/^X//" >'gzip-1.2.2/msdos/Makefile.msc' <<'END_OF_FILE'
X# Makefile for gzip
X# Microsoft C 5.1 or 6.0.
X
X# To use, do "make makefile.msc"
X
X# WARNING: the small model is not supported. The compact model is used
X# here. If you want to use the large model, add -D__LARGE__ to ASFLAGS
X# Add -DSMALL_MEM to CFLAGS if you wish to reduce the memory
X# requirements. Add -DNO_ASM to CFLAGS and remove match.obj from OBJI if
X# you do not have masm.
X
X# ------------- Microsoft C 5.1 and later -------------
XMODEL=-AC
XFP=
XCFLAGS=-Ox -nologo $(MODEL)
XBFLAGS=-Oait -Gs -nologo $(MODEL)
X# BFLAGS are the 'bug workaround' flags.
XCC=cl
XLD=link
XLDFLAGS=/e/st:0x1000/noe
X#     If you use lzexe as recommended, remove /e from LDFLAGS
XAS=masm
X#     For MSC 6.0, use: AS=ml 
XASFLAGS=-ml -t
X# Add -DDYN_ALLOC to ASFLAGS if you have defined it in tailor.h or CFLAGS
XLIB = c:\c51\lib
X
X# ------------- Common declarations:
XSTRIP=rem
X#    If you don't have lzexe, get it (by ftp on wuarchive.wustl.edu
X#    in /mirrors/msdos/filutl/lzexe91e.zip). Then define:
X#STRIP=lzexe
X#    Or if you've registered PKLITE, then define:
X#STRIP=pklite
X#    This makes a big difference in .exe size (and possibly load time)
X
XO=.obj
XOBJA=match$(O) $(LIB)\setargv$(O)
XALLOCA=alloca$(O)
X
X# ------------- Used by install rule
X# set BIN to the directory you want to install the executables to
XBIN = c:\bin
X
X# variables
XOBJ1 = gzip$(O) zip$(O) deflate$(O) trees$(O) bits$(O) unzip$(O) inflate$(O) \
X       util$(O)
XOBJ2 = crypt$(O) lzw$(O) unlzw$(O) unpack$(O) unlzh$(O) getopt$(O) $(OBJA) \
X       $(ALLOCA)
X
Xgzip.obj: gzip.c gzip.h tailor.h crypt.h revision.h lzw.h
X	$(CC) -c $(CFLAGS) $*.c
X
Xzip.obj: zip.c gzip.h tailor.h crypt.h
X	$(CC) -c $(CFLAGS) $*.c
X
Xdeflate.obj: deflate.c gzip.h tailor.h
X	$(CC) -c $(CFLAGS) $*.c
X
Xtrees.obj: trees.c gzip.h tailor.h
X	$(CC) -c $(CFLAGS) $*.c
X
Xbits.obj: bits.c gzip.h tailor.h crypt.h
X	$(CC) -c $(CFLAGS) $*.c
X
Xunzip.obj: unzip.c gzip.h tailor.h crypt.h
X	$(CC) -c $(CFLAGS) $*.c
X
Xinflate.obj: inflate.c gzip.h tailor.h
X	$(CC) -c $(CFLAGS) $*.c
X
Xutil.obj: util.c gzip.h tailor.h crypt.h
X	$(CC) -c $(BFLAGS) $*.c
X
Xcrypt.obj: crypt.c gzip.h tailor.h crypt.h
X	$(CC) -c $(CFLAGS) $*.c
X
Xlzw.obj: lzw.c gzip.h tailor.h
X	$(CC) -c $(CFLAGS) $*.c
X
Xunlzw.obj: unlzw.c gzip.h tailor.h lzw.h
X	$(CC) -c $(CFLAGS) $*.c
X
Xunpack.obj: unpack.c gzip.h tailor.h
X	$(CC) -c $(CFLAGS) $*.c
X
Xunlzh.obj: unlzh.c gzip.h tailor.h
X	$(CC) -c $(CFLAGS) $*.c
X
Xtailor.obj: tailor.c gzip.h tailor.h
X	$(CC) -c $(CFLAGS) $*.c
X
Xgetopt.obj: getopt.c getopt.h
X	$(CC) -c $(CFLAGS) $*.c
X
Xalloca.obj: alloca.c
X 	$(CC) -c $(CFLAGS) $*.c
X
Xmatch.obj:	match.asm
X	$(AS) $(ASFLAGS) match;
X
X# we must cut the command line to fit in the MS/DOS 128 byte limit:
Xgzip.exe: $(OBJ1) $(OBJ2)
X	echo $(OBJ1)+ > gzip.rsp
X	echo $(OBJ2); >> gzip.rsp
X	$(LD) $(LDFLAGS) @gzip.rsp
X	del gzip.rsp
X	$(STRIP) gzip.exe
X
Xinstall: gzip.exe
X	copy /b gzip.exe $(BIN)
X	copy /b gzip.exe $(BIN)\gunzip.exe
X
X#clean:
X#	del *.obj
X#	del *.exe
END_OF_FILE
if test 2898 -ne `wc -c <'gzip-1.2.2/msdos/Makefile.msc'`; then
    echo shar: \"'gzip-1.2.2/msdos/Makefile.msc'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/msdos/Makefile.msc'
fi
if test -f 'gzip-1.2.2/msdos/Makefile.bor' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/msdos/Makefile.bor'\"
else
echo shar: Extracting \"'gzip-1.2.2/msdos/Makefile.bor'\" \(2897 characters\)
sed "s/^X//" >'gzip-1.2.2/msdos/Makefile.bor' <<'END_OF_FILE'
X# Makefile for gzip
X# Borland (Turbo) C++.
X# Warning: this file is not suitable for Turbo C 2.0. In this case, read
X# then invoke the file doturboc.bat.
X
X# To use, do "make -fmakefile.bor"
X
X# WARNING: the small model is not supported. The compact model is used
X# here. If you want to use the large model, add -D__LARGE__ to ASFLAGS
X# Add -DSMALL_MEM to CFLAGS if you wish to reduce the memory
X# requirements. Add -DNO_ASM to CFLAGS and remove match.obj from OBJA if
X# you do not have tasm.
X
X# ------------- Turbo C++, Borland C++ -------------
XMODEL=-mc
X#CFLAGS=-w -w-eff -w-def -w-sig -w-cln -a -d -G -O -Z $(MODEL)
XCFLAGS=-O2 -Z $(MODEL)
XCC=bcc
XLD=bcc
X#   replace bcc with tcc for Turbo C++ 1.0
XLDFLAGS=$(MODEL)
XAS=tasm
XASFLAGS=-ml -t -DDYN_ALLOC -DSS_NEQ_DS
XLIB = c:\bcc\lib
X
X# ------------- Common declarations:
XSTRIP=rem
X#    If you don't have lzexe, get it (by ftp on wuarchive.wustl.edu
X#    in /mirrors/msdos/filutl/lzexe91e.zip). Then define:
X#STRIP=lzexe
X#    Or if you've registered PKLITE, then define:
X#STRIP=pklite
X#    This makes a big difference in .exe size (and possibly load time)
X
XO=.obj
XOBJA=match$(O) tailor$(O) $(LIB)\wildargs.obj
XALLOCA=alloca$(O)
X
X# ------------- Used by install rule
X# set BIN to the directory you want to install the executables to
XBIN = c:\bin
X
X# variables
XOBJ1 = gzip$(O) zip$(O) deflate$(O) trees$(O) bits$(O) unzip$(O) inflate$(O) \
X       util$(O)
XOBJ2 = crypt$(O) lzw$(O) unlzw$(O) unpack$(O) unlzh$(O) getopt$(O) $(OBJA) \
X       $(ALLOCA)
X
Xall: gzip.exe
X
Xgzip.obj: gzip.c gzip.h tailor.h crypt.h revision.h lzw.h
X	$(CC) -c $(CFLAGS) $*.c
X
Xzip.obj: zip.c gzip.h tailor.h crypt.h
X	$(CC) -c $(CFLAGS) $*.c
X
Xdeflate.obj: deflate.c gzip.h tailor.h
X	$(CC) -c $(CFLAGS) $*.c
X
Xtrees.obj: trees.c gzip.h tailor.h
X	$(CC) -c $(CFLAGS) $*.c
X
Xbits.obj: bits.c gzip.h tailor.h crypt.h
X	$(CC) -c $(CFLAGS) $*.c
X
Xunzip.obj: unzip.c gzip.h tailor.h crypt.h
X	$(CC) -c $(CFLAGS) $*.c
X
Xinflate.obj: inflate.c gzip.h tailor.h
X	$(CC) -c $(CFLAGS) $*.c
X
Xutil.obj: util.c gzip.h tailor.h crypt.h
X	$(CC) -c $(CFLAGS) $*.c
X
Xcrypt.obj: crypt.c gzip.h tailor.h crypt.h
X	$(CC) -c $(CFLAGS) $*.c
X
Xlzw.obj: lzw.c gzip.h tailor.h
X	$(CC) -c $(CFLAGS) $*.c
X
Xunlzw.obj: unlzw.c gzip.h tailor.h lzw.h
X	$(CC) -c $(CFLAGS) $*.c
X
Xunpack.obj: unpack.c gzip.h tailor.h
X	$(CC) -c $(CFLAGS) $*.c
X
Xunlzh.obj: unlzh.c gzip.h tailor.h
X	$(CC) -c $(CFLAGS) $*.c
X
Xtailor.obj: tailor.c gzip.h tailor.h
X	$(CC) -c $(CFLAGS) $*.c
X
Xgetopt.obj: getopt.c getopt.h
X	$(CC) -c $(CFLAGS) $*.c
X
Xalloca.obj: alloca.c
X 	$(CC) -c $(CFLAGS) $*.c
X
Xmatch.obj:	match.asm
X	$(AS) $(ASFLAGS) match;
X
X# we must cut the command line to fit in the MS/DOS 128 byte limit:
Xgzip.exe: $(OBJ1) $(OBJ2)
X	echo $(OBJ1) > gzip.rsp
X	echo $(OBJ2) >> gzip.rsp
X	$(LD) $(LDFLAGS) @gzip.rsp
X	del gzip.rsp
X	$(STRIP) gzip.exe
X
Xinstall: gzip.exe
X	copy /b gzip.exe $(BIN)
X	copy /b gzip.exe $(BIN)\gunzip.exe
X
Xclean:
X	del *.obj
X	del *.exe
END_OF_FILE
if test 2897 -ne `wc -c <'gzip-1.2.2/msdos/Makefile.bor'`; then
    echo shar: \"'gzip-1.2.2/msdos/Makefile.bor'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/msdos/Makefile.bor'
fi
if test -f 'gzip-1.2.2/msdos/Makefile.djg' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/msdos/Makefile.djg'\"
else
echo shar: Extracting \"'gzip-1.2.2/msdos/Makefile.djg'\" \(5760 characters\)
sed "s/^X//" >'gzip-1.2.2/msdos/Makefile.djg' <<'END_OF_FILE'
X# Makefile for gzip (GNU zip)    -*- Indented-Text -*-
X# Copyright (C) 1992-1993 Jean-loup Gailly and the Free Software Foundation
X# Modified for GNUish make/MS_SH200/DJGPP 1.09+ by Eric Backus
X
X# This program is free software; you can redistribute it and/or modify
X# it under the terms of the GNU General Public License as published by
X# the Free Software Foundation; either version 2, or (at your option)
X# any later version.
X
X# This program is distributed in the hope that it will be useful,
X# but WITHOUT ANY WARRANTY; without even the implied warranty of
X# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X# GNU General Public License for more details.
X
X# You should have received a copy of the GNU General Public License
X# along with this program; if not, write to the Free Software
X# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
X# $Id: Makefile.djg,v 1.2 1993/06/12 06:55:22 jloup Exp $
X
X#### Start of system configuration section. ####
X
X.SUFFIXES: .o
XLONGARGS = gcc:rm
X
Xsrcdir = .
XVPATH = .
X
XCC = gcc
XCPP = gcc -O -E
X
XINSTALL = install -c
XINSTALL_PROGRAM = $(INSTALL)
XINSTALL_DATA = $(INSTALL) -m 644
X
X# tailor.h defines things for DJGPP so nothing is needed here
XDEFS =
XLIBS =
XALLOCA =
X
X# additional assembly sources for particular systems may be required.
XOBJA = match.o
X
XSEDCMD = 1d
X
XCFLAGS = -O2 -finline-functions -fomit-frame-pointer
XLDFLAGS = -s
X
XX=.exe
X# For OS/2 or MSDOS, use: X=.exe
X
XO=.o
X# For OS/2 or MSDOS, use: O=.obj
X
Xprefix = /usr/local
Xexec_prefix = $(prefix)
X
Xbindir = $(exec_prefix)/bin
Xdatadir = $(prefix)/lib
Xlibdir = $(prefix)/lib
Xinfodir = $(prefix)/info
X
X# Extension (not including `.') for the installed manual page filenames.
Xmanext = 1
X# Where to install the manual pages.
Xmandir = $(prefix)/man/man$(manext)
X
X#### End of system configuration section. ####
X
XSHELL = /bin/sh
X
XLOADLIBES = $(LIBS)
X
XTAR = tar
X
XSRCS = gzip.c zip.c deflate.c trees.c bits.c unzip.c inflate.c util.c crypt.c\
X       lzw.c unlzw.c unpack.c unlzh.c makecrc.c getopt.c alloca.c match.S
X
XOBJ1 = gzip$(O) zip$(O) deflate$(O) trees$(O) bits$(O) unzip$(O) inflate$(O) \
X       util$(O)
XOBJ2 = crypt$(O) lzw$(O) unlzw$(O) unpack$(O) unlzh$(O) getopt$(O) $(OBJA) \
X       $(ALLOCA)
X
XHDRS = gzip.h lzw.h tailor.h revision.h crypt.h getopt.h
X
X.c$O:
X	$(CC) -c $(DEFS) $(CFLAGS) $<
X
X#.PHONY: default all force test check
X
Xdefault:  all
Xall:	gzip$X zcmp zdiff zmore znew zforce gzexe
Xforce:
X
Xinstall: all
X	for f in gzip$X zcmp zdiff zmore znew zforce gzexe; do \
X	  $(INSTALL_PROGRAM) $${f} $(bindir)/$${f}; done
X	for f in gunzip$X zcat$X ; do \
X	  rm -f $(bindir)/$${f}; ln $(bindir)/gzip$X $(bindir)/$${f}; done
X	-cd $(srcdir); \
X	  for f in gzip gunzip zcat zcmp zmore znew zforce gzexe; do \
X	  rm -f $(mandir)/$${f}.$(manext); \
X	  $(INSTALL_DATA) $${f}.1 $(mandir)/$${f}.$(manext); done
X	-cd $(srcdir); for f in gzip.info* ; do $(INSTALL_DATA) $${f} \
X	  $(infodir)/$${f}; done
X
Xuninstall: force
X	-cd $(bindir); rm -f gzip$X gunzip$X zcat$X \
X	  zcmp zdiff zmore znew zforce gzexe
X	-for f in gzip gunzip zcat zcmp zmore znew gzexe; do \
X	  rm -f $(mandir)/$${f}.$(manext); done
X	-cd $(infodir); rm -f gzip.info*
X
X# install all files and replace compress (not recommended)
Xinstall_compress: install
X	-test -f $(bindir)/compress.old || \
X	  mv $(bindir)/compress$X $(bindir)/compress.old
X	ln $(bindir)/gzip$X $(bindir)/compress$X
X	rm -f $(bindir)/uncompress$X
X	ln $(bindir)/gzip$X $(bindir)/uncompress$X
X
Xtest: check
Xcheck:	all
X	./gzip -5 < $(srcdir)/texinfo.tex > _gztest.z
X	# Either GNUish make or MS_SH has trouble with backquotes
X	#@if test `wc -c < _gztest.z` -ne 30890; then \
X	#   echo FAILED gzip test: incorrect size; rm -f _gztest*; exit 1; \
X	#   else :; fi
X	@echo Should be 30890:\\c
X	@wc -c < _gztest.z
X	rm -f _gztest
X	./gzip -d _gztest.z
X	@if cmp _gztest $(srcdir)/texinfo.tex; then \
X	   echo gzip test OK; \
X	else \
X	   echo FAILED gzip test: incorrect decompress; \
X	fi
X	rm -f _gztest*
X
XTAGS: $(SRCS) $(HDRS)
X	cd $(srcdir); etags $(SRCS) $(HDRS)
X
XMakefile: Makefile.in ./config.status
X	./config.status
X
X./config.status: configure
X	$(srcdir)/configure --srcdir=$(srcdir) --no-create
X
Xconfigure: configure.in
X	@echo Warning: configure is out of date
X#	cd $(srcdir); autoconf
X
Xclean:
X	rm -f *$O gzip$X gunzip$X zcat$X a.out core gzip
X	rm -f zcmp zdiff zmore znew zforce gzexe _gztest*
X	rm -f *.aux *.cp *.cps *.dvi *.fn *.fns *.ky *.kys *.log
X	rm -f *.pg *.pgs *.toc *.tp *.tps *.vr *.vrs
X
Xmostlyclean: clean
X
Xdistclean: clean
X	rm -f Makefile config.status
X
Xrealclean: distclean
X	rm -f TAGS gzip.info*
X
X# Actual build-related targets
X
Xgzip$X:	gzip
X	aout2exe gzip
X
Xgzip:	$(OBJ1) $(OBJ2)
X        echo $(OBJ1) > gzip.rsp
X        echo $(OBJ2) $(LIBS) >> gzip.rsp
X	$(CC) $(LDFLAGS) -o $@ @gzip.rsp
X	del gzip.rsp
X
Xgzip$O zip$O deflate$O trees$O bits$O unzip$O inflate$O: gzip.h tailor.h
Xutil$O lzw$O unlzw$O unpack$O unlzh$O crypt$O: gzip.h tailor.h
X
Xgzip$O unlzw$O: revision.h lzw.h
X
Xbits$O unzip$O util$O zip$O: crypt.h
X
Xgzip$O getopt$O: getopt.h
X
Xmatch$O: match.S
X	$(CC) -c match.S
X
Xzcmp: zcmp.in
X	sed "$(SEDCMD)" $(srcdir)/zcmp.in > zcmp
X	chmod 755 zcmp
X
Xzdiff: zdiff.in
X	sed "$(SEDCMD)" $(srcdir)/zdiff.in > zdiff
X	chmod 755 zdiff
X
Xzmore: zmore.in
X	sed "$(SEDCMD)" $(srcdir)/zmore.in > zmore
X	chmod 755 zmore
X
Xznew: znew.in
X	sed "$(SEDCMD)" $(srcdir)/znew.in > znew
X	chmod 755 znew
X
Xzforce: zforce.in
X	sed "$(SEDCMD)" $(srcdir)/zforce.in > zforce
X	chmod 755 zforce
X
Xgzexe: gzexe.in
X	sed "$(SEDCMD)" $(srcdir)/gzexe.in > gzexe
X	chmod 755 gzexe
X
Xgzip.info: gzip.texi
X	cd $(srcdir); makeinfo gzip.texi
X
Xgzip.dvi: gzip.texi
X	cd $(srcdir); texi2dvi gzip.texi
X
Xgzip.doc: gzip.1
X	cd $(srcdir); nroff -man gzip.1 | col -b | uniq > gzip.doc
X
X# Prevent GNU make v3 from overflowing arg limit on SysV.
X.NOEXPORT:
X
X# end of file
END_OF_FILE
if test 5760 -ne `wc -c <'gzip-1.2.2/msdos/Makefile.djg'`; then
    echo shar: \"'gzip-1.2.2/msdos/Makefile.djg'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/msdos/Makefile.djg'
fi
if test ! -d 'gzip-1.2.2/os2' ; then
    echo shar: Creating directory \"'gzip-1.2.2/os2'\"
    mkdir 'gzip-1.2.2/os2'
fi
if test -f 'gzip-1.2.2/os2/Makefile.os2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/os2/Makefile.os2'\"
else
echo shar: Extracting \"'gzip-1.2.2/os2/Makefile.os2'\" \(2061 characters\)
sed "s/^X//" >'gzip-1.2.2/os2/Makefile.os2' <<'END_OF_FILE'
X# Makefile for gzip (GNU zip), OS/2 version    -*- Indented-Text -*-
X# Written by Kai Uwe Rommel <rommel@informatik.tu-muenchen.de>
X
X# specialized version for OS/2
X
Xdefault:
X	@echo "Enter $(MAKE) -f makefile.os2 target"
X	@echo "where target is one of:"
X	@echo "   msc mscdebug gcc gccdyn gccdebug"
X
X# compilation with emx 0.8f (gcc 2.3.3) or newer
X#
X# release version, statically linked C runtime
Xgcc:
X	$(MAKE) -f Makefile.os2 all \
X	CC="gcc -Zomf -Zsys" O=".obj" S=".S" \
X	AS="gcc -Zomf -xassembler-with-cpp -c -o" \
X	CFLAGS="-O" LDFLAGS="gzip.def -s"
X#
X# release version, dynamically linked C runtime
Xgccdyn:
X	$(MAKE) -f Makefile.os2 all \
X	CC="gcc -Zomf -Zmt" O=".obj" S=".S" \
X	AS="gcc -Zomf -xassembler-with-cpp -c -o" \
X	CFLAGS="-O" LDFLAGS="gzip.def -s"
X#
X# debugging version
Xgccdebug:
X	$(MAKE) -f Makefile.os2 all \
X	CC="gcc -g" O=".o" S=".S" \
X	AS="gcc -g -xassembler-with-cpp -c -o" \
X	CFLAGS="" LDFLAGS="gzip.def"
X
X# compilation with MS C 6.00
X#
X# release version
Xmsc:
X	$(MAKE) -f Makefile.os2 all \
X	CC="cl -nologo -AC" O=".obj" S=".asm" \
X	AS="ml -nologo -Zm -Cp -c -Fo" \
X	CFLAGS=" -W1 -Zap -J -G2s -Ocegit" \
X	LDFLAGS="-Lp -F 2000 setargv.obj gzip16.def -link /noe"
X#
X# debugging version
Xmscdebug:
X	$(MAKE) -f Makefile.os2 all \
X	CC="cl -nologo -AC -Zi" O=".obj" S=".asm" \
X	AS="ml -nologo -Zm -Zi -Cp -c -Fo" \
X	CFLAGS="-W1 -Zap -J -G2 -Od" \
X	LDFLAGS="-Lp -F 2000 setargv.obj gzip16.def -link /noe /exe"
X
XDEFS  = -DOS2 -DASMV
X
XOBJS = gzip$O zip$O deflate$O trees$O bits$O unzip$O inflate$O util$O \
X       crypt$O lzw$O unlzw$O unpack$O unlzh$O getopt$O match$O
X
X.SUFFIXES: .c $O
X
X.c$O:
X	$(CC) $(CFLAGS) $(DEFS) -c $<
X
Xall: gzip.exe gzip.info gzip.doc
X
Xgzip.exe: $(OBJS)
X	$(CC) -o $@ $(OBJS) $(LDFLAGS)
X
Xgzip$O zip$O deflate$O trees$O bits$O unzip$O inflate$O: gzip.h tailor.h
Xutil$O lzw$O unlzw$O unpack$O unlzh$O crypt$O: gzip.h tailor.h
X
Xgzip$O unlzw$O: revision.h lzw.h
X
Xbits$O unzip$O util$O zip$O: crypt.h
X
Xmatch$O: match$S
X	$(AS) $@ match$S
X
Xgzip.info: gzip.texi gpl.texinfo
X	makeinfo gzip.texi
X
Xgzip.doc: gzip.1
X	groff -man gzip.1 > $@
END_OF_FILE
if test 2061 -ne `wc -c <'gzip-1.2.2/os2/Makefile.os2'`; then
    echo shar: \"'gzip-1.2.2/os2/Makefile.os2'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/os2/Makefile.os2'
fi
if test -f 'gzip-1.2.2/os2/gzip.def' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/os2/gzip.def'\"
else
echo shar: Extracting \"'gzip-1.2.2/os2/gzip.def'\" \(98 characters\)
sed "s/^X//" >'gzip-1.2.2/os2/gzip.def' <<'END_OF_FILE'
XNAME GZIP WINDOWCOMPAT NEWFILES
XDESCRIPTION 'GNU gzip file compression program'
XSTACKSIZE 0x80000
END_OF_FILE
if test 98 -ne `wc -c <'gzip-1.2.2/os2/gzip.def'`; then
    echo shar: \"'gzip-1.2.2/os2/gzip.def'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/os2/gzip.def'
fi
if test -f 'gzip-1.2.2/os2/gzip16.def' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/os2/gzip16.def'\"
else
echo shar: Extracting \"'gzip-1.2.2/os2/gzip16.def'\" \(80 characters\)
sed "s/^X//" >'gzip-1.2.2/os2/gzip16.def' <<'END_OF_FILE'
XNAME GZIP WINDOWCOMPAT NEWFILES
XDESCRIPTION 'GNU gzip file compression program'
END_OF_FILE
if test 80 -ne `wc -c <'gzip-1.2.2/os2/gzip16.def'`; then
    echo shar: \"'gzip-1.2.2/os2/gzip16.def'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/os2/gzip16.def'
fi
if test ! -d 'gzip-1.2.2/vms' ; then
    echo shar: Creating directory \"'gzip-1.2.2/vms'\"
    mkdir 'gzip-1.2.2/vms'
fi
if test -f 'gzip-1.2.2/vms/Makefile.vms' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/vms/Makefile.vms'\"
else
echo shar: Extracting \"'gzip-1.2.2/vms/Makefile.vms'\" \(4570 characters\)
sed "s/^X//" >'gzip-1.2.2/vms/Makefile.vms' <<'END_OF_FILE'
X# Makefile for gzip (GNU zip)    -*- Indented-Text -*-
X# Copyright (C) 1992-1993 Jean-loup Gailly and the Free Software Foundation
X# VMS version made by Klaus Reimann <kr@cip.physik.uni-stuttgart.de>,
X# revised by Roland B Roberts <roberts@nsrl31.nsrl.rochester.edu>.
X# This version is for VAXC. Tested with Todd Aven's MAKE/VMS.
X
X# After constructing gzip.exe with this Makefile, you should set up
X# symbols for gzip.exe.  Edit the example below, changing
X# "disk:[directory]" as appropriate.
X#
X# $ gzip   == "$disk:[directory]gzip.exe"
X# $ gunzip == "$disk:[directory]gunzip.exe"
X# $ zcat   == "$disk:[directory]zcat.exe"
X
X
X# This program is free software; you can redistribute it and/or modify
X# it under the terms of the GNU General Public License as published by
X# the Free Software Foundation; either version 2, or (at your option)
X# any later version.
X
X# This program is distributed in the hope that it will be useful,
X# but WITHOUT ANY WARRANTY; without even the implied warranty of
X# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X# GNU General Public License for more details.
X
X# You should have received a copy of the GNU General Public License
X# along with this program; if not, write to the Free Software
X# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
X#### Start of system configuration section. ####
X
XCC = cc
XLINK = link
X
XCFLAGS =
X# CFLAGS = /warning
XLDFLAGS =
X
X# Things you might add to DEFS
X# -DDIRENT              Use <dirent.h>  for recursion (-r)
X# -DSYSDIR              Use <sys/dir.h> for recursion (-r)
X# -DSYSNDIR             Use <sys/ndir.h> for recursion (-r)
X# -DNDIR                Use <ndir.h> for recursion (-r)
X# -DSTDC_HEADERS        Use <stdlib.h>
X# -DHAVE_UNISTD_H	Use <unistd.h>
X# -DNO_UTIME_H		Don't use <utime.h>
X# -DHAVE_SYSUTIME_H	Use <sys/utime.h>
X# -DNO_MEMORY_H         Don't use <memory.h>. Not needed if STDC_HEADERS.
X# -DNO_STRING_H         Use strings.h, not string.h. Not needed if STDC_HEADERS
X# -DRETSIGTYPE=int      Define this if signal handlers must return an int.
X# -DNO_SYMLINK          OS defines S_IFLNK but does not support symbolic links
X# -DNO_MULTIPLE_DOTS    System does not allow file names with multiple dots
X# -DNO_UTIME		System does not support setting file modification time
X# -DNO_CHOWN		System does not support setting file owner
X# -DNO_DIR		System does not support readdir()
X# -DPROTO		Force function prototypes even if __STDC__ not defined
X# -DASMV		Use asm version match.S
X# -DMSDOS		MSDOS specific
X# -DOS2			OS/2 specific
X# -DVAXC		Vax/VMS with Vax C compiler
X# -DVMS			Vax/VMS with gcc
X# -DDEBUG		Debug code
X# -DDYN_ALLOC		Use dynamic allocation of large data structures
X# -DMAXSEG_64K		Maximum array size is 64K (for 16 bit system)
X# -DRECORD_IO           read() and write() are rounded to record sizes.
X# -DNO_STDIN_FSTAT      fstat() is not available on stdin
X# -DNO_SIZE_CHECK       stat() does not give a reliable file size
X
X# DEFS = /define=(VAXC)
XDEFS =
XLIBS =
X
XX=.exe
XO=.obj
X
X# additional assembly sources for particular systems be required.
XOBJA =
XALLOCA = alloca$O
X# only if CC != gcc
X
X#### End of system configuration section. ####
X
XOBJS = gzip$O zip$O deflate$O trees$O bits$O unzip$O inflate$O util$O \
X       crypt$O lzw$O unlzw$O unpack$O unlzh$O getopt$O vms$O $(OBJA) $(ALLOCA)
X
X# --- rules ---
X
X*$O:	*.c
X	define/user sys sys$library
X	$(CC) $* $(DEFS) $(CFLAGS)
X#	create sys$output
X#		$(CC) $* $(DEFS) $(CFLAGS)$
X
Xdefault:  all
X
Xall:	gzip$X #zcmp zdiff zmore znew
X
Xgzip$X : $(OBJS) #Makefile
X  linkobjs:=$(OBJS)
X  Schleife:
X	p = f$locate(" ",linkobjs)
X	if p .lt. f$length(linkobjs)
X		then	linkobjs[p,1]:=","
X			goto Schleife
X	endif
X  write sys$output "linking ''linkobjs'"
X  $(LINK) $(LDFLAGS) /exec=gzip$X  'linkobjs',sys$input/opt
X	SYS$LIBRARY:VAXCRTL/SHARE $
X#
X#  Create a hard link.  To remove both files, use "make clean".  Using a hard
X#  link saves disk space, by the way.  Note, however, that copying a hard link
X#  copies the data, not just the link.  Therefore, set up the link in the
X#  directory in which the executable is to reside, or else rename (move) the
X#  executables into the directory.
X# 
X  set file/enter=gunzip.exe gzip.exe
X  set file/enter=zcat.exe   gzip.exe
X
X
Xclean:
X	set file/remove gunzip.exe;0
X	set file/remove zcat.exe;0
X	delete gzip.exe;0
X	delete *$O;0
X
X# Actual build-related targets
X
Xgzip$O zip$O deflate$O trees$O bits$O unzip$O inflate$O: gzip.h tailor.h
Xutil$O lzw$O unlzw$O unpack$O unlzh$O crypt$O: gzip.h tailor.h
X
Xgzip$O unlzw$O: revision.h lzw.h
X
Xbits$O unzip$O util$O zip$O: crypt.h
X
Xgzip$O getopt$O: getopt.h
END_OF_FILE
if test 4570 -ne `wc -c <'gzip-1.2.2/vms/Makefile.vms'`; then
    echo shar: \"'gzip-1.2.2/vms/Makefile.vms'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/vms/Makefile.vms'
fi
if test -f 'gzip-1.2.2/vms/Makefile.gcc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/vms/Makefile.gcc'\"
else
echo shar: Extracting \"'gzip-1.2.2/vms/Makefile.gcc'\" \(4518 characters\)
sed "s/^X//" >'gzip-1.2.2/vms/Makefile.gcc' <<'END_OF_FILE'
X# Makefile for gzip (GNU zip)    -*- Indented-Text -*-
X# Copyright (C) 1992-1993 Jean-loup Gailly and the Free Software Foundation
X# VMS version made by Klaus Reimann <kr@cip.physik.uni-stuttgart.de>,
X# revised by Roland B Roberts <roberts@nsrl31.nsrl.rochester.edu>.
X# This version is for gcc.
X
X# After constructing gzip.exe with this Makefile, you should set up
X# symbols for gzip.exe.  Edit the example below, changing
X# "disk:[directory]" as appropriate.
X#
X# $ gzip   == "$disk:[directory]gzip.exe"
X# $ gunzip == "$disk:[directory]gunzip.exe"
X# $ zcat   == "$disk:[directory]zcat.exe"
X
X
X# This program is free software; you can redistribute it and/or modify
X# it under the terms of the GNU General Public License as published by
X# the Free Software Foundation; either version 2, or (at your option)
X# any later version.
X
X# This program is distributed in the hope that it will be useful,
X# but WITHOUT ANY WARRANTY; without even the implied warranty of
X# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X# GNU General Public License for more details.
X
X# You should have received a copy of the GNU General Public License
X# along with this program; if not, write to the Free Software
X# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
X#### Start of system configuration section. ####
X
XCC = gcc
XLINK = link
X
XCFLAGS =
X# CFLAGS = /warning
XLDFLAGS =
X
X# Things you might add to DEFS
X# -DDIRENT              Use <dirent.h>  for recursion (-r)
X# -DSYSDIR              Use <sys/dir.h> for recursion (-r)
X# -DSYSNDIR             Use <sys/ndir.h> for recursion (-r)
X# -DNDIR                Use <ndir.h> for recursion (-r)
X# -DSTDC_HEADERS        Use <stdlib.h>
X# -DHAVE_UNISTD_H	Use <unistd.h>
X# -DNO_UTIME_H		Don't use <utime.h>
X# -DHAVE_SYSUTIME_H	Use <sys/utime.h>
X# -DNO_MEMORY_H         Don't use <memory.h>. Not needed if STDC_HEADERS.
X# -DNO_STRING_H         Use strings.h, not string.h. Not needed if STDC_HEADERS
X# -DRETSIGTYPE=int      Define this if signal handlers must return an int.
X# -DNO_SYMLINK          OS defines S_IFLNK but does not support symbolic links
X# -DNO_MULTIPLE_DOTS    System does not allow file names with multiple dots
X# -DNO_UTIME		System does not support setting file modification time
X# -DNO_CHOWN		System does not support setting file owner
X# -DNO_DIR		System does not support readdir()
X# -DPROTO		Force function prototypes even if __STDC__ not defined
X# -DASMV		Use asm version match.S
X# -DMSDOS		MSDOS specific
X# -DOS2			OS/2 specific
X# -DVAXC		Vax/VMS with Vax C compiler
X# -DVMS			Vax/VMS with gcc
X# -DDEBUG		Debug code
X# -DDYN_ALLOC		Use dynamic allocation of large data structures
X# -DMAXSEG_64K		Maximum array size is 64K (for 16 bit system)
X# -DRECORD_IO           read() and write() are rounded to record sizes.
X# -DNO_STDIN_FSTAT      fstat() is not available on stdin
X# -DNO_SIZE_CHECK       stat() does not give a reliable file size
X
XDEFS = /define=(VMS)
XLIBS = #@LIBS@
X
XX=.exe
XO=.obj
X
X# additional assembly sources for particular systems be required.
XOBJA = #@OBJA@
XALLOCA = alloca$O
X
X#### End of system configuration section. ####
X
XOBJS = gzip$O zip$O deflate$O trees$O bits$O unzip$O inflate$O util$O \
X       crypt$O lzw$O unlzw$O unpack$O unlzh$O getopt$O vms$O $(OBJA) $(ALLOCA)
X
X# --- rules ---
X
X*$O:	*.c
X	$(CC) $* $(DEFS) $(CFLAGS)
X#	create sys$output
X#		$(CC) $* $(DEFS) $(CFLAGS)$
X
Xdefault:  all
X
Xall:	gzip$X #zcmp zdiff zmore znew
X
Xgzip$X : $(OBJS) #Makefile
X  linkobjs:=$(OBJS)
X  Schleife:
X	p = f$locate(" ",linkobjs)
X	if p .lt. f$length(linkobjs)
X		then	linkobjs[p,1]:=","
X			goto Schleife
X	endif
X  write sys$output "linking ''linkobjs'"
X  $(LINK) $(LDFLAGS) /exec=gzip$X  'linkobjs',sys$input/opt
X	GNU_CC:[000000]GCCLIB/LIB,SYS$LIBRARY:VAXCRTL/SHARE $
X
X#  Create a hard link.  To remove both files, use "make clean".  Using a hard
X#  link saves disk space, by the way.  Note, however, that copying a hard link
X#  copies the data, not just the link.  Therefore, set up the link in the
X#  directory in which the executable is to reside, or else rename (move) the
X#  executables into the directory.
X# 
X  set file/enter=gunzip.exe gzip.exe
X  set file/enter=zcat.exe   gzip.exe
X
X
Xclean:
X	set file/remove gunzip.exe;0
X	set file/remove zcat.exe;0
X	delete gzip.exe;0
X	delete *$O;0
X
X# Actual build-related targets
X
Xgzip$O zip$O deflate$O trees$O bits$O unzip$O inflate$O: gzip.h tailor.h
Xutil$O lzw$O unlzw$O unpack$O unlzh$O crypt$O: gzip.h tailor.h
X
Xgzip$O unlzw$O: revision.h lzw.h
X
Xbits$O unzip$O util$O zip$O: crypt.h
X
Xgzip$O getopt$O: getopt.h
END_OF_FILE
if test 4518 -ne `wc -c <'gzip-1.2.2/vms/Makefile.gcc'`; then
    echo shar: \"'gzip-1.2.2/vms/Makefile.gcc'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/vms/Makefile.gcc'
fi
if test -f 'gzip-1.2.2/vms/makegzip.com' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/vms/makegzip.com'\"
else
echo shar: Extracting \"'gzip-1.2.2/vms/makegzip.com'\" \(2498 characters\)
sed "s/^X//" >'gzip-1.2.2/vms/makegzip.com' <<'END_OF_FILE'
X$! Makefile for VMS
X$! DCL-Shell-language. Edit the symbols section at the end.
X$!
X$ On Control_Y Then Goto The_Exit
X$ On Error Then Goto The_Exit
X$ define/user sys sys$library
X$ cc gzip.c /define=(VAXC)
X$ define/user sys sys$library
X$ cc zip.c /define=(VAXC)
X$ define/user sys sys$library
X$ cc deflate.c /define=(VAXC)
X$ define/user sys sys$library
X$ cc trees.c /define=(VAXC)
X$ define/user sys sys$library
X$ cc bits.c /define=(VAXC)
X$ define/user sys sys$library
X$ cc unzip.c /define=(VAXC)
X$ define/user sys sys$library
X$ cc inflate.c /define=(VAXC)
X$ define/user sys sys$library
X$ cc util.c /define=(VAXC)
X$ define/user sys sys$library
X$ cc crypt.c /define=(VAXC)
X$ define/user sys sys$library
X$ cc lzw.c /define=(VAXC)
X$ define/user sys sys$library
X$ cc unlzw.c /define=(VAXC)
X$ define/user sys sys$library
X$ cc unpack.c /define=(VAXC)
X$ define/user sys sys$library
X$ cc unlzh.c /define=(VAXC)
X$ define/user sys sys$library
X$ cc getopt.c /define=(VAXC)
X$ define/user sys sys$library
X$ cc vms.c /define=(VAXC)
X$ define/user sys sys$library
X$ cc alloca.c /define=(VAXC)
X$ linkobjs:=gzip.obj zip.obj deflate.obj trees.obj bits.obj unzip.obj -
X   inflate.obj util.obj crypt.obj lzw.obj unlzw.obj unpack.obj unlzh.obj -
X   getopt.obj vms.obj alloca.obj
X$ Schleife:
X$ p = f$locate(" ",linkobjs)
X$ if p .lt. f$length(linkobjs)
X$ then	linkobjs[p,1]:=","
X$ goto Schleife
X$ endif
X$ write sys$output "linking ''linkobjs'"
X$ link  /exec=gzip.exe  'linkobjs',sys$input/opt
XSYS$LIBRARY:VAXCRTL/SHARE 
X$
X$ ! Create a hard link.  (To remove both files, delete the copy FIRST, then
X$ ! the original.  Otherwise, if original deleted first [copy says "no such
X$ ! file"], must use "set file/remove gunzip.exe;#" to get rid of the copy.
X$ ! Unlike in Unix, deleting the original ALWAYS destroys the data--but not
X$ ! the directory entry of the copy.)  Using a hard link saves disk space, by
X$ ! the way.  Note, however, that copying a hard link copies the data, not
X$ ! just the link.  Therefore, set up the link in the directory in which the
X$ ! executable is to reside, or else rename (move) the executables into the
X$ ! directory.
X$ !
X$ set file/enter=gunzip.exe gzip.exe
X$ set file/enter=zcat.exe   gzip.exe
X$
X$ ! Set up symbols for the gzip executable.  Edit the example below,
X$ ! changing "disk:[directory]" as appropriate.
X$ !
X$ gzip   == "$disk:[directory]gzip.exe"
X$ gunzip == "$disk:[directory]gunzip.exe"
X$ zcat   == "$disk:[directory]zcat.exe"
X$
X$The_Exit:
X$ Save_Status = $STATUS
X$ exit Save_Status
END_OF_FILE
if test 2498 -ne `wc -c <'gzip-1.2.2/vms/makegzip.com'`; then
    echo shar: \"'gzip-1.2.2/vms/makegzip.com'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/vms/makegzip.com'
fi
if test -f 'gzip-1.2.2/vms/Makefile.mms' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/vms/Makefile.mms'\"
else
echo shar: Extracting \"'gzip-1.2.2/vms/Makefile.mms'\" \(4428 characters\)
sed "s/^X//" >'gzip-1.2.2/vms/Makefile.mms' <<'END_OF_FILE'
X# Makefile for gzip (GNU zip)    -*- Indented-Text -*-
X# Copyright (C) 1992-1993 Jean-loup Gailly and the Free Software Foundation
X# VMS version made by Klaus Reimann <kr@cip.physik.uni-stuttgart.de>,
X# revised by Roland B Roberts <roberts@nsrl31.nsrl.rochester.edu>
X# and Karl-Jose Filler <pla_jfi@pki-nbg.philips.de>
X# This version is for VAXC with MMS.
X
X# After constructing gzip.exe with this Makefile, you should set up
X# symbols for gzip.exe.  Edit the example below, changing
X# "disk:[directory]" as appropriate.
X#
X# $ gzip   == "$disk:[directory]gzip.exe"
X# $ gunzip == "$disk:[directory]gunzip.exe"
X# $ zcat   == "$disk:[directory]zcat.exe"
X
X
X# This program is free software; you can redistribute it and/or modify
X# it under the terms of the GNU General Public License as published by
X# the Free Software Foundation; either version 2, or (at your option)
X# any later version.
X
X# This program is distributed in the hope that it will be useful,
X# but WITHOUT ANY WARRANTY; without even the implied warranty of
X# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X# GNU General Public License for more details.
X
X# You should have received a copy of the GNU General Public License
X# along with this program; if not, write to the Free Software
X# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
X#### Start of system configuration section. ####
X
XCC = cc
XLINK = link
X
XCFLAGS =
X# CFLAGS = /warning
XLDFLAGS =
X
X# Things you might add to DEFS
X# -DDIRENT              Use <dirent.h>  for recursion (-r)
X# -DSYSDIR              Use <sys/dir.h> for recursion (-r)
X# -DSYSNDIR             Use <sys/ndir.h> for recursion (-r)
X# -DNDIR                Use <ndir.h> for recursion (-r)
X# -DSTDC_HEADERS        Use <stdlib.h>
X# -DHAVE_UNISTD_H	Use <unistd.h>
X# -DNO_UTIME_H		Don't use <utime.h>
X# -DHAVE_SYSUTIME_H	Use <sys/utime.h>
X# -DNO_MEMORY_H         Don't use <memory.h>. Not needed if STDC_HEADERS.
X# -DNO_STRING_H         Use strings.h, not string.h. Not needed if STDC_HEADERS
X# -DRETSIGTYPE=int      Define this if signal handlers must return an int.
X# -DNO_SYMLINK          OS defines S_IFLNK but does not support symbolic links
X# -DNO_MULTIPLE_DOTS    System does not allow file names with multiple dots
X# -DNO_UTIME		System does not support setting file modification time
X# -DNO_CHOWN		System does not support setting file owner
X# -DNO_DIR		System does not support readdir()
X# -DPROTO		Force function prototypes even if __STDC__ not defined
X# -DASMV		Use asm version match.S
X# -DMSDOS		MSDOS specific
X# -DOS2			OS/2 specific
X# -DVAXC		Vax/VMS with Vax C compiler
X# -DVMS			Vax/VMS with gcc
X# -DDEBUG		Debug code
X# -DDYN_ALLOC		Use dynamic allocation of large data structures
X# -DMAXSEG_64K		Maximum array size is 64K (for 16 bit system)
X# -DRECORD_IO           read() and write() are rounded to record sizes.
X# -DNO_STDIN_FSTAT      fstat() is not available on stdin
X# -DNO_SIZE_CHECK       stat() does not give a reliable file size
X
X# DEFS = /define=(VAXC)
XDEFS =
XLIBS =
X
XX=.exe
XO=.obj
X
X# additional assembly sources for particular systems be required.
XOBJA =
XALLOCA = alloca.obj
X# only if CC != gcc
X
X#### End of system configuration section. ####
X
XOBJS = gzip.obj zip.obj deflate.obj trees.obj bits.obj unzip.obj inflate.obj \
X       util.obj crypt.obj lzw.obj unlzw.obj unpack.obj unlzh.obj getopt.obj \
X       vms.obj $(OBJA) $(ALLOCA)
X
X# --- rules ---
X
X.c.obj :
X	define/user sys sys$library
X	$(CC) $* $(DEFS) $(CFLAGS)
X#	create sys.output
X#		$(CC) $* $(DEFS) $(CFLAGS)$
X
Xgzip.exe : $(OBJS)
X	define lnk$library sys$share:vaxcrtl
X	$(LINK) $(LDFLAGS) /exec=gzip  $+
X#
X#  Create a hard link.  To remove both files, use "make clean".  Using a hard
X#  link saves disk space, by the way.  Note, however, that copying a hard link
X#  copies the data, not just the link.  Therefore, set up the link in the
X#  directory in which the executable is to reside, or else rename (move) the
X#  executables into the directory.
X# 
X	set file/enter=gunzip.exe gzip.exe
X	set file/enter=zcat.exe   gzip.exe
X
Xclean :
X	set file/remove gunzip.exe;0
X	set file/remove zcat.exe;0
X	delete gzip.exe;0
X	delete *.obj;0
X
X# Actual build-related targets
X
Xgzip.obj zip.obj deflate.obj trees.obj bits.obj unzip.obj inflate.obj : gzip.h tailor.h
Xutil.obj lzw.obj unlzw.obj unpack.obj unlzh.obj crypt.obj : gzip.h tailor.h
X
Xgzip.obj unlzw.obj : revision.h lzw.h
X
Xbits.obj unzip.obj util.obj zip.obj : crypt.h
X
Xgzip.obj getopt.obj : getopt.h
END_OF_FILE
if test 4428 -ne `wc -c <'gzip-1.2.2/vms/Makefile.mms'`; then
    echo shar: \"'gzip-1.2.2/vms/Makefile.mms'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/vms/Makefile.mms'
fi
if test -f 'gzip-1.2.2/vms/vms.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/vms/vms.c'\"
else
echo shar: Extracting \"'gzip-1.2.2/vms/vms.c'\" \(2233 characters\)
sed "s/^X//" >'gzip-1.2.2/vms/vms.c' <<'END_OF_FILE'
X/* vms.c -- target dependent functions for VMS
X * This is free software; you can redistribute it and/or modify it under the
X * terms of the GNU General Public License, see the file COPYING.
X *
X * This file was written by Karl-Jose Filler <pla_jfi@pki-nbg.philips.de>
X * and updated by Jean-loup Gailly.
X */
X
X#include <stdio.h>
X
Xstatic char **vms_argv = NULL;
X
Xstatic int max_files = 10000;
X
Xstruct	Str_desc {
X    int     length;
X    char    *addr;
X};
X
Xvms_expand_args(old_argc, argv)
X    int *old_argc;
X    char **argv[];
X{
X    int	    i;
X    int	    new_argc = 0;
X    int	    context, status;
X    char    buf[255], *p;
X    
X    vms_argv = (char**)xmalloc((max_files+1)*sizeof(char*));
X
X    vms_argv[new_argc++] = **argv;
X
X    for (i=1; i < *old_argc; i++) {
X	if (*argv[0][i] == '-') {   /* switches */
X	    if (new_argc < max_files) {
X		vms_argv[new_argc++] = argv[0][i];
X	    }
X	} else {		    /* Files */
X	    context = 0;
X	    if (find_file_c(argv[0][i], buf, sizeof(buf), &context) & 1 != 1) {
X		/* 
X	         * Wrong file ?
X		 * forward it to gzip
X		 */
X		if (new_argc < max_files) {
X		    vms_argv[new_argc++] = argv[0][i];
X		}
X	    } else {
X		p = (char*)xmalloc(strlen(buf)+1);
X		strcpy(p, buf);
X		if (new_argc < max_files) {
X		    vms_argv[new_argc++] = p;
X		}
X		while (find_file_c(argv[0][i], buf, 
X		       sizeof(buf), &context) & 1 == 1) {
X		    p = (char*)xmalloc(strlen(buf)+1);
X		    strcpy(p, buf);
X		    if (new_argc < max_files) {
X			vms_argv[new_argc++] = p;
X		    }
X		}
X	    }
X	}
X    }
X    if (new_argc <= max_files) {
X	*old_argc = new_argc;
X	vms_argv[new_argc] = NULL;
X	*argv = vms_argv;
X    } else {
X	free(vms_argv); /* the expanded file names should also be freed ... */
X	vms_argv = NULL;
X	max_files = new_argc + 1;
X	vms_expand_args(old_argc, argv);
X    }
X}
X
Xint find_file_c(in,out,out_len,context)
X    char *in;
X    char *out;
X    int   out_len;
X    int  *context;
X{
X    struct	Str_desc in_desc,out_desc;
X    int		status;
X    char	*p;
X  
X    in_desc.addr = in;
X    in_desc.length = strlen(in);
X  
X    out_desc.addr = out;
X    out_desc.length = out_len;
X  
X    status = lib$find_file(&in_desc,&out_desc,context);
X
X    p   = out_desc.addr;
X    while(*p != ' ') {
X	p++;
X    }
X    *p = 0;
X  
X    return status;
X}
END_OF_FILE
if test 2233 -ne `wc -c <'gzip-1.2.2/vms/vms.c'`; then
    echo shar: \"'gzip-1.2.2/vms/vms.c'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/vms/vms.c'
fi
if test -f 'gzip-1.2.2/vms/gzip.hlp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/vms/gzip.hlp'\"
else
echo shar: Extracting \"'gzip-1.2.2/vms/gzip.hlp'\" \(12595 characters\)
sed "s/^X//" >'gzip-1.2.2/vms/gzip.hlp' <<'END_OF_FILE'
X1 GZIP
XNAME
X     gzip, gunzip, zcat - compress or expand files
X
XSYNOPSIS
X     gzip [ -acdfhlLnrtvV19 ] [-S suffix] [ name ... ]
X     gunzip [ -acfhlLnrtvV ] [-S suffix] [ name ... ]
X     zcat [ -fhLV ] [ name ... ]
X
X2 DESCRIPTION
X     Gzip reduces the size of the named  files  using  Lempel-Ziv
X     coding  (LZ77).  Whenever possible, each file is replaced by
X     one with the extension .gz, while keeping the same ownership
X     modes,  access  and modification times.  (The default exten-
X     sion is -gz for VMS, z for MSDOS, OS/2 FAT and Atari.) If no
X     files are specified, the standard input is compressed to the
X     standard output.  Gzip will only attempt to compress regular
X     files.
X
X     If the new file name is too long for its file  system,  gzip
X     truncates  it  and  keeps  the  original  file  name  in the
X     compressed file.  Gzip attempts to truncate only  the  parts
X     of  the file name longer than 3 characters.  (A part is del-
X     imited by dots.) If the name consists of small  parts  only,
X     the  longest parts are truncated. For example, if file names
X     are limited to 14 characters, gzip.msdos.exe  is  compressed
X     to gzi.msd.exe.gz.  Names are not truncated on systems which
X     do not have a limit on file name length.
X
X     Compressed files can be  restored  to  their  original  form
X     using  gzip -d or gunzip or zcat. If the original name saved
X     in the compressed file is not suitable for its file  system,
X     a  new  name is constructed from the original one to make it
X     legal.
X
X     gunzip takes a  list  of  files  on  its  command  line  and
X     replaces each file whose name ends with .gz, -gz, .z, -z, _z
X     or .Z and which begins with the correct magic number with an
X     uncompressed  file  without  the original extension.  gunzip
X     also recognizes the special  extensions  .tgz  and  .taz  as
X     shorthands   for  .tar.gz  and  .tar.Z  respectively.   When
X     compressing, gzip  uses  the  .tgz  extension  if  necessary
X     instead of truncating a file with a .tar extension.
X
X     gunzip can currently decompress files created by gzip,  zip,
X     compress,  compress  -H  or pack. The detection of the input
X     format is automatic.  When using the first two formats, gun-
X     zip  checks  a  32  bit  CRC.  For  pack,  gunzip checks the
X     uncompressed length. The standard compress  format  was  not
X     designed  to  allow  consistency  checks.  However gunzip is
X     sometimes able to detect a bad .Z file. If you get an  error
X     when uncompressing a .Z file, do not assume that the .Z file
X     is correct simply because the standard uncompress  does  not
X     complain.  This generally means that the standard uncompress
X     does not check its input, and happily generates garbage out-
X     put.   The  SCO  compress -H format (lzh compression method)
X     does not include a CRC  but  also  allows  some  consistency
X     checks.
X
X     Files created by zip can be uncompressed  by  gzip  only  if
X     they  have  a  single member compressed with the 'deflation'
X     method. This feature is only intended to help conversion  of
X     tar.zip  files  to  the  tar.gz format. To extract zip files
X     with several members, use unzip instead of gunzip.
X
X     zcat is identical to gunzip -c. (On some systems,  zcat  may
X     be  installed  as  gzcat  to  preserve  the original link to
X     compress.) zcat uncompresses either a list of files  on  the
X     command   line   or   its  standard  input  and  writes  the
X     uncompressed data on standard output.  zcat will  uncompress
X     files that have the correct magic number whether they have a
X     .gz suffix or not.
X
X     Gzip uses the Lempel-Ziv algorithm used in  zip  and  PKZIP.
X     The  amount  of  compression obtained depends on the size of
X     the input and the distribution of common substrings.   Typi-
X     cally,  text  such  as  source code or English is reduced by
X     60-70%.  Compression is  generally  much  better  than  that
X     achieved  by  LZW  (as used in compress), Huffman coding (as
X     used in pack), or adaptive Huffman coding (compact).
X
X     Compression is always performed, even if the compressed file
X     is  slightly larger than the original. The worst case expan-
X     sion is a few bytes for the gzip file header, plus  5  bytes
X     every  32K  block, or an expansion ratio of 0.015% for large
X     files. Note that the  actual  number  of  used  disk  blocks
X     almost  never increases.  gzip preserves the mode, ownership
X     and timestamps of files when compressing or decompressing.
X
X2 OPTIONS
X     -a --ascii
X          Ascii text mode: convert end-of-lines using local  con-
X          ventions.  This  option  is supported only on some non-
X          Unix systems. For MSDOS, CR LF is converted to LF  when
X          compressing,   and  LF  is  converted  to  CR  LF  when
X          decompressing.
X
X     -c --stdout --to-stdout
X          Write output on standard output;  keep  original  files
X          unchanged.   If there are several input files, the out-
X          put consists of a sequence of independently  compressed
X          members.  To obtain better compression, concatenate all
X          input files before compressing them.
X
X     -d --decompress --uncompress
X          Decompress.
X
X     -f --force
X          Force compression or decompression even if the file has
X          multiple   links  or  the  corresponding  file  already
X          exists, or if the compressed data is read from or writ-
X          ten to a terminal. If the input data is not in a format
X          recognized by gzip, and if the option --stdout is  also
X          given,  copy the input data without change to the stan-
X          dard ouput: let zcat behave as cat. If -f is not given,
X          and when not running in the background, gzip prompts to
X          verify whether an existing file should be overwritten.
X
X     -h --help
X          Display a help screen and quit.
X
X     -l --list
X          For each compressed file, list the following fields:
X
X              compressed size: size of the compressed file
X              uncompressed size: size of the uncompressed file
X              ratio: compression ratio (0.0% if unknown)
X              uncompressed_name: name of the uncompressed file
X
X          The uncompressed size is given as -1 on VMS because it
X	  it is not possible to seek reliably to the end of the
X          compressed file, where this size is stored.
X
X          In combination with the --verbose option, the following
X          fields are also displayed:
X
X              method: compression method (deflate,compress,lzh,pack)
X              crc: the 32-bit CRC of the uncompressed data
X              date & time: time stamp for the uncompressed file
X
X          The crc is given as ffffffff on VMS for the reason given
X          above about the uncompressed size.
X
X	  With --quiet, the title line is not displayed.
X
X     -L --license
X          Display the gzip license and quit.
X
X     -n --no-name
X          When compressing, do not save the original file name by
X          default. (The original name is always saved if the name
X          had  to  be  truncated.)  When  decompressing,  do  not
X          restore  the original file name if present: remove only
X          the gzip suffix from the compressed file name.
X
X     -q --quiet
X          Suppress all warnings.
X
X     -r --recurse
X          Travel the directory structure recursively. If  any  of
X          the file names specified on the command line are direc-
X          tories,  gzip  will  descend  into  the  directory  and
X          compress  all  the  files it finds there (or decompress
X          them in the case of gunzip ).
X
X     -S suf --suffix suf
X          Use suffix suf instead  of  -gz.   Any  suffix  can  be
X          given,  but  suffixes  other  than -z and -gz should be
X          avoided to avoid confusion when files  are  transferred
X          to   other.   A  null  suffix  forces  gunzip  to   try
X          decompression on all given files regardless of  suffix,
X          as in:
X
X              gunzip -S "" *.*
X
X          Previous versions of gzip used the -z suffix. This  was
X          changed to avoid a conflict with pack on Unix.
X
X     -t --test
X          Test. Check the compressed file integrity.
X
X     -v --verbose
X          Verbose. Display the name and percentage reduction  for
X          each file compressed or decompressed.
X
X     -V --version
X          Version. Display the  version  number  and  compilation
X          options then quit.
X
X     -# --fast --best
X          Regulate the speed of compression using  the  specified
X          digit  #,  where  -1  or  --fast  indicates the fastest
X          compression method (less compression) and -9 or  --best
X          indicates   the  slowest  compression  method  (optimal
X          compression).  The  default  compression  level  is  -6
X          (that is, biased towards high compression at expense of
X          speed).
X
X2 ENVIRONMENT
X     The environment variable GZIP_OPT can hold a set of  default
X     options  for  gzip.  These options are interpreted first and
X     can be overwritten by explicit command line  parameters. For
X     example:
X           GZIP_OPT == "-8 -v"
X
X2 SEE ALSO
X     compress, zip, unzip
X
X2 DIAGNOSTICS
X     Exit status is normally 0; if an error occurs,  exit  status
X     is 1. If a warning occurs, exit status is 2.
X
X     Usage: gzip [-cdfhlLnrtvV19] [-S suffix] [file ...]
X             Invalid options were specified on the command line.
X     file: not in gzip format
X             The  file  specified  to   gunzip   has   not   been
X             compressed.
X     file: Corrupt input. Use zcat to recover some data.
X             The compressed file has been damaged. The data up to
X             the point of failure can be recovered using
X                   define /user sys$output file.recover
X                   zcat file
X     file: compressed with xx bits, can only handle yy bits
X             File was compressed (using LZW) by  a  program  that
X             could  deal  with more bits than the decompress code
X             on this machine.  Recompress  the  file  with  gzip,
X             which compresses better and uses less memory.
X     file: already has -gz suffix -- no change
X             The  file  is  assumed  to  be  already  compressed.
X             Rename the file and try again.
X     file already exists; do you wish to overwrite (y or n)?
X             Respond "y" if  you  want  the  output  file  to  be
X             replaced; "n" if not.
X     gunzip: corrupt input
X             A SIGSEGV violation was detected which usually means
X             that the input file has been corrupted.
X     xx.x%
X             Percentage  of  the  input  saved  by   compression.
X             (Relevant only for -v and -l.)
X     -- not a regular file or directory: ignored
X             When the input file is not a regular file or  direc-
X             tory, it is left unaltered.
X
X2 CAVEATS
X     On VMS:
X     - upper case options need quotes: gzip "-V".
X     - restoration of timestamps and version numbers is not supported
X     - If a compressed file already exists, gzip -f overwrites it, it
X       does not create a new version.
X     - multi-part gzip files are not supported.
X     - gunzip does not preserve the input file format. You can use a
X       separate utility to restore the original format.
X     - gunzip and zcat can be used only if you have created the
X       links to gzip as documented in makegzip.com.  Otherwise
X       you must use explicit parameters ("gzip -c" or "gzip -dc").
X     - gzip --list cannot give the uncompressed size and crc.
X
X     When writing compressed data to  a  tape,  it  is  generally
X     necessary  to pad the output with zeroes up to a block boun-
X     dary. When the data is read and the whole block is passed to
X     gunzip for decompression, gunzip detects that there is extra
X     trailing garbage after the compressed data and emits a warn-
X     ing  by  default.  You  have  to  use  the --quiet option to
X     suppress the warning. This option can be  set  in  the  GZIP
X     environment variable as in:
X         GZIP == "-q"
X         tar xfz /dev/rmt/datn
X
X     In the above example, gzip is invoked implicitly by  the  -z
X     option  of  GNU  tar. Make sure that the same block size (-b
X     option of tar) is used for reading  and  writing  compressed
X     data on tapes.
X
X2 BUGS
X     On VMS, files in VFC record format are not correctly handled by
X     the C runtime library (the linefeed character is suppressed).
END_OF_FILE
if test 12595 -ne `wc -c <'gzip-1.2.2/vms/gzip.hlp'`; then
    echo shar: \"'gzip-1.2.2/vms/gzip.hlp'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/vms/gzip.hlp'
fi
if test ! -d 'gzip-1.2.2/amiga' ; then
    echo shar: Creating directory \"'gzip-1.2.2/amiga'\"
    mkdir 'gzip-1.2.2/amiga'
fi
if test -f 'gzip-1.2.2/amiga/Makefile.sasc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/amiga/Makefile.sasc'\"
else
echo shar: Extracting \"'gzip-1.2.2/amiga/Makefile.sasc'\" \(2103 characters\)
sed "s/^X//" >'gzip-1.2.2/amiga/Makefile.sasc' <<'END_OF_FILE'
X# Makefile for gzip (GNU zip)    -*- Indented-Text -*-
X# This Makefile is for SAS/C 6.2 on the Amiga
X# Made by Carsten Steger (carsten.steger@informatik.tu-muenchen.de)
X
X# Some notes on gzip for the Amiga:
X# Due to a broken implementation of readdir() in the SAS/C 6.2 library
X# you should not use gzip -r on a directory in the RAM-Disk. To zip all
X# files in a directory 'dir' in the RAM-Disk use something like
X# gzip ram:dir/#? ram:dir/#?/#? ...
X# where the number of '#?'s reflects the depth of the directory 'dir'.
X#
X# Alas, the program has it's full functionality only if you have
X# Kickstart 2.0 or higher installed. This affects the expansion of
X# wildcards and the preservation of file access times. You should use
X# a shell that does wildcard expansion under Kickstart 1.3.
X
X
XCC = sc
X
X# If you have a 68020 or more you can define UNALIGNED_OK below
XDEFS = DEF=AMIGA
XLIBS = LIB LIB:scnb.lib
X
XCFLAGS = DATA=FAR.html NOSTKCHK IDIR=
XOPTFLAGS = OPT OPTGO OPTPEEP OPTCOMP=3 OPTDEP=3 OPTRDEP=3
X# PARM=R not yet supported in CFLAGS
XLDFLAGS = FROM LIB:c.o
X
XOBJS = gzip.o zip.o deflate.o trees.o bits.o unzip.o inflate.o util.o \
X      crypt.o lzw.o unlzw.o unpack.o unlzh.o getopt.o alloca.o tailor.o match.o
X
X.c.o:
X	$(CC) $(DEFS) $(CFLAGS) $(OPTFLAGS) $<
X.a.o:
X	$(CC) $(DEFS) $(CFLAGS) $<
X
Xall: gzip
X
Xgzip: $(OBJS)
X	slink $(LDFLAGS) $(OBJS) TO $@ $(LIBS)
X
Xgzip.o: gzip.c gzip.h tailor.h revision.h lzw.h getopt.h
Xzip.o: zip.c gzip.h tailor.h crypt.h
Xdeflate.o: deflate.c gzip.h tailor.h
Xbits.o: bits.c gzip.h tailor.h crypt.h
Xunzip.o: unzip.c gzip.h tailor.h crypt.h
Xinflate.o: inflate.c gzip.h tailor.h
Xutil.o: util.c gzip.h tailor.h crypt.h
Xlzw.o: lzw.c lzw.h gzip.h tailor.h
Xunlzw.o: unlzw.c gzip.h tailor.h revision.h lzw.h
Xunpack.o: unpack.c gzip.h tailor.h
Xunlzh.o: unpack.c gzip.h tailor.h
Xcrypt.o: crypt.c gzip.h tailor.h
Xgetopt.o: getopt.c getopt.h
Xtailor.o: tailor.c
X
Xalloca.o: alloca.c
X	$(CC) $(DEFS) DEF=STACK_DIRECTION=-1 $(CFLAGS) $(OPTFLAGS) $<
X
Xmatch.o: match.a
X
X# Compile trees.c without optimization (produces incorrect code)
X
Xtrees.o: trees.c gzip.h tailor.h
X	$(CC) $(DEFS) $(CFLAGS) $<
END_OF_FILE
if test 2103 -ne `wc -c <'gzip-1.2.2/amiga/Makefile.sasc'`; then
    echo shar: \"'gzip-1.2.2/amiga/Makefile.sasc'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/amiga/Makefile.sasc'
fi
if test -f 'gzip-1.2.2/amiga/Makefile.gcc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/amiga/Makefile.gcc'\"
else
echo shar: Extracting \"'gzip-1.2.2/amiga/Makefile.gcc'\" \(1863 characters\)
sed "s/^X//" >'gzip-1.2.2/amiga/Makefile.gcc' <<'END_OF_FILE'
X# Makefile for gzip (GNU zip)    -*- Indented-Text -*-
X# Copyright (C) 1992-1993 Jean-loup Gailly and the Free Software Foundation
X
X# Amiga GCC version, written by Preston Hunt <gt5708a@prism.gatech.edu>
X
X# This program is free software; you can redistribute it and/or modify
X# it under the terms of the GNU General Public License as published by
X# the Free Software Foundation; either version 2, or (at your option)
X# any later version.
X
X# This program is distributed in the hope that it will be useful,
X# but WITHOUT ANY WARRANTY; without even the implied warranty of
X# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X# GNU General Public License for more details.
X
X# You should have received a copy of the GNU General Public License
X# along with this program; if not, write to the Free Software
X# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
XCC = gcc
XCPP = cpp
X
XCFLAGS = -m68020 -m68881 -O2
X#CFLAGS = -m68000 -O2
X#for the 68000, set below: OBJA=
XCPPFLAGS = -Dmc68020
XLDFLAGS = 
XO = .o
X
XSRCS = gzip.c zip.c deflate.c trees.c bits.c unzip.c inflate.c util.c crypt.c\
X       lzw.c unlzw.c unpack.c unlzh.c makecrc.c getopt.c alloca.c match.S
X
XOBJA = match$O
X
XOBJS = gzip$O zip$O deflate$O trees$O bits$O unzip$O inflate$O util$O \
X       crypt$O lzw$O unlzw$O unpack$O unlzh$O getopt$O match$O $(ALLOCA)
X
XHDRS = gzip.h lzw.h tailor.h revision.h crypt.h getopt.h
X
X.c.o:
X	$(CC) -c $(DEFS) $(CFLAGS) $<
X
X.PHONY: default all
Xall:	gzip
X
Xgzip: $(OBJS)
X	$(CC) $(LDFLAGS) -o $@ $(OBJS) $(LIBS)
X
Xgzip$O zip$O deflate$O trees$O bits$O unzip$O inflate$O: gzip.h tailor.h
Xutil$O lzw$O unlzw$O unpack$O unlzh$O crypt$O: gzip.h tailor.h
X
Xgzip$O unlzw$O: revision.h lzw.h
X
Xbits$O unzip$O util$O zip$O: crypt.h
X
Xgzip$O getopt$O: getopt.h
X
Xmatch$O: match.S
X	$(CPP) $(CPPFLAGS) match.S > _match.s
X	$(CC) -c _match.s
X	mv _match$O match$O
X	rm -f _match.s
END_OF_FILE
if test 1863 -ne `wc -c <'gzip-1.2.2/amiga/Makefile.gcc'`; then
    echo shar: \"'gzip-1.2.2/amiga/Makefile.gcc'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/amiga/Makefile.gcc'
fi
if test -f 'gzip-1.2.2/amiga/tailor.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/amiga/tailor.c'\"
else
echo shar: Extracting \"'gzip-1.2.2/amiga/tailor.c'\" \(4439 characters\)
sed "s/^X//" >'gzip-1.2.2/amiga/tailor.c' <<'END_OF_FILE'
X/* tailor.c -- target dependent functions
X * Copyright (C) 1993 Carsten Steger (carsten.steger@informatik.tu-muenchen.de)
X * This is free software; you can redistribute it and/or modify it under the
X * terms of the GNU General Public License, see the file COPYING.
X */
X
X/*
X * This file contains Amiga specific functions for gzip.
X */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <string.h>
X#include <error.h>
X#include <time.h>
X#include <utime.h>
X#include <exec/types.h>
X#include <dos/dos.h>
X#include <dos/dosextens.h>
X#include <dos/dosasl.h>
X#include <proto/dos.h>
X
X#define MAXPATH 1024
X#define MAXARGS 512
X
Xextern struct DosLibrary *DOSBase;
X
Xextern void *xmalloc(unsigned int size);
X
Xstatic char *expand_next_file (char *pattern);
Xstatic int in_prev_args (char *arg, char **argv, int argc);
Xextern void _expand_args (int *oargc, char ***oargv);
X
X
Xstatic char *expand_next_file (pattern)
X     char *pattern;
X{
X  long err;
X  char *pathname;
X  static struct AnchorPath *an = NULL;
X
X  pathname = NULL;
X  if (pattern == NULL)
X    err = -1;
X  else
X    do
X      {
X        if (an == NULL)
X          {
X            an = xmalloc (sizeof (struct AnchorPath) + MAXPATH);
X            memset (an, 0, sizeof (struct AnchorPath) + MAXPATH);
X            an->ap_BreakBits = SIGBREAKF_CTRL_C;
X            an->ap_Strlen = MAXPATH;
X            an->ap_Flags = APF_DOWILD;
X            err = MatchFirst (pattern, an);
X          }
X        else
X          err = MatchNext (an);
X
X        pathname = an->ap_Buf;
X      } while (err == 0 && pathname == NULL);
X
X  if (err)
X    {
X      MatchEnd (an);
X      free (an);
X      an = NULL;
X      return NULL;
X    }
X  else
X    return pathname;
X}
X
X
Xstatic int in_prev_args (arg, argv, argc)
X     char *arg, **argv;
X     int argc;
X{
X  int i, is_in_args;
X
X  is_in_args = 0;
X  for (i = 1; i < argc - 1; i++)
X    if (stricmp (arg, argv[i]) == 0)
X      is_in_args = 1;
X  return is_in_args;
X}
X
X
Xvoid _expand_args (oargc, oargv)
X     int *oargc;
X     char ***oargv;
X{
X  int i;
X  char *str, **argv;
X  static char buf[MAXPATH];
X  int argc, no_match_at_all, num_matches, contains_wildcards;
X
X  /* With Kickstart 1.3 wildcards can't be expanded. */
X  if (DOSBase->dl_lib.lib_Version < 37) return;
X
X  no_match_at_all = 1;
X  contains_wildcards = 0;
X  argc = 0;
X  argv = xmalloc (MAXARGS * sizeof (char *));
X
X  argv[argc++] = (*oargv)[0];
X  for (i = 1; i < *oargc; i++)
X    {
X      if (ParsePattern ((*oargv)[i], buf, MAXPATH))
X        {
X          contains_wildcards = 1;
X          num_matches = 0;
X          while (str = expand_next_file ((*oargv)[i]))
X            if (argc >= MAXARGS)
X              {
X                expand_next_file (NULL);
X                fprintf (stderr,"Too many files.\n");
X                exit (20);
X              }
X            else
X              {
X                /* Avoid duplicate entries */
X                if (!in_prev_args (str, argv, argc))
X                  {
X                    argv[argc++] = strdup (str);
X                    num_matches++;
X                  }
X              }
X          if (num_matches != 0)
X            no_match_at_all = 0;
X        }
X      else
X        if (argc >= MAXARGS)
X          {
X            fprintf (stderr,"Too many files.\n");
X            exit (20);
X          }
X        else
X          {
X            if (!in_prev_args ((*oargv)[i], argv, argc))
X              argv[argc++] = (*oargv)[i];
X          }
X    }
X  *oargc = argc;
X  *oargv = argv;
X  if (no_match_at_all && contains_wildcards) {
X    fprintf (stderr,"No match.\n");
X    exit (20);
X  }
X}
X
X
Xint utime (path, times)
X     char *path;
X     struct utimbuf *times;
X{
X  struct DateStamp date;
X  LONG error;
X  time_t modtime;
X
X  /* With Kickstart 1.3 setting the filedate could be done, I guess.
X   * Maybe someone else will implement and test the code for this
X   * case (I don't have Kickstart 1.3). */
X  if (DOSBase->dl_lib.lib_Version < 37) return 0;
X
X  /* Amiga dates are counted from 1. Jan 1978 as opposed to 1. Jan 1970
X   * on Unix. Therefore we have to subtract 2922 days (8*365+2). We also
X   * have to subtract the value of __timezone since SAS/C uses "CST+06"
X   * as the default value. */
X  modtime = times->modtime - __timezone;
X  date.ds_Days = (modtime / 86400) - 2922;
X  modtime %= 86400;
X  date.ds_Minute = modtime / 60;
X  modtime %= 60;
X  date.ds_Tick = modtime * TICKS_PER_SECOND;
X  error = SetFileDate (path, &date);
X  if (error == DOSFALSE)
X    {
X      errno = EOSERR;
X      return -1;
X    }
X  return 0;
X}
END_OF_FILE
if test 4439 -ne `wc -c <'gzip-1.2.2/amiga/tailor.c'`; then
    echo shar: \"'gzip-1.2.2/amiga/tailor.c'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/amiga/tailor.c'
fi
if test -f 'gzip-1.2.2/amiga/utime.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/amiga/utime.h'\"
else
echo shar: Extracting \"'gzip-1.2.2/amiga/utime.h'\" \(197 characters\)
sed "s/^X//" >'gzip-1.2.2/amiga/utime.h' <<'END_OF_FILE'
X#ifndef _UTIME_H
X#define _UTIME_H 1
X
X#ifndef _TIME_H
X#include <time.h>
X#endif
X
Xstruct utimbuf {
X  time_t actime;
X  time_t modtime;
X};
X
Xextern int utime (char *path, struct utimbuf *times);
X
X#endif
END_OF_FILE
if test 197 -ne `wc -c <'gzip-1.2.2/amiga/utime.h'`; then
    echo shar: \"'gzip-1.2.2/amiga/utime.h'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/amiga/utime.h'
fi
if test -f 'gzip-1.2.2/amiga/match.a' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/amiga/match.a'\"
else
echo shar: Extracting \"'gzip-1.2.2/amiga/match.a'\" \(3597 characters\)
sed "s/^X//" >'gzip-1.2.2/amiga/match.a' <<'END_OF_FILE'
X; match.a -- optional optimized asm version of longest match in deflate.c
X; Copyright (C) 1992-1993 Jean-loup Gailly
X; This is free software; you can redistribute it and/or modify it under the
X; terms of the GNU General Public License, see the file COPYING.
X 
X; $Id: match.a,v 1.1 1993/03/11 16:05:57 jloup Exp $
X;
X; Adapted for the Amiga by Carsten Steger <stegerc@informatik.tu-muenchen.de>
X; using the code in match.S.
X; The major change in this code consists of removing all unaligned
X; word accesses, because they cause 68000-based Amigas to crash.
X; For maximum speed, UNALIGNED_OK can be defined in Makefile.sasc.
X; The program will then only run on 68020-based Amigas, though.
X;
X; This code will run with registerized parameters too, unless SAS
X; changes parameter passing conventions between new releases of SAS/C.
X
X
XCur_Match	reg	d0	; Must be in d0!
XBest_Len	reg	d1
XLoop_Counter	reg	d2
XScan_Start	reg	d3
XScan_End	reg	d4
XLimit		reg	d5
XChain_Length	reg	d6
XScan_Test	reg	d7
XScan		reg	a0
XMatch		reg	a1
XPrev_Address	reg	a2
XScan_Ini	reg	a3
XMatch_Ini	reg	a4
X
XMAX_MATCH	equ	258
XMIN_MATCH	equ	3
XWSIZE		equ	32768
XMAX_DIST	equ	WSIZE-MAX_MATCH-MIN_MATCH-1
X
X
X	xref	_max_chain_length
X	xref	_prev_length
X	xref	_prev
X	xref	_window
X	xref	_strstart
X	xref	_good_match
X	xref	_match_start
X	xref	_nice_match
X
X
X	section match,code
X
X	xdef	_match_init
X	xdef	@match_init
X	xdef	_longest_match
X	xdef	@longest_match
X
X
X_match_init:
X@match_init:
X	rts
X
X
X_longest_match:
X	move.l	4(sp),Cur_Match
X@longest_match:
X	ifd	UNALIGNED_OK
X	movem.l	d2-d6/a2-a4,-(sp)
X	else
X	movem.l	d2-d7/a2-a4,-(sp)
X	endc
X	move.l	_max_chain_length,Chain_Length
X	move.l	_prev_length,Best_Len
X	lea	_prev,Prev_Address
X	lea	_window+MIN_MATCH,Match_Ini
X	move.l	_strstart,Limit
X	move.l	Match_Ini,Scan_Ini
X	add.l	Limit,Scan_Ini
X	subi.w	#MAX_DIST,Limit
X	bhi.b	limit_ok
X	moveq	#0,Limit
Xlimit_ok:
X	cmp.l	_good_match,Best_Len
X	bcs.b	length_ok
X	lsr.l	#2,Chain_Length
Xlength_ok:
X	subq.l	#1,Chain_Length
X
X	ifd	UNALIGNED_OK
X
X	move.w	-MIN_MATCH(Scan_Ini),Scan_Start
X	move.w	-MIN_MATCH-1(Scan_Ini,Best_Len),Scan_End
X
X	else
X
X	move.b	-MIN_MATCH(Scan_Ini),Scan_Start
X	lsl.w	#8,Scan_Start
X	move.b	-MIN_MATCH+1(Scan_Ini),Scan_Start
X	move.b	-MIN_MATCH-1(Scan_Ini,Best_Len),Scan_End
X	lsl.w	#8,Scan_End
X	move.b	-MIN_MATCH(Scan_Ini,Best_Len),Scan_End
X
X	endc
X
X	bra.b	do_scan
X
Xlong_loop:
X
X	ifd	UNALIGNED_OK
X
X	move.w	-MIN_MATCH-1(Scan_Ini,Best_Len),Scan_End
X
X	else
X
X	move.b	-MIN_MATCH-1(Scan_Ini,Best_Len),Scan_End
X	lsl.w	#8,Scan_End
X	move.b	-MIN_MATCH(Scan_Ini,Best_Len),Scan_End
X
X	endc
X
Xshort_loop:
X	lsl.w	#1,Cur_Match
X	move.w	0(Prev_Address,Cur_Match),Cur_Match
X	cmp.w	Limit,Cur_Match
X	dbls	Chain_Length,do_scan
X	bra.b	return
X
Xdo_scan:
X	move.l	Match_Ini,Match
X	add.l	Cur_Match,Match
X
X	ifd	UNALIGNED_OK
X
X	cmp.w	-MIN_MATCH-1(Match,Best_Len),Scan_End
X	bne.b	short_loop
X	cmp.w	-MIN_MATCH(Match),Scan_Start
X	bne.b	short_loop
X
X	else
X
X	move.b	-MIN_MATCH-1(Match,Best_Len),Scan_Test
X	lsl.w	#8,Scan_Test
X	move.b	-MIN_MATCH(Match,Best_Len),Scan_Test
X	cmp.w	Scan_Test,Scan_End
X	bne.b	short_loop
X	move.b	-MIN_MATCH(Match),Scan_Test
X	lsl.w	#8,Scan_Test
X	move.b	-MIN_MATCH+1(Match),Scan_Test
X	cmp.w	Scan_Test,Scan_Start
X	bne.b	short_loop
X
X	endc
X
X	move.w	#(MAX_MATCH-MIN_MATCH),Loop_Counter
X	move.l	Scan_Ini,Scan
Xscan_loop:
X	cmpm.b	(Match)+,(Scan)+
X	dbne	Loop_Counter,scan_loop
X
X	sub.l	Scan_Ini,Scan
X	addq.l	#(MIN_MATCH-1),Scan
X	cmp.l	Best_Len,Scan
X	bls.b	short_loop
X	move.l	Scan,Best_Len
X	move.l	Cur_Match,_match_start
X	cmp.l	_nice_match,Best_Len
X	bcs.b	long_loop
Xreturn:
X	move.l	Best_Len,d0
X	ifd	UNALIGNED_OK
X	movem.l	(sp)+,d2-d6/a2-a4
X	else
X	movem.l	(sp)+,d2-d7/a2-a4
X	endc
X	rts
X
X	end
END_OF_FILE
if test 3597 -ne `wc -c <'gzip-1.2.2/amiga/match.a'`; then
    echo shar: \"'gzip-1.2.2/amiga/match.a'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/amiga/match.a'
fi
if test ! -d 'gzip-1.2.2/atari' ; then
    echo shar: Creating directory \"'gzip-1.2.2/atari'\"
    mkdir 'gzip-1.2.2/atari'
fi
if test -f 'gzip-1.2.2/atari/Makefile.st' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/atari/Makefile.st'\"
else
echo shar: Extracting \"'gzip-1.2.2/atari/Makefile.st'\" \(1336 characters\)
sed "s/^X//" >'gzip-1.2.2/atari/Makefile.st' <<'END_OF_FILE'
X# Makefile for gzip (GNU zip)    -*- Indented-Text -*-
X# This is free software; you can redistribute it and/or modify it under the
X# terms of the GNU General Public License, see the file COPYING.
X
X# Simple Atari-specific makefile for gcc.
X# Written by Daniel Eriksson <den@hgs.se>
X# Modified by Andreas Schwab <schwab@ls5.informatik.uni-dortmund.de>
X
X# This Makefile is configured by default for the Atari ST using the
X# Minix filesytem. It can be modified (for efficiency) for an Atari TT
X# according to the instructions given below. It must be modified
X# for building a TOS-filesystem version.
X
XBASIC_FLAGS = -O2 -DATARI
X
X# Use this for a TT-only version
X#TT_FLAGS = -m68020
X
X# CFLAGS for building a Minix-filesystem version
XCFLAGS = $(BASIC_FLAGS) $(TT_FLAGS)
X
X# CFLAGS for building a TOS-filesystem version
X#CFLAGS = $(BASIC_FLAGS) $(TT_FLAGS) -DTOSFS
X
XOBJA = match.o
XOBJS = bits.o crypt.o deflate.o getopt.o gzip.o inflate.o lzw.o \
X  trees.o unlzw.o unpack.o unlzh.o unzip.o util.o zip.o $(OBJA)
X
Xgzip.ttp:	$(OBJS)
X	$(CC) $(LDFLAGS) -o $@ $(OBJS)
X
Xgzip.o zip.o deflate.o trees.o bits.o unzip.o inflate.o: gzip.h tailor.h
Xutil.o lzw.o unlzw.o unpack.o unlzh.o crypt.o: gzip.h tailor.h
X
Xgzip.o unlzw.o: revision.h lzw.h
X
Xbits.o unzip.o util.o zip.o: crypt.h
X
Xgzip.o getopt.o: getopt.h
X
Xmatch.o: match.S
X	$(CC) $(CFLAGS) -c $< -o $@
END_OF_FILE
if test 1336 -ne `wc -c <'gzip-1.2.2/atari/Makefile.st'`; then
    echo shar: \"'gzip-1.2.2/atari/Makefile.st'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/atari/Makefile.st'
fi
if test ! -d 'gzip-1.2.2/primos' ; then
    echo shar: Creating directory \"'gzip-1.2.2/primos'\"
    mkdir 'gzip-1.2.2/primos'
fi
if test -f 'gzip-1.2.2/primos/readme' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/primos/readme'\"
else
echo shar: Extracting \"'gzip-1.2.2/primos/readme'\" \(948 characters\)
sed "s/^X//" >'gzip-1.2.2/primos/readme' <<'END_OF_FILE'
XTo build GZIP for PRIMOS you should just have to type:
X
X   r *>primos>build
X
Xwhile standing in the directory above this PRIMOS subdirectory.
X
XIf the files in these directories looks strange, then it might be
Xbecause they are in normal ASCII. You'll need to convert them into
XPASCII before you will be able to build the GZIP executable.
X 
XYou can find a simple ASCII to PASCII converter via anonymous FTP
Xfrom "ftp.lysator.liu.se" in the directory "pub/primos/run" as
Xthe file "topascii.run".
X
XYou can reach me at a number of places in case there are any bugs
Xin this port to report...
X
X   Email:
X
X      pen@signum.se        Signum is a company giving support for 
X                           Free Software. Call/Mail us if you're 
X                           interrested! (Phone: +46-13-21-46-00)
X
X      pen@lysator.liu.se   Lysator is a computer society at the
X                           Linkoping University in Sweden.
X
XPeter Eriksson, 25 May 1993
END_OF_FILE
if test 948 -ne `wc -c <'gzip-1.2.2/primos/readme'`; then
    echo shar: \"'gzip-1.2.2/primos/readme'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/primos/readme'
fi
if test -f 'gzip-1.2.2/primos/primos.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/primos/primos.c'\"
else
echo shar: Extracting \"'gzip-1.2.2/primos/primos.c'\" \(2027 characters\)
sed "s/^X//" >'gzip-1.2.2/primos/primos.c' <<'END_OF_FILE'
X/*
X** primos.c
X**
X** This file contains emulation routines for some common Unix functions
X**
X** Author: Peter Eriksson <pen@lysator.liu.se>
X*/
X
X#ifdef __50SERIES
X
X#include <stdio.h>
X#include <fcntl.h>
X#include <sys/stat.h>
X
X
Xuid_t  primos_uid = 42;
Xgid_t  primos_gid = 42;
Xmode_t primos_mode = 600;
X
X/* Dummy do-nothing routine for chmod() */
Xint chmod(path, mode)
X  char *path;
X  int mode;
X{
X   return 0;
X}
X
Xchar *getenv(var)
X  char *var;
X{
X  char buf[256];
X  extern char *gvget();
X  
X  buf[0] = '.';
X  strcpy(buf+1, var);
X
X  return gvget(buf);
X}
X
X
Xunlink(path)
X  char *path;
X{
X  return delete(path);
X}
X 
Xint lstat(path, buf)
X  char *path;
X  struct stat *buf;
X{
X  return stat(path, buf);
X}
X
Xint stat(path, buf)
X  char *path;
X  struct stat *buf;
X{
X  buf->st_dev     = 1;
X  buf->st_ino     = 1;
X  buf->st_nlink   = 1;
X  buf->st_uid     = primos_uid;
X  buf->st_gid     = primos_gid;
X  buf->st_rdev    = 1;
X  buf->st_blksize = 2048;
X
X  buf->st_rwlock = frwlock(path);
X  switch (buf->st_type = ftype(path))
X  {
X    case 0:
X    case 1:
X      /* Regular file (SAM or DAM) */
X      buf->st_size   = fsize(path);
X      buf->st_mtime  = fdtm(path);
X
X      buf->st_mode = S_IFREG|primos_mode;
X      break;
X
X    case 4:
X      buf->st_size = 0;
X      buf->st_mtime = fdtm(path);
X
X      buf->st_mode = S_IFDIR|primos_mode;
X      break;
X
X    case -1:
X      return -1;
X      
X    default:
X      buf->st_mode = primos_mode;
X      buf->st_size = fsize(path);
X      buf->st_mtime = fdtm(path);
X  }
X
X  buf->st_blocks = (buf->st_size-1) / buf->st_blksize + 1;
X
X  /* Should be fixed to really fetch these values, but that
X   * would require calling some PRIMOS subroutines and I don't have
X   * a copy of the Primos Subroutine reference manuals here..
X   */
X  buf->st_atime = buf->st_mtime;
X  buf->st_ctime = buf->st_mtime;
X  
X  return 0;
X}
X
Xint fstat(fd, buf)
X  int fd;
X  struct stat *buf;
X{
X  char path[1025];
X
X  return stat(getname(fd, path), buf);
X}
X
Xint ascii2pascii(c)
X  int c;
X{
X  return (c ? (c | 0x80) : '\0');
X}
X
X
X#endif /* __50SERIES */
END_OF_FILE
if test 2027 -ne `wc -c <'gzip-1.2.2/primos/primos.c'`; then
    echo shar: \"'gzip-1.2.2/primos/primos.c'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/primos/primos.c'
fi
if test -f 'gzip-1.2.2/primos/alloca.pma' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/primos/alloca.pma'\"
else
echo shar: Extracting \"'gzip-1.2.2/primos/alloca.pma'\" \(1486 characters\)
sed "s/^X//" >'gzip-1.2.2/primos/alloca.pma' <<'END_OF_FILE'
X*
X* ALLOCA.PMA                                      Stack heap storage allocator.
X*
X* Date      Programmer     History
X* --------- -------------- --------------------------------------------------
X* 880805    P. Eriksson    Initial coding.
X*
X
X
X         SEGR
X         SYML
X         RLIT
X
X         ENT G$ALLOCA,ECB$$
X
XP$ALLOCA EQU *
X         L 2,XB%+0            - Fetch 'size' argument
X         BRLE 2,FAIL          - Terminate if 'size' <= 0
X         IR1 2                - Compensate for odd bytes
X         SR1 2                - Convert to number of shorts
X         BHNE 2,FAIL          - Fail if high word != 0
X         IRH 2                - Put length into halfword
X         CH% 2,=65530         - Compare with maximum limit
X         BMGT FAIL            - Fail if block too big
X         IRH 2                - Put length into fullword
X         L 1,2                - Save length for later usage
X         STEX 2               - Allocate stack storage
X
X         L 3,2                - Save block pointer for later
X
XZNEXT    ZMH R2%              - Clear halfword
X         IR1 2                - Point at next
X         DR1 1                - Decrement length
X         BRGT 1,ZNEXT         - Loop until length == 0
X
X         L 2,3                - Get block pointer back
X         JMP R0%              - Return to caller
X
XFAIL     CR 2                 - Put a NULL pointer into R2
X         JMP R0%              - Return to caller
X
X         LINK
XECB$$    ECB P$ALLOCA,,,-1
X
X         END
END_OF_FILE
if test 1486 -ne `wc -c <'gzip-1.2.2/primos/alloca.pma'`; then
    echo shar: \"'gzip-1.2.2/primos/alloca.pma'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/primos/alloca.pma'
fi
if test -f 'gzip-1.2.2/primos/ci.opts' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/primos/ci.opts'\"
else
echo shar: Extracting \"'gzip-1.2.2/primos/ci.opts'\" \(74 characters\)
sed "s/^X//" >'gzip-1.2.2/primos/ci.opts' <<'END_OF_FILE'
X-define PRIMOS
X-include *>PRIMOS>INCLUDE
X-ignoreregister
X-packbytes
X-sof
X
END_OF_FILE
if test 74 -ne `wc -c <'gzip-1.2.2/primos/ci.opts'`; then
    echo shar: \"'gzip-1.2.2/primos/ci.opts'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/primos/ci.opts'
fi
if test -f 'gzip-1.2.2/primos/build.cpl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/primos/build.cpl'\"
else
echo shar: Extracting \"'gzip-1.2.2/primos/build.cpl'\" \(1726 characters\)
sed "s/^X//" >'gzip-1.2.2/primos/build.cpl' <<'END_OF_FILE'
X/* Gzip build file for Primos.
X/* author: Peter Eriksson, pen@lysator.liu.se
X/*
Xtype
Xtype 'Building GZIP for PRIMOS - Please Wait...'
Xtype
X&if ^ [exists *>PRIMOS>OBJ -dir] &then &do
X      type 'Creating *>PRIMOS>OBJ directory...'
X      type
X      create *>PRIMOS>OBJ
X   &end
X
Xtype 'Compiling...
X
X&set_var unit := 0
X
X/*
X&set_var cdefines  :=  -debug
X
Xcomo *>primos>compile.como
X&do file &items [wild *>@@.c -single unit]
X  &set_var filebase := [before %file% .]
X  &if ^  [exists *>primos>obj>%filebase%.bin] &then &do
X  type 'Compiling "'%file%'"...'
X  ci *>%file% -binary *>primos>obj>=.bin %cdefines% -optionsfile *>primos>ci.opts
X  &end
X&end
Xclose -unit %unit%
X&set_var unit := 0
X
X&do file &items [wild *>primos>@@.c -single unit]
X  &set_var filebase := [before %file% .]
X  &if ^  [exists *>primos>obj>%filebase%.bin] &then &do
X  type 'Compiling "'%file%'"...'
X  ci *>primos>%file% -binary *>primos>obj>=.bin %cdefines% -optionsfile *>primos>ci.opts
X  &end
X&end
Xpma *>primos>alloca.pma -b *>primos>obj>=.bin -l no
Xcomo -end
X
Xtype
Xtype
Xtype 'Binding...'
X
X&set_var unit := 0
X&data bind
X  li ccmain
X  load *>primos>obj>gzip
X  load *>primos>obj>alloca
X  load *>primos>obj>bits
X  load *>primos>obj>crypt
X  load *>primos>obj>deflate
X  load *>primos>obj>getopt
X  load *>primos>obj>inflate
X  load *>primos>obj>lzw
X  load *>primos>obj>makecrc
X  load *>primos>obj>primos
X  load *>primos>obj>trees
X  load *>primos>obj>unlzw
X  load *>primos>obj>unpack
X  load *>primos>obj>unlzh
X  load *>primos>obj>unzip
X  load *>primos>obj>util
X  load *>primos>obj>zip
X  li c_lib
X  li
X  dynt -all
X  nwc
X  nitr
X  ntw
X  compress
X  file *>primos>gzip.run
X&end
X
Xtype
Xtype
Xtype 'All done. (Hopefully). The executable should be in *>PRIMOS>GZIP.RUN'
X&return
END_OF_FILE
if test 1726 -ne `wc -c <'gzip-1.2.2/primos/build.cpl'`; then
    echo shar: \"'gzip-1.2.2/primos/build.cpl'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/primos/build.cpl'
fi
if test ! -d 'gzip-1.2.2/primos/include' ; then
    echo shar: Creating directory \"'gzip-1.2.2/primos/include'\"
    mkdir 'gzip-1.2.2/primos/include'
fi
if test -f 'gzip-1.2.2/primos/include/errno.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/primos/include/errno.h'\"
else
echo shar: Extracting \"'gzip-1.2.2/primos/include/errno.h'\" \(218 characters\)
sed "s/^X//" >'gzip-1.2.2/primos/include/errno.h' <<'END_OF_FILE'
X/*
X** errno.h
X**
X** Emulation of the Unix errno.h header file for PRIMOS
X**
X** Author: Peter Eriksson <pen@lysator.liu.se>
X*/
X
X#ifndef __ERRNO_H__
X#define __ERRNO_H__
X
X#include <errd.h>
X
X#define ENOENT e$fntf
X
X#endif
X
END_OF_FILE
if test 218 -ne `wc -c <'gzip-1.2.2/primos/include/errno.h'`; then
    echo shar: \"'gzip-1.2.2/primos/include/errno.h'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/primos/include/errno.h'
fi
if test -f 'gzip-1.2.2/primos/include/fcntl.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/primos/include/fcntl.h'\"
else
echo shar: Extracting \"'gzip-1.2.2/primos/include/fcntl.h'\" \(329 characters\)
sed "s/^X//" >'gzip-1.2.2/primos/include/fcntl.h' <<'END_OF_FILE'
X/*
X** fcntl.h
X**
X** Emulation of the Unix fcntl.h header file for PRIMOS
X**
X** Author: Peter Eriksson <pen@lysator.liu.se>
X*/
X
X#ifndef __FCNTL_H__
X#define __FCNTL_H__
X
X#define O_RDONLY 0
X#define O_WRONLY 1
X#define O_RDWR   2
X
X#define O_BINARY 0
X#define O_EXCL   0
X#define O_NDELAY 0
X#define O_CREAT  0
X#define O_TRUNC  0
X
X#endif
END_OF_FILE
if test 329 -ne `wc -c <'gzip-1.2.2/primos/include/fcntl.h'`; then
    echo shar: \"'gzip-1.2.2/primos/include/fcntl.h'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/primos/include/fcntl.h'
fi
if test -f 'gzip-1.2.2/primos/include/stdlib.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/primos/include/stdlib.h'\"
else
echo shar: Extracting \"'gzip-1.2.2/primos/include/stdlib.h'\" \(227 characters\)
sed "s/^X//" >'gzip-1.2.2/primos/include/stdlib.h' <<'END_OF_FILE'
X/*
X** stdlib.h
X**
X** Emulation of the Unix stdlib.h header file for PRIMOS
X**
X** Author: Peter Eriksson <pen@lysator.liu.se>
X*/
X
X#ifndef __STDLIB_H__
X#define __STDLIB_H__
X
Xextern char *malloc();
Xextern char *calloc();
X
X#endif
X
END_OF_FILE
if test 227 -ne `wc -c <'gzip-1.2.2/primos/include/stdlib.h'`; then
    echo shar: \"'gzip-1.2.2/primos/include/stdlib.h'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/primos/include/stdlib.h'
fi
if test -f 'gzip-1.2.2/primos/include/sysStat.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/primos/include/sysStat.h'\"
else
echo shar: Extracting \"'gzip-1.2.2/primos/include/sysStat.h'\" \(2027 characters\)
sed "s/^X//" >'gzip-1.2.2/primos/include/sysStat.h' <<'END_OF_FILE'
X/*
X** sys/stat.h
X**
X** Emulation of the Unix sys/stat.h header file for PRIMOS
X**
X** Author: Peter Eriksson <pen@lysator.liu.se>
X*/
X
X#ifndef __SYS_STAT_H__
X#define __SYS_STAT_H__
X
X
X#include <sys/types.h>
X
Xstruct	stat {
X        /* First some PRIMOS standard entries */
X	off_t	st_size;
X	time_t	st_mtime;
X	short	st_type;        /* Primos file type */
X	short	st_rwlock;      /* Primos read/write lock */
X
X	/* Begin Unix compatibility - don't believe these entries! */
X	dev_t	st_dev;       
X	ino_t	st_ino;
X	mode_t	st_mode;
X	short	st_nlink;
X	uid_t	st_uid;
X	gid_t	st_gid;
X	dev_t	st_rdev;
X	time_t	st_atime;
X	time_t	st_ctime;
X	long	st_blksize;
X	long	st_blocks;
X};
X
X#define	_IFMT		0170000	/* type of file */
X#define	_IFREG		0100000	/* regular */
X#define	_IFDIR		0040000	/* directory */
X
X/* Some stupid programs check if these are defined and then
X   believe these are supported in the OS - not so in PRIMOS ... */
X#ifndef __50SERIES
X#  define _IFCHR	0020000
X#  define _IFBLK	0060000
X#  define _IFLNK	0120000
X#  define _IFSOCK	0140000
X#  define _IFIFO	0010000
X#endif
X
X#define	S_ISUID		0004000
X#define	S_ISGID		0002000
X#define	S_ISVTX		0001000
X#define	S_IREAD		0000400
X#define	S_IWRITE 	0000200
X#define	S_IEXEC		0000100
X
X#define	S_ENFMT 	0002000
X
X#define	S_IFMT		_IFMT
X#define	S_IFREG		_IFREG
X#define	S_IFDIR		_IFDIR
X#ifndef __50SERIES
X#  define S_IFCHR	_IFCHR
X#  define S_IFBLK	_IFBLK
X#  define S_IFLNK	_IFLNK
X#  define S_IFSOCK	_IFSOCK
X#  define S_IFIFO	_IFIFO
X#endif
X
X#define	S_IRWXU 	0000700
X#define	S_IRUSR		0000400
X#define	S_IWUSR		0000200
X#define	S_IXUSR		0000100
X#define	S_IRWXG		0000070
X#define	S_IRGRP		0000040
X#define	S_IWGRP		0000020
X#define	S_IXGRP		0000010
X#define	S_IRWXO		0000007
X#define	S_IROTH		0000004
X#define	S_IWOTH		0000002
X#define	S_IXOTH		0000001
X
X#define	S_ISREG(m)	(((m) & _IFMT) == _IFREG)
X#define	S_ISDIR(m)	(((m) & _IFMT) == _IFDIR)
X#ifndef __50SERIES
X#  define S_ISBLK(m)	(((m) & _IFMT) == _IFBLK)
X#  define S_ISCHR(m)	(((m) & _IFMT) == _IFCHR)
X#  define S_ISFIFO(m)	(((m) & _IFMT) == _IFIFO)
X#endif
X
X
X#endif
END_OF_FILE
if test 2027 -ne `wc -c <'gzip-1.2.2/primos/include/sysStat.h'`; then
    echo shar: \"'gzip-1.2.2/primos/include/sysStat.h'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/primos/include/sysStat.h'
fi
if test -f 'gzip-1.2.2/primos/include/sysTypes.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gzip-1.2.2/primos/include/sysTypes.h'\"
else
echo shar: Extracting \"'gzip-1.2.2/primos/include/sysTypes.h'\" \(388 characters\)
sed "s/^X//" >'gzip-1.2.2/primos/include/sysTypes.h' <<'END_OF_FILE'
X/*
X** sys/types.h
X**
X** Emulation of the Unix sys/types.h header file for PRIMOS
X**
X** Author: Peter Eriksson <pen@lysator.liu.se>
X*/
X
X#ifndef __SYS_TYPES_H__
X#define __SYS_TYPES_H__
X
Xtypedef long	size_t;
Xtypedef long	time_t;
X
Xtypedef long	off_t;
Xtypedef short	dev_t;
Xtypedef short	ino_t;
Xtypedef short	mode_t;
Xtypedef short	uid_t;
Xtypedef short	gid_t;
X
Xtypedef char   *caddr_t;
X
X#endif
X
END_OF_FILE
if test 388 -ne `wc -c <'gzip-1.2.2/primos/include/sysTypes.h'`; then
    echo shar: \"'gzip-1.2.2/primos/include/sysTypes.h'\" unpacked with wrong size!
fi
# end of 'gzip-1.2.2/primos/include/sysTypes.h'
fi
echo shar: End of shell archive.
exit 0
