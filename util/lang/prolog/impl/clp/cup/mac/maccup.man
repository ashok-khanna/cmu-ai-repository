		          ＭａｃＣｕｐガイド
			    
		中京大学情報科学部  白井英俊
		email: sirai@sccs.chukyo-u.ac.jp
		1992年11月07日(MacCupV0.78u版)

目次
  1......はじめに
  2......プログラムの入力と走らせ方
  3......コマンド
  4......組み込み述語
  5......ファイルの入出力
  6......制約変換機構
  7......トレース機構
  8......部分項(PST, Partially Specified Term)

１．はじめに
  MacCupは制約論理型言語CUPのMac版です。CUPは、従来の制約論理型言
語の多くが代数方程式を制約に取るのと異なり、ユーザーが定義した述語などを制
約として用いることができます。そのため、記号的・組み合わせ的な制約を自然に
記述でき、自然言語処理だけではなく人工知能全般に応用できるプログラミング言
語と言えるでしょう。
  CUPはICOTで開発されました。その名の由来である制約単一化(Constraint 
Unification)は橋田浩一氏により提唱され、白井によりProlog上の実装が行われ、
津田宏氏によってCによる実装が行われました。そして現在に至るまで、津田氏と白
井により拡張が行われています。Unix OS上のシステムの著作権はICOTにあり、配布
はICOTによって行われています。またMacCupの著作権は白井にあり、最新版はcsli.
stanford.eduからanonymous ftpにより入手することが可能です。

２．プログラムの入力と走らせ方

  ２．１  プログラムの書き方
  MacCupはCUPと同じ構文を採用しています。つまり、Dec-10 Prologとほぼ同
様の構文を採用しています。ただし、以下の点に注意して下さい。
  (1) 通常のホーン節以外に、制約付ホーン節(Constrained Horn Clause)をサポー
トしています。これにより、従来のPrologでは変数が取り得るいろいろな値を後戻り
によって扱わなければならなかったのに対し、そのような部分を「制約」として記述
することにより、不要な後戻りを避けた効率的なプログラムを書く事が可能になりま
した。詳しくは２．４節を参照して下さい。
  (2) 部分項(PST, Partially Specified Term)と呼ばれる構造をサポートしていま
す。詳しくは８節を参照して下さい。
  (3) 従来のPrologではアスキーコードのリストとしてストリングが扱われていまし
たが、MacCupdではストリングは他のプログラミング言語でのストリングと同様の扱
いをしています。そのため、ストリングを扱ういろいろな述語が用意されています。
  (4) 選言的な実行制御の構文が異なります。MacCupでは、`;'はホーン節とそれに
付加する制約との句切り記号として用いています。選言的な実行制御にはor 述語を
使って下さい。orには2項、3項、4項、5項の４種類があります。
	例。 従来のPrologでの書き方
		(a(X), a1(X), a2(X)) ; (b(X), b1(X)) ; c(X).
	MacCupでの書き方
		or( (a(X), a1(X), a2(X)), (b(X), b1(X)), (c(X)) ).
	もしくは
		or( [a(X), a1(X), a2(X)], [b(X), b1(X)], [c(X)]).

  ２．２  プログラムの入力
  MacCupを起動すると、以下のようなオープンメッセージの後、`_'というプロンプ
トが出ます。

	*****  MacCup  Ver. 0.6.4  *****
	All Modular mode (help ->  %h)


このようにプロンプトが出て、入力待ちになっている状態を、MacCupのトップレベル
といいます。この時点では、次のようなことができます。
  (1) MacCupのプログラムを入力する。ホーン節をキーボードから入力すると、そ
れが定義される述語とみなされます。
	例。_ member(X,[X|_]).   => memberの一つの定義が行われた。
  (2) `:-'から始まるホーン節を入力して、プログラムを実行させる。MacCupは`:-'
をプログラム実行のキーワードとみなしています。
	例。_ :-member(X,[a,b,c]).  => member述語の実行評価。
  (3) `@'に続けてホーン節を入力し、制約変換を行います。つまり、ホーン節
を制約の列と見なして、ある規準をみたす制約の「標準形」を求めます。
	例。_ @ member(X,Y),append(Y,W,Z).
  (4) `%'となんらかのキーワードを入力して、MacCupのコマンドを実行させます。
`%'はMacCupコマンドのプリフィックスです。MacCupのコマンドについては３節を見
て下さい。
  (5) マウスを使って、メニューからMacCupのコマンドを実行させます。上で述べ
たコマンドのほとんどをメニューによって実行できます。また、フォントのスタイ
ルや大きさを変えるのは、メニューによってしか、できません。
また、キーボードから入力する代わりに、MacCupのウィンドゥに表示されたものの
一部を、マウスを使って、カット＆ペーストすることもできます。


  ２．３  プログラムの走らせ方
  標準的なMacCupプログラムの開発方法は次の二通りが考えられます。

  (1) プログラムをキーボードから入力し、実行させる。その後、定義されたプロ
グラムをファイルに格納する。
  (2) プログラムをファイルから入力し、実行させる。

  ファイルからプログラムを入力するには、ファイル名を`"'でくくって入力するか、
もしくはFileメニューからOpenをクリックしてファイルを選択する、の二通りがあ
ります。前者は、Unixから受け継いだ方法で、後者はMac流と言えるでしょう。
  定義されたプログラムを格納するのも、同様に二通りの方法があります。一つは
`%w'コマンドによるもの、もう一つは、FileメニューからSave Programをクリック
するというものです。
  MacCupも時には暴走します。その時には、CMNDキーと`.'を一緒に押して下さい。
するとContinue, StepTrace, Abortの三つのボタンが現れます．Continueをクリッ
クすれば、現在の実行を続けます．StepTraceをクリックすると，ステップトレース
・モードになります（制約変換に対してもステップトレース・モードになります）。
またAbortをクリックすると、現在の実行を中止して、トップレベルに戻ります。

  ２．４  プログラムの構文
  MacCupのプログラムは次の３種類があります。さらに、これらにはそれぞれ、通
常のホーン節と、ホーン節に制約を付加した制約付ホーン節の二つがあります。
 (1) 事実
	H.  もしくは
	H ; C1, ..., Cn.
	例。append([],X,X).
	    lexicon(put, {pos/v, form/X, infl/Y}) ; agreemnt(X,Y).
 (2) ルール節
	H :- B1, ..., Bm.  もしくは
	H :- B1, ..., Bm ; C1, ..., Cn.
	例。append([A|X],Y,[A|Z]) :- append(X,Y,Z).
	    cat(M) :- cat(L), cat(R) ; psr(L,R,M).
 (3) 質問節
	:- B1, ..., Bm.  もしくは
	:- B1, ..., Bm ; C1, ..., Cn.
	例。:- permutation(X,[a,b,c]), well_orderd(X).
	    :- choice(X), good(X) ; memb(X, [a,b,c,d,e]).
  ここでHを頭(Head)、Biを本体(Body)、Ciを制約(Constraint)と呼びます。
　なお、プログラムの本体で素式を表す変数も許されています。従って、
	call(X) :- X.
というようなプログラムを書くこともできます。

３．システムコマンド
  MacCupのコマンドとして以下のものが用意されています。これらの大抵のものは、
MacCupのメニューからも同じ事ができます。以下ではpredは述語名、もしくは述語
名/アリティを表すものとします(例えば、memberという述語がmember(X,[X|_])とい
うような定義を持つなら、そのアリティが２であるといい、member/2と書けます)。

  ３．１  一般的なコマンド
  (1) %h	ヘルプ(コマンド一覧)。
  (2) %d  pred	述語の定義を表示する。
      %d*	全述語の定義を表示する。
      %d?	述語名を表示する。
      %d-	ユーザーが定義した述語名を表示する。
  (3) %f	MacCupが使用している記憶領域の使用状況を表示。
  (4) %Q	MacCupを終了する。
  (5) %R	MacCupの初期化。
  (6) %c 数	推論の深さの上限を設定する。これより深いゴールは失敗とする。
  (7) %u	未定義述語をエラー(TRUE)にするか、失敗(FALSE)にするかのスイ
		ッチ。
  (8) %n 名前   制約変換やgensymなどで、新しく作られる名前の元を設定する。
		(初期値は`c')
  (9) %T	実行時間を表示する／させない。デフォルトは表示させない。

  ３．２  ファイルの入出力に関するコマンド
  (1) "ファイル名"	ファイルからプログラムを読み込む。
  (2) "ファイル名?	ファイルからプログラムを表示させながら読み込む。
  (3) %l 	ログファイルを設定する。
  (4) %w	現在定義されているプログラムをファイルに書き出す。

  ３．３  デバッグに関するコマンド
  (1) %p pred	述語にスパイフラグを設定/解除する。
      %p *	すべての述語にスパイフラグを設定する。
      %p .	すべての述語のスパイフラグを解消する。
      %p >	制約変換にスパイフラグを設定/解除する。
      %p ?	スパイフラグが設定されている述語名を表示する。
  (2) %t	トレース情報を出力する/させない（ノーマル）。
  (3) %s	対話的にトレース情報を出力する/させない（ステップ）。

  なお、トレースがノーマルの場合はプロンプトが`$'に、ステップの場合は`>'に
変わります。

  ３．４  制約変換に関するコマンド
  (1) %L	制約変換で作られた新述語の導入定義節を表示する。
  (2) %M 数     制約変換で扱う変数の個数の上限値を設定する(デフォルトは50)。
  (3) %P pred	述語の定義節の制約部を前処理する(標準形に書き換える)。
      %P *	全ての述語の定義節の制約部を前処理する。
      %P ?	標準形でない制約を持つ定義節を表示する。
  (4) %o	制約変換の方式を充足性保証(M-solvable)モードにする。
  (5) %a	制約変換の方式を全解探索モードにする(デフォルト)。

  ３．５  表示する文字に関するコマンド
   表示する文字のフォントと大きさを変えることができます。これはそれぞれメニ
ューのFontとSizeを選択し、好きな値をクリックすることでできます。
  ただし、それだけでは既に表示されている文字は変わりません。そこで、ウィン
ドウの大きさを変化させれば、既に表示されている文字も変更されます。


  ４．組込み述語
  ４。１　用語
 (1)項(term)
	アトム、変項(変数)、複合項、部分項
 (2)アトム
	定項(定数)、ストリング、数
 (3)定項
	英小文字もしくは日本語文字で始まり、英大小文字、アンダースコア(_)、
	日本語文字だけからなる文字列、`''で囲まれた任意の文字列、#や$など
	の特殊文字だけからなる文字列
 (4)ストリング
	`"'で囲まれた任意の文字の並び
 (5)数
	整数、浮動小数点数、指数表現(例。1.0e-3)
 (6)変項
	英大文字または`_'で始まる文字列。`_'のみは無名変項と呼ばれ、任意の
	二つの無名変項は異なった変項として扱う。
 (7)複合項
	pを定項、t1, t2, ... tnを項としたとき、p(t1,t2,...,tn)を複合項と言
	う。この時、pをファンクタ、tiをその引数、nをアリティと言う。特に、
	他の項の引数に現れる複合項を関数、pを関数子(ファンクタ)と呼び、そ
	れ以外の複合項を述語、pを述語名と呼んで区別する事がある。
 (8)オペレータ
	前置的なファンクタ(not)、後置的なファンクタ、中間置的な二項ファン
	クタ(==や<等)もサポートされている。特にこれらを演算子(オペレータ)
	という。
 (9)部分項(PST)
	素性名と素性値の対の並びを{}で囲んだもの。素性名は定項、素性値は項
	である。また、素性名と素性値の対は、二項オペレータ`/'をファンクタ、
	素性名を第１引数、素性値を第２引数とする複合項として表され、対同士
	はコンマ`,'で区切られる。特に、そのような対を含まない空の部分項も許
	され、{}と表される。
 (10)リスト
	項の並びを[]で囲んだもの。項同士はコンマ`,'で区切られる。特に、項
	を含まない空リストも許され、[]と表される。リストは`.'をファンクタ
	とする二項の複合項として定義される。従って、[a,b,c]は
	`.'(a,`.'(b,`.'(c,[])))の略記である。また`.'(a,X)のような構造を
	[a | X]と書くことがある。この表記法によれば、[a,b,c]は
	[a | [b | [c]]]とも書ける。
 (11)ファイルポインタ
	特にファイルから文字や項を読み込んだり、書き込んだりする場合、open
	述語を用いてファイルを開き、ファイルとMacCupがデータのやりとりをす
	るための構造を用意する。この構造をファイルポインタという。読み書き
	するための述語readやwriteに引数としてこのファイルポインタを指定す
	る事により、同時に複数のファイルを開いて、そこから読み込んだり、書
	き込んだりすることができる。
	特に、userはキーボードおよび画面から入出力を行うためのファイル名と
	して用いられる。
 (12)ストリーム
	キーボードやファイルから文字や項を読みとったり、画面やファイルに文
	字や項を書き出したりするためにreadやwriteという述語が用意されてい
	る。ここで、特にファイルポインタによってどこを入出力先にするかを指
	定しない場合の、読み出し先および書き込み先をそれぞれ入力ストリー
	ム、出力ストリームと言う。これはsee、tellによって開かれ、seen、
	toldによって閉じられる。デフォルトはそれぞれキーボードと画面であ
	り、seenやtoldによってストリームが閉じられると、これらが入力ストリ
	ーム、出力ストリームに戻る。
 (13)節
	項の並びを()で囲んだもの。項同士はコンマ`,'で区切られる。
 (14)ホーン節
	Prologのプログラムの基本です。２．４節を参照の事。


　４。２　組み込み述語の一覧
  MacCupでは以下の組込み述語が用意されています。ただし、引数に+がついている
ものは例示化された項、-は自由変項を表します。+も-も付いていないものは、どち
らでもよいものです。

 !
	カット(この前には後戻りせず、失敗とする)。
 X+ < Y+
	引数はすべて数でなければならない。X < Yならば成功し、さもなくば失敗
	する。less(X,Y)と同じ。
	例。:- 1.0 < 0.99.			--> 失敗
	    :- 1.0 < 1.00.			--> 失敗
	    :- 1.0 < 1.01.			--> 成功
 X+ <= Y+
	引数はすべて数でなければならない。X <= Yならば成功し、さもなくば失
	敗する。leq(X,Y)と同じ。
	例。:- 1.0 <= 0.99.			--> 失敗
	    :- 1.0 <= 1.00.			--> 成功
	    :- 1.0 <= 1.01.			--> 成功
 X+ > Y+
	引数はすべて数でなければならない。X > Yならば成功し、さもなくば失敗
	する。greater(X,Y)と同じ。
	例。:- 1.0 > 0.99.			--> 成功
	    :- 1.0 > 1.00.			--> 失敗
	    :- 1.0 > 1.01.			--> 失敗
 X+ >= Y+
	引数はすべて数でなければならない。X >= Yならば成功し、さもなくば失
	敗する。geq(X,Y)と同じ。
	例。:- 1.0 >= 0.99.			--> 成功
	    :- 1.0 >= 1.00.			--> 成功
	    :- 1.0 >= 1.01.			--> 失敗
 X = Y
	XとYとを単一化する。equal(X,Y)と同じ。
 X == Y
	XがYと等しければ成功し、そうでなければ失敗する。これは主に変項が同
	一の変項かどうかの検査に用いられる。eq(X,Y)と同じ。
	例。:- X == X.				--> 成功
	    :- X == Y.				--> 失敗
	    :- a(b) == a(b).			--> 成功
	    :- X=..[a,b], X == a(b).		--> 失敗
 Term =.. List
	項Termが例示化されている場合は、そのファンクタをリストの第１要素、
	残りの引数をリストの残りの要素としたリストに変換する。リストListが
	例示化されている場合は、この逆を行う。ml(Term,List)と同じ。
	例。 :- a(b,c,d) =.. X.			--> X => [a,b,c,d]
	     :- X =.. [a,b,c].			--> X => a(b,c)
 abolish(Name+, Arity+)
	述語名Name, アリティArityを持つユーザーが定義した述語をプログラム
	から抹消する。
	例。 :- abolish(member,2).		--> member/2を抹消する
 arg(Pos+, Term+, Arg-)
	第１引数のTermはリストか、1項以上の関数でなければエラーとなる。項
	TermのPos番目の引数とArgとを単一化する。リストは、例えば[a,b,c]は
	`.'(a,[b,c])のように2項関数として扱われる。
	例。 :- arg(2,a(b,c,d),X).		--> X => c
 assert(Head+)
 assert(Head+, Body+)
 assert(Head+, Body+, Constraint+)
	Headを頭部、Bodyを本体、Constraintを制約にもつ述語をプログラムの
	先頭に付け加える。BodyとConstraintはリストでも節でもよい。
	例。 :-assert(member(X,[X|_])).	--> member(X,[X|_])が定義される 
 asserta(Head+)
 asserta(Head+, Body+)
 asserta(Head+, Body+, Constraint+)
	assertと同じ。
 assertz(Head+)
 assertz(Head+, Body+)
 assertz(Head+, Body+, Constraint+)
	Headを頭部、Bodyを本体、Constraintを制約にもつ述語をプログラムの
	最後に付け加える。BodyとConstraintはリストでも節でもよい。
 atomname(Term, String)
	Termがファンクタならば、その関数の名前ストリングとStringとを単一化
	する。逆にStringがストリングならば、その名前を持つアトムとTermとを
	単一化する。
	例。  :-atomname(atom(X),Y).		--> Y => "atom"
	      :-atomname(X,"string").		--> X => string
 attach_constraint(Constraint+)
	Constraintを現在処理中のプロセスに対する新たな制約として付け加え
	る。Constraintはリストでも節でもよい。
	例。 attach_constraint((member(X,[a,b,c])))
	--> member(X,[a,b,c])がXの値に対する制約として付け加えられる
 clause(Head+, Body, Constraint)
	Headに単一化する頭部を持つ述語の定義を返す。頭部がHeadと単一化し、
	また本体のリストがBodyと、制約のリストがConstraintと単一化する。
	本体や制約が空の場合は、空リスト[]が返される。またその様な定義が
	複数ある場合は、後戻りさせることで、それらをすべて取り出すことが可
	能である。
	例。 clause(member(X,Y),Body,Const)
	--> member(A,[A|_])が定義されていれば、次のような値を返す。
	X = A, Y = [A|_], Body = Const = []
 clause_list(Clause,List)
	Clauseが変数でなければ、節ClauseをリストにしたものとListとを単一化
	する。ただし、Clauseがただ一つの項からなる場合は、それを唯一の要素
	とするリストとListとを単一化する。また逆に、Clauseが変数の場合、
	Listがリストであれば、その要素からなる節とClauseとを単一化する。
	ただし、Listが[A|X]のようなリストは、[A,X]と同様に扱われる。
	例。:- clause_list((a,b,c),X).		--> X = [a,b,c]
	    :- clause_list(X,[a,b,c]).		--> X = (a,b,c)
 close(FP+)
	ファイルポインタFPで指定されるファイルを閉じる。
 closefiles
	open/3によって開いているファイルをすべて閉じる。
 compare(X+,Y+,C-)
	XとYは共に数またはストリングでなければならない。それ以外はエラー
	となる。そしてそれらの大小関係（＞、＝＝、＜）をCの値として返す。
	例。 compare(123, 124, X)		--> X = `<'
 concat(Str1, Str2, Str3)
	Str3、もしくはStr1とStr2の両方が例示化されたストリングでなければな
	らない。Str1とStr2を連結して得られるストリングがStr3であるよう
	に値を返す。後戻りしたとき、別解を求めようとする。
	例。:- concat(X,"de","abcde").		--> X = "abc"
	    :- concat(X,Y,"abc").		--> X = "abc", Y = ""
 concat2(String, List)
	ストリングStringを一文字からなるストリングに分解して、それらをリス
	トにしたものをListの値とする。もしくは、その逆を行なう。
	例。:- concat2("abc", X).		--> X = ["a", "b", "c"]
 condname(Terms+, List)
	Termsは項のリストでなければならない。Terms中の項のファンクタのリス
	トをListの値として返す。
	例。 :- [a(T),b(U,V),c(d)], X).		--> X = [c, b, a]
 count(N)
	Nが数であれば、カウンタをその値にセットする。Nが変項であれば、呼び
	出し毎にカウンタの値と単一化し、カウンタの値を１ずつ増やす。カウン
	タの初期値は0である。ただし、後戻り時には失敗する。
	例。 :- count(2), count(A), count(B).
	--> A = 2, B = 3 となる。
 default(Target+, Filter+, DefaultVal+)
	Target, Filter, DefaultValはみな部分項でなければならない。Filter中
	の属性値対をTargetが一つでも含まなければ失敗とする。そうでなければ
	Targetの値は、Targetと両立するDefaultValの属性名と属性値の対を加え
	たものとなる。
	例。:- X = {pos/p, form/ga}, default(X, {pos/p}, {form/wo, gr/obj}).
	--> X = {pos/p, form/ga, gr/obj}
	    :- X = {pos/n, sem/Y}, default(X, {pos/p}, {form/wo}).
	--> 失敗。
 divstr(String+,Pos,FirstHalf,LastHalf)
	ストリングStringのPos番目から前のストリングをFirstHalfと、それ以降
	のストリングを後をLastHalfと単一化する。ただし、先頭の文字の位置を
	0とする。また、最後の位置を-1, その前の位置を-2、...とすることもで
	きる。
	例。:- divstr("abcde",-2,X,Y).		--> X = "abc", Y = "de"
	    :-divstr("abcde",N,"abc",Y).	--> N = 3, Y = "de"
	    :-divstr("abcde",N,X,"de").		--> N = 3  X = "abc"
 equal(X,Y)
	XとYとを単一化する。X = Yと同じ。
 eq(X,Y)
	XがYと等しければ成功し、そうでなければ失敗する。これは主に変項が同
	一の変項かどうかの検査に用いられる。X == Yと同じ。
	例。:- eq(X,X).				--> 成功(TRUE)
	    :- eq(X,Y).				--> 失敗(FAIL)
	    :- eq(a(b),a(b)).			--> 成功
	    :- X=..[a,b], eq(X,a(b)).		--> 失敗
 execute(Terms+)
	リストまたは節Terms中の項を一つ一つ実行する。途中で失敗すれば、後
	戻りを行なう。
	例。:- execute([memb(X,[a,b]),memb(X,[b,c])]).	--> X = b
 fail
	常に失敗する
	例。:- member(X, [a,b,c]), write(X), nl, fail.
	--> a b c と打ち出され、最終的に失敗する。
 functor(Term,Name,Arity)
	第１引数のTermは例示化されている場合は、リストか、関数か、ファンク
	タでなければエラーになる。項TermのファンクタとNameとが、またTermの
	アリティとArityとが単一化する。Termが変項の場合は、第２引数と第３
	引数は例示化されていなければならない。そしてNameをファンクタとし、
	アリティがArityの関数とTermとが単一化する。
	例。:- functor(a(b,c), X, Y).		-->  X = a  Y = 2
	    :- functor(X, a, 3).		-->  X = a(_1, _2, _3)
 gensym(Atom-)
	新たな定項を作り、引数のAtomと単一化する。この定項は何らかの文字
	列と数とから構成され、その文字列の初期値は`%n'コマンドで変更される。
	例。:- gensym(X).			--> X = c0
 gensym(Name+,Atom-)
	Nameは定項でもストリングでも良く、それに数を加えた新たな定項を作り、
	引数のAtomと単一化する。ただし、後戻り時には失敗する。
	例。:-gensym("gen", X).			--> X = gen1
 geq(X+,Y+)
	引数はすべて数でなければならない。X >= Yならば成功し、さもなくば
	失敗する。X >= Yと同じ。
	例。:- geq(1.0, 0.99).			--> 成功
	    :- geq(1.0, 1.00).			--> 成功
	    :- geq(1.0, 1.01).			--> 失敗
 get(X)
 get(X,FP+)
	現在の入力ストリーム(もしくはファイルポインタFP)から一文字読み込む。
	ただし、スペースや改行などの制御文字は読み込まれない。そしてその文
	字コード(数)と引数Xとを単一化する。後戻り時には、また新たな文字を読
	み込む。日本語文字の場合は、一文字が二回に分けて読み込まれる。
	例。:- get(X), write(X).
	--> a (改行) と入力すると97が出力され、X = 97となる。
	    :- get(X), get(Y), write(X), tab, write(Y).
	--> あ (改行) と入力すると130、160が出力される。
 get0(X)
 get0(X,FP+)
	現在の入力ストリーム(もしくはファイルポインタFP)から一文字読み込む。
	get/1とほぼ同じだが、スペースやタブなどの幾つかの制御コードも読み込
	まれ、そのコード(数)と引数Xとを単一化する。ただし改行コードは31とい
	う値になる。
 get1(X)
 get1(X,FP+)
	現在の入力ストリーム(もしくはファイルポインタFP)から一文字読み込む。
	get0/1とほぼ同じだが、改行コードもそのままのコードとする。
 greater(X+,Y+)
	引数はすべて数でなければならない。X > Yならば成功し、さもなくば失敗
	する。X > Yと同じ。
	例。:- greater(1.0, 0.99).		--> 成功
	    :- greater(1.0, 1.00).		--> 失敗
	    :- greater(1.0, 1.01).		--> 失敗
 halt
	MacCupを終了させる。
 isop(Prec,Type,Op)
	定義されているオペレータ(演算子)の優先度、型、名前をそれぞれPrec,
	Type,Opと単一化する。後戻りによって、いろいろなオペレータと束縛させ
	ることができる。
	例。:- isop(X,Y,Z).		--> X = 900, Y = xfy, Z = '/'
	    :-isop(X,Y,(:-)).		--> X = 1200  Y = fx
	(注意。上の例のように、優先度が高いものを引数とする場合は、()でく
	くる)
 length(X+,N)
	第１引数は例示化されたリスト、節、ストリング、もしくは部分項でなけ
	ればならない。その要素の個数（ストリングの場合は文字数）と第２引数
	とを単一化する。ただし、第１引数が[a|_]のようなリストの場合は、長さ
	を１とする。
	例。:- length([a,b,c], X).		--> X = 3
	    :- length((a,b),X).			--> X = 2
	    :- length({a/1, b/2, c/X},Y).	--> Y = 3
 leq(X+, Y+)
	引数はすべて数でなければならない。X <= Yならば成功し、さもなくば失
	敗する。X <= Yと同じ。
	例。:- leq(1.0, 0.99).			--> 失敗
	    :- leq(1.0, 1.00).			--> 成功
	    :- leq(1.0, 1.01).			--> 成功
 less(X+,Y+)
	引数はすべて数でなければならない。X < Yならば成功し、さもなくば失敗
	する。X < Yと同じ。
	例。:- less(1.0, 0.99).			--> 失敗
	    :- less(1.0, 1.00).			--> 失敗
	    :- less(1.0, 1.01).			--> 成功
 listing
 listing(Functor+)
 listing(Functor+ / Arity+)
	Functorを述語名とする述語名の定義を表示する。アリティArityが指定さ
	れていない場合は、すべてのアリティの述語を表示する。ただし、システム
	定義の述語の場合は、表示は行なわない。これは、常に成功する。
	例。:- listing(del).
		--> 成功し、delという述語の定義を表示する。
	    :- listing(a/3).
		--> 成功し、アリティ3の述語aの定義を表示する。
 ml(Term,List)
	項Termが例示化されている場合は、そのファンクタをリストの第１要素、
	残りの引数をリストの残りの要素としたリストに変換する。リストListが
	例示化されている場合は、この逆を行う。Term =.. List と同じ。
	例。 :- a(b,c,d) =.. X.			--> X => [a,b,c,d]
	     :- X =.. [a,b,c].			--> X => a(b,c)
 memb(X, List+)
	第２引数Listはリストでなければならない。第１引数のXは、Listの要素と
	単一化する。つまり、組み込みのmemberである。
	例。:- memb(X,[a,b,c]), write(X), nl, fail.
	--> a b cと打ち出される。
 multiply(X,Y,Z)
	３つの引数のうち２個以上が変項の場合は失敗する。例示化されている場
	合は、数でなければならない。X * Y = Zとなるように単一化する。
	例。:- multiply(2, 3, X).		--> X = 6
	    :- multiply(X, 3, 6).		--> X = 2
 name(Atom,List)
	第１引数Atomが定項であれば、それを構成する文字のアスキーコード(数)
	のリストと第２引数Listとを単一化する。またAtomが自由変項で、Listが
	アスキーコードのリストListであれば、そのコードに対応する文字からな
	る定項とAtomとを単一化する。
	例。:- name(gen, X).			--> X = [103, 101, 110]
	    :- name(X,[97,98,99]).		--> X = abc
 nl
 nl(FP+)
	改行コードを現在の出力ストリーム(もしくはファイルポインタFP)に書き
	出す。ただし改行コードはMacintoshでは`\r'である。
 not Term+
	述語Termが成功すれば、これ自体は失敗する。逆に述語Termが失敗すれば、
	これは成功する。Prologの\+と同じ(\+はMacCupではサポートしていない)。
	例。:- not true.			--> 常に失敗する。
	    :- not fail.			--> 常に成功する。
 op(Prec+,Type+,Op+)
	Opは一つの名前アトム、または名前アトムのリストである。その一つ一つ
	を優先度Prec、型Typeを持つ演算子として定義する。同じ名前、同じ型を
	もつ演算子が既にある場合は、それが破棄され、新しい定義が有効となる。
	（注意。既にシステムで定義されているものでも変更できる。また、定義
	できる優先度は0から1200以下であり、型はxf,yf,fx,fy,xfx,xfy,yfxのう
	ちのどれかである。
	例。:- op(500, xfy, [to, from]).
	--> 成功し、toとfromが優先度500、型xfyを持つ演算子として定義される。
 open(FileName+,Type+,FP-)
	ファイル名FileNameで指定されるファイルをTypeの値により、読み込みか
	書き出しのために開き、そのポインターをFPと単一化する。Typeの値は、
	`r'か`w'か`a'のいずれかである。このポインターは、read/2, write/2, 
	nl/1, tab/1などの引数に与えることで、そのファイルに対する入出力を
	行なうことができる。また、ファイルを閉じるにはclose/1を用いる。
 openfiles(FileName)
 openfiles(FileName,Pointer)
 openfiles(FileName,Pointer,OpenMode)
	open/3によって開かれているファイルの名前とFileNameを、ファイルポイ
	ンタとPointerを、ファイルを開いたモード(r,w,a)とOpenModeをそれぞれ
	単一化する。ただし、OpenModeはストリングとなる。後戻りによって、す
	べてのファイルを調べる事ができる。
 or(X+,Y+)
 or(X+,Y+,Z+)
 or(X+,Y+,Z+,U+)
 or(X+,Y+,Z+,U+,V+)
	引数はすべてタームのリストか節でなければならない。引数中のゴール
	を評価し、すべてが成功すれば、成功する。失敗した時は、リスト（
	もしくは節）の中で後戻りをするが、それでも失敗した時は、別な引数
	のリスト（もしくは節）に対して評価を行なう。
 pcon
	現在のプロセスが抱えている制約を出力する。
 pnames(PST+,List)
	部分項PSTの素性名のファンクタからなるリストとListとを単一化する。
	要素の順番は不定である。
	例。:- pnames({a/A, b/B, c/C}, X).	--> X = [c, b, a]
 prompt(String+)
	read/1でキーボードからファンクタを読み込む場合のプロンプトを設定す
	る。デフォルトは"? "。
	例。:- prompt("> ").			-->プロンプトが"> "になる。
 put(X)
 put(X,FP+)
	文字コードXを現在の出力ストリーム(もしくはファイルポインタ)に書き出
	す。
	例。:- member(X,[97,98,99]),put(X),fail.
	--> abcと出力される。(a, b, cの文字コードは97, 98, 99)
 pvalue(PST+,Pname+,Pvalue)
	部分項PSTで素性名Pnameの値とPvalueとを単一化する。部分項PSTがPname
	という素性を持たなければ失敗する。
	例。:- pvalue({a/1, b/2, c/3}, b, X).	-> X = 2
 read(X-)
	現在の入力ストリームから項を一個読み込み、引数と単一化する。必ず、
	ピリオドで区切られていなければならない。また、ファイルから読み込む
	場合は、それがファイルの終わり(end of file)ならば、end_of_fileとい
	うアトムと単一化する。キーボードからの入力の場合、prompt/1で指定さ
	れるプロンプトによって、入力を要求される。日本語コードも読む事がで
	きる。
	例。:-read(X).
	-->プロンプト`? 'が出て入力待ちになる。それに対し
	? 漢字.
	と入力すると、X = 漢字 となる。
 read(X-,FP+)
	第２引数のファイルポインタで指定されたファイルからファンクタを一個
	読み込む以外は、read/1と同じ。
 reset_timer
	CPUタイマをリセットする。これはtimerと組で用いられる。
 retract(Head+)
 retract(Head+,Body)
 retract(Head+,Body,Constraint)
	Headを頭部、Bodyを本体、Constraintを制約にもつ述語をプログラムか
	ら削除する。BodyとConstraintはリストでも節でもよいが、省略したと
	きは空であるものだけを削除する。後戻り時には別な定義を削除しようと
	する。
	例。 :-retract(member(X,Y)).
	-->定義されていればmemberの定義(member(X,[X|_]).)が削除される。
 see(File+)
	引数はストリングか名前アトムでなければならない。そして、その名前を
	持つファイルが現在の入力ストリームになる。そのようなファイルがない
	場合は失敗する。
	例。:- see("HD40:program:test.p"),read(X),write(X),seen.
	-->ハードディスクHD40のprogramフォルダーのtest.pファイルから一個フ
	ァンクタを読み込み、出力した後、ファイルを閉じる。
 seeing(X)
	現在の入力ストリームとなっているファイル名を返す。
 seen
	現在の入力ストリームを閉じる。これはsee/1と組で用いられる。
 stayflag(Pred+,Arity+,Value)
	アリティArityをもつ述語Predに対し、それが制約として用いられた場合、
	制約変換の際に値Value(成功ならtrue, 失敗ならfailのいずれか)を返す場
	合、展開不能として制約として保持させる事を指定する。
	例。sum/3は少なくとも二つの引数が例示化されていなければ制約変換の際
	に失敗(fail)するので、それを制約として使う場合は、
		:- stayflag(sum,3,fail).
	と指定すると、sumの少なくとも二つの引数が例示化されるまで制約変換時
	に展開されずに保持される。
 strcmp(X+,Y+,C-)
	ストリングXとストリングYの大小関係(<,==,>)とCとを単一化する。
	例。:- strcmp("ab","abc",X).		--> X = `<'
	    :- strcmp("abc","ab",X).		--> X = `>'
 strlen(String+,N)
	ストリングStringの長さ(文字数)と第２引数Nとを単一化する。これは
	length/2の特殊な場合である。
	例。:- strlen("",N).			--> N = 0
	    :- strlen("abc",N).			--> N = 3
 substring(String+,Pos+,X-)
	ストリングStringのPos番目の文字以降のストリングを第３引数Xと単一化
	する。ただし先頭の文字の位置は0番目と考える。またPosが負の場合はス
	トリングの末尾からの位置とみなす。
	例。:- substring("abc",1,X).		--> X = "bc"
	    :- substring("abc",-1,X).		--> X = "c"
 substring(String+,Pos+,Length+,X-)
	ストリングStringのPos番目の文字から後ろLength個の文字からなるストリ
	ングを第４引数Xと単一化する。ただし先頭の文字の位置は0番目と考える。
	またPosが負の場合はストリングの末尾からの位置とみなす。Lengthは負で
	あってはならない。
	例。 :- substring("abcde",2,2,X).	--> X = "cd"
	     :- substring("abcde",-2,2,X).	--> X = "de"
 sum(X,Y,Z)
	３つの引数のうち２個以上が変項の場合は失敗する。例示化されている場
	合は、数でなければならない。X + Y = Zとなるように単一化する。
	例。:- sum(2, 3, X).			--> X = 5
	    :- sum(X, 3, 5).			--> X = 2
 tab
	現在の入力ストリームに対しタブコードを出力する。しかしMacCupでは、
	スペースにしかならない。
 tab(FP+)
	ファイルポインタFPで指定されたファイルにタブコードを出力する。
 tell(File+)
	引数はストリングか名前アトムでなければならない。そして、その名前を
	持つファイルが現在の出力ストリームになる。
	例。:- tell("HD40:program:log"),read(X),write(X),told.
	-->一個ファンクタをキーボードから読み込み、ハードディスクHD40の
	programフォルダーのlogファイルに出力した後、ファイルを閉じる。
 tella(File+)
	ファイルの最後から書き出す以外は、tell/1と同じ。
 telling(X)
	現在の出力ストリームとなっているファイル名を返す。
 timer(X-,Y-)
	第１引数Xにはreset_timer以後の経過時間(秒)、Yにはそのうち制約変換に
	使われた時間(秒)と単一化する。
	例。:- reset_timer, complex_computation, timer(X,Y).
	--> complex_computationの実行に要した総時間と制約変換に要した時間が
	それぞれXとYに単一化する。
 told
	現在の出力ストリームを閉じる。
 true
	常に成功する。
 type(X+,Type)
	Xの型によってTypeは次のどれかと単一化する。var, integer, float, 
	string,	file_pointer, pst, clause, list, functor, atom。
	例。:- type(X,Y).			--> X = var
	    :- type(1,X).			--> X = integer
	    :- type(1.02,X).			--> X = float
	    :- type("abc",X).			--> X = string
	    :- open("HD40:programs:test.p","r",T),type(T,X).
						--> X = file_pointer
	    :- type({a/1},X).			--> X = pst
	    :- type((a(U),b(V,W)),X)		--> X = clause
	    :- type([a,b,c],X).			--> X = list
	    :- type(a(Y,Z),X).			--> X = functor
	    :- type(a,X).			--> X = atom
 unbreak
	ステップトレースでbreakした後、:-unbreak.でその時点に戻れる。
 unify(Terms+,List-)
	Termsは節またはリストであり、その要素である述語を制約として変換した
	結果(リスト)とListとを単一化する。
	例。:- unify([member(A,X),append(X,Y,Z)],W).
		--> W = [c0(A,X,Y,Z)] という様な制約が得られる。
 var(X)
	引数Xが自由変項であれば成功、さもなくば失敗する。
	例。:- var(a).				-->失敗。
	    :- var(X).				-->成功。
 write(X)
	現在の出力ストリームにファンクタXを出力する。ただし、引数がストリン
	グの場合、引用記号は出力されない。
	例。:- write(':-').			--> ':-'と出力される。
	    :- write(":-").			-->  :- と出力される。
 write(X,FP+)
	第２引数のファイルポインタで指定されたファイルにファンクタXを出力す
	る以外は、write/1と同じ。


５。ファイルの入出力

５。１  プログラムのロード方法
  ファイルからMacCupプログラムを入力するには、ファイル名を`"'でくくって入力
するか、もしくはFileメニューからOpenをクリックしてファイルを選択する、の二
通りがあります。前者はUnixから受け継いだ方法で、後者はMac流と言えるでしょう。
どちらかと言えば、後者の方法をお勧めします。しかし、どのような内容のファイ
ルを読み込んでいるかを確認する方法は今の所前者の方法(ファイル・パスの最後に
`?'をつける)しかサポートしていません。

５。２  ファイルの指定法
  プログラムをロードしたり、プログラムの中でファイルから読み込んだり、ファ
イルに書き出したりするには、ファイルを指定することが必要です。それには、
Mac流のファイル・パスをストリングとして書きます。例えばハードディスクHD40の
programsフォルダーのtestというファイルを指定するには、"HD40:programs:test"
とします。余計なスペースをいれないよう注意して下さい。また、ディスク名や、
フォルダー名とファイル名との句切りはコロン`:'を使います。

５。３  入出力ストリームとファイルポインタ
  プログラムからファイルの読み書きをするには、Mac流では不便です。そこで、フ
ァイルからの入力のためにsee/1(そしてseen/0), ファイルの出力のためにtell/1か
tella/1(そしてtold/0)、また入力と出力の両方のためにopen/3を用います。
  see/1は現在の入力ストリーム(read/1などが読み込む対象)を指定したファイルに
切り替え、tell/1は現在の出力ストリーム(write/1などが書き込む対象)を指定した
ファイルに切り替えるものです。またtella/1はファイルの最初からではなく、既に
に存在するファイルに追加的に書き込みます。
  このようなストリームの切り替えは、プログラムの実行中だけではなく、プログ
ラムの終了後もseen/0もしくはtold/0を実行しない限り保存されます。どんなファ
イルが現在の入力ストリームや出力ストリームになっているかは、seeing/1と
telling/1によってそれぞれしらべることができます。
  しかしseeやtellによる方法では、一度には入力、出力用にそれぞれ一つのファイ
ルしか開く事ができません。
  それに対し、open/3は、ストリームをファイルポインタという形で(assertなどに
より）保持することができ、また同時に複数個のファイルも開くことができます。
そしてそのファイルポインタに対してread/2, write/2などをすることにより、その
ファイルから読み書きすることができます。ただし、現在は同時に開けるファイル
の個数は15個に制限されています。どのようなファイルを開いているかは、
openfiles/1で調べることができ、またこれらのファイルすべてをclosefiles/0で閉
じることもできます。それぞれのファイルを閉じるには、close/1を用います。
  また、ファイルポインタの値は#に16進数が続いた形のものですが、これを
read/2やwrite/2の引数として直接与えることができます。
  例。  :- open("HD40:programs:test",r,X).
	--> X = #0		ファイルポインタ#0が返された。
	:- read(X,#0).		ファイルポインタ#0を直接与えて、ファイルか
				ら読み込む。
	--> X = a(1)		HD40:programs:testの最初のタームが返された。
	:- openfiles(X,Y).	どういうファイルが開いているか調べる。
	--> X = "HD40:programs:test", Y = #0

６。制約変換機構
　Prologは一般に、プログラムの実行を次のような方法で行っています。

  (1)プログラムが書かれた順番に行われる。
  (2)解が複数個ある場合は、一般的には後戻りによって、すべての解を求める。

しかし、これはプログラムの論理的な性質とは無関係であって、Prologが手続き的
なプログラミング言語であるための欠点とも言えます。
　制約変換は、プログラムの論理的な性質を保証するために考案されました。即ち、

  (1)プログラムは書かれた順番ではなく、６．５節で述べるようなプログラムの
内部的な性質によって実行（展開）される。
  (2)プログラムの「実行」は、定義部の展開(folding)と、畳み込み(unfolding)
によって行われる。従って、解を１個求める、というのではなく、プログラムに
は解が存在することを保証しながら、その解すべてを覆うような述語を生成して
いく。このような述語は「モジュラー」と呼ばれる性質を満たすように定義され
る。

ということが行われています。実際には、多くの組み込み述語も(一部はstayflag
を使うなどして)制約として書くことができるため、ほとんどのPrologのプログラ
ムは、制約変換によって「実行」可能です。しかし、解を求める方略が予め分かっ
ているような場合は、従来のProlog流のやり方の方が効率的だといえます。

この章では、制約変換の具体的な手法と、そのデバッグ法などについて述べます。
なお、その内容は津田宏氏による「cu-Prolog第３版ユーザーズマニュアル」を参
考にさせて頂きました。

６。１  ３通りの制約変換方式
MacCupでは制約変換を次のような３通りの方法で行うことができます。

(1) @モード
トップレベルから制約変換機構を単独で使うことができます。これはデバッグ時な
ど、制約変換だけを試したい時に有効です。

	@ member(X,[a,b,c]),member(X,[b,c,d]).

とすると、MacCupはこれと等価でモジュラーな制約(例えばc0(X))を返します。また、
制約変換の際に作られた新述語の定義も出力します。

(2) unify(C,NC)
組み込み述語unify/2によりプログラムの実行中に変換機構を陽に起動することがで
きます。この場合、制約は次のように素式を要素とするリストもしくは節で記述し
ます。

	 [c0(X,[a,b,c]), c1(P,Q,R), c2(Q,S)]

unify(OldCond, NewCond)は、OldCondがリスト形式の制約に例示化されていて、
NewCondが自由変項の場合にのみ制約変換を実行し、この変項の値としてOldCond
を変換した制約を格納します。

(3) 制約付きホーン節
制約付きホーン節を定義しておいて、それを実行中に呼び出すことで、自動的に制
約変換が行われます。

６。２  制約変換の操作
制約変換でできる新しい節の集合(以下、「節集合」と呼ぶ)として、以下の3つが用
いられます。

(1) DEFINITION 新述語の導入節
(2) NON-MODULAR 新定義節のうちモジュラーでない節
(3) MODULAR 新定義節のうちモジュラーな節

ここで、「モジュラー」な節とは、簡単に言えば、
    『どの項の引数も変項であり、かつそれらの変項は互いに異なっている』
ような節の事です。制約変換とは、モジュラーでない節を、モジュラーな節になる
ように変換するものです。それは以下の手順で行われます。
  モジュラーでない制約をC、Cに含まれる変項をX1,..,Xn、pをn引数の新述語名と
します。制約変換ルーチンはp(X1,...,Xn)==C.をDEFINITIONに付加し、以下の三つ
の基本操作を繰り返すことで、DEFINITIONおよびNON-MODULAR を空にすることがで
きた場合に成功します。このとき、MODULARの中の節が新定義節で、Cは
p(X1,...,Xn)に書き換えられたことになります。なおMacCupでは、制約変換の前後
でreduction操作(定義節が一つの述語は強制的に展開する)を行っている。
(a) unfolding
	NON-MODULARまたはDEFINITIONから一つの節Cを取り除き、節Cの本体から一
	つのリテラルLを選び、展開を行う。展開による新定義節のうちモジュラー
	でない節はNON-MODULARに、モジュラー節はMODULARに追加される。
(b) folding
	NON-MODULARの節Cの本体より、残りの本体と共有変項を持たないリテラル
	列L=L1,...,Lnを選ぶ。DEFINITIONの中の一つの節Dの本体が変項の置換に
	よりLと同一なら、CのLをDの頭部(の変項を置換したもの)と置換する。
(c) modularize
	NON-MODULARから一つの節H:-B.を取り除き、Bを変項による同値類B1,...,
	Bnに分割する。Biに含まれる変項をXi1...,Xim、piを新述語として、Pi=
	pi(Xi1,...,Xim)とする。
	1 <= i <= n についてPi == Bi.をDEFINITIONに追加し、MODULARに
	H:-P1,...,Pn.を追加する。

６。３  制約変換のトレース
制約変換のトレースは、まず`Trace'メニューから`Marking SPY'を選択し、
`UnfoldFold'をクリックすることによって制約変換にスパイをかけます（以上の
事は、`%p >'をキーボードから打ち込むことでも実行できます）。次に、`Trace'
メニューから`Step TRACE'か`Normal TRACE'を指定してトレースモードに入ります
（これもキーボードから`%t'または`%s'により指定できます）。

実際にトレースに入ると、次のような表示が行われます。
(1) DEFINITIONに含まれる節(新述語の導入節)は、以下の書式で表示されます。

[節番号(節状態,述語定義数)] 導入節
	例 [1(d,0)] c0(X) <=> member(X,[a,b,c]).

ここで、節状態は以下の記号で表されます。
	r	removed: unfoldingにより消去され(以下のf,gでない)節
	d	derivation: 導入節でunfoldingされていないもの
	g	registered: 新述語の定義に一つ以上の単位節が得られたもの
	f	false\_registerd: 新述語の定義が空となったもの

(2) NON-MODULARおよびMODULARに含まれる節(新しく定義された節)は、以下の書式
で表示されます。
	<節番号(節状態,述語定義数)>新定義節
	例。 <2(u)> c0(X):-member(X,[b,c]).

ここで、節状態は以下の記号で表されます。
	r	removed: 簡約化操作、unfoldingにより消去された節
	u	untouched: NON-MODULARの節
	m	modular: 本体に変項の共有関係がない節
	i	unit: 単位節

６。４  ステップトレースのユーザ入力
ステップトレース・モードでは、MacCupはトレース表示をした後、ユーザが入力し
てくれるのを待ちます。そこでは次のような入力ができます。

	リターン	継続: デフォルトのヒューリスティックスで節とリテラ
			ルを選択し継続する
	u CN LN		マニュアルunfolding: CNで節番号、LNで本体の何番目を
			展開するかを指定する。
	s		トレースの中止: 以後の変換過程は表示されない。
	n		ステップトレースの中止: 以後ノーマルトレースとなる。
	q		制約変換の中断: その時点で新定義節のうち消去されて
			いないものをアサートして制約変換を終了する。
	z		制約変換の中止: 新定義節を消去後、制約変換を終了す
			る。

６。５  制約変換におけるヒューリスティックス
  MacCupでは制約変換を次の手順で行っています。
(1) DEFINITIONに節がある場合には、DEFINITIONより一つの節Cを選びunfoldingす
る。節CはDEFINITIONより取り除く。
(2) DEFINITIONが空の場合には、NON-MODULARより節Nを選び、Nの頭部において全て
の引数が相異なる変項の場合には、unfoldingを行う。
(3) そうでない場合は節Nの本体をfoldingまたはmodularizeする。
(4) 以上の操作を、DEFINITIONおよびNON-MODULARが空になるまで繰り返す。

したがって、ヒューリスティックスとしては
(a) DEFINITIONからの節の選び方
(b) NON-MODULARからの節の選び方
(c) unfoldingにおいて展開するリテラルの選び方
が考えられます。現在DEFINITIONおよびNON-MODULARはスタックを使って実現してお
り、最も新しく作られたものを最初に選ぶというヒューリスティックスを採用して
います。
  unfoldingにおけるリテラルの選択に関するヒューリスティックは、現行では以下
の要素により各リテラルの活性係数を計算し、活性係数の最も高いものから展開し
ています。

Arity  = 述語の引数の個数
Const  = 引数のうち定数に具体化しているものの個数
Vnum   = 引数に現れる自由変項が制約全体の中で何回出現しているかの個数
Funct  = 引数のうち(変項を含む)複合項に具体化しているものの個数
Rec    = 述語が再帰的なら1、そうでなければ0
Defs   = 述語の定義節の個数
Units  = 述語の定義節のうち単位節(本体が空)の個数
Facts  = 述語定義がすべて単位節からなる場合に1、そうでなければ0

活性係数 = 3*Const + 2*Funct + Vnum - Defs + Units - 2*Rec + 3*Facts

活性係数は、cu-Prologの制約変換に関して今まで経験的に得られていたヒューリス
ティックを含むように決定していますが、将来変更するかも知れません。また、い
ろいろな要素を加味して活性係数を決めることにより、一層有効なヒューリスティ
ックスが得られると思われます。

７。トレース機能
  MacCupには、制約変換以外のプログラムのデバッグのために、次のようなトレー
ス機能があります。制約変換のトレースについては前節を参照して下さい。
(1) ノーマルトレース: プロンプトが`$'になります。スパイするよう指定された述
語に関してだけ、プログラム実行に関するいろいろな情報を垂れ流し方式で表示し
ます。
(2) ステップトレース: プロンプトが`>'になります。処理過程のステップ毎に実行
を一時中断し、ユーザーからのコマンド入力待ちになります。スパイ指定に関係な
く、処理過程のすべての情報を表示します。

７。１  スパイフラグの設定方法
  `Trace'メニューの`Marking SPY'を選択して下さい。
(1) `ALL'をクリックすればすべての述語に対してスパイ指定される(これは`%p *'
によってもできる）。
(2) カーソルが点滅しているボックスの中に述語を書けば、その述語に対するスパ
イ指定がスイッチする。つまり、スパイ指定されていれば解除され、されていなけ
ればスパイ指定される(`%p predicate'でも同じことになる)。
(3) `Spy Reset'をクリックすれば、全ての述語のスパイ指定が解除される(`%p .'
でも同じことになる)。
(4) `UnfoldFold'をクリックすれば、制約変換に対しスパイ指定が行われる。
(5) `Show'をクリックすれば、スパイ指定されている述語名を表示する(`%p ?'でも
同じ）。

７。２  トレースモード
トレースモードにはノーマルトレースとステップトレースの２種類のモードがあり
ます。これは次のようにして指定します。
(1) `Trace'メニューから`Step TRACE'を指定する。これによりステップトレースモ
ードになる。
(2) `Trace'メニューから`Normal TRACE'を指定する。これによりノーマルトレース
になる。
(3) `Trace'メニューから`Trace OFF'を指定する。これによりトレースが解除され
る。

この他にも、`%s'と`%t'というステップトレース、ノーマルトレースのそれぞれの
トグルスィッチによりトレースモードを切り替えることができます。

７。３  ステップトレースのユーザー入力
  ステップトレース・モードでは、処理過程において、現在のゴールを表示した後、
ユーザからのコマンド入力待ちになります。そこでは次のようなコマンドが入力で
きます。

	リターン	実行を継続する。
	a		その時点までの親ゴールを表示する。
	b		ブレーク。一時的にトップレベルに移る。 unbreak/0に
			よりこの時点に戻ることができる。
	d		述語の表示。トップレベルにおける`%d'コマンドと同じ。
	f		現在のゴールをfailさせる。
	l		リープ。スパイされている次の述語の呼び出しまで飛ぶ。
			その間のトレース情報は垂れ流しになる。
	s		最左ゴールが終了するまでトレースを省略する。
	z		実行を放棄し、トップレベルに戻る。

８。部分項
  部分項(PST, Partially Specified Term)は、属性とその値の対からなる構造を表
現するのに向いた構造です。これは特に、あらかじめどのような属性があるかが定
まらないような構造の表現に向いています。私たちは日本語句構造文法の構文解析
器の作成において、素性構造を表現するのに部分項を用いています。
  部分項は次のように表現されます。
	{属性1 / 値1, 属性2 / 値2, ..., 属性n / 値n}
ここで、nには制限が有りません。特にn=0の場合は{}と表されます。
  部分項の単一化の方法は特殊です。部分項同士が単一化「しない」のは、それら
が単一化不能な値を同じ属性に対して持つ場合に限られます。それ以外の場合は単
一化可能です。例を見て下さい。
 (1) 属性を全く持たない部分項{}はどのような部分項とも単一化します。
    例。{}と{a/1,b/2}は単一化して、共に{a/1,b/2}となる。
 (2) 同じ属性を共有しない部分項同士も単一化します。
    例。{a/1, b/2}と{c/3}は単一化して共に{a/1, b/2, c/3}となる。
 (3) 同じ属性を持つが、その値が単一化可能なら、単一化する。
    例。{a/X, b/2}と{a/1, b/Y, c/3}も単一化して共に{a/1, b/2, c/3}となる。
 (4) 同じ属性を持ち、その値が単一化不能の場合、単一化不能である。
    例。{a/1, b/2}と{a/1,b/3}は属性bの値2と3とが単一化不能なので、単一化に
失敗する。

  部分項を扱うための述語が幾つか用意されています。
 (a) pvalue(PST+,Pname+,Pvalue)
	部分項PSTで素性名Pnameの値とPvalueとを単一化する。部分項PSTがPname
	という素性を持たなければ失敗する。
	例。:- pvalue({a/1, b/2, c/3}, b, X).	-> X = 2
 (b) pnames(PST+,List)
	部分項PSTの素性の定項からなるリストとListとを単一化する。要素の
	順番は不定である。
	例。:- pnames({a/A, b/B, c/C}, X).	--> X = [c, b, a]
 (c) default(Target+, Filter+, DefaultVal+)
	Target, Filter, DefaultValはみな部分項でなければならない。Filter
	中の属性値対をTargetが一つでも含まなければ失敗とする。そうでなけ
	ればTargetの値は、Targetと両立するDefaultValの属性値対を加えたも
	のとなる。
	例。:- X = {pos/p, form/ga}, default(X, {pos/p}, {form/wo, gr/obj}).
	--> X = {pos/p, form/ga, gr/obj}
	    :- X = {pos/n, sem/Y}, default(X, {pos/p}, {form/wo}).
	--> 失敗。
 (d) length(X+,N)
	第１引数は例示化された部分項の要素の個数と単一化する。
	例。 :- length({a/1, b/2, c/A},X).	--> X = 3
	     :- length({}, X).			--> X = 0

  制約変換では、部分項を引数にとる述語も使えますが、注意が必要です。
呼び出し側の述語（制約）が変数を含まないか、もしくは制約変換によって
要素が増える場合、期待したような結果が得られない場合があります。これ
は、主として制約変換の効率をあげるために取られた方針によるものです。


９。MacCupの構文

９。１ MacCupの構文のBNFによる記述
<文字>		::= <定文字> | <特殊文字> | <バー> | <括弧> |
			<句読点> | <スペース> | .
<定文字>	::= <英大文字> | <英小文字> | <数字> | <日本語文字>
<英大文字>	::= A | B | C | ... | X | Y | Z
<英小文字>	::= a | b | c | ... | x | y | z
<数字>		::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
<日本語文字>	::= あ | い | ... | 亜 | ...
<定文字列>	::= _ <定文字> | <定文字> <定字列>
<バー>		::= |
<特殊文字>	::= < | > | = | - | + | * | # | : | $ | % | & | @
<数字列>	::= <数字> | <数字><数字列>
<符号>		::= <空> | -
<数>		::= <符号> <数字列> | <符号> <数字列> . <数字列> |
			<符号> <数字列> . <数字列> { E | e} {-} <数字列>
<文字列>	::= <空> | <文字><文字列>
<ストリング>	::= "<文字列>"
<特殊文字列>	::= <特殊文字> | <特殊文字> <特殊文字列>
<定項>		::= <英小文字><定字列> | <日本語文字><定字列> |
		 <特殊文字列> |	 '<文字列>'
<変項>		::= <英大文字><定字列> | _<定字列>
<アトム>	::= <定項> | <数> | <ストリング>
<ファンクタ>	::= <定項>
<オペレータ>	::= <定項>
<述語名>	::= <定項>
<リスト>	::= [] | [<項列>] | [<項列><バー><項>]
<属性対>	::= <定項> / <項>
<属性対列>	::= <属性対> | <属性対>,<属性対列>
<部分項>	::= {} | {<属性対列>}
<項>		::= <変項> | <定項> | <ファンクタ>(<項列>) |
			<オペレータ><項> | <項><オペレータ><項> |
			<項> <オペレータ> | <部分項> | <リスト> | (<項>)
<項列>		::= <項> | <項>,<項列>
<節>		::= (<項列>)
<定リテラル>	::= <述語名> | <述語名>(<項列>) | <オペレータ><項> |
			 <項><オペレータ><項> |	<項> <オペレータ>
<リテラル>	::= <定リテラル> | <変項>
<リテラル列>	::= <リテラル> | <リテラル> , <本体>
<ホーン節本体>	::= <定リテラル> | <リテラル> :- <リテラル列> |
			 :- <リテラル列> | ?- <リテラル列>
<ホーン節>	::= <ホーン節本体>. 
<制約付きホーン節> ::= <ホーン節本体>;<リテラル列>.

９。３  MacCup組み込みの演算子

	優先度		型	　　オペレータ
--------------------------------------------------
	700		xfx		=
	700		xfx		==
	700		xfx		<=
	700		xfx		<
	700		xfx		>=
	700		xfx		>
	700		xfx		=..
	900		xfy		/
	900		fy		not
(	1000   		yfy 		   ,  	)
	1200		xfx		<=>
	1200		yfx		where
	1200		yfx		;
	1200		fx		?-
	1200		fx		:-
	1200		xfx		:-
---------------------------------------------------

注意：, は再定義できない。

