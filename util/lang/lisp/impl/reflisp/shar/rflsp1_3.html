#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of shell archive."
# Contents:  README man.txt makefile lisp.c commn.c eval.c gc.c
#   tgraph.c graph.c lex.c math.c midi.c parse.c print.c symtab.c
#   unix.c ipc.c view.c cells.h init.lsp times.lsp bignum.lsp
#   qtime.lsp
# Wrapped by bbirch@brno on Mon Mar  8 19:54:49 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(1472 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X;;; ****************************************************************
X;;; RefLisp ********************************************************
X;;; ****************************************************************
X
XRefLisp is a small Lisp interpreter written by Bill Birch. Versions
Xexist for MS-DOS and UNIX (AIX). The MS-DOS version supports
XCGA/EGA/VGA graphics and the Microsoft Mouse.  The interpreter is a
Xshallow-binding, reference counting design making it suitable for
Xexperimenting with real-time and graphic user interface programming.
XCommon Lisp compatibility macros are provided, and most of the
Xexamples in "Lisp" by Winston & Horn have been run on RefLisp.
XRefLisp comes with an ASCII manual and many demonstration programs,
Xincluding an analogue clock which never stops for garbage collection.
XIt is written in ANSI C and is in the public domain.
X
XThis copy of the distribution was obtained from the Lisp Utilities
XRepository by anonymous ftp from ftp.cs.cmu.edu in the directory
X   /afs/cs.cmu.edu/user/mkant/Public/Lisp/ 
Xas the files reflisp1_3, reflisp2_3, reflisp3_3 and reflisp_README.
X
X   reflisp1_3 is a shar file containing the C source files and documentation
X   reflisp2_3 is a shar file containing demo lisp programs
X   reflisp3_3 is a uuencoded file containing a MS-DOS binary executable
X
XFor further information, contact the author by writing to Peter
XWilliam Birch, 23 Marlins Turn, Gadebridge, Hemel Hempstead, HP1 3LQ,
XGreat Britian.
X
X;;; *EOF*
END_OF_FILE
if test 1472 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'man.txt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man.txt'\"
else
echo shar: Extracting \"'man.txt'\" \(68076 characters\)
sed "s/^X//" >'man.txt' <<'END_OF_FILE'
X
X
X
X
X
X
X
X
X                   Reference-Counting Lisp (RefLisp)
X		      
X                        USER'S REFERENCE MANUAL
X                           and DOCUMENTATION
X
X			     Version 2.67
X			    
X			      27 Feb 1993
X
X
X
X
X         Copyright (c) 1989,1990,1991,1992 Peter William Birch
X		   
X                          All rights Reserved.
X
X
X
X                           23 Marlins Turn,
X                              Gadebridge,
X                            Hemel Hempstead,
X                         HP1 3LQ, Great Britian
X			     
X                          Tel: +44 442 230 654
X
X                   Internet: B.Birch@uk03.hemel.co.uk
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X	Table of Contents
X	
X		0  COPYRIGHT
X		1  INTRODUCTION
X		2  LEXICAL AND SYNTACTIC CONVENTIONS
X		3  THE TOP LEVEL
X			3.1 Installing RefLisp on MS-DOS
X			3.2 Starting RefLisp
X			3.3 RefLisp Execution
X			3.4 Scope and Extent
X 		4  LIST PROCESSING FUNCTIONS
X		5  SYMBOL FUNCTIONS
X		6  CONTROL FUNCTIONS
X		7  EVALUATION FUNCTIONS
X		8  PREDICATE FUNCTIONS
X		9  MATHEMATICAL FUNCTIONS
X		10 RELATIONAL FUNCTIONS
X		11 PROPERTY LISTS
X		12 INPUT/OUTPUT FUNCTIONS	
X			12.1 File I/O
X			12.2 Graphics Functions
X			12.3 ATARI-ST Specific I/O
X				12.3.1 MIDI I/O
X		13 DEBUGGING FUNCTIONS
X		14 HISTORY & DESIGN NOTES
X		15 MEMORY MANAGEMENT
X		16 THE SOURCE CODE
X			16.1 List of Files
X			16.2 Portability
X			16.3 Metrics
X			16.4 List of Example Programs 
X		17 BIBLIOGRAPHY
X
X		APPENDIX A	ROUND TOITS
X		APPENDIX B	UPDATES
X		APPENDIX C	BUGS
X
X
X0 COPYRIGHT
X	
X	You may copy RefLisp, and this manual provided that:
X
X	1) Neither the manual or the program are modified in any way.
X		
X	2) Both the manual and the program are copied together.
X		
X	3) If you find a bug in this program, please notify the author
X           so that it can be fixed in subsequent releases.
X
X1  INTRODUCTION
X
XRefLisp is a portable Lisp interpreter written in 'C.' Reflisp is designed
Xto investigate reference counting garbage collection, and as a useful tool
Xfor software development. It can be used as a base for writing portable
Xprograms. It is in the public domain for people to learn Lisp, and to
Xanswer the question "Reference counting is slow, but HOW slow?".
X
XRefLisp exists in MS-DOS, UNIX and ATARI-ST versions, the MS-DOS
Xversion is the base version, from which others are ported. Programs
Xwritten for RefLisp can be ported to Standard Lisp or Common Lisp. The
Xinterpreter is built according to Standard Lisp principles. It also
Xparses the Common Lisp quoting syntax, and  Common Lisp functions are
Xprovided in Lisp. Future versions will migrate towards inbuilt Common
XLisp, with Standard Lisp as Lisp source.
X	
XThis manual is written you have assuming some familiarity with Lisp. If
Xyou are learning Lisp,  read one of the excellent tutorials mentioned
Xin the Bibliography. 
X	
XThis manual contains a description of the  functions of the
XRefLisp interpreter grouped in subject headings. Beginners should try
Xout every function in turn to get a feel for them. The rest of the
Xdocument contains sections on design and other issues.
X	
XThe interpreter is supplied with a number of demonstration programs
Xwhich can be run by starting RefLisp with DEMOS.LSP as a command
Xparameter: 
X	
X	C:\>REFLISP DEMOS.LSP 	; MS-DOS
X	$ reflisp demos.lsp 	; UNIX
X     	
X2  LEXICAL AND SYNTACTIC CONVENTIONS
X	
XThe parser of the interpreter uses the (read) function to parse in the
Xnext s-expression to evaluate. Thus the syntax described here is
Xessentially that of (read). The syntax of RefLisp follows Common Lisp.
XThe special characters recognised are:
X
X	(		-- beginning of a list, or cons cell.
X	)		-- end of a list, or cons cell
X	.		-- separates the car and cdr halves of a cell.
X	'		-- quote character
X	`		-- backquote character
X	,		-- comma function
X	,@		-- comma-at function
X	#'		-- function character
X	#!		-- first user reader macro.
X	#?		-- second user reader macro.
X	"		-- start and end of strings
X	\		-- escape char for within strings (not Common Lisp)
X	;		-- starts a comment
X	\		-- escape for the next character in symbols.
X	-0123456789 	-- start an integer
X
XWhitespace characters are recognised as the separator between lexical
Xtokens. 
X
XA more formal description of the s-expression syntax might be:
X
X	An <s-exp> can be an <atom> or a <list>
X
X	<atom>s can be:
X
X		nil	; nil is an atom
X	
X		positive or negative integers eg:
X
X                              545, -23
X
X		floating point numbers eg:
X
X                              13.4, -33.7, 12.4E8, 23.4e-2
X
X		unlimited length character strings delimited by "s
X		with special characters in strings:
X				"\n" = newline
X				"\e" = escape
X				"\t" = tab
X				"\r" = carriage return
X				"\f" = form feed
X				"\\" = \
X				"\"" = "
X				"\c" = c where c is any other charater.
X	symbols
X		- symbol names may include any character preceded
X		  by the \ character.
X			eg. A\(strange\.symbol
X
X		- alphabetic characters are all converted to
X		  lower case in the interpreter. Thus FOOBAR
X		  and foobar are the same.
X
X	- constants
X		
X		- special symbols whose value cannot be changed
X		  with set, and which are never garbage collected.
X		
X	<list>s can be either:
X		nil	; the null list
X		() 	; the null list which equals nil
X		( <s-exp> . <s-exp> ) ; a cons cell
X		( <s-exp> <s-exp> etc.... ) ; which is the same as
X		( <s-exp> . ( <s-exp> . (  <s-exp> etc.. . nil ))))
X
X	An s-expression preceded by the ' single quote character
X	is expanded by (read) to be quoted:
X
X		'<s-exp>  ==>	(quote <s-exp>)
X
X	Other characters have this effect also:
X
X		`<s-exp> ==>	(backquote <s-exp>)
X		,<s-exp> ==>	(comma <s-exp>)
X		,@<s-exp> ==>	(comma-at <s-exp>)
X		#'<s-exp> ==>	(function <s-exp>)
X
X	[The notation "==>" means "evaluates to".]
X
X	These functions are defined in the initialisation file and are
X	intended to provide compatibility with Common Lisp. 
X
X		#!<s-exp> ==>	(quser1 <s-exp>)
X		#?<s-exp> ==>	(quser2 <s-exp>)
X
X	These quote characters intended to be user-definable.
X	
X3  THE TOP LEVEL
X	
X3.1 Installing RefLisp on MS-DOS
X
XAssuming you have a full release disk, make a directory and copy the
Xfiles on the release disk to it. (For example directory C:\BILL\LISP
XAdd an entry in your PATH environment variable pointing to the
Xdirectory. Set up the environment variable LISPINIT to point to the
Xinitialisation file. Include these lines in your AUTOEXEC.BAT file if
Xyou intend to use the program frequently. For example use:
X
X	PATH C:\BILL\LISP;%PATH%
X	SET LISPINIT=C:\BILL\LISP\INIT.LSP
X
XTo run the demonstrations, change into the RefLisp directory and type
Xthe following into the DOS prompt:
X
X	REFLISP DEMOS.LSP 
X
X3.2 Starting RefLisp
X
XOn your operating system, there will be a command or mouse-clicking
Xoperation which will get the program started. For MS-DOS the command
Xis:
X
X	C:\>REFLISP [arg ...] 	
X
Xand on UNIX:
X
X	reflisp [arg ...]
X
XIf the program does not start on ATARI machines it probably means
Xthere is not enough memory.
X
XOnce started, the program accumulates the command line parameters in a
Xlist in symbol ARGV. The program then reads and executes the
Xinitialisation file file. This filename is taken from the environment
Xvariable "LISPINIT". If the environment variable is missing RefLisp
Xattempts to read "init.lsp" in the current directory. You should set up
Xyour environment variables to point to your initialisation file. On MS-DOS:
X
X	C:> SET LISPINIT=C:\BILL\LISP\INIT.LSP 
X
XThe shipped initialisation file then processes the command line 
Xparameters. Each is taken to be the name of a file to be read and
Xexecuted. It processes each file in turn, skipping files it cannot
Xopen. You may prefer to use the command line arguments in a different
Xway, if so you must alter your LISPINIT file.
X		
X3.3 RefLisp Execution
X
XThis section describes what happens after you invoke Lisp. After the
Xinitialisation messages you will be presented with a > prompt:
X
X	C:\> REFLISP
X	; reading C:\bill\lisp\init.lsp
X	; ... some messages ...
X	1082>
X
XThe prompt is the number of cons cells in use by your program followed  by >.
XThis number will increase and decrease as you work, as cells are used
Xand replaced in the free pool. If it reaches the maximum available on
Xthe machine you may be able to continue by reclaiming some memory 
Xmanually. (see Memory Management below.)
X
XExpressions are read in at the prompt, evaluated and the result being
Xdisplayed on the terminal. The prompt is re-displayed after an
Xevaluation.
X
XTo halt execution type (exit). Also the interpreter returns control to
Xthe operating system when it sees end-of-file (or the *eof* symbol).
XThe character used to signify this varies from one system to  another,
Xon MS-DOS and the ATARI-ST it is Control-Z.
X
XThe operation of the interpreter is a read-eval-print loop. Its
Xoperation is the same as (eval <s-exp>) and is as follows:
X
XAtoms which are not symbols such as: integer, float, string, subrs,
Xfsubr, stream. evaluate to themselves. eg 
X
X	> 12
X	12 
X
XSymbols are tested to see if they have  a value, in which case that is
Xreturned. e.g. 
X	
X	> year
X	93
X	
XIf a symbol has no bound value then an error is reported and processing
Xstops.
X	
XSome symbols are regarded as constants, and should not be changed. They
Xusually evaluate to themselves, or a string  constant.
X
XImportant constants are:	nil, t, pname, unbound, *eof*
X		
XIf the expression is a list, the first element of the list is evaluated
Xuntil an atom or list is derived. If an atom is derived and it is a
XSUBR, the rest of the elements of the list are evaluated, [these are
Xthe actual arguments]. Then they are passed to the machine code pointed
Xto  by the SUBR CELL. e.g.
X 
X	(cons 2 3) ==> (<subr:2783823> 2 3) ==> (2 . 3)
X		
XIf a FSUBR is derived, the actual arguments are
Xnot evaluated before application of the subroutine. e.g.
X
X	(quote foobar) ==> (<fsubr:989977> foobar) ==> foobar
X
XIn the case where the first element evalutes to a list, and the first
Xelement of THAT list is "lambda", "macro" or  "lambdaq", this is taken
Xto be a function call. The processing used is identical to that of
X(apply).
X
XIf "lambda" is found, the actual arguments are evaluated. The
Xfunction's parameter symbols are then (set) to these values, each one
Xin turn. The previous values of the function parameter symbols are
Xsaved. e.g.
X
X	> ((lambda first (x) (car x)) (list 1 2 3 4))
X	1
X
XIf "lambdaq" is found, the actual arguments are not evaluated.
X
X	> ((lambdaq first (x) (car x)) (list 1 2 3 4))
X	list
X
XIf "macro" is found, the actual arguments are not evaluated, as for
Xlambdaq, however the result of the apply is evaluated again. e.g.
X	
X	> ((macro first (x) `(car ,x)) '(1 2 3 4))
X	1
X 
XIf there are too many or two few arguments passed to the function, so
Xthey do not match the function parameters, then an error is reported. 
X
XIf a formal parameter is the special symbol &rest, then all remaining
Xactual parameters are set to the formal parameter following the &rest.
XFor example:
X
X	> ((lambda (a &rest b) (list a b)) 1 2 3 4 5 6)
X	(1 (2 3 4 5 6))
X
XIf a formal parameter is the symbol &optional, then any missing actual
Xarguments are set to NIL. For example:
X
X	> ((lambda (a &optional b) (list a b)) 99)
X	(99 nil)
X
XIf an optional parameter is expressed as a list of the form (<symbol>
X<initform>) then the <initform> is evaluated and used when no actual
Xparameter is supplied.
X
X	> ((lambda (a &optional (b 27)) (list a b)) 99)
X	(99 27)
X
XThe symbols &rest and &optional may be used in combination. For example:
X
X	> ((lambda (a &optional b &rest c) (list a b c)) 99)
X	(99 nil nil)
X
XIn all cases the body of the function is then evaluated with the new
Xbindings. The value of this evaluation is then returned. After
Xexecution of the function, the previous  values of the symbols used as
Xparameters are restored. 
X
X3.4 Scope and Extent
X
XReflisp is a "shallow" binding interpreter and as such it has no
Xenvironments. The function arguments therefore have dynamic extent and
Xglobal scope. This means that the formal parameters of a lambda-list
Xare the same symbols available at the top level, and are effectively
Xglobals. It also means that when a function is applied, the formal
Xarguments are shadowed, and are removed when the function finishes.
X
XIn it's basic form then, the interpreter suffers from the "funarg"
Xproblem. The #' reader macro is provided to allow (function) to be
Xdefined in Lisp. 
X
XLexical scope may be added to programs by re-defining DEFUN with a
Xversion that re-writes the formal arguments of defined functions. This
Xfacility is available in the file "lexical.lsp". Functions loaded
Xafter "lexical.lsp" will have lexical scope and dynamic extent. 
X
XAdding both lexical scope and indefinite extent can be achieved  by
Xdeferring the re-writing of functions until evaluation time. This
Xfacility is implemented in the file "extent.lsp" which provides an
Xanother alernative version of DEFUN. Programs will run significantly
Xslower if they use indefinite extent.  Some Common Lisp functions
Xrequire indefinite extent scope to run correctly, usually those that
Ximplement objects with local state.
X
XThe file "scheme.lsp" provides "define" conforming to Scheme syntax
Xwhich also has indefinite extent. 
X
X4  LIST PROCESSING FUNCTIONS
X
XThe following sections describe the inbuilt functions provided in the	
Xinterpreter.
X
X(car <expr>) 
X 	Returns the first element of the list <expr>, or more 
X	strictly, the A side of the cons cell.
X		
X	example: (car '(1 2 3 4)) ==> 1
X		 (car '()) ==> nil
X		
X(cdr <expr>) 
X	Returns everything except the first element of <expr>
X	
X	example: (cdr '(1 2 3 4)) ==> (2 3 4)
X		 (cdr '()) ==> nil
X		
X(cadr <expr>) 
X	Returns the second element of <expr>
X	
X	example: (cadr '(1 2 3 4)) ==> 2
X		
X(caddr <expr>) 
X	Returns the third element of <expr>
X	
X	example: (caddr '(1 2 3 4)) ==> 3
X		
X(nth <integer> <expr>) 
X	Returns the nth element of <expr>, numbering from zero. 
X	It returns NIL if <integer> is greater than the length of the list.
X	
X	example: (nth 3 '(0 1 2 3 4)) ==> 3
X		
X(cons <expr1> <expr2>) 
X  	Returns a new cons cell with <expr1> and <expr2> 
X	as its car and cdr.
X		
X	examples: (cons 1 2)   ==> (1 . 2)
X		  (cons 1 nil) ==> (1) ==> (1 . nil)
X		  (cons 1 '(8 9)) ==> (1 8 9)
X			  
X(length <expr>) 
X	  	Returns the number of elements in the list, or the number of
X		characters in a string or symbol name.
X	  	
X	  	examples: (length nil) ==> 0
X	  		  (length '(1 2 3 4)) ==> 4
X			  (length "foobar") ==> 6
X			  (length (symbol-name 'fred)) ==> 4
X	  		  	
X(member <expr> <list>)
X  	Returns a sublist if <expr> is a member of the list, nil
X  	otherwise. (equal) is used to compare the elements.
X	  	
X  	Definition:
X	  	
X  	(de member (expr list)
X  		(cond
X  			((null list) nil)
X	  			((equal expr (car list)) list)
X			(t (member expr (cdr list)))))
X	  			
X	Examples: (member '23 '(a s d f)) ==> nil
X		  (member '23 '(a b c 23 d)) ==> (23 d)
X
X(append <a> &rest <b>)
X	Appends one or more lists together, examples:
X	(append '(1 3) '(3 4) ==> (1 2 3 4)
X	(append '(1 2) '(3 4) '(5 6) ==> (1 2 3 4 5 6)
X
X(reverse <x>)
X	Reverses the top level of a list. example:
X	(reverse '(1 2 3 4)) ==> (4 3 2 1)
X
X(move <to-cell> <from-cell>)		
X
X	This function destructively modifies the to-cell by copying the
X	contents of from-cell into it. It attempts to discard the cells
X	pointed to by to-cell before the operation if it was a cons
X	cell. It checks to see if a circular structure would result
X	from the operation. It is an error to create circular
X	structures, because the reference counting garbage collector
X	cannot handle them.
X
X	
X	Examples:
X	
X	> (de rplaca (to from)		; define RPLACA
X		(move to (cons from (cdr to)))
X	> (setq A '(1 . 2))		; initialise a cell
X	> (setq B A)
X	> (rplaca A 99)			; overwrite it
X	> B
X	(99 . 2)
X
X5 SYMBOL FUNCTIONS
X
XThe value of an symbol is *unbound* if none of these functions below have
Xgiven it a value. If you (set) or (setq) a symbol to *unbound*, the
Xcells used in the previous value are reclaimed if possible.
X	
X(set <symbol> <value>)
X	Assigns the free <symbol> the <value> specified.
X	Returns the value. <symbol> must be an identifier. 
X			
X	Examples:
X		(set 'x 21) ==> 21
X		x ==> 21
X			
X(symbol-value <symbol>)
X	Returns the current value of the symbol. An error occurs if
X	the symbol has no value.
X
X	Example:
X		(set 'foobar 21)
X		(symbol-value 'foobar) ==> 21
X
X(setq <symbol> <value>)
X	Performs the same as (set) however <symbol>
X	is not evaluated. This the usual assignment function
X	in Lisp.
X			
X	Example:
X		(setq x 89) ==> 89
X		x ==> 89
X
X(defconstant <symbol> <value)
X	The same as setq, however the type of the <symbol> is changed
X	into a constant. After which time the symbol us unchangeable.
X				
X(intern <string>)
X  	Creates a new symbol, with a printname of <string>. The
X	symbol is added to the symbol table, and can be found by
X	(read). If the symbol was already present it is returned. This
X	function is equivalent to (addsym).
X	 
X	Example: 
X		 > (set (intern "foobar") 23)
X		 23
X		 foobar
X		 23		 
X	
X(gensym)
X  	Creates a unique new symbol, with a printname of G<n>, where
X  	<n> is a unique number. The symbol is NOT added to the
X	symbol table, it is inaccessible to (read). eg:
X
X	>(gensym)
X	G123
X
X(outsym <s-exp> &optional <proforma>) This creates and interns
X	a symbol with a print name of <s-exp> even if a symbol with
X	that name is already present. The optional <proforma> is used
X	to derive the number of the hash bucket where the symbol is
X	stored. If <proforma> is absent, <s-exp> is used which is the
X	default. The symbol is returned. Note: RefLisp is different
X	from Common Lisp which only allows symbols to have string print
X	names. 
X
X(addsym <s-exp> &optional <proforma>) 
X	
X	This looks for a symbol with a name equal to <s-exp>, using
X	(rdpsym). If none is found it adds it. The optional  <proforma>
X	is  used to derive the number of the hash bucket where the
X	symbol  is looked for and stored. If <proforma> is absent,
X	<s-exp> is  used which is the default. (read) uses (addsym)
X	with no proforma. The symbol is	returned. If this operation 
X	duplicates an existing symbol, (read) will use the newest one.
X 
X(rdpsym <s-exp> &optional <proforma>)
X
X	This looks for a symbol with a name equal to <s-exp>, if none
X	is found it returns nil. The optional <proforma> is  used to
X	derive the number of the hash bucket which is searched. If
X	<proforma> is absent, <s-exp> is  used by default. In addition,
X	if the proforma contains the wildcard * symbol, then (rdpsym)
X	matches on the symbol name. The symbol found is returned,
X	otherwise nil. 
X
X	Definition of the matching used: 
X		(de match (mask y)
X			(cond
X				((equal mask '*) t)
X				((equal mask y) t) 
X				(t  (cond
X					((and (consp mask) (consp y))
X					 (and (match (car mask) (car y)) 
X					 (match (cdr mask) (cdr y))))
X				(t nil)))))
X	Example:
X	> (or
X	> (setq person '(name * age *))			; create a proforma
X	  (outsym '(name (john doe) age 23) person) 	; and an instance
X	  (rdpsym * person))				; look for any person
X	(name (john doe) age 23) 			; found John Doe!
X
X	This function can be used in conjunction with one of the
X	user defined quote charaters to achieve a usable syntax:
X
X		> (de quser2 (name) (eval (rdpsym name)))
X		quser2
X		(setq w 2)
X		2
X		#?w	; (rdpsym "w") ==> 'w
X		2
X
X		;; make a new symbol
X		(set (addsym '(matrix 12 34)) 123.3) 
X		123.3
X		#?(matrix 12 34)	; access it
X		123.3
X
X		;; or if (quser1) is defined like (backquote):
X		#!(matrix ,x-cood ,y-coord ) ; x-coord is a symbol
X
X(inpsym <s-exp> &optional <proforma>)
X	This looks for a symbol using (rdpsym), if one is found,
X	it is removed from the symbol table, and an attempt is made
X	to garbage collect it. If a symbol is found, its print
X	name is returned.
X		
X(defun <function> <arglist> <expr>  .... )
X		
X	This macro is equivalent to:
X	(setq <function> '(lambda <arglist> <expr> .....))
X	and is used to declare new functions. Functions 
X	declared with (defun) will have all their arguments 
X	evaluated prior to being executed. (defun) is a macro.
X			
X	<arglist> can be either an atomic symbol or a 
X	list of symbols. In the first case all arguments
X	are passed as a list in the single parameter, 
X	otherwise the actual arguments are placed in the
X	corresponding symbol values using (set). The &optional and
X	&rest flags can also be used.
X			
X	The <function> symbol is returned.
X		
X	Examples:
X		(defun foo (&rest args) (length args)) ==> foo
X		(foo 1 2 3 4) ==> 4
X			
X		(defun bar (arg1 arg2) (cons arg1 arg2))==>bar
X		(bar 'a 'b) ==> (a . b)
X
X			
X(df <function> <arglist> <expr>  .... )
X		
X	This macro is equivalent to:
X	(setq <function> '(lambdaq <arglist> <expr> .....))
X	and is used to declare new functions. Functions 
X	declared with (df) do not have their arguments 
X	evaluated prior to being executed.(df) is a macro.
X			
X	<arglist> can be either an atomic symbol or a 
X	list of symbols. In the first case all arguments
X	are put into <arglist> with (set), otherwise the actual 
X	arguments are placed in the corresponding symbol values 
X	using (set). 
X			
X	The <function> symbol is returned.
X		
X	Examples:
X		(df foo (&rest args)  args) ==> foo
X		(foo a b c d) ==> (a b c d)
X		
X		(df if (c true false) 
X			(cond ((eval c) true) (t false))) ==> if
X
X		(if (zerop 9) (cons 1 2) (cons 3 4)) ==> (cons 3 4)
X			
X(defmacro <function> <arglist> <expr>  .... )
X		
X	This macro is equivalent to:
X	(setq <function> '(macro <arglist> <expr> .....))
X	and is used to declare macros. Functions 
X	declared with (defmacro) do not have their arguments 
X	evaluated prior to being executed. A macro
X	is evaluated like a (df) function, with the result
X	receiving an additional evaluation. 
X			
X	The <function> symbol is returned.
X		
X	Examples:
X		(defmacro if (c true false) 
X			(cond ((eval c) true) (t false))) ==> if
X
X		(if (zerop 9) (cons 1 2) (cons 3 4)) ==> (3 . 4)
X
X		(defmacro amacro (&rest args) args)
X		(amacro cons 1 2 ) ==> (1 . 2)
X
X			
X(oblist)
X	Returns a list of all the symbols in the symbol table, in hashed
X	order, whether bound or not. 	
X
X6  CONTROL FUNCTIONS
X	
X(cond (<predicate> <expr> .....)
X  	(<predicate> <expr> .....) 
X  	....)
X	  	
X	This is the main conditional control structure in Lisp.
X  	The predicates are evaluated in turn until one is 
X	found that returns a non-nil value. Then each of the 
X	expressions <expr> following are evaluated in turn.
X	The value returned from the (cond) is the value of
X	the final expression. If no <predicate> evaluates
X	to non-nil then the value of the (cond) is nil.
X	Likewise a null <expr> list renders nil.	  	
X	  	
X(do-while <condition> <expr> .....)
X  	The <condition> is evaluated, if it is not nil,
X  	the <expr> list is evaluated, each in turn. This process
X  	is repeated until the <condition> becomes nil.
X  	The last <expr> evaluated is returned, or nil.
X  	
X(do-until (<condition> <result> ... <lastresult>) <expr> .....)
X  	The <condition> is evaluated, if it is nil,
X  	the <expr> list is evaluated, each in turn. This process
X  	is repeated until the <condition> becomes non-nil.
X	Then the <result> forms are evaluated, the value of the <lastresult> 
X	is returned. If no <results> are present NIL is returned.
X
X	Example:
X	(defun test1 (n)
X		(do-until ((equal n 0) "finished")
X			(print n)
X			(setq n (- n 1))))
X  	
X(progn <expr> <expr> .......)
X  	This function evaluates each of the expressions in its
X  	arguments. The value of the last argument is returned.
X	  	
X(error <expr>)						[function]
X  	The expression is printed, and the interpreter jumps
X  	to the top level. This function can be used to jump out of
X  	a user program if a severe error is detected. Note that
X  	cells will be permanently lost from the free pool in the 
X	process.
X
X(catch <tag-symbol> <expr> ..... <expr-n>)
X	First half of no-local goto. The <tag-symbol> is (set) to the current
X	stack frame. The expressions following are executed and
X	the value of the last expression is returned. 
X
X	(catch) is equivalent to:
X	
X	(set <tag-symbol> current stack frame)
X	(progn <expr> ..... <expr-n)
X
X	The special tag 'error-tag is used by the interpreter. If it
X	finds an error it calls (throw 'error-tag <>). You can therfore
X	catch errors by enclosing functions in (catch 'error-tag ...). 
X
X(throw <tag-symbol> <return-expr>)
X	Second half of a non-local goto. The <tag-symbol> is evaluated,
X	and must result in a stack-frame object set up by a previous,
X	current (throw). The <return-exp> is evaluated, and execution then
X	jumps to the last (throw) with the <tag-symbol>. The (throw)
X	returns with <return-exp>. (throw 'error-tag <>) is a way of
X	signalling a user error.
X
X	Implementation note: catch and throw are implemented with the C
X	setjmp() and longjmp() functions. Therefore, references
X	to cells on the stack cannot be garbage-collected, and (throw)
X	will "leak" memory. Use (catch) and (throw) to catch user errors
X	or for circumstances that are infrequent.
X
X	Example:
X
X	; function to calculate Square-root safely.
X	(defun my-sqrt (x) 
X		(cond ((< x 0) (throw 'math-error "whoops!"))
X			  (t (exp (/ (log x) 2)))))
X
X	(catch 'math-error 
X		(print 1)
X		(my-sqrt -22)
X		(print 2))
X
X	; When executed this prints:
X	1 "whoops!"
X		
X7  EVALUATION FUNCTIONS
X	
X(eval <expr>)
X	The <expr> is evaluated, given that <expr> may have
X	been evaluated before (eval) was called, this would
X	make the second evaluation of <expr>. Since shallow binding
X	is used in the interpreter, the current bindings are used.
X	
X	Examples:
X		(eval '(cons 1 2)) ==> (1 . 2)
X		(eval ''x) ==> x
X		(setq ex '(* 2 3))
X		(eval ex) ==> 6
X			
X(apply <func> <actuals>)
X   	The <func> is applied to the argument list <actuals>. 
X   	<func> must be a SUBR or FSUBRP or a lambda expression, and
X   	<actuals> must be a list of arguments as required by 
X   	the <func> being invoked.
X	   	
X   	Examples:
X	   	
X   		(apply 'cons '(1 2)) ==> (1 . 2)
X   		(apply '(lambda x (cons x x) '(3)) ==> ((3) 3)
X	   		
X(quote <expr>)
X   	The <expr> is returned un-evaluated. (quote) could be written
X   	as: (df quote (x) x)
X   	The parser in (read) turns '<expr> into (quote <expr>) when 
X	it reads expressions.
X	   	
X   	Examples:
X   		(quote w) ==> w
X   		'w	==> w
X
X(backquote <expr>)
X	The back-quote function
X	provides an easy way to write macros. The (comma) and (comma-at)
X	markers are also supported. The description of the backquote
X	mechanism is rather complex, suffice it to say that it behaves
X	like (quote) with the addition that any expressions enclosed by 
X	the (comma) are evaluated, and those enclosed by (comma-at)
X	are evaluated and spliced into the result. Note that (read)
X	expands ` , and ,@ to (backquote) (comma) and (comma-at). 
X
X	Examples:
X
X	`(foo ,(* 2 3)) 	; evaluates to (foo 6)
X	`(bar ,@(list 3 4))	; ==> (bar 3 4)
X
X	;; example of backquote used to define a macro:
X	;;
X	(defmacro if (condition true-exp false-exp)
X		`(cond (,condition ,true-exp)
X			(t ,false-exp)))
X	(if (equal 1 2) 'equal 'not-equal)  ; ==> 'not-equal   
X
X	;; And used to define a macro with variable arguments.
X	(defmacro toto (&rest x)
X		`(cons ,@x))
X	(toto 1 2) ; ==> (1 . 2)
X 		
X	   		
X8  PREDICATE FUNCTIONS
X	
X(atom <expr>)
X	Returns nil if <expr> is a list, else t.
X 
X(consp <expr>)
X	Returns t if <expr> is a list, else nil.
X 
X(null <expr>)
X	Returns t if <expr> is nil, else it returns nil.
X
X(symbolp <expr>)
X	Returns t if <expr> is an symbol, else nil.
X			
X	Example:
X		(symbolp 'car) ==> t
X		(symbolp car) ==> nil ; because car evaluates to a SUBRP
X			
X(stringp <expr>)
X	Returns t if <expr> is a string, else nil.
X			
X        Example:
X		(stringp "car") ==> t
X				(stringp 'car) ==> nil
X			
X(eq <expr1> <expr2>)
X	Returns t if the two expressions point to the same
X	object in memory. 
X			
X	Examples:
X		(eq 'foo 'foo) ==> t
X		(eq "foo" "foo") ==> nil
X		(eq 1 1) ==> nil
X
X(equal <expr1> <expr2>)
X	Returns t if the two expressions are equivalent, 
X	irrespective of their location in memory. This is
X	safer than (eq).
X			
X	Examples:
X		(eq 'foo 'foo) ==> t
X		(eq "foo" "foo") ==> t
X		(eq 1 1) ==> t
X
X(boundp <expr>)
X	Returns nil if <expr> is an symbol with no 
X	assigned value. Useful for testing a symbol's 
X	value without provoking an error.
X			
X	Examples:
X		(boundp x) ==> nil
X		(setq x 1)
X		(boundp x) ==> t
X				
X(integerp <expr>)
X	Returns t if <expr> is an integer, else nil.
X			
X		Examples:
X		(fixp 32) ==> t
X		(fixp 32.8) ==> nil
X	
X(floatp <expr>)
X	Returns t if <expr> is a floating point number , else nil.
X			
X	Examples:
X		(floatp 32.3) ==> t
X		(floatp 2) ==> nil
X	
X(numberp <expr>)
X	Returns t if <expr> is a number (float or integer), else nil.
X			
X	Examples:
X		(numberp 32) ==> t
X		(numberp 3.2) ==> t
X		(numberp "32") ==> nil
X	
X9  MATHEMATICAL FUNCTIONS
X	
XMathematical functions may convert their arguments from integer types
Xto floats before evaluation.
X
X
X(+ <num1> <num2> ..... <numN>)
X		Returns the sum of a list of integer arguments. Non-
X		integer arguments provoke an error message.
X
X(- <num1> &optional <num2>)
X		Returns <num1> - <num2>. If <num2> is absent it returns 
X		-1 * <num1>.  Non-numeric arguments provoke an error message.
X			
X(* <num1> ..... )
X		Returns the product of a list of numeric arguments. May float
X		if necesary. Non-integer arguments provoke an error message.
X
X(/ <num1> &optional <num2>)
X		Returns <num1> divided by <num2>. If <num2> is absent it 
X		returns 1/<num1>.  Non-numeric arguments provoke an error 
X		message. A float will be returned if <num1> is not divisible
X		by <num2>.
X
X(rem <num1> <num2>)
X		Returns the remainder when <num1> is divided by 
X		<num2>. Non-integer arguments provoke an error 
X		message.
X
X(floor <number>)
X		Converts its argument by truncating towards negative infinity.
X		i.e. the result is is the largest integer that is not larger
X		than the <number>. A integer data type is always returned.
X		
X(abs <num>)
X		Returns the absolute value of <num>.
X			
X(random <range>) 
X		Returns a pseudo-random number between 0 and <range>.
X			
X(seed <num>)
X		Sets the starting point of the random number 
X		generator sequence. The (rand) called directly after
X		(seed) will always generate the same sequence for
X		the same seed. (Not Common Lisp).
X
X(hash <sexp>)
X        Computes an hash index on the <sexp> input, 
X	returning an integer. This is used by (addsym) etc
X	to calculate the hash bucket to use for symbols.
X	[The function may change from one version to the next.]
X				     
X(float <integer>)
X	Returns float equivalent of its argument.
X
X(log <num>)
X	Returns natural logarithm of argument.
X
X(log10 <num>)
X	Returns log to base 10 of argument.
X
X(exp <num>)
X	Returns e raised to the power of argument.
X
X(sin <num>)
X	Returns trigonometric sine of <num> which 
X	is in radians..
X
X(cos <num>)
X	Returns trigonometric cosine of <num> which 
X	is in radians..
X
X(arc-sin <num>)
X	Returns trigonometric inverse sine of <num> which 
X	is between 0 and 1, returns radians.
X
X(arc-cos <num>)
X	Returns trigonometric inverse cosine of <num> which 
X	is between 0 and 1, returns radians.
X
X10  RELATIONAL FUNCTIONS
X	
X(and <expr1> <expr2> .... <exprN>)		[Macro]
X	Evaluates each expression in turn until one is found
X	that has a value of nil, in which case nil is
X	returned. The remaining expressions are not evaluated.
X	If none are nil then t is returned.
X			
X(or <expr1> <expr2> .... <exprN>)
X	Evaluates each expression in turn until one is found
X	that has a value of t, in which case t is
X	returned. The remainder are not evaluated.
X        If none are t then nil is returned.
X
X(> <num1> <num2>)
X	Returns t if <num1> is greater than <num2>, else nil
X	is returned. Numeric arguments only.
X			
X(< <num1> <num2>)
X	Returns t if <num1> is less than <num2>, else nil is
X	returned. Numeric arguments only.
X
X(string< <left> <right>)
X	Returns t if <left> is lexically less than <right>,
X	else nil is returned. A mixture of symbol and string
X	parameters is accepted.
X			
X	Example:
X		(string< 'a 'b) ==> t
X		(string< "b" 'a) == nil
X			
X		
X11 PROPERTY LISTS
X	
XEach symbol, with or without a value has a property list. The
Xproperties are stored as an "alist". ie  ((<prop1> . <value1>) (<prop2>
X. <valu2>) .........) All symbols have a property which is the text
Xused when the symbol is printed, PNAME.
X	
X(put <symbol> <property> <value>)
X	Sets the symbol's property to the value given.
X	Returns the <value>.
X			
X	Examples:
X		(put 'mary 'age 21) ==> 21
X		(put 'foobar 'what "first")
X
X(get <symbol> <property> <value>)
X	Returns the value of the property attached to the
X	symbol. If this property is not attached nil is
X	returned.
X			
X	Examples:
X		(get 'john 'age) ==> 21
X
X(remprop U IND)
X	Removes the property with indicator IND from the 
X	property list of U.  Returns the removed property 
X	or NIL if there was no such indicator.
X
X(symbol-name <symbol>)
X	Returns a expression (string) containing the name of the symbol. 
X	
X	Example:
X		(symbol-name 'fred) ==> "fred"
X	
X(symbol-plist <symbol>)
X	Returns the entire property list of the symbol.
X			
X	Example:
X	> (symbol-plist 'john) 
X	(PNAME  john age  21)
X        > (symbol-plist (addsym '(plan 9))
X        (PNAME (plan 9))
X
X(slot <object> <slot>)
X	This facilitates Object-Oriented programming. All 
X	RefLisp objects are deemed to belong to a class. To find
X	the class of an object you call (slot) thusly:
X
X	(slot <object> 'class)
X
X	When <object> is not an symbol, or if the symbol has no 'class
X	property, the function returns a symbol corresponding to the
X	Lisp basic type, from this list:
X
X		cons, fixnum, subr, fsubr, string, stream, 
X		symbol, float
X
X	Example:
X		(slot 34.7 'class) ==> float
X		(slot '(1 2) 'class) ==> cons
X			
X	If the object is an symbol the class is assumed 
X	to be the value of its 'class property. If it has
X	no 'class property then (slot) returns SYMBOL.
X
X	If <slot> is not equal to 'class then (slot) looks
X	in the object's property list for it. If it
X	cannot find it, then it fetches the class of the 
X	object, and looks in the class object's property list, and so on.
X			
X	Example:
X		(put 'mammal 'skin 'fur)  	; mammals are furry
X		(put 'cat 'class 'mammal) 	; cats are mammals
X		(put 'dog 'class 'mammal) 	; so are dogs
X		(put 'felix 'class 'cat)  	; felix is a cat
X		; What is felix's skin like?
X		(slot 'felix 'skin) ==> fur
X
X	Example:
X		; Use green for all integers
X		(put 'INTEGER 'color 'green)
X		(slot 35 'color) ==> green
X		(slot 346 'color) ==> green
X				
X	Definition - handling of symbols:
X
X		IF <slot> is a property of the symbol <object> 
X		THEN
X			return the value; 
X			   ie return: (get <object> <slot>)
X		ELSE IF 'class is a property of <object> THEN
X			recursively call slot;
X				ie return: (slot (get <class> 'class) <slot>)
X		ELSE IF <slot> is 'class 
X			return the value 
X
X(type-of <obj>)
X	Returns a symbol indicating the type of the object. See (slot).
X	Definition:
X 
X		(defun type-of (o) (slot o 'class))
X			
X		
X12  INPUT/OUTPUT FUNCTIONS
X	
X12.1 File I/O
X	
X(open <filename> &key :direction <direction>)
X	Opens the file specified, using the mode specified. 
X	<filename> can be an symbol or string.
X	<direction> is has the following meanings:
X			
X	:input  open for reading
X	:output  truncate or create for writing
X	
X	If no mode is specified, :input is assumed.			
X
X	(open) returns a stream, otherwise NIL.
X			
X	Examples:
X	(open "C:\\BILL\\LISP\\TEST.LSP" :direction :input) ==> <file:9823891>
X	(setq fd (open 'data :direction :output)) ==> <file:2829849>
X	(open "test.lsp") 
X				
X(close <fd>)
X	Closes a file opened by (open). <fd> must be a stream.
X			
X	Example:
X		(setq fd (open 'data 'input) ==> <file:2829849>
X		(close fd)
X				
X(force-output <fd>)
X	Forces all buffered data to be output on the file 
X	specified.  <fd> must be a file descriptor returned
X	by (open). 
X			
X	Example:
X		(setq fd (open 'data 'output) ==> <file:2829849>
X		(flush fd)
X				
X(read &optional <fd>)
X	Read parse the next s-expression from the file
X	specified. <fd> must have been returned from (open).
X	If <fd> is absent, then the standard
X	input is read. *eof* is returned at the end of file.
X			
X	Example:
X		(read)(hello world) ==> (hello world)
X		(read (open 'file 'input)) ==> eof
X				
X(load <filename-string> &key :verbose :print)
X	This function opens, reads, parses and evaluates the  input
X	file specified, <infilename> can be a symbol, string or
X	bigstring. If :verbose is t (default), then a comment is
X	printed to standard output. If :print is true, then the results
X	of evaluations are printed to standard output. :print nil is
X	the default.
X
X
X	Examples:
X		(load "demos.lsp" :verbose t :print nil) ; The default
X		(load "/usr/mcarthy/eliza" :print t) ; print results. 
X
X(chdir <pathname>)
X	This function changes the current working directory to that 
X	specified in <pathname>. This affects (open) and (directory)
X	which rely on the current working directory, if a relative
X	pathname is used.
X
X	It returns the current directory before the change was made,
X	or else NIL.
X
X	MS-DOS Examples:
X
X	(chdir "C:\\BILL\\LISP") ==> t 	; Does not affect current drive.
X	(chdir "..")
X	
X(directory <pathname>)
X	This function returns a list consisting of the names of the
X	files which match the <pathname> supplied. 
X
X	MS-DOS Example:
X	
X	(directory "c:\\*.bat") ==> (FOO.BAT BAR.BAT) 
X	(directory ".") ==> (BILL) ; The current directory
X
X	; On MS-DOS, pathname is a string with an optional drive specifier, 
X	; path, and file name of the file to be found. The file name portion 
X	; can contain wildcard match characters (such as ? or *).
X
X(princ <expr>)
X	Prints the <expr> on the standard output. Strings
X	are not quoted, nor are special characters. Returns
X	<expr>.
X			
X	Example:
X		(princ "string") string 
X		(princ ''foo)  (quote foo)
X				
X(prin1 <expr> &optional <fd>)
X	Prints the <expr> on the standard output. Strings
X	are quoted, and some quote forms are reduced. Returns
X	<expr>. This function is designed to output in a form
X	suitable to be (read) again.
X			
X	Example:
X		(prin1 "string") "string"
X		(prin1 weird\\symbol) weird\\symbol 
X		(prin1 ''foo)  'foo
X		(prin1 ',@bar) ,@bar
X				
X(write <fd> <expr> .....)
X	Prints the expressions to the file specified,
X	using (princ). If the first argument is not an <fd>
X	returned from (open) an error is reported.
X			
X(read-char <fd>)
X	Reads the next character from the file specified.
X	The value is returned as an integer less than 256.
X	<fd> must have been returned from (open), if absent
X	the standard input is read. *eof* is returned at the
X	end of file.
X			
X(write-char <char> <fd> )
X	Outputs one character from the file specified.
X	<char> is an integer which will be output.<fd> must
X	 have been returned from (open), if absent the 
X	 standard output is used. 
X		
X(atoi <string>)
X	ASCII to integer transformation. Returns an integer
X	corresponding to the value of the numeric string.
X			
X	Example:
X		(atoi "143") ==> 143
X				
X(itoa <number>)
X	Integer to ASCII convertion. Returns a string
X	with the ASCII representation of the integer.
X			
X	Example:
X		(stringp (itoa 678)) ==> t
X	
X(ftoa <number> <width> <precision> <leading 0s>)
X	Float to ASCII convertion. Returns a string
X	with the ASCII representation of the float.
X			
X	<width> is the number of characters in the output string
X	<precision> if the number of decimal places.
X	if <leading 0s> is eq to t then the number
X	is padded out with leading zeros.
X
X	Examples:
X		> (ftoa 50.0 3 0 t)
X                050
X		> (stringp (ftoa 678))
X		t
X	
X(system <program> <arg> <arg> ....)
X	This function allows you to call another program
X	from within Lisp. The result depends upon the base
X	operating system. In general it calls execv().
X			
X	Example: (MS-DOS)
X		(system "C:\BIN\EMACS.EXE" "FOOBAR.LSP") 
X
X	Example: (ATARI-TOS)
X		(system "C:\MEGAMAX\LS.TTP" "*.LSP") 
X
X	Example: (UNIX)
X		(system "emacs" "/usr/bill/lisp/man.txt") 
X		
X(getenv <string>)
X	This function returns the value of the environment variable 
X	named by <string>, or NIL if it is absent. 
X 
X12.2 Graphics Functions
X
XThe following functions relate to terminal graphics, available on
XMS-DOS and ATARI-ST. These are all provided in tgraph.c. A virtual
Xco-ordinate system is used. The bottom left-hand corner is 0,0 and the
Xvirtual screen coordinates are roughly 10 times the physical ones. The
Xvirual to physical mapping accounts for differences between machines so
Xthe RefLisp code is portable.
X
XPractically the only thing that can be relied on for ports between
Xmachines is line drawing and placing of text. XOR mode is usally
Xavailable also, but only for lines. Do not rely on (color) being
Xportable.
X 
X(GraphOpen &optional <driver> <mode> )
X	Initialises various parts of the underlying
X	graphics system. Clears the screen. Returns
X	the height and width of the screen in the form:
X			
X		(<width> . <height>)
X
X	The values returned are 6400 and 4800, but don't rely on it!
X
X	The optional arguments allow MS-DOS users to force a particular
X	graphics mode. If no arguments are given Autodetect is used.
X
X		    graphics_drivers  |
X				      |   Numeric value
X		------------------------------------------------------
X		    DETECT            |   0 (requests autodetection)
X		    CGA               |   1
X		    MCGA              |   2
X		    EGA               |   3
X		    EGA64             |   4
X		    EGAMONO           |   5
X		    VGA               |   9
X
X   Graphics|                |       | Column    |            |
X    driver | graphics_modes | Value |  x row    | Palette    | Pages
X  ------------------------------------------------------------------
X    CGA    | CGAC0          |  0    |  320 x 200|    C0      |  1
X           | CGAC1          |  1    |  320 x 200|    C1      |  1
X           | CGAC2          |  2    |  320 x 200|    C2      |  1
X           | CGAC3          |  3    |  320 x 200|    C3      |  1
X           | CGAHI          |  4    |  640 x 200|     2 color|  1
X   MCGA    | MCGAC0         |  0    |  320 x 200|    C0      |  1
X           | MCGAC1         |  1    |  320 x 200|    C1      |  1
X           | MCGAC2         |  2    |  320 x 200|    C2      |  1
X           | MCGAC3         |  3    |  320 x 200|    C3      |  1
X           | MCGAMED        |  4    |  640 x 200|     2 color|  1
X           | MCGAHI         |  5    |  640 x 480|     2 color|  1
X   EGA     | EGALO          |  0    |  640 x 200|    16 color|  4
X           | EGAHI          |  1    |  640 x 350|    16 color|  2
X   EGA64   | EGA64LO        |  0    |  640 x 200|    16 color|  1
X           | EGA64HI        |  1    |  640 x 350|     4 color|  1
X   EGA-MONO| EGAMONOHI      |  3    |  640 x 350|     2 color|  1*
X           | EGAMONOHI      |  3    |  640 x 350|     2 color|  2**
X   VGA     | VGALO          |  0    |  640 x 200|    16 color|  2
X           | VGAMED         |  1    |  640 x 350|    16 color|  2
X           | VGAHI          |  2    |  640 x 480|    16 color|  1
X
X *   64K on EGAMONO card
X** 256K on EGAMONO card
X
X
X(mode <number>)
X	Changes the way graphics is written to the display. 
X	The modes are:
X
X		1 - Paint Mode, All source pixels are transferred.
X		3 - XOR Mode, the source and destination are XORed
X
X		The actual mode used is returned.
X
X(color <number>)
X	Changes the current line drawing colour. This
X	is machine dependant. The actual colour number used is returned.
X
X(fillarea <points>)
X		
X	<points> - ((h . v) (h . v) ... )
X			
X	h - horizontal coordinate
X	v - vertical coordinate
X	
X	Paints a complex polygon defined by the list of points. A maximum of
X	?? points is accepted.
X
X(fillstyle <pattern> <color>)
X
X        fillstyle sets the current fill pattern and fill color.
X	This function is machine dependant. For MS-DOS the values are:
X
X	The integer <pattern>, gives names for the predefined fill patterns:
X
X	       Name         | Value |  Description
X	  ------------------|-------|----------------------------
X	    EMPTY_FILL      |   0   |  Fill with background color
X	    SOLID_FILL      |   1   |  Solid fill
X	    LINE_FILL       |   2   |  Fill with ---
X	    LTSLASH_FILL    |   3   |  Fill with ///
X	    SLASH_FILL      |   4   |  Fill with ///, thick lines
X	    BKSLASH_FILL    |   5   |  Fill with \\\, thick lines
X	    LTBKSLASH_FILL  |   6   |  Fill with \\\
X	    HATCH_FILL      |   7   |  Light hatch fill
X	    XHATCH_FILL     |   8   |  Heavy crosshatch fill
X	    INTERLEAVE_FILL |   9   |  Interleaving line fill
X	    WIDE_DOT_FILL   |   10  |  Widely spaced dot fill
X	    CLOSE_DOT_FILL  |   11  |  Closely spaced dot fill
X
X	  All but EMPTY_FILL fill with the current fill color. EMPTY_FILL
X		uses the current background color.
X
X
X(textxy h v <text>)
X	Writes text onto the screen.
X
X		h - horizontal coordination
X		v - vertical coordinate
X		text - either a string, bigstring or identifier to be 
X			displayed
X
X	Prints the text DOWN from the location specified 
X	on the screen with a border around the text.
X	It returns a pair containing  width and height of 
X	the button in pixels.
X
X	eg	(textxy 123 50 'nottub) ==> (56 . 16)
X
X(line x1 y1 x2 y2)
X	Draws a line between (x1,y1) and (x2,y2), x being
X	the horizontal axis.
X			 
X(clear)
X	Clears the graphics screen.
X			 
X(setview <camera parameters>)
X	Sets the location of a camera in 3D space, as well
X	as the camera characteristics.
X			 
X	The parameters are as follows:
X
X	<camera position> (x y z) in metres from the origin
X
X	<camera orientation> : (xaxis yaxis zaxis) 
X		angles of camera rotation in degrees
X
X	<camera focal length in millimeters>
X	<horizontal camera backplane pixel density>
X	<vertical camera backplane pixel density>
X		Number of pixels in the film of the camera,
X		horizontal then vertical.
X
X	<central axis of camera, horizontal coord>
X	<central axis of camera, horizontal coord>
X		Location of camera lens axis on backplane,
X		horizontal then vertical. Usually the centre
X		of the screen.
X	)
X
X	Example: A 50.0 mm lens on a 35mm camera, looking towards
X		the origin from 1.5 metres up and 8 metres back. 
X		These are the default initial values.
X
X		    (setview 
X   			(list 0.0 1.50 -8.0) 	; camera position
X   			(list -6.0 0.0 0.0) 	; camera angle 6d down
X   			50.0			; camera focal length
X   			(quotient 6400.0 35e-3)	; pixels/meter of screen x
X   			(quotient 6400.0 35e-3)	; pixels/meter of screen y
X  			3200 2000
X  		     )
X
X
X(view (x y z))
X
X	Converts a point in 3D space into a screen location
X	using the rules of perspective, and the camera
X	parameters set by (setview). The inputs are 
X	distances from the origin in metres. Return
X	the horizontal and vertical screen coordinates.
X	The value of z should be positive.
X
X	Example:
X		(view '(1.0 1.0 1.0)) ==> (4215 . 4250)
X			 
X(show <3dlines>)
X	
X	Draws the list of 3d lines in perspective according
X	to the current (setview) parameters. It uses (view)
X	and (line) to draw the lines. Lines which fall
X	behind the camera are not draw correctly.
X
X	<3dlines> is a list of pairs of 3D points:
X
X	(((xa1 ya1 za1) (xa2 ya2 za2))
X	 ((xb1 yb1 zb1) (xb2 yb2 zb2)) ... )
X
X(GraphClose)
X	Tidies up the underlying graphics device after
X	a (GraphOpen) and subsequent operations.
X
X(getevent &optional <timeout>)
X	Returns a list representing an input event from 
X	outside the computer. Events can come from a mouse,
X	the keyboard, the MIDI IN port or an RS232 port.
X	If <timeout> is non-zero, and there was no event to report,
X	(getevent) returns *timeout*.
X
X	The list returned has the following format:
X		
X	(<event type> <event data> ....)
X	
X	<event type> can have the following values:
X			
X				*timeout*	No event occurred
X				*down*		Mouse Button Down
X				*sdown*		Shift Key + Mouse Button Down 
X				*up*		Mouse Button Up
X				*move*		Mouse moved
X				*keys*		Key pressed on Keyboard
X				*midi*		Midi Message received
X				*RS232*		Char received on RS232 port.
X
X			The <event data> format depends on the type:
X
X			*down*, *sdown*, *up*, *move*:
X
X				mouse button status <integer> 
X				horizontal coordinate <integer>
X				vertical coordinate <integer>
X
X				eg (*move* 0 125 49)
X		
X			*keys*
X				ASCII representation of key pressed <integer>
X			
X			*midi*
X				list of integers as read from the port
X				
X				eg (*midi* 144 64 60) ; note on
X	
X			*RS232*
X				integer as read.
X
X
X(get-decoded-time)
X	This routine reads the computer's clock and returns
X	the time and date. The return value is a list of
X	integers in the following format:
X			
X		(second		; 0-59 
X	 	minute 		; 0-59
X		hour 		; 0-23
X		date 		; 1-31
X		month		; 1-12
X		year 		; two digits
X		day-of-week	; 0-6 where 0 = Monday
X		daylight-saving ;
X		)
X	
X	NB
X	  The ATARI-ST clock only ticks every 2 seconds!
X			
X	Example:
X		(get-decoded-time) ==> (11 20 21 1 7 92 3)
X
X(get-universal-time)
X	This routine gets the number of seconds since the epoch (Jan 1
X	00:00:00 GMT 1970). It returns a float because integers are too
X	small to contain the value. Therefore the value doesn't change
X	very often!
X				
X12.4 ATARI-ST Specific I/O
X	
X12.4.1  MIDI I/O
X	
X(NoteOn <channel> <note> <velocity>)
X		Sends the note-on sequence to the MIDI-out port.
X		Channels are numbered from 0, note and velocity 
X		have the usual MIDI meanings.
X			Example: 
X			(NoteOn 0 60 64)	; Middle C
X
X(NoteOff <channel> <note> <velocity>)
X		Sends the note-off sequence to the MIDI-out port.
X		Channels are numbered from 0, note and velocity 
X		have the usual MIDI meanings.
X
X			Example: 
X				(NoteOff 0 60 0)	; Middle C
X
X(ProgramChange <channel> <value>)
X		Sends the program change sequence to the MIDI-out 
X		port.
X
X(PlayNote <channel> <note> <velocity> <length>)
X		Plays a single note uusing (NoteOn), (Delay) and
X		(NoteOff). The processor suspends while the note 
X		is played.
X			
X(PlayTune <notelist>)
X		Plays a list of notes using (PlayNote). The 
X		structure of the list is as follows:
X
X		<notelist> :== ( <note> <note> ...... )
X		<note> :== ( <channel> <note> <velocity> <length> )
X			
X		Example:
X			(PlayTune '((0 60 63 3) (0 62 63 3) ))
X				
X(Delay <length>)
X		Executes a wait loop of <length>. The processor
X		does nothing else in this loop. The actual
X		wait depends on processor speed and the value set
X		by (Tempo).
X			
X(Tempo <period>)
X		Sets the multiplyer used by the wait loop in
X		(Delay), (PlayNote) and (PlayTune).
X			
X		Example:
X			(Tempo 1000)
X				
X(Major <note> <note_adj> <key> <key_adj>)
X		Converts note numbers from the usual major scale
X		system into MIDI note numbers. Where:
X	
X		note -	note in the scale eg. 0-C, 1-D, 2-E ...
X		adj -	+1 = sharp, 0 = natural, -1 = flat
X		key -	starting point of the scale eg. 0-C, 1-D, 2-E  
X		adj -	+1 = sharp, 0 = natural, -1 = flat
X 			
X		Returns the MIDI note number of the note given
X		in the scale given.
X 			
X		Example:
X			(Major 	14	; Middle C
X				0	; natural
X 				2	; Key is E
X 				+1	; Key is E sharp
X 				) ==>	; Midi note
X 			
X(emu <filename>)
X		Provides a simple but effective dumb terminal
X		capability, with capture to disk of the received
X		data. [If the host is echoing, this means you get
X		both transmitted and received data, except 
X		non-echoed passwords.]
X
X		<filename> can be a string or a symbol or missing 
X		altogether, in which case the session is not 
X		logged to disk.
X
X		(emu) monitors what you type and can execute commands 
X		preceded by a tilde. Commands are:
X
X		~.	Return to the Lisp interpreter.
X		~~	Transmit a tilde character.
X			
X		Examples:
X			(emu "script")
X			(emu 'logfile)
X
X(bios <arg1> [<arg2>] [<arg3>] [<arg4>])
X		This function calls the BIOS operating system 
X		functions in the ATARI-ST ROM. The arguments must 
X		all be integers, the return value is the integer
X		as returned by BIOS.
X			
X		Example:
X			(bios 3 2 42) ; send 1 char to the screen
X			
X(xbios <arg1> [<arg2>] [<arg3>] [<arg4>])
X		This function calls the extended BIOS operating 
X		system functions in the ATARI-ST ROM. The arguments
X		must all be integers, the return value is the 
X		integer as returned by BIOS.
X			
X		Example:
X			(xbios 17) ; gets a random number
X			
X(putstr <port> <data>)
X		Outputs a string of bytes to the port specified
X		using BIOS. The port number values understood are:
X			
X		Printer 		0
X		Modem   		1
X		Keyboard/Screen 	2
X		MIDI 			3
X		<data> can be a string or a symbol.
X			
X		Example:
X			(putstr 1 "qix")
X				
X(getstr <port> <timeout>)
X		Reads the port specified using BIOS. The reading
X		process strips white space before the string.
X		If nothing is read for <timeout> seconds, the
X		function returns nil. 
X		
X		(Settime <hour> <min> <sec> <day> <month> <year>)
X			Allows you to set the time of the computer's clock.
X			The arguments must all be integers.
X			
X			Example:
X				(Settime 12 20 32 25 09 89)
X					 ==> (12 20 32 25 09 89)
X		
X13 DEBUGGING FUNCTIONS
X	
X(room)
X	Prints out a message about this RefLisp including 
X	the version number and memory usage. Memory is 
X	allocated from a fixed-size pool, when that becomes
X	full, memory is acquired from the operating system
X	heap via malloc(). The behaviour of the operating
X	system determines what happens when the heap is
X	all used up. ATARI-TOS aborts the program!
X	The program uses a lot of stack (16,384 bytes on the
X	ST, 64K on MS-DOS).
X
X(eroom)
X	Returns total number of cells currently used.
X			
X(dump <arg>)
X	(dump 1) instructs the interpreter to print every
X	argument to the main evaluation functions. The
X	return values are not printed. (The return values
X	from most executions of "eval" and "apply" will
X	usually appear as arguments to subsequent calls
X	to these functions.)
X			
X	(dump 0) switches tracing off.
X			
X(trace <symbol-function>)
X	This is defined in INIT.LSP, and prints the call and return of 
X	lambda functions. See INIT.LSP for details.
X	Example:
X		> (trace our-function)
X
X(untrace <symbol-function>) 
X	Removes the effects of (trace). INIT.LSP for details.
X
X14 EXTENSIONS TO LISP
X
X(extensions <boolean>)
X	This function switches on Bill Birch's extensions to Lisp if <boolean>
X	is T, and switches them off if NIL. The extensions activated are:
X
X	(apply): Before apply attempts to apply its functional argument to
X	the actual argument list, it checks to see if there exists a symbol
X	whose PNAME is of the form (<func> <actuals). If there is, (apply)
X	evaluates the symbol instead of normal application. The symbol
X	value is returned. This extension permits memoisation of functions,
X	and allows a more functional programming style. for example:
X
X
X	(extensions t)			; activate extensions
X
X	; handy function to create symbols which look like 
X	; function applications
X	(defun assert (form result)		
X		(set (addsym form) result))
X
X	; Fibonnacci Series
X	(defun fib (n)
X		; Note total lack of COND statements !!
X		(+ (fib (- n 1)) (fib (- n 2))) )
X	
X	; Declare the terminating conditions of fibonacci series.
X	; These are found by APPLY in preference to an application.
X	(assert `(,fib 1) 1)	
X	(assert `(,fib 0) 1)
X	
X	;; Here is a memoised version of the fibonnacci series 
X	;; which is very much faster than (fib)
X	(defun fib-fast (n)
X		; The assert statement saves the result for
X		; future executions of APPLY
X		(assert (list fib-fast n) 
X			(+ (fib-fast (- n 1)) (fib-fast (- n 2))) ))
X
X	(assert `(,fib-fast 1) 1)
X	(assert `(,fib-fast 0) 1)
X
X
X15 HISTORY & DESIGN NOTES
X
XThis interpreter started out conforming to Standard Lisp [3] in the
Xmost part. This came about by accident, since the interpreter logic was
Xcopied from an older system than Standard Lisp see [1]. Later eval()
Xwas modified to be like Cambridge Lisp  for the Sinclair-QL and
XATARI-ST. These two are derived are from Standard Lisp, hence this
Ximplementation was mostly compatabile with Standard Lisp. RefLisp is
Xnow moving towards Common Lisp as defined in [CLtL2].  
X
XThere have been some fundamental design rules in force during the
Xdevelopment of this interpreter. The main point is that this version of
XLisp uses reference counting instead of mark and sweep garbage
Xcollection.
X
XHere is a list of the design goals:
X		
X1	The cell manipulation code must be a self-contained
X	module able to be used for thing other than a Lisp 
X	interpreter. (For example the first use of this code was
X	a simple assembler).
X		
X2	Only one data type is permitted, the CELL. All data is
X	stored in subfields of the CELL. This prevents list
X	manipulation code from being repeated for different data
X	types. (also, malloc is not always available) Eventually
X	this may come in handy for a multi-process version in
X	shared memory.
X	
X3	Only the cell manipulation module can access the
X	internals of CELLs directly. Other modules (such as the 
X	interpreter) must use function or macro calls.
X		
X4	The 'C' source code of the system must look as much like Lisp
X	as possible.
X		
X5	The 'C' source code must be portable.
X		
X6	The translation of Lisp code to 'C' must be as painless 
X	as possible, and eventually automated.
X		
X7	Garbage collection is to be done using reference-counting
X	rather than by mark & sweep. This allows 'C' variables to
X	point to CELLs, and promotes real-time list processing.
X		
X8 	The Interpreter is to be regarded as a first "bootstrap" 
X	version. Which means the source code is a bit of a mess!
X		
XThese rules have (mostly) been beneficial: the code has survived major
Xchanges to the internal CELL structure, without mishap ; the symbol
Xtable has been changed three times without a problem ;  addition of new
XSUBR functions has been trivially easy.  This version has been run on
Xthe following:
X
X	  MS-DOS, AIX 3.2 (RS/6000), 
X	
X
X15 MEMORY MANAGEMENT	
X
XOne of the best things about Lisp is that it manages memory allocation
Xfor you. Lisp folk refer to this as "garbage collection" because the
Xfirst Lisp used this term for freeing of unused memory. The main
Xmethods of garbage collection used in Lisp are based on mark-sweep or
Xstop-and-copy algorithms. These both can cause the interpreter to halt
Xexecution while the garbage is collected. On a small machine (like my
Xold 64Kbyte Sinclair QL) the interpreter spends most of its energy
Xcollecting garbage. This makes it impossible to write anything that
Xneeds to run with deterministic response times.
X 
XReference counting has some advantages over mark-sweep  garbage
Xcollection.  The interpreter does not stop for a long time while
Xgarbage collection is executed. This means that soft real-time programs
Xcan be written in Lisp.  For example, programs have been written to
Ximplement point-and-click mouse driven user interfaces, and which play
Xmusic. Both these would be un-usable if  a garbage sweep occurred
Xmid-processing. See CLOCK.LSP and GOB.LSP for real-time programs.
X
XIn addition, reference counting allows the internal memory cells to be
Xaccessed by anonymous 'C' pointers.  This allows for the compilation of
XLisp source into C programs which use C variables, execution stack and
Xfunction calling. The presence of a garbage collector would force such
Xcompiled programs to use Lisp cells as variables since garbage
Xcollector must know the address of every possible pointer in the
Xsystem. 
X
XReference counting is allegedly much slower than other schemes, the
Xinterpreter would appear to bear this out, however by re-compiling
Xwithout reference counting functions, almost no speed-up is obtained.
XMore work is still to be done bench-marking RefLisp against straight
X'C' and other Lisp interpreters.
X	
XIt is usually easy to manually translate from RefLisp to 'C' which uses
XRefLisp support code. The only additional work required is to add the
Xreferencing and de-referencing of stored lists. (The functions in GC.C
Xdo all the reference counting garbage collection.)  Sometimes debugging
Xmemory allocation can be difficult! 
X
XA disadvantage of this implementation is that (catch) and (throw) leak
Xmemory. This is because the cell-references on the execution stack are
Xlost; the cells they are pointing to cannot be freed.
X
X16 THE SOURCE CODE
X
X16.1 List of Files
X
XTo be added.
X
X16.2 Portability
X
XIn general the source code is moving from K&R to ANSI C. (This will
Xcause problems for people without ANSI C compilers. The code is written
Xto be portable, and has been checked by the UNIX "lint" utility.  So
Xfar this version has been compiled and run on the following machines
Xand operating systems:
X
X
X	Machine				Operating System 
X	================================================ 
X	Zenith 386 SX/20 PC		MS-DOS 5.0 
X	Bull DPX/2 (68040)		UNIX (BOS) 
X	RS/6000				UNIX (AIX 3.2)
X
XIn the past, the code has been run on the ATARI-ST and other UNIX
Xsystems. MINIX will not be a supported platform until it has a floating
Xpoint compiler however. This version needs porting back to the ATARI. 
X
X16.3 Metrics
X
XIn this section lists statistics about the interpreter source code and
Xrelative performance.
X
X16.3.1	Size of the Source Code
X
XThe list below gives for each source file, the number of lines, the
Xnumber of Format Independant Delivered Source Instructions (FIDSI) and
Xthe number of comments. FIDSI are defined as part of the COCOMO model
Xdefined in [5] and are a semi-defacto standard for measuring the size
Xof a program. The program is too small to be modeled by COCOMO. Note
Xthe lack of comments!
X
X	  Lines	 FIDSI Comm.  Filename		
X
X	     86     47      3 lisp.c
X	   1014    517     75 commn.c
X	    514    333     20 eval.c
X	    108     60     16 gc.c
X	    508    272     19 tgraph.c
X	    511    277     20 graph.c
X	    394    245     38 lex.c
X	    346    210      4 math.c
X	    415    234     14 midi.c
X	    297    178     10 parse.c
X	    223    129      4 print.c
X	    619    353     45 symtab.c
X	    200    115      6 unix.c
X	    509    221     27 view.c
X	    176    116     20 cells.h
X	===============================
X	   5920   3307    321 total
X
X16.3.2	Internal Function Calling Profile
X
XThe following table is the output from the UNIX "prof" utility run on
XVersion 2.28 of RefLisp, compiled with the -p option. The test was run
Xusing sort.lsp and bignum.lsp.
X
XSubsequent versions will have the most used functions replaced by
Xmacros. Functions replaced with macros are indicated by a leading *.
X__mcount is the profiling subroutine, and should be excluded from
Xdiscussions about resource usage. The less-frequently used functions
Xare not listed.
X
XName                 %Time     Seconds     Cumsecs  #Calls   msec/call
X.__mcount             37.0       30.46       30.46
X*car                   8.6        7.06       37.52 3569237      0.0020
X*cdr                   7.6        6.28       43.80 3208130      0.0020
X.eval                  5.4        4.43       48.23  471698      0.0094
X.dereference           5.3        4.38       52.61 1087608      0.0040
X*atom                  3.9        3.24       55.85 3509798      0.0009
X.purge                 3.7        3.05       58.90  745590      0.0041
X.reference             3.6        2.93       61.83 1852270      0.0016
X*subrp                 3.0        2.45       64.28  992799      0.0025
X*fsubrp                2.2        1.84       66.12  705840      0.0026
X*numberp               2.1        1.71       67.83  478750      0.0036
X*bigstringp            1.7        1.39       69.22  468474      0.0030
X*stringp               1.7        1.38       70.60  473896      0.0029
X.eval_list             1.6        1.34       71.94  323045      0.0041
X.ref_evlis             1.6        1.30       73.24  136037      0.0096
X.value                 1.5        1.23       74.47  678077      0.0018
X.get_cell              1.5        1.21       75.68  366122      0.0033
X*idp                   1.0        0.83       76.51  831715      0.0010
X.apply                 1.0        0.80       77.31  161523      0.0050
X.c_release             0.9        0.77       78.08  365852      0.0021
X.evprogn               0.7        0.58       78.66   65282      0.0089
X.savelis               0.6        0.51       79.17   40386      0.0126
X.cons                  0.6        0.51       79.68  347003      0.0015
X.setlis                0.4        0.35       80.03   40386      0.0087
X.cfr                   0.4        0.32       80.35  121137      0.0026
X.set                   0.3        0.24       80.59  131774      0.0018
X.ap_lambda             0.2        0.17       80.76   40386      0.0042
X.fixp                  0.2        0.13       80.89   50869      0.0026
X.cir                   0.1        0.09       80.98   47130      0.0019
X.restorlis             0.1        0.09       81.07   40386      0.0022
X*floatp                0.1        0.09       81.16   55894      0.0016
X.quotient              0.1        0.08       81.24    3378      0.024
X.evcond                0.1        0.08       81.32   24486      0.0033
X.equal                 0.1        0.07       81.39   12634      0.0055
X.bcar                  0.1        0.06       81.45   21787      0.0028
X.__mcount              0.1        0.06       81.51
X.lessp                 0.1        0.06       81.57    7232      0.008
X.newicell              0.1        0.06       81.63   14239      0.0042
X.eq                    0.1        0.06       81.69  121158      0.0005
X.plus                  0.1        0.06       81.75    5052      0.012
X._ptrgl                0.1        0.05       81.80
X
X
X
X17 BIBLIOGRAPHY
X		
X		
X	[1]	Timothy P. Hart and Thomas G. Evans, "Notes on 
X		Implementing Lisp for the M-460 Computer", in 
X		"THE PROGRAMMING LANGUAGE Lisp: Its Operation and 
X		Applications", Information International Inc. 
X		March 1964.
X						
X	[2]	Arthur Norman and Gillian Cattell, "Lisp on the BBC 
X		Microcomputer", Acornsoft, 1983.
X		
X	[3]	J. Marti, A. C. Hearn, M. L. Griss, C. Griss,
X		"Standard Lisp Report", SIGPLAN Notices, Vol 14,
X		Part 10, Pages 48-68, 1979
X			
X	[4]	Winston & Horn, "Lisp", 2nd edition, published by
X		Addison Wesley, 1980. (there's a third edition too.)
X	
X	[5]	"Software Engineering Economics", Barry Boehm
X	
X	[CLtL2]	"Common Lisp the Language", 2nd Edition, Guy L Steele,
X		Digital Press.	
X			
X[1] was used in the development of eval and read. Standard Lisp is
Xdefined in [3]. Beginners should read [4].  It is very readable and
Xgives some quite varied and useful examples. Some of the examples in 
Xthe book are supplied with the interpreter. Examples are also taken
Xfrom [2], which is a good primer for Standard Lisp. Common Lisp is
Xdefined in [CLtL2], all 1,030 pages of it!	
X		
XAPPENDIX A	ROUND TOITS -- THE FUTURE
X
XThe work on RefLisp has been done in the author's spare time, in the
Xevenings on weekends. It is not a "professional" effort, usual
Xstandards of programming have given way to late-night hacking.  This a
Xlist of things that should be done when the author gets around to it.
X:-)  These are listed in decreasing  order of priority: 
X
X	-  Fix the Bugs! [A permanent entry.]
X	-  Add user breaks for aborting from infinite loops.
X	-  Run some benchmarks with and without GC enabled.
X	-  Change all functions to be a Common Lisp subset.
X	-  Produce a comprehensive regression test suite.
X	-  Document and clean up the source.
X	-  Add code to check overflowing refcounts and copy.
X	-  Spell check this document.
X	
XAPPENDIX B	UPDATES -- THE PAST
X
XVersion 2.08
X
X	Big strings added to: (button) text field; (open); (system)
X	and (rdf). This allows full operating system pathnames to
X	be used when reading or executing programs.
X
X	Updated the graphics demo to be mouse based.
X	
XVersion 2.22
X
X	Added (inpsym)(outsym)(addsym)(rdpsym)(replace)
X
XVersion 2.25
X
X	Changed many Standard Lisp function names to the Common 
X	Lisp equivalents. de,dm,plus,difference,quotient,minus,
X	times, etc...	
X
XVersion 2.26
X	
X	Made NIL a symbol. Changed the internal NIL not to be a zero
X	pointer. Fixed (princ) memory leakage. Fixed *eof*.
X
XVersion 2.34
X
X	Bug fixes: When memory runs out it complains properly instead of the
X	confusing "x not STRING for CSR" message.
X
XVersion 2.38
X
X	Bug fixes: The backqoute "\" has been repaired, so that "\w" ==> "w"
X
XVersion 2.39
X
X	Changed initialisation to use the LISPINIT environment variable. Added
X	(getenv). (open) now uses the &key :direction syntax.
X
XVersion 2.41
X
X	Bug fixes for BSD 4.3 and GCC for Bryan.
X
XVersion 2.51
X	
X	Added (do-until), &rest, &optional and initform in lambda lists.
X	Fixed user quotes in lex.c. Fixed GENSYM
X
XVersion 2.58	
X
X	Added CONSTANT types. Cures a bug in which *unbound* was
X	being garbage collected in loops.
X
XVersion 2.59
X
X	Added (errno), (strerrno), (fork), (semget), (semctl), (semop) 
X	and the source file "ipc.c".
X
XVersion 2.67
X
X	Added (append), (reverse), (backquote), fixed memory leakage
X	of functions which are self-modifying or which required
X	further evaluation before application.
X
XAPPENDIX C 	BUGS
X	
X1.	(move) does not take out all the garbage as it should.
X2.	The mouse misbehaves in the following following graphics modes:
X		CGA: 2 3
X		MCGA: 0,1,2,3
X3.	Some functions may not work as described in CLtL2. This 
X	results from their origins in Standard Lisp.
X4.	Reference counts are not checked for rollover through MAXINT.
X
X
X
END_OF_FILE
if test 68076 -ne `wc -c <'man.txt'`; then
    echo shar: \"'man.txt'\" unpacked with wrong size!
fi
# end of 'man.txt'
fi
if test -f 'makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile'\"
else
echo shar: Extracting \"'makefile'\" \(1996 characters\)
sed "s/^X//" >'makefile' <<'END_OF_FILE'
XCFLAGS=-DUNIX 
X
Xbin=reflisp
X
XLISPS = \
X anag.lsp \
X bignum.lsp \
X circle.lsp \
X clock.lsp \
X comb.lsp \
X common.lsp \
X compile.lsp \
X curves.lsp \
X cycle.lsp \
X demos.lsp \
X dict.lsp \
X drawing.lsp \
X expand.lsp \
X fib.lsp \
X fsmoo.lsp \
X gob.lsp \
X gui.lsp \
X ipc.lsp \
X lexical.lsp \
X lisprc.lsp \
X litoc.lsp \
X love.lsp \
X mathtest.lsp \
X mem.lsp \
X menu.lsp \
X oops.lsp \
X permute.lsp \
X profile.lsp \
X qtime.lsp \
X run.lsp \
X scheme.lsp \
X shake.lsp \
X sort.lsp \
X test.lsp \
X times.lsp \
X tstrand.lsp 
X
X
Xsource =  lisp.c \
X commn.c \
X eval.c \
X gc.c \
X tgraph.c \
X graph.c \
X lex.c \
X math.c \
X midi.c \
X parse.c \
X print.c \
X symtab.c \
X unix.c \
X ipc.c \
X view.c \
X cells.h 
X
X
Xobject= lisp.o\
X commn.o\
X eval.o\
X gc.o \
X graph.o\
X lex.o\
X math.o\
X midi.o\
X parse.o\
X print.o\
X unix.o\
X ipc.o\
X view.o \
X symtab.o
X
Xlibrary= lisp.o\
X commn.o\
X eval.o\
X gc.o \
X graph.o\
X lex.o\
X math.o\
X midi.o\
X parse.o\
X print.o\
X unix.o\
X ipc.o\
X view.o \
X symtab.o
X
XDEMOS= anag.lsp curves.lsp expand.lsp init.lsp sort.lsp benchmar.lsp \
Xdemos.lsp fgtest.lsp mathtest.lsp test.lsp bignum.lsp dict.lsp \
Xfra.lsp menu.lsp times.lsp chaos.lsp doctor.lsp fsmoo.lsp oops.lsp \
Xtstrand.lsp circle.lsp drawing.lsp gc.lsp patter.lsp view.lsp \
Xclock.lsp exit.lsp gob.lsp qtime.lsp search.lsp calc.lsp grep.lsp queen.lsp \
Xrules.lsp prolog.lsp common.lsp gui.lsp fib.lsp shake.lsp profile.lsp \
Xscheme.lsp church.scm lexical.lsp
X
X
X$(bin) : $(object) makefile
X	cc $(object) -lm -o $(bin)
X
Xlint : $(source) makefile
X	lint $(CFLAGS) -wP -b -u $(source)
X
Xmetrics : $(source) makefile
X	count $(source)
X
Xrelease : reflisp1_3  reflisp2_3 reflisp3_3
X
Xreflisp1_3 : README makefile $(source) man.txt init.lsp times.lsp bignum.lsp qtime.lsp
X	shar README man.txt makefile $(source) init.lsp times.lsp \
Xbignum.lsp qtime.lsp >reflisp1_3
X
Xreflisp2_3 : makefile $(DEMOS)
X	shar $(DEMOS) > reflisp2_3
X
Xreflisp3_3 : makefile reflisp.exe
X	compress -c reflisp.exe >reflisp.exe.Z
X	uuencode reflisp.exe.Z < reflisp.exe.Z >reflisp3_3
X
END_OF_FILE
if test 1996 -ne `wc -c <'makefile'`; then
    echo shar: \"'makefile'\" unpacked with wrong size!
fi
# end of 'makefile'
fi
if test -f 'lisp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lisp.c'\"
else
echo shar: Extracting \"'lisp.c'\" \(1705 characters\)
sed "s/^X//" >'lisp.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <setjmp.h>
X#ifdef MSDOS
X#include <dos.h>
X#endif
X#include "cells.h"
Xextern int rawread(char *, char *, int, int);
Xextern int readfile(FILE *, FILE *, int, int);
Xextern char *InitOS();
Xextern void InitIPC();
Xextern void	InitCells();
Xextern void	InitSymtab();
Xextern void	InitParse();
Xextern void	InitPrint();
Xextern void	InitEval();
Xextern void	InitMidi();
Xextern void	InitMath();
Xextern void	InitGraph();
Xextern void	InitView();
X/******************************************************************************
X *
X *
X *
X */
Xjmp_buf top_level;
X
X#ifdef LASER
Xlong _stksize = 100*1024L;
X#endif
X#ifdef MSDOS
Xunsigned _stklen = 48*1024 ;
X#endif
X
X int main(int argc, char **argv)
X{
X
Xchar *initfile;
Xint arg;
XEXP command_args = NIL;
X
X	initfile = "lisprc.lsp";
X
X	if( setjmp(top_level) ){
X
X		printf("Intialisation error, exiting...\n");
X		return(-1);
X	}
X	InitCells();
X	InitSymtab();    
X	InitParse();
X	InitPrint();
X	InitEval();
X	initfile = InitOS();	/* Operating System specific stuff */
X    InitIPC();
X	InitMidi();
X	InitMath();
X	InitGraph();
X	InitView();
X
X	{  /* handle command line arguments */
X
X		for(arg = argc-1 ; arg >= 0 ; arg--) {
X			command_args = cons(newbigstring(argv[arg]),command_args);
X		}
X		set(lookup("command-line-args"), reference(command_args));
X    }
X	set( lookup("error-tag") , newvoidcell((void *)&top_level));
X	if( setjmp(top_level) )
X		fprintf(stderr,"; skipping files...");
X	else {
X
X		if( rawread(initfile,(char *)NULL, (int)0, (int)1) == 0)
X			fprintf(stderr,"; cannot read %s, continuing...\n",
X				initfile);
X			fflush(stderr);
X	
X	}
X	if( setjmp(top_level) )
X		printf("back to top level...\n");
X	readfile(stdin,stdout, 1, 0);
X
X	exit((int)0);
X	return(0);
X}
X
X
X
X 
END_OF_FILE
if test 1705 -ne `wc -c <'lisp.c'`; then
    echo shar: \"'lisp.c'\" unpacked with wrong size!
fi
# end of 'lisp.c'
fi
if test -f 'commn.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'commn.c'\"
else
echo shar: Extracting \"'commn.c'\" \(16751 characters\)
sed "s/^X//" >'commn.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <stdlib.h>
X#include "cells.h"
X
Xextern void *malloc(size_t);
X
Xextern EXP hashtab[HASHMODULO];
X
Xextern char *pname(EXP);
Xextern EXP lookup(char *);
Xextern EXP oblist;
Xextern void new_constant(char *, EXP, EXP);
X
XCELL cell_pool[POOL_SIZE];
Xlong cellcount;
Xlong watermark;
Xlong totalcells = POOL_SIZE;
X
X/*
X * Bootstrap Constants: Step 1
X * Declare pointers to well known, but as yet un-initialised objects.
X * This allows some initialisations, which just require a valid cell pointer. 
X * Step 2 will actually initialise these cells.
X */
XCELL real_nil;
X
XCELL unb,true,rq,rbq,rc,rca,real_printname,ruc1,ruc2,rf;
X
XEXP PRINTNAME = &real_printname;
X
XEXP UNBOUND = NIL;
XEXP free_list = NIL;
XEXP T = NIL;
XEXP beof = NIL;
XEXP lpar = NIL;
XEXP rpar = NIL;
XEXP raw_quote = NIL;
XEXP quote = NIL;
XEXP back_quote = NIL;
XEXP backquote = NIL;
XEXP raw_comma = NIL;
XEXP comma = NIL;
XEXP raw_comma_at = NIL;
XEXP comma_at = NIL;
XEXP raw_uchar1 = NIL;
XEXP uchar1 = NIL;
XEXP raw_uchar2 = NIL;
XEXP uchar2 = NIL;
XEXP raw_func = NIL;
XEXP func_quote = NIL;
XEXP period = NIL;
X
X
Xchar *csr(EXP x)
X{
X	lif( stringp(x)) {
X   		return(x->reg.zstring);
X	}
X	else {
X		c_error(" not STRING for CSR",x);
X		return((char *)NULL);
X	}
X}
X/******************************************************************************
X *
X *
X *
X */
Xvoid *cvoidr(EXP x)
X{
X	if( x->ztype == VOIDPTR) {
X		return(x->reg.zvoid);
X	}
X	else {
X		serr("non-pointer passed to cvoidr");
X		return((void *)NULL);
X	}
X}
XFILE *cor(EXP x)
X{
X	lif( filep(x)) {
X		return(x->reg.zfile);
X	}
X	else {
X		serr("non-file passed to cor");
X		return(stdout);
X	}
X}
XPTRFCELLPTR cfr(EXP x)
X{
X	lif( lor( subrp(x) , fsubrp(x))) {
X		return(x->reg.zfunction);
X	}
X	else {
X		serr("non-subrp passed to cfr");
X		return(x->reg.zfunction);
X	}
X}
Xvoid rplcf(EXP x, PTRFCELLPTR val, int type)
X{
X	lif( lnot(null(x))) {
X	   x->ztype = type;
X	   x->reg.zfunction = val;
X	}
X	else {
X		serr("nil passed to rplcf");
X	}
X}
XEXP newffcell( PTRFCELLPTR func )
X{
Xregister EXP new;
X
X	new = get_cell();
X	rplcf( new, func, FSUBRP );
X	return(new);
X}
XEXP newfcell( PTRFCELLPTR func )
X{
Xregister EXP new;
X
X	new = get_cell();
X	rplcf( new, func, SUBRP );
X	return(new);
X}
X/******************************************************************************
X *
X *
X *
X */
Xvoid rplci(EXP x, int val)
X{
X	lif( lnot(null(x)) ) {
X	   x->reg.zinteger = val;
X	}
X	else {
X		serr("nil passed to rplci");
X	}
X}
X/******************************************************************************
X *
X *
X *
X */
Xint ccr(EXP x)
X{
X	lif( lnot(null(x)) ) {
X 	  return(x->zcount);
X	}
X	else {
X		serr("nil passed to ccr");
X		return((int)NULL);
X	}
X}
X/******************************************************************************
X *
X *
X *
X */
Xint cir(EXP x)
X{
X	lif( fixp(x) ) {
X  		 return(x->reg.zinteger);
X	}
X	else lif( floatp(x) ) {
X  		 return((int)x->reg.zfloat);
X	}
X	else {
X		serr("non-integer passed to cir");
X		return((int)NULL);
X	}
X}
X/*
X * Contents of float register
X */
Xfloat cflor(EXP x)
X{
X	lif( floatp(x) ) {
X  		 return(x->reg.zfloat);
X	}
X	else lif( fixp(x) ) {
X  		 return((float)x->reg.zinteger);
X	}
X	else {
X		serr("non-float passed to cflor");
X		return((float)0);
X	}
X}
XEXP fixp(EXP x)
X{
X   lif( lnot(null(x)) ) {
X	   if(x->ztype == INTEGER )
X	       return(T);
X	   else
X	      return(NIL);
X	}
X	else {
X		serr("nil passed to fixp");
X		return(NIL);
X	}
X}
XEXP nth(int n , EXP l)
X{
X	for(n=n; n>0; n--) {
X		lif( (null(l) ) ) {
X			return(NIL);
X			/* c_error("nth: to few list elements", l);  */
X		}
X		l = cdr(l);
X	}
X	lif( l)
X		return(car(l));
X	else
X		return(NIL);
X}
XEXP member(EXP a , EXP l)
X{
X	lwhile( lnot(null(l)) ) {
X		lif( equal(a,car(l)) )
X			return(l);
X		l = cdr(l);
X	}
X	return(NIL);
X}
X/************************************************************************
X *
X * Put a cell back on the free list
X *
X */
Xvoid c_release(EXP x)
X{
X
X   if( x == NIL) 
X		return;
X   if( x->ztype == BIGSTRING ) {
X		EXP tmp;
X
X		tmp = x->reg.zpair.zcdr;
X		c_release(x->reg.zpair.zcar);
X          x->ztype = STRING;
X		c_release(x);
X		c_release(tmp);
X		return;
X   }
X   cellcount++;
X   x->zcount = 0;
X   x->ztype = PAIR;
X   x->reg.zpair.zcar = NIL;
X   x->reg.zpair.zcdr = free_list;
X   free_list = x;
X}
X
X/******************************************************************
X *
X *
X */
X
XEXP newflocell(float init)
X{
Xregister EXP new;
X
X   new = get_cell();
X   new->ztype = FLOAT;
X   new->reg.zfloat = (float) init;
X   return(new);
X}
XEXP newicell(int init)
X{
Xregister EXP new;
X
X   new = get_cell();
X   new->ztype = INTEGER;
X   new->reg.zinteger = init;
X   return(new);
X}
XEXP newvoidcell(void *init)
X{
Xregister EXP new;
X
X   new = get_cell();
X   new->ztype = VOIDPTR;
X   new->reg.zvoid = init;
X   return(new);
X}
XEXP newocell(FILE *init)
X{
Xregister EXP new;
X
X   new = get_cell();
X   new->ztype = FILEPTR;
X   new->reg.zfile = init;
X   return(new);
X}
X/******************************************************************
X *
X *
X *
X */
XEXP newbscell(EXP str)
X{
Xregister EXP new;
X
X   new = get_cell();
X   new->ztype = BIGSTRING;
X   new->reg.zpair.zcar = str;
X   return(new);
X}
XEXP newbigstring(char *str)
X{
Xint i = 0;
Xchar string[LEN_STRING];
XEXP tmp = NIL;
XEXP	last = NIL;    /* pointer to last in chain */
XEXP first = NIL;   /* pointer to first in the list */
X
X   while( *str != 0 ) {
X	 /* if( *str == '\\' )
X			str++;      Comment out \ processing */
X		if( i < LEN_STRING -1)
X			string[i++] = *str;  	/* use the buffer */
X		else {          		/*   buffer full so append another */
X			
X			string[i] = 0; 				/* terminate buffer */
X			tmp = newbscell(newscell(string));
X			tmp->reg.zpair.zcdr = NIL;  	/* last points nowhere */
X			if( first == NIL )  {
X				first = tmp;
X				last = tmp;
X			}
X			last->reg.zpair.zcdr = tmp;    /* append to chain */
X			last = tmp;                    /* update pointer */
X			i = 0;                         /* start from the beginning */
X			string[i++] = *str;              /* add the char */
X		}
X      str++;
X	}    /* end of loop */
X	string[i] = 0;       /* terminate current buffer */
X	if( first == NIL )  {  /* identifyer length < LEN_STRING */
X		first = newscell(string);
X	}
X	else {
X		if( i != 0 ) {       /* completely fill buffers  */
X			tmp = newbscell(newscell(string));
X			tmp->reg.zpair.zcdr = NIL;
X		}
X		last->reg.zpair.zcdr = tmp;
X	}
X	return( first );
X}
X/******************************************************************
X *
X *
X *
X */
XEXP newscell(char *str)
X{
Xregister EXP new;
Xint i,not_finished=1;
X
X   new = get_cell();
X   new->ztype = STRING;
X   i = 0;
X  	while( not_finished) {
X		new->reg.zstring[i] = str[i];
X      	i++;
X		if( (i == LEN_STRING-1) || str[i] == 0 ) /* last in string */
X			not_finished = 0;	
X	}
X	new->reg.zstring[i] = 0;
X   	return(new);
X}
X/**************************************************************
X *
X *
X */
XEXP get_cell()
X{
Xregister EXP new = NIL;
X
X   lif( null(free_list) ) {
X#ifndef LINT
X			/* lint complains about the next line:
X			 * "possible pointer alignment problem, op CAST"
X			 *, but it is OK really
X			 */
X		new = (EXP)malloc(sizeof(CELL));
X#endif
X		if( new == NULL ) {
X      		serr("no more free memory");
X      		return(NIL);
X		}
X		else {
X			totalcells++;
X      		new->reg.zpair.zcdr = NIL;
X      		new->ztype = PAIR;
X      		new->zcount = 0;
X      		return(new);
X		}
X   }
X   else {
X      cellcount--;
X      if( cellcount < watermark )
X         watermark = cellcount;
X      new = free_list;
X      free_list = free_list->reg.zpair.zcdr;
X      new->reg.zpair.zcdr = NIL;
X      new->ztype = PAIR;
X      new->zcount = 0;
X      return(new);
X   }
X}
X
X/******************************************************************************
X *
X * Decrement the usage count of the cell.
X *
X */
Xvoid c_decr(EXP x)
X{
X	if( x != NIL) 
X		x->zcount--;
X}
X/******************************************************************************
X *
X * Decrement the usage count of the cell, then attempt discard.
X *
X */
Xvoid c_unlinkaux(EXP x)
X{
X
X	lif( consp(x) ) {   /* if it is a list
X                            * attempt to release the
X			    * children of this cell 
X			    */
X		c_unlink( car(x) );
X		c_unlink( cdr(x) );
X	}
X	/* put this cell onto the free list ,
X	because it is unused */
X	c_release(x);
X}
X/******************************************************************************
X *
X *  Points a C variable at a cell , ensuring that the use count is incremented.
X *
X */
Xvoid c_link(EXP *variable_adr, EXP x)
X/* EXP *variable_adr;         location of the C variable cell pointer */
X/* EXP x;                     Address of cell to point to  */
X{
X   /* Give it a new value */
X   *variable_adr = x;
X
X   if( x != NIL )
X      (*variable_adr)->zcount++;
X
X}
Xvoid c_dlinkcell( EXP to, EXP from)
X{
X	c_link( &to->reg.zpair.zcdr, from);
X}
Xvoid c_alinkcell( EXP to, EXP from)
X{
X	c_link( &to->reg.zpair.zcar, from);
X}
X/******************************************************************************
X *
X *
X *
X */
XEXP cons(EXP a, EXP d)
X{
Xregister EXP new;
X
X   new = get_cell();
X   new->ztype = PAIR;
X   new->reg.zpair.zcar = a;
X   new->reg.zpair.zcdr = d;
X   return(new);
X}
X/******************************************************************************
X *
X *
X *  
X */
XEXP equal(EXP x, EXP y)
X{
Xregister EXP retval = NIL;
X
X#ifdef DEBUG
Xprintf("equal: "); c_prints(x); printf(" "); c_prints(y);printf("\n");
X#endif
X
X   retval = NIL;
X   if( x == NIL && y == NIL)
X      retval = T;
X   else if( x == NIL || y == NIL )
X      retval = NIL;
X   else if( x->ztype == y->ztype)
X
X      switch( x->ztype ) {
X         case PAIR :
X			lif( land(equal( car(x) , car(y)) , equal( cdr(x), cdr(y) ) ))
X                  retval = T;
X            else
X                  retval = NIL;
X            break;
X
X		 case IDENTIFYER :
X		 case CONSTANT :
X            if( x == y)
X               retval = T;
X            else
X               retval = NIL;
X            break;
X
X         case STRING :
X            if( strncmp( x->reg.zstring, 
X					y->reg.zstring,LEN_STRING) == 0)
X               retval = T;
X            else
X               retval = NIL;
X            break;
X
X		 case BIGSTRING : {
X				EXP tmpx = x;
X				EXP tmpy = y;
X                retval = T;
X				lwhile( land(lnot(null(tmpx)) , lnot(null(tmpy))) ) {
X				   if( strncmp( tmpx->reg.zpair.zcar->reg.zstring,
X				       tmpy->reg.zpair.zcar->reg.zstring,LEN_STRING) != 0) {
X								retval = NIL;
X								tmpx = NIL; /* terminate loop */
X				   }
X                   else {
X						tmpx = tmpx->reg.zpair.zcdr;
X						tmpy = tmpy->reg.zpair.zcdr;
X                    }
X			   }
X			}
X            break;
X
X         case INTEGER :
X            if( x->reg.zinteger == y->reg.zinteger)
X               retval = T;
X            else
X               retval = NIL;
X            break;
X
X         case FILEPTR :
X            if( x->reg.zfile == y->reg.zfile)
X               retval = T;
X            else
X               retval = NIL;
X            break;
X
X         case SUBRP :
X         case FSUBRP :
X            if( x->reg.zfunction == y->reg.zfunction )
X               retval = T;
X            else
X               retval = NIL;
X            break;
X
X         default :
X            retval = NIL;
X
X      }
X#ifdef DEBUG
Xprintf("==> "); c_prints(retval); printf("\n");
X#endif
X
X	return(retval);
X
X}
X
X/*****************************************************************************
X *
X *
X *
X */
XEXP eq(EXP x , EXP y)
X{
X   if( x == y)
X      return( T );
X   else
X      return( NIL );
X
X}
X/*
X * Function to check if a circularity exists.
X */
Xint c_circularp(EXP target, EXP b)
X{
XEXP tmp = b;
X
X	lwhile( land(target , tmp) )    {
X		lif(idp(tmp))
X			return(0);
X		else if( target == tmp )
X			return(1);
X		else lif(consp(tmp)) {
X			if( c_circularp( target, car(tmp) )) {
X				return(1);
X			}
X			tmp = cdr(tmp);
X		}
X		else
X        	tmp = NIL;
X	}
X	return(0);
X}
X/*
X * Function to copy contents of a cell to another (except it's ref count).
X */
Xvoid c_movecell(EXP to, EXP from)
X{
X	lif( lor( null(to) , null(from)) ) {
X		serr(" attempt to replace cell with NIL in c_movecell");
X		return;
X	}
X	if( to == from)
X		return;
X	to->ztype = from->ztype;
X	switch(from->ztype) {
X		case INTEGER:
X			to->reg.zinteger = from->reg.zinteger;
X		break;
X		case PAIR :  {
X			to->reg.zpair.zcar = from->reg.zpair.zcar;
X			to->reg.zpair.zcdr = from->reg.zpair.zcdr;
X		}
X		break;
X		case IDENTIFYER :
X			to->reg.zpair.zcar = from->reg.zpair.zcar;
X			to->reg.zpair.zcdr = from->reg.zpair.zcdr;
X		break;
X		case SUBRP :
X		case FSUBRP :
X			to->reg.zfunction = from->reg.zfunction;
X		break;
X		case STRING :
X			strncpy(to->reg.zstring , from->reg.zstring, LEN_STRING);
X		break;
X		case FILEPTR :
X			to->reg.zfile = from->reg.zfile;
X		break;
X		case FLOAT :
X			to->reg.zfloat = from->reg.zfloat;
X		break;
X		case BIGSTRING :
X			to->reg.zpair.zcar = from->reg.zpair.zcar;
X			to->reg.zpair.zcdr = from->reg.zpair.zcdr;
X		break;
X		default:
X			serr("unknown Cell type passed to c_copycell");
X        break;
X	}
X}
X/*
X * Function to over-write one cell with another
X */
XEXP c_replace(EXP target, EXP source)
X{
XEXP tmp = NIL;
X
X	lif( lor( null(target) , null(source)) ) {
X		serr("can't replace cell with NIL in c_replace");
X	}
X
X	if( source == target)
X		return(target);
X	if(c_circularp(target, source)) {
X		c_error("circular structure in c_replace",
X				cons(target,source));
X	}
X	tmp = get_cell();
X	c_movecell(tmp, target);
X	reference(tmp);
X	/* reference(source);       */
X	reference(target);
X	c_movecell(target , source);	/* over-write */
X	purge(tmp);
X    dereference(target);
X	/* dereference(source);    */
X	return(target);
X}
Xvoid InitCells()
X{
Xregister int i;
X
X
X
X	watermark = POOL_SIZE;
X	for(i=0;i<POOL_SIZE;i++) {
X		cell_pool[i].ztype = STRING;
X		c_release( &cell_pool[i]);
X		}
X	oblist = NIL;
X
X	for(i=0;i<HASHMODULO;i++)
X		hashtab[i] = NIL;
X
X	{
X	extern void intern_sym(EXP);
X	/* 
X	 * Bootstrap data declarations: Step 2
X	 * Some constants are used everywhere, and require proper
X	 * definition before anything else.
X	 */
X	 /* NIL is a macro ! */
X	 T = &true;  /* used in #define macros like null() */
X
X    /*
X	 * PRINTNAME is used by eputprop() when lookup() or
X	 * addsym() create a new symbol. therfore hand-build
X	 * it now. The explicit initialisation avoids having
X	 * zero fields, which screws up the reference() etc.
X	 * 
X	 *
X	 */
X		PRINTNAME = &real_printname;
X		new_constant("pname", PRINTNAME, PRINTNAME);
X		intern_sym(PRINTNAME);
X	/*
X	 * The code below hand-builds the "nil" symbol. Notice
X	 * it uses PRINTNAME, which is built just above.
X	 *
X	 * NIL ==> &real_nil ; NIL is a macro !
X	 * NIL is used inside the interpreter, even in the cell pools
X	 * as above. It is used to terminate hash lists in the
X	 * symbol table, therfore cannot appear there. It must
X	 * be created "by hand", and lookup() etc must check for
X	 * it explicitly to simulate internment.
X	 *
X	 *
X	 */ 
X	 new_constant("nil",NIL, NIL);
X		/*
X		 * UNBOUND is used by lookup() to set the value field of a symbol.
X		 */
X		UNBOUND = &unb;
X		new_constant("unbound", UNBOUND, UNBOUND);
X		intern_sym(UNBOUND);
X
X		/*
X		 * T is used in macros like null(), needs a symbol.
X         * the actual value of T is irrelevant, and can be over-written.
X		 */
X		 new_constant("t",T,T);
X         intern_sym(T);
X	}
X
X	/*
X	 * Here we generate some constants for internal use.
X	 * lookup() is used just to construct some unique pointers.
X     */
X
X	c_link(&beof ,lookup("_*eof*"));
X	c_link(&lpar ,lookup("lpar"));
X	c_link(&rpar ,lookup("rpar"));
X	back_quote =  reference(lookup("`")); ;
X	raw_comma = reference(lookup(",")); /* &rc;     */
X	raw_quote = reference(lookup("\'")); /* &rq;  */
X	raw_uchar1 = reference(lookup("#!")); /* &ruc1;   */
X	raw_uchar2 = reference(lookup("#?")); /* &ruc2;   */
X	raw_func = reference(lookup("#'")); /* &rf;  */
X	raw_comma_at = reference(lookup(",@")); /* &rca;  */
X	c_link(&quote ,lookup("quote"));
X	c_link(&uchar1 ,lookup("quser1"));
X	c_link(&uchar2 ,lookup("quser2"));
X	c_link(&func_quote ,lookup("function"));
X	c_link(&backquote ,lookup("backquote"));
X	c_link(&comma ,lookup("comma"));
X	c_link(&comma_at ,lookup("comma-at"));
X	c_link(&period ,lookup("period"));
X
X}
X/*
X * Function to convert identifyers, strings and bigstrings to a 
X * character array. Caller supplies array. No checks are done
X * regarding length which is obviously crap!
X */
XEXP c_tostr( char *str, EXP x)
X{
X  	lif(idp(x)) {
X		sprintf(str, "%s", pname(x) );
X		return(T);
X	} 
X	else lif( stringp( x ) ) {
X      	sprintf(str, "%s", csr(x) );
X		return(T);
X	}
X	else lif( bigstringp( x ) ) {
X		while(x != NIL) {
X      		sprintf(str, "%s", csr(x->reg.zpair.zcar) );
X			str += strlen(csr(x->reg.zpair.zcar));
X			x = x->reg.zpair.zcdr;
X		}
X		return(T);
X   	}
X	else 
X		return(NIL);
X}
Xint c_lenstr( EXP x)
X{
X	lif(idp(x)) {
X		return(c_lenstr(nameof(x)));
X	} 
X	else lif( stringp( x ) ) {
X		return(strlen(csr(x)));
X	}
X	else lif( bigstringp( x ) ) {
X		int l = 0;
X		while(x != NIL) {
X			l += strlen(csr(x->reg.zpair.zcar));
X			x = x->reg.zpair.zcdr;
X		}
X		return(l);
X   	}
X	else 
X		return(-1);
X}
X
END_OF_FILE
if test 16751 -ne `wc -c <'commn.c'`; then
    echo shar: \"'commn.c'\" unpacked with wrong size!
fi
# end of 'commn.c'
fi
if test -f 'eval.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'eval.c'\"
else
echo shar: Extracting \"'eval.c'\" \(14545 characters\)
sed "s/^X//" >'eval.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <stdlib.h>
X#include "cells.h"
X#include <time.h>
X
Xint flag_non_standard = 0;
Xint trace_on = 0;
Xint eval_depth = 0;
Xextern long cellcount;
Xextern long watermark;
Xextern long totalcells;
Xextern char *filearg();
Xextern EXP rdsym(EXP);
X 
Xchar version[] = "2.67";
Xchar thedate[] = "27 Feb 1993";
XEXP e_null(EXP);
XEXP about(EXP);
X
XEXP eval(EXP);
XEXP apply(EXP, EXP);
XEXP ref_evlis(EXP);
XEXP evcond(EXP);
XEXP evwhile(EXP);
X
XEXP ap_lambda(EXP, EXP, EXP);
XEXP eval_list(EXP, EXP);
XEXP savelis(EXP);
Xvoid setlis(EXP, EXP);
Xvoid restorlis(EXP);
X
XEXP evprogn(EXP);
X
X/*
X * Constant pointers
X */
XEXP lambda = NIL;
XEXP macro = NIL;
XEXP lambdaq = NIL;
XEXP rest = NIL;
XEXP optional = NIL;
X
X
Xvoid traceaux(char *str)
X{
X	printf(str);
X	fflush(stdout);
X}
Xvoid trace_exp_aux(EXP sexp)
X{
X		c_prints(sexp);
X}
XEXP trace_toggle(EXP flag)
X{
X	if( cir(car(flag)) == 0)
X		trace_on = 0;
X	else if( cir(car(flag)) == 1)
X		trace_on = 1;
X	return(T);
X}
XEXP bextensions(EXP flag)
X{
X	lif( car(flag) )
X		flag_non_standard = 1;
X	else
X		flag_non_standard = 0;
X        	
X	return(T);
X}
XEXP u_error(EXP x)
X{
X	c_error("user:",x);
X	return(T);
X}
Xvoid printn_spaces(int n)
X{
X	for(; n>0; n--)
X		printf(" ");
X}
X/****************************************************************
X *
X */
X
XLISPFUNC(eroom)
X{
X	args = args;
X    return(newicell(totalcells));
X}
XLISPFUNC(about)
X{
X	args = args;
X	fprintf(stderr,"         RefLisp, Version %s             \n",version);
X	fprintf(stderr,"  Copyright (C) Peter William Birch    \n");
X	fprintf(stderr,"         %s             \n\n",thedate);
X
X	fprintf(stderr,"    An experiment in garbage collection       \n");
X	fprintf(stderr,"           by reference-counting.          \n\n");
X
X	fprintf(stderr,"      Telephone +44 442 230 654\n");
X	fprintf(stderr," Gadebridge, Hemel Hempstead, HP1 3LQ, U.K.          \n\n");
X
X	fprintf(stderr,"Cell Pool has %ld cells x %d bytes/cell = %ld bytes\n", 
X		(long)totalcells,
X		(int)sizeof(CELL),
X		(long)sizeof(CELL)*(long)totalcells);
X	fprintf(stderr,"there are %ld free cells , lowest watermark= %ld \n",
X		cellcount, watermark); 
X	{
X		time_t now = time((time_t *)NULL) ;
X		printf("Universal time now is: %ld\n", now);
X	}
X	return( T );
X}
X/****************************************************************
X *
X */
XEXP e_null(EXP x)
X{
X	lif( null(car(x)) )
X		return( T );
X	else
X		return( NIL );
X}
X/****************************************************************************
X *
X *
X *
X */
XEXP ref_evlis(EXP list)
X{
XEXP result =NIL;
XEXP start =NIL;
XEXP previous =NIL;
X
X	lwhile( lnot(null(list))) {
X		result = reference(cons(eval(car(list)),NIL));
X		lif(previous)
X			previous->reg.zpair.zcdr = result;
X		else
X			start = result;
X		list = cdr(list);
X		previous = result;
X	}
X	return(start);
X}
X/****************************************************************************
X *
X *
X *
X */
XEXP eval(EXP form)
X{
XEXP retval;
X
X	dump {
X		eval_depth++;
X		printf("%4d eval: ", eval_depth);
X		printn_spaces(eval_depth);
X		c_prints(form);
X		printf("\n");
X	}
X   lif( null(form) ) {
X      retval = NIL;
X	}
X   else lif( numberp( form) )
X	  retval = form ;
X   else lif( stringp( form) )
X      retval = form ;
X   else lif( bigstringp( form) )
X	  retval = form;
X   else lif( subrp( form) )
X	  retval = form;
X   else lif( fsubrp( form) )
X	  retval = form ;
X   else lif( filep(form) )
X		retval = form;
X   else lif( atom(form) ) {
X	  if( value(form) != UNBOUND ) {
X		 retval = value(form);
X      }
X      else {
X         c_error("eval: unbound variable",form);
X		 retval = NIL;
X      }
X   }
X   /* Now lists */
X   else {
X	retval = eval_list( car(form), cdr(form) );
X   }
X	dump {
X		printf("%4d eval= ", eval_depth);
X		printn_spaces(eval_depth);
X		c_prints(retval);
X		eval_depth--;
X		printf("\n");
X	}
X    return(retval);
X}
X/****************************************************************************
X *
X *
X *
X */
XEXP eval_list( EXP func, EXP args )
X{
X	lif( atom(func) ) {
X			lif( subrp(func)  ) {
X         		EXP actuals, result;
X
X         		actuals = ref_evlis( args );
X				result = reference(apply( func, actuals ));
X         		purge( actuals );
X		 		dereference(result); 
X         		return(result);
X      		}	 
X      		else {
X				lif( fsubrp(func) ) {
X					return(apply( func, args ));
X      			}
X				else {
X				EXP evaled = reference(eval(reference(func)));
X				EXP result = reference(eval_list(evaled, args));
X
X				purge(evaled);
X            	dereference(func); dereference(result);
X				return(result);
X				}
X        	}
X   	}
X   	else {  /* if func is a list */
X			lif( eq( car(func), lambdaq ) ) {
X			return( apply(func, args ) );
X      		}
X			else lif( eq( car(func), macro ) ) {
X				EXP result;
X				EXP appresult = reference(apply(func, args ));
X				result = reference(eval(appresult));
X				purge(appresult);
X				dereference(result);
X				return( result );
X      		}
X      		else {
X			EXP actuals, result;
X
X			actuals = ref_evlis( args );
X
X			result = reference(apply(func, actuals ));
X			purge(actuals);
X			dereference(result);
X			return(result);
X      		}
X   	}
X}
X/****************************************************************************
X *
X *
X *
X */
XEXP apply(EXP func, EXP args)
X{
X	dump {
X		printf("%4d apply: ", eval_depth);
X		printn_spaces(eval_depth);
X		c_prints(func);
X		c_prints(args);
X		printf("\n");
X	}
X	lif( null(func) ) {
X         return(NIL);
X	}
X	non_standard {
X		/* first make sure that the list is not the name of a symbol */
X		EXP form = cons(func, args);
X		EXP symbol = rdsym(form);
X		lif( symbol ) {
X			c_release(form);
X			return(eval(symbol)); /* get the symbol value */
X		}
X		c_release(form);
X	}
X 	lif( atom(func) ) {
X			lif( lor( subrp( func ) , fsubrp( func )) ) {
X				register EXP retval;
X				register PTRFCELLPTR  fn;
X		
X				fn =  cfr(func);
X				retval = (*fn)(args);
X				return(retval);
X      		}
X			else {
X				EXP evaled = reference(eval(reference(func)));
X				EXP result = reference(apply(evaled, args));
X
X				purge(evaled);
X            	dereference(func); dereference(result);
X				return(result);
X		}
X   	}
X   	/* now when func is a list */ 
X   	else {
X		lif( lor(lor( eq( car(func) , lambda) ,
X			 eq( car(func) , lambdaq) ) ,
X			eq( car(func) , macro))) {
X  	    		return( ap_lambda( cdr(cdr(func)),
X  		       		car(cdr( func)),
X  		       		args ));
X	   	}
X		else {
X			EXP evaled = reference(eval(reference(func)));
X			EXP result = reference(apply(evaled, args));
X
X			purge(evaled);
X            dereference(func); dereference(result);
X			return(result);
X
X		}
X	}
X}
X
X/****************************************************************************
X *
X *
X *
X */
XEXP evwhile( EXP form )
X{
XEXP condition, result=NIL;
X
X   lif( null(form)  ) {
X      serr("null while");
X      return(NIL);
X   }
X   else {
X      	condition = reference( eval( car(form)) );
X		while( condition != NIL ) {
X			purge(result);
X    	   	result = reference(evprogn( cdr(form)));
X	      	purge(condition);
X      		condition = reference( eval( car(form)) );
X		}
X		purge(condition);
X   }
X	dereference(result);
X   return( result );
X}
X
X/****************************************************************************
X *
X *  (do-until (<end-test> results ... <result>) body ...)
X *
X */
XEXP evuntil( EXP form )
X{
XEXP condition, result=NIL;
XEXP end_form = NIL;
X
X   lif( null(form)  ) {
X      serr("null until");
X      return(NIL);
X   }
X   else {
X	end_form = car(form);
X	condition = reference( eval( car(end_form)) );
X	while( condition == NIL ) {
X		purge(result);
X    	   	result = reference(evprogn( cdr(form)));
X	      	purge(condition);
X		condition = reference( eval( car(end_form)) );
X		}
X	purge(result);
X	/* calculate the result */
X	result = reference(evprogn( cdr(end_form)));
X	purge(condition);
X	dereference(result);
X	return( result );
X   }
X   return(NIL);
X}
X
X/****************************************************************************
X *
X *
X *
X */
XEXP evcond(EXP form)
X{
XEXP condition, result =NIL;
X
X	lwhile(form) {
X		condition = reference(eval(car(car(form))));
X		if(condition != NIL) {
X			lif(lnot(null(cdr(car(form))))) {
X				result = reference(evprogn(cdr(car(form))));
X				purge(condition);
X				dereference(result);
X				return(result);
X			}
X			else {
X				dereference(condition);
X				return(condition);
X                        }
X		}
X		else {
X			purge(condition);
X		}
X		form = cdr(form);
X	}
X	return(NIL);
X}
X/****************************************************************************
X *
X *
X *
X */
XEXP ap_lambda( EXP forms, EXP arglist, EXP actual)
X{
XEXP old, result;
X
X
X   old = reference( savelis(arglist));
X   setlis(arglist, actual);
X   result = reference( evprogn(forms));
X   restorlis(old);
X   purge(old);
X   dereference( result);
X   return(result);
X}
X/****************************************************************************
X *
X *
X *
X */
Xvoid setlis(EXP arglist, EXP actual)
X{
Xint optional_on = 0;           /* flag 1 if &optional parameters */
X
X	lwhile(arglist) {
X	EXP symbol = NIL;
X		int default_on = 0;     /* flag 1 if parameter has a default */
X
X		lif( eq(car(arglist), optional) ) {
X			optional_on = 1;
X			arglist = cdr(arglist); /* skip the flag */
X		}
X		lif( eq(car(arglist), rest) ) {
X			arglist = cdr(arglist); /* skip the flag */
X			set( car(arglist), actual);
X			return;
X		}
X		lif(atom(car(arglist))) {
X			symbol = car(arglist);
X                }
X		else {
X                	default_on = 1;
X			symbol = car(car(arglist));
X		}
X
X		lif(null(actual)) {
X			if( optional_on) {
X				if(default_on) {
X					set( symbol,
X						eval(car(cdr(car(arglist)))));
X				}
X                                else {
X					set( symbol, NIL);
X				}
X				arglist = cdr(arglist);
X			}
X			else {
X				c_error("setlis: missing args in function",arglist);
X				return;
X			}
X		}
X		else {
X			set( symbol, car(actual));
X			arglist = cdr(arglist);
X			actual = cdr(actual);
X                }
X	}
X	lif( actual )
X		c_error("setlis: too many args in function",actual);
X}
X/****************************************************************************
X *
X *
X *
X */
XEXP savelis(EXP arglist)
X{
X	lif(null(arglist))
X		return(NIL);
X	else lif( atom(arglist) ) {
X		return( cons(cons( arglist, value( arglist)), NIL));
X	}
X	else {
X	register EXP result = NIL;
X        register EXP symbol = NIL;
X
X		lwhile( lnot(null(arglist)) ) {
X			lif(atom(car(arglist))) {
X				symbol = car(arglist);
X			}
X			else {
X				symbol = car(car(arglist));
X                        }
X			result = cons( cons( symbol, 
X						value( symbol)),result);
X			arglist = cdr(arglist);
X		}
X		return(result);
X	}
X}
X
X/****************************************************************************
X *
X *
X *
X */
Xvoid restorlis(EXP alist)
X{
X
X   while( alist != NIL ) {
X      set( car(car(alist)), cdr(car(alist)) );
X      alist = cdr(alist);
X   }
X}
X/****************************************************************
X *
X */
XEXP evprogn(EXP args)
X{
XEXP start,retval = NIL;
X
X	lif( lnot(consp(args)) )
X		return(NIL);
X	else {
X		start = reference(args);
X		do {
X			purge(retval);
X			retval = reference( eval(car(args)) );
X			args = cdr(args);
X			
X		} lwhile( lnot(null(args)));
X
X		dereference(start);
X		dereference(retval);
X		return(retval);
X	}
X}
X/*
X * Auxiliary functions
X */
XEXP bcar(EXP arg) {
X	lif(null(car(arg))) {
X		return(NIL); }
X	    else { return( car(car(arg)) ); }}
X
XEXP bcdr(EXP arg) {
X	lif(null(car(arg)))
X		{ return(NIL); }
X	    else { return( cdr(car(arg)) ); }}
X
XEXP bcadr(EXP arg)  { return( nth((int) 1, car(arg)) ); }
XEXP bcaddr(EXP arg) { return( nth((int) 2, car(arg)) ); }
XEXP bnth(EXP arg) { return( nth(cir(car(arg)), car(cdr(arg))) ); }
XEXP bcons(EXP arg) { return( cons(car(arg),car(cdr(arg))) ); }
XEXP breplace( EXP args)
X{
X	return(c_replace(car(args), car(cdr(args)) ) );
X}
XEXP batom(EXP arg)  { return( atom(car(arg)) ); }
XEXP bpairp(EXP arg) { return( consp(car(arg)) ); }
XEXP blistp(EXP arg)  { return( listp(car(arg)) ); }
XEXP bidp(EXP arg) { return( idp(car(arg)) ); }
XEXP bstringp(EXP arg) { return( stringp(car(arg)) ); }
XEXP bnumberp(EXP arg)  { return( numberp(car(arg)) ); }
XEXP bfixp(EXP arg) { return( fixp(car(arg)) ); }
XEXP bfloatp(EXP arg)  { return( floatp(car(arg)) ); }
XEXP bmember(EXP arg)  { return( member(car(arg),car(cdr(arg))) ); }
XEXP bccr(EXP arg)  { return( newicell(ccr(car(arg))) ); }
XEXP beq(EXP arg)  { return( eq(car(arg),car(cdr(arg))) ); }
XEXP bequal(EXP arg) { return( equal(car(arg),car(cdr(arg))) ); }
XEXP beval(EXP arg) { return( eval(car(arg)) ); }
XEXP bapply(EXP arg) { return( apply(car(arg),car(cdr(arg))) ); }
XEXP bquote(EXP args) { return( car(args) ); }
XEXP bsetq(EXP args)
X{
XEXP result = eval( car(cdr(args)) );
X
X	set( car(args), result );
X	return( result ); 
X}
XEXP bde(EXP args) {
X		 set( car(args), cons( lambda, cdr(args) ) ) ;
X		 return( car(args) );
X      }
XEXP bdm(EXP args) {
X		 set( car(args), cons( macro, cdr(args) ) ) ;
X		 return( car(args) );
X      }
XEXP bdf(EXP args) {
X		 set( car(args), cons( lambdaq, cdr(args) ));
X		 return( car(args) );
X      }
Xvoid InitEval()
X{
X
X   lambda = reference(lookup("lambda"));
X   macro= reference( lookup("macro"));
X   lambdaq = reference( lookup("lambdaq"));
X   optional = reference( lookup("&optional"));
X   rest = reference( lookup("&rest"));
X   set( lookup("ccr"), newfcell(bccr));
X   set( lookup("car"), newfcell( bcar ) );
X   set( lookup("cdr"), newfcell(bcdr));
X   set( lookup("nth"), newfcell(bnth));
X   set( lookup("cadr"), newfcell(bcadr));
X   set( lookup("caddr"), newfcell(bcaddr));
X   set( lookup("cons"), newfcell(bcons));
X   set( lookup("move"), newfcell(breplace));
X   set( lookup("atom"), newfcell(batom));
X   set( lookup("symbolp"), newfcell(bidp));
X   set( lookup("member"), newfcell(bmember));
X   set( lookup("stringp"), newfcell(bstringp));
X   set( lookup("numberp"), newfcell(bnumberp));
X   set( lookup("integerp"), newfcell(bfixp));
X   set( lookup("floatp"), newfcell(bfloatp));
X   set( lookup("consp"), newfcell(bpairp));
X   set( lookup("equal"), newfcell(bequal));
X   set( lookup("eq"), newfcell(beq));
X   set( lookup("eval"), newfcell(beval));
X   set( lookup("apply"), newfcell(bapply));
X   set( lookup("null"), newfcell( e_null ));
X
X   set( lookup("quote"), newffcell(bquote));
X   set( lookup("cond"), newffcell(evcond));
X   set( lookup("do-while"), newffcell(evwhile));
X   set( lookup("do-until"), newffcell(evuntil));
X   set( lookup("setq"), newffcell(bsetq));
X   set( lookup("defun"), newffcell(bde));
X   set( lookup("defmacro"), newffcell(bdm));
X   set( lookup("df"), newffcell(bdf));
X   set( lookup("progn"), newffcell(evprogn));
X
X	set( lookup("eroom"), newfcell(eroom));
X	set( lookup("room"), newfcell(about));
X	set( lookup("dump"), newfcell( trace_toggle ));
X	set( lookup("extensions"), newfcell( bextensions ));
X	set( lookup("error"), newfcell(u_error) );
X
X}
X
X 
X
END_OF_FILE
if test 14545 -ne `wc -c <'eval.c'`; then
    echo shar: \"'eval.c'\" unpacked with wrong size!
fi
# end of 'eval.c'
fi
if test -f 'gc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gc.c'\"
else
echo shar: Extracting \"'gc.c'\" \(2020 characters\)
sed "s/^X//" >'gc.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "cells.h"
X/*
X *	Function to Increment relative ref counts of an entire tree.
X *	Returns the calling argument;
X */
XEXP reference(EXP tree)
X{
XEXP arg = tree;
X
X	while( tree != NIL ) {
X		if( tree->ztype != PAIR) {
X			tree->zcount += 1;
X			return(arg);
X		}
X		/* Lists */
X		else if( tree ->zcount > 0 ) {
X			tree->zcount += 1;
X			return(arg);
X		}
X		else {
X
X			tree->zcount = 1;
X			/* NOT USED */
X			reference( car (tree) );
X		}
X		tree = cdr(tree);
X	}
X	return(arg);
X}
X/*
X *	Function to decrement use relative ref counts of all cells in a tree.
X */
Xvoid dereference(EXP tree)
X{
X	lwhile( tree ) {
X		lif( atom(tree) ) {
X				tree->zcount -= 1;
X			return;
X		}
X		else if( tree ->zcount != 1 ) {
X				tree->zcount -= 1;
X			return;
X		}
X		else {
X			tree->zcount = 0;
X			dereference( car (tree) );
X		}
X		tree = cdr(tree);
X	}
X}
X/*
X *	Function to release all unused cells in a tree.
X */
Xvoid erase(EXP tree)
X{
XEXP next = NIL;
X
X	lwhile( lnot(null(tree) )) {
X		if( tree ->zcount !=0 ) 		/* Not unused so quit */
X			return;
X		lif( atom(tree) ) {
X			lif( constantp(tree) )		/* Do not erase constants */
X				return;
X			c_release(tree);
X			return;
X		}
X		else {				/* it's a list */
X			erase( car (tree) );	/* recurse on car side */
X			next = cdr(tree);		/* save pointer */
X			c_release(tree);		/* free this cell */
X		}
X		tree = next;			/* and again */
X	}
X}
X/*
X * Combination of dereference() followed by erase()
X */
Xvoid purge(EXP tree)
X{
XEXP next = NIL;
X
X
X	lwhile( lnot( null(tree) )) {
X		lif( atom(tree) ) {
X			lif( constantp(tree) )		/* Do not erase constants */
X				return;
X			if( (tree->zcount -= 1) == 0 ) {
X				lif( idp(tree) ) {
X
X					purge(zapval(tree));   /* value */
X					purge(zprops(tree));   /* properties */
X				}
X				c_release(tree);
X			}
X			return;
X		}
X		else if( tree ->zcount != 1 ) { /* It's a list with refcount > 1 */
X			tree->zcount -= 1;
X			return;
X		}
X		else { 				/* it's a list with ref count == 1 */
X			purge( car (tree) );
X			next = cdr(tree);
X			c_release(tree);
X		}
X		tree = next;
X	}
X}
X
END_OF_FILE
if test 2020 -ne `wc -c <'gc.c'`; then
    echo shar: \"'gc.c'\" unpacked with wrong size!
fi
# end of 'gc.c'
fi
if test -f 'tgraph.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tgraph.c'\"
else
echo shar: Extracting \"'tgraph.c'\" \(9973 characters\)
sed "s/^X//" >'tgraph.c' <<'END_OF_FILE'
X#ifdef MSDOS
X
X#include <graphics.h>
X#include <stdlib.h>
X#include <stdio.h>
X#include <dos.h>
X
X#include "cells.h"
X
X/*
X#define clipx(z) (z>ScreenWidth?ScreenWidth:z)
X#define clipy(z) (z>ScreenHeight?ScreenHeight:z)
X*/
X#define clipx(z) (z)
X#define clipy(z) (z)
X/* Standardised screen size */
X#define SCREENSIZEX 6400
X#define SCREENSIZEY 4800
X/* Horizontal Aspect Ratio */
X#define to_real(x) ((x)/aspect_ratio)
X#define to_square(x) ((x)*aspect_ratio)
X
X/* Normalised Actual Screen Size */
Xint	ScreenWidth;
Xint	ScreenHeight;
Xint scale_factor = 10;
Xfloat aspect_ratio = 1.0;
X
Xint MouseScaleX;
Xint MouseScaleY;
X
X
X/* Scaling from Virtual to Physical Screen size, factors */
X/*
X#define SCALEY(x) (ScreenHeight -((int)(((float)(x)*(float)ScreenHeight)/SCREENSIZEY)))
X#define SCALEX(x) to_real(((int)(((float)(x)*(float)ScreenWidth)/SCREENSIZEX)))
X#define ELACSX(x) ((int)(((float)(to_square(x))*(float)SCREENSIZEX)/ScreenWidth))
X#define ELACSY(x) ((int)(((float)(ScreenHeight -(x))*(float)SCREENSIZEY)/ScreenHeight))
X#define ABSELACSY(x) ((int)(((float)(x)*(float)SCREENSIZEY)/ScreenHeight))
X
X*/
X#define SCALEX(x) (to_real(x/scale_factor))
X#define SCALEY(y) (ScreenHeight -(y)/scale_factor)
X
X/* Scaling from Physical to Virtual Screen size, factors */
X#define ELACSX(x) (to_square(x)*scale_factor)
X#define ELACSY(x) ((ScreenHeight -(x))*scale_factor)
X#define ABSELACSY(x) ((x)*scale_factor)
X
X#define inside(x,y) (	((x)<SCREENSIZEX) \
X					&& ((x) >= 0) \
X					&& ((y)<SCREENSIZEY) \
X					&& ((y) >= 0))
X
X#define fpequals(a,b) (a-b<1.0E-10)
X
Xvoid clip(float *x, float *y, float m, float b)
X{
X
X	if( *x < 0) {
X		*x = 0;
X		*y = m*(*x) + b;
X	}
X	if( *x > SCREENSIZEX) {
X		*x = SCREENSIZEX-1;
X		*y = m*(*x) + b;
X	}
X	if( *y > SCREENSIZEY) {
X		*y = SCREENSIZEY-1;
X		if( m == 0) 
X			*x = SCREENSIZEX;
X		else
X			*x = (*y - b)/m;
X	}
X	if( *y < 0) {
X		*y = 0;
X		if( m == 0) 
X			*x = SCREENSIZEX;
X		else
X			*x = (*y - b)/m;
X	}
X}
Xvoid SysMouseOn ()
X{
X	union REGS inregs, outregs;
X	inregs.x.ax = 1;
X	int86 (0x33,&inregs,&outregs);
X
X}
Xvoid SysMouseOff ()
X{
X	union REGS inregs, outregs;
X	inregs.x.ax = 2;
X	int86 (0x33,&inregs,&outregs);
X
X}
Xstatic void SysMousePosition (int *fx, int *fy)
X{
X	union REGS inregs, outregs;
X
X	inregs.x.ax = 3;
X	int86 (0x33,&inregs,&outregs);
X	*fx = (float) outregs.x.cx;
X	*fy = (float) outregs.x.dx;
X    *fx = ELACSX( *fx );
X	*fy = ELACSY( *fy );
X
X}
X
Xint graphics_state = 0;
X
XLISPFUNC(GraphStop)
X{
X	args = args;
X	closegraph();
X	graphics_state = 0;
X	return(T);
X}
Xvoid lineaux(int x1, int y1, int x2, int y2)
X{
X/*	printf("b_pline: x1 %d y1 %d x2 %d y2 %d\n",x1,y1,x2,y2);
X*/	line( x1, y1, x2, y2);
X}
Xvoid b_pline( int x1, int y1, int x2, int y2)
X{
X#ifdef DEBUG
Xprintf("b_pline: x1 %d y1 %d x2 %d y2 %d\n",x1,y1,x2,y2);
X#endif
X    SysMouseOff();
X    lineaux( clipx(SCALEX(x1)),
X		clipy(SCALEY(y1)),
X		clipx(SCALEX(x2)),
X		clipy(SCALEY(y2)));
X    SysMouseOn();
X
X}
X
Xvoid b_fpline( float x1, float y1, float x2, float y2)
X{
Xfloat m;
Xfloat b;			/* y axis intercept */
X
X	if( fpequals(x2, x1) )
X		m = 1e-10;
X	else
X		m = (y2 -y1)/(x2 - x1);	/* slope */ 
X
X	b = y1 - m*x1;
X	clip(&x1, &y1, m ,b); 
X	clip(&x1, &y1, m ,b);
X	clip(&x2, &y2, m ,b);
X	clip(&x2, &y2, m ,b);
X
X	if(inside(x1,y1) && inside(x2,y2)) {
X
X#ifdef DEBUG
Xprintf("b_pline: x1 %d y1 %d x2 %d y2 %d\n",x1,y1,x2,y2);
X#endif
X  
X	
X	line( SCALEX(x1), SCALEY(y1), SCALEX(x2), SCALEY(y2));
X
X	}
X}
XLISPFUNC(bpline)
X{
XEXP x1 = NIL,y1 = NIL,x2 = NIL,y2 = NIL;
X
X	x1 = car(args);
X	y1 = car(cdr(args));
X	x2 = car(cdr(cdr(args)));
X	y2 = car(cdr(cdr(cdr(args))));
X
X	lif( lor(lor(floatp(x1) , floatp(x2)) , lor(floatp(y1) , floatp(y2))) )
X		b_fpline( cflor(x1), cflor(y1), cflor(x2), cflor(y2));
X	else
X		b_pline( cir(x1), cir(y1), cir(x2), cir(y2));
X	return(T);
X}
XLISPFUNC(bmode)
X{
X	int mode = cir(car(args));
X	/* select XOR drawing mode */
X	if( mode == 3)
X		setwritemode(XOR_PUT);
X	else
X		setwritemode(COPY_PUT);
X
X	return(NIL);
X}
X
XLISPFUNC(btextxy)
X{
XEXP textarg = car(cdr(cdr(args)));
Xint x,y, w,h;
Xint gap = 3;
Xchar buffer[80];
X
X	if(c_tostr(buffer, textarg) == NIL)
X		return(NIL);
X
X	x = SCALEX(cir(car(args)));
X	y = SCALEY(cir(car(cdr(args))));
X
X	h = textheight(buffer);
X	w = textwidth(buffer);
X
X	SysMouseOff();
X	outtextxy(x+gap, y+gap, buffer);
X	SysMouseOn();
X	return(	cons(	newicell((int)ELACSX(w+2*gap)),
X					newicell((int)ABSELACSY(h+2*gap))
X			)
X		);
X}
XLISPFUNC(brectangle)
X{
X	args = args;
X	return(NIL);
X}
XLISPFUNC(bclear)
X{
X	args = args;
X	SysMouseOff();
X	cleardevice();
X	SysMouseOn();
X	
X	return(NIL);
X}
XLISPFUNC(bcolour)
X{
Xint old_color = getcolor();
X
X	int colour = cir(car(args));
X	setcolor(colour);
X	return(newicell(old_color));
X}
X#define PRT 0
X#define AUX 1
X#define CON 2
X#define MIDI 3
X
X#define B_EVSIZE 4
Xtypedef struct b_message {
X	int type;
X	int used;
X	int data[B_EVSIZE];
X} B_MSG;
X
X/*
X * System messages 0 .. 1000
X *
X *		User messages are -ve integers
X */
X#define B_NULL_MSG		0
X#define B_MOUSE_DOWN 	1
X#define B_MOUSE_DOWN_SHIFT 	5
X#define B_MOUSE_UP		2
X#define B_MOUSE_MOVE 	3
X#define B_TIME_OUT	4
X/*
X * Other Raw Messages
X */
X#define B_KEYB 		100
X#define B_MIDI		200
X#define B_V24 		300
X
Xgetmidievent(B_MSG *event)
X{
X   event = event; return(0);
X}
X#define LEFTBUTTON 1
X#define RIGHTBUTTON 2
X#define LSHIFT 1
X#define RSHIFT 2
X
Xvoid SysMouseButt(int *buttons)
X{
X	union REGS inreg, outreg;
X
X	inreg.x.ax = 3;
X	int86 (0x33,&inreg,&outreg);
X	*buttons = outreg.x.bx;
X}
Xgetmousevent(B_MSG *event)
X{
Xstatic int last_status, last_x, last_y;
Xint status, x, y, keys;
X
X	SysMousePosition(&x, &y);
X    SysMouseButt(&status);
X
X	keys = bioskey(2)&3;
X
X	if( (last_status & LEFTBUTTON)!= (status & LEFTBUTTON) ) {
X		if( status & LEFTBUTTON) {
X			if( keys & LSHIFT || keys & RSHIFT)
X				event->type = B_MOUSE_DOWN_SHIFT;
X			else {
X				event->type = B_MOUSE_DOWN;
X			}
X		}
X		else 
X			event->type = B_MOUSE_UP;
X	}
X	else if (last_x != x || last_y != y ) {
X		event->type = B_MOUSE_MOVE;
X	}
X	else
X		return(0);
X
X	event->used = 3;
X	event->data[0]=status;
X	event->data[1]=x;
X	event->data[2]=y;
X	last_status = status;
X	last_x = x;
X	last_y = y;
X	return(1);
X}
Xvoid getevent(B_MSG *event, int timeout)
X{
X
X	event->type = B_NULL_MSG;
X	while( event->type == B_NULL_MSG) {
X		if(getmousevent(event)) {
X			return;
X		}
X		else if( getmidievent(event) ){
X			return;
X		}
X		else if( bioskey(1) != 0) {
X			event->type = B_KEYB;
X			event->used = 1;
X			event->data[0] = bioskey(0) & 0xFF;
X			
X		}
X		else if(timeout != 0){
X			event->type = B_TIME_OUT;
X			event->used = 0;
X		}
X
X	}
X}
XLISPFUNC(bgetevent)
X{
XB_MSG latest;
Xint c, timeout = 0;
XEXP type = NIL, result = NIL;
X
X	lif(lnot(null(args))) {
X    	timeout = cir(car(args));
X	}
X	getevent( &latest, timeout);
X	result = NIL;
X	for( c = latest.used-1; c >= 0 ; c--) {
X		result = cons( newicell(latest.data[c]), result ) ;
X	}
X	switch ( latest.type ) {
X
X		case  B_MOUSE_DOWN :
X				type = lookup("*down*");
X				break;
X		case  B_TIME_OUT :
X				type = lookup("*timeout*");
X				break;
X		case  B_MOUSE_DOWN_SHIFT :
X				type = lookup("*sdown*");
X				break;
X		case  B_MOUSE_UP :
X				type = lookup("*up*");
X				break;
X		case  B_MOUSE_MOVE :
X				type = lookup("*move*");
X				break;
X		case  B_KEYB 		:
X				type = lookup("*keys*");
X				break;
X		case  B_MIDI		:
X				type = lookup("*midi*");
X				break;
X		case  B_V24 		:
X				type = lookup("*rs232*");
X				break;
X	}
X	return(cons( type, result));
X}
X
XLISPFUNC(bfillstyle)
X{
Xint pattern = cir(car(args));
Xint color = cir(car(cdr(args)));
X
X	setfillstyle(pattern, color);
X	return( (graphresult()==grError ? NIL : T));
X}
XLISPFUNC(bfillarea)
X{
XEXP points = NIL, tmp = NIL;
Xint number= 0;
X/* our polygon array */
X#define ARRAYSIZE 20
Xint poly[ARRAYSIZE];
X
X	points = car(args);
X	tmp = points;
X	while( number < ARRAYSIZE && tmp != NIL ) {
X		poly[number++] = SCALEX(cir(car(car(tmp))));
X		poly[number++] = SCALEY(cir(cdr(car(tmp))));
X		tmp = cdr(tmp);
X	}
X	SysMouseOff();
X	fillpoly(number/2, poly);
X    SysMouseOn();
X	return( (graphresult==grOk?T:NIL));
X}
XLISPFUNC(GraphOpen)
X{
X
X
X	int wdriver = DETECT;
X	int wmode = 0;
X	int xasp;
X	int yasp;
X
X	 if (registerbgidriver(CGA_driver) < 0) {
X			serr("registerbgidriver failed");
X	 }
X	 if (registerbgidriver(EGAVGA_driver) < 0) {
X			serr("registerbgidriver failed");
X	 }
X
X	lif( args ) {
X		wdriver = cir(car(args));
X		wmode = cir(car(cdr(args)));
X	}
X	initgraph(&wdriver, &wmode, "");
X	/* read result of initialization */
X    { int result = graphresult();
X		if ( result != grOk)  { /* an error occurred */
X			c_error("graphics initialisation failed",newicell(result));
X		}
X    }
X    SysMouseOn();
X/*	setbkcolor (15);
X	blockoffset = 512;
X	setpalette (15,0);
X	SysMouse ();
X    */
X	{ int xasp, yasp;
X		getaspectratio (&xasp, &yasp);
X		aspect_ratio = (float) xasp / (float) yasp;
X    }
X	ScreenWidth = to_square(getmaxx()+1) ;
X	ScreenHeight = getmaxy()+1 ;
X
X	if( (ScreenHeight/ScreenWidth ) > (SCREENSIZEX/SCREENSIZEY)) {
X    	scale_factor = SCREENSIZEY/ScreenHeight;
X	}
X	else {
X		scale_factor = SCREENSIZEX/ScreenWidth;
X	}
X
X	graphics_state = 1;
X
X	return(cons(newicell(SCREENSIZEX),newicell(SCREENSIZEY)));
X}
Xvoid AbortGraph()
X{
X	if(graphics_state == 1)
X	   closegraph();
X}
Xvoid InitGraph()
X{
X	{ /* init mouse */
X		/* Assume mouse driver installed for the moment */
X
X	union REGS inregs, outregs;
X
X
X	inregs.x.ax = 0;
X	int86 (0x33,&inregs,&outregs);
X	}
X	set( lookup("graphopen"), newfcell(GraphOpen));
X	set( lookup("graphclose"), newfcell(GraphStop));
X
X	set( lookup("line"), newfcell(bpline));
X	set( lookup("mode"), newfcell(bmode));
X	set( lookup("textxy"), newfcell(btextxy));
X	set( lookup("clear"), newfcell(bclear));
X	set( lookup("colour"), newfcell(bcolour));
X	set( lookup("fillarea"), newfcell(bfillarea));
X	set( lookup("fillstyle"), newfcell(bfillstyle));
X
X	set( lookup("getevent"), newfcell(bgetevent));
X
X	set(lookup("*down*"),	lookup("*down*"));
X	set(lookup("*sdown*"),	lookup("*sdown*"));
X	set(lookup("*up*"),		lookup("*up*"));
X	set(lookup("*move*"),	lookup("*move*"));
X	set(lookup("*keys*"),	lookup("*keys*"));
X	set(lookup("*midi*"),	lookup("*midi*"));
X	set(lookup("*rs232*"),	lookup("*rs232*"));
X	set(lookup("*timeout*"),	lookup("*timeout*"));
X
X};
X#endif
X
X
X 
END_OF_FILE
if test 9973 -ne `wc -c <'tgraph.c'`; then
    echo shar: \"'tgraph.c'\" unpacked with wrong size!
fi
# end of 'tgraph.c'
fi
if test -f 'graph.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'graph.c'\"
else
echo shar: Extracting \"'graph.c'\" \(9492 characters\)
sed "s/^X//" >'graph.c' <<'END_OF_FILE'
X
X#ifndef LASER
X#include <stdio.h>
X#include "cells.h"
Xvoid InitGraph() {};
X
XEXP bpline(EXP args)
X{
X	args = args;
X	return(NIL);
X}
X#endif
X
X#ifdef LASER
X#include <stdio.h>
X#include <math.h>
X#include <osbind.h>
X#include <obdefs.h>
X#include <gemdefs.h>
X#include "cells.h"
X
X#define PRT 0
X#define AUX 1
X#define CON 2
X#define MIDI 3
X
X#define B_EVSIZE 4
Xtypedef struct b_message {
X	int type;
X	int used;
X	int data[B_EVSIZE];
X} B_MSG;
X
X/*
X * System messages 0 .. 1000
X *
X *		User messages are -ve integers
X */
X#define B_NULL_MSG		0
X#define B_MOUSE_DOWN 	1
X#define B_MOUSE_DOWN_SHIFT 	5
X#define B_MOUSE_UP		2
X#define B_MOUSE_MOVE 	3
X#define B_REDRAW		4
X/* 
X * FILE
X */
X#define B_NEW		11
X#define B_OPEN		12
X#define B_CLOSE		13
X#define B_SAVE		14
X#define B_PRINT		15
X#define B_QUIT		16
X/*
X * EDIT
X */
X#define	B_UNDO		21
X#define	B_CUT		22
X#define	B_COPY		23
X#define	B_PASTE		24
X#define B_CLEAR		25
X#define B_DUPLICATE 26
X#define	B_SELECT_ALL 27
X/*
X * Other Raw Messages
X */
X#define B_KEYB 		100
X#define B_MIDI		200
X#define B_V24 		300
X 
X/* GEM juk */
X	int apl_id;
X	MFDB	myscreen;
X	int phys_handle,a,b,c,d;
X
X/* VDI junk */
Xint vdi_handle;
Xint contrl[12];
Xint ptsin[256];
Xint intout[256];
Xint ptsout[256];
Xint intin[256];
X
X#define clipx(z) (z>ScreenWidth?ScreenWidth:z)
X#define clipy(z) (z>ScreenHeight?ScreenHeight:z)
X
X/* Standardised screen size */
X#define SCREENSIZEX 6400
X#define SCREENSIZEY 4000
X
X/* Actual Screen Size */
Xint	ScreenWidth;
Xint	ScreenHeight;
X
X/* Scaling from Virtual to Physical Screen size, factors */
X#define SCALEX(x) ((int)(((float)x*(float)ScreenWidth)/SCREENSIZEX))
X#define SCALEY(x) (ScreenHeight -((int)(((float)x*(float)ScreenHeight)/SCREENSIZEY)))
X
X/* Scaling from Physical to Virtual Screen size, factors */
X#define ELACSX(x) ((int)(((float)x*(float)SCREENSIZEX)/ScreenWidth))
X#define ELACSY(x) ((int)(((float)(ScreenHeight -x)*(float)SCREENSIZEY)/ScreenHeight))
X
Xclip(x,y,m,b)
Xfloat *x, *y;
Xfloat m, b;
X{
X
X	if( *x < 0) {
X		*x = 0;
X		*y = m*(*x) + b;
X	}
X	if( *x > SCREENSIZEX) {
X		*x = SCREENSIZEX-1;
X		*y = m*(*x) + b;
X	}
X	if( *y > SCREENSIZEY) {
X		*y = SCREENSIZEY-1;
X		if( m == 0) 
X			*x = SCREENSIZEX;
X		else
X			*x = (*y - b)/m;
X	}
X	if( *y < 0) {
X		*y = 0;
X		if( m == 0) 
X			*x = SCREENSIZEX;
X		else
X			*x = (*y - b)/m;
X	}
X}
X
X#define inside(x,y) (	((x)<SCREENSIZEX) \
X					&& ((x) >= 0) \
X					&& ((y)<SCREENSIZEY) \
X					&& ((y) >= 0))
X
X#define fpequals(a,b) (a-b<1.0E-10)
X
Xb_pline( x1, y1, x2, y2)
Xint x1,y1,x2,y2;
X{
X  int arry[2][2];
X#ifdef DEBUG
Xprintf("b_pline: x1 %d y1 %d x2 %d y2 %d\n",x1,y1,x2,y2);
X#endif
X  
X    arry[0][0] = clipx(SCALEX(x1));
X    arry[0][1] = clipy(SCALEY(y1));
X    arry[1][0] = clipx(SCALEX(x2));
X    arry[1][1] = clipy(SCALEY(y2));
X
X#ifdef DEBUG
X{
Xint i;
Xprintf("b_pline: ");
X	for(i=0;i<2;i++)
X		printf("%d %d\n", arry[i][0], arry[i][1]);
X}
X#endif
X	v_hide_c(vdi_handle);
X    v_pline(vdi_handle, 2, arry);
X	v_show_c(vdi_handle,0);
X}
X
Xb_fpline( x1, y1, x2, y2)
Xfloat x1,y1,x2,y2;
X{
Xint arry[2][2];
Xfloat m;
Xfloat b;			/* y axis intercept */
X
X	if( fpequals(x2, x1) )
X		m = 1e-10;
X	else
X		m = (y2 -y1)/(x2 - x1);	/* slope */ 
X
X	b = y1 - m*x1;
X	clip(&x1, &y1, m ,b); 
X	clip(&x1, &y1, m ,b);
X	clip(&x2, &y2, m ,b);
X	clip(&x2, &y2, m ,b);
X
X	if(inside(x1,y1) && inside(x2,y2)) {
X
X#ifdef DEBUG
Xprintf("b_pline: x1 %d y1 %d x2 %d y2 %d\n",x1,y1,x2,y2);
X#endif
X  
X	
X    arry[0][0] = SCALEX(x1);
X    arry[0][1] = SCALEY(y1);
X    arry[1][0] = SCALEX(x2);
X    arry[1][1] = SCALEY(y2);
X
X	v_hide_c(vdi_handle);	/* make mouse pointer dissappear,
X							* because XOR line over it leave junk 
X							* behind.
X							*/
X    v_pline(vdi_handle, 2, arry);
X	v_show_c(vdi_handle,0); /* reappear */
X	}
X}
XEXP bpline(args)
XEXP args;
X{
XEXP x1,y1,x2,y2;
X
X	x1 = car(args);
X	y1 = car(cdr(args));
X	x2 = car(cdr(cdr(args)));
X	y2 = car(cdr(cdr(cdr(args))));
X
X	if( floatp(x1) || floatp(x2) || floatp(y1) || floatp(y2) )
X		b_fpline( cflor(x1), cflor(y1), cflor(x2), cflor(y2));
X	else
X		b_pline( cir(x1), cir(y1), cir(x2), cir(y2));
X	return(T);
X}
X
XEXP bsetlut(args)
XEXP args;
X{
Xint color,newcolor, oldcolor, red, green, blue;
X
X	color = cir(car(args))& 0xf;
X	red = cir(car(cdr(args)))& 0xf;
X	green = cir(car(cdr(cdr(args))))& 0xf;
X	blue = cir(car(cdr(cdr(cdr(args)))));
X	newcolor  = blue + (green << 4) + (red << 8) ;
X	oldcolor = Setcolor(color, newcolor);
X
X	return( cons( newicell((oldcolor >> 8) & 0xf ) ,
X			cons( newicell((oldcolor >> 4) & 0xf), 
X			cons( newicell((oldcolor >> 0) & 0xf) , NIL ))));
X}
X
XEXP GraphOpen(args)
XEXP args;
X{
X
X
X	apl_id = appl_init();
X	vdi_handle =open_workstation(&myscreen);
X
X	phys_handle = graf_handle(&a,&b,&c,&d);	
X	ScreenWidth = myscreen.fd_w;
X	ScreenHeight = myscreen.fd_h;
X
X	v_clrwk(vdi_handle);
X	vsl_color(vdi_handle, 3);
X	
X	return(cons(newicell(SCREENSIZEX),newicell(SCREENSIZEY)));
X}
X
X
XEXP GraphStop(args)
XEXP args;
X{
X	v_show_c(vdi_handle,0);
X	
X	graf_mouse(0,NULL);
X/*	appl_exit(); */
X	v_clsvwk(vdi_handle);
X	return(T);
X}
X
X
Xdraw_button(x,y,text,mode)
Xint mode;
Xint x,y;
Xchar *text;
X{
X	int w,h;
X	int extent[10];
X	int box[4];
X
X	x = SCALEX(x);
X	y = SCALEY(y);
X
X	vqt_extent(vdi_handle,text,extent );
X	h =extent[5];
X	w =extent[2];
X
X	if( mode == 1)
X		vst_effects(vdi_handle,0); /* Black on White */
X	else
X		vst_effects(vdi_handle,1); 
X
X	extent[0] = x;
X	extent[1] = y;
X	extent[4] = x+w;
X	extent[5] = y+h;
X	extent[2] = extent[4];
X	extent[3] = extent[1];
X	extent[6] = extent[0];
X	extent[7] = extent[5];
X	extent[8] = extent[0];
X	extent[9] = extent[1];
X	
X	v_hide_c(vdi_handle);
X	v_justified(vdi_handle,	x +2,
X					y + h -2,
X					text,
X					w-3,0,1); 
X
X	vst_effects(vdi_handle,0); /* normal text font */
X	v_pline(vdi_handle, 5, extent);
X
X	v_show_c(vdi_handle, 0);
X}
XEXP bmode(args)
XEXP args;
X{
X	int mode = cir(car(args));
X	
X	return(newicell(vswr_mode(vdi_handle, mode)));
X}
XEXP bcolour(args)
XEXP args;
X{
X	int colour = cir(car(args));
X	
X	return(newicell(vsl_color(vdi_handle, colour)));
X}
XEXP bdraw_button(args)
XEXP args;
X{
XEXP textarg = car(cdr(cdr(args)));
Xint x,y, w,h;
Xint extent[10];
Xchar buffer[80];
X
X	if(c_tostr(buffer, textarg) == NIL)
X		return(NIL);
X
X	x = SCALEX(cir(car(args)));
X	y = SCALEY(cir(car(cdr(args))));
X
X	vqt_extent(vdi_handle,buffer,extent );
X	h =extent[5];
X	w =extent[2];
X
X
X	vst_effects(vdi_handle,0); /* Black on White */
X
X	extent[0] = x;
X	extent[1] = y;
X	extent[4] = x+w;
X	extent[5] = y+h;
X	extent[2] = extent[4];
X	extent[3] = extent[1];
X	extent[6] = extent[0];
X	extent[7] = extent[5];
X	extent[8] = extent[0];
X	extent[9] = extent[1];
X	
X	v_hide_c(vdi_handle);
X	v_justified(vdi_handle,	x +2,
X					y + h -2,
X					buffer,
X					w-3,0,1); 
X
X	vst_effects(vdi_handle,0); /* normal */
X	v_pline(vdi_handle, 5, extent);
X
X	v_show_c(vdi_handle, 0);
X	return( cons(newicell(ELACSX(x+w)),newicell(ELACSY(y+h))));
X
X}
X
Xgetmidievent(event) 
XB_MSG *event;
X{
X
X	for(event->used = 0; event->used < B_EVSIZE; event->used++) {
X		if( Bconstat(MIDI) != 0 ){
X			event->data[event->used] = Bconin(MIDI) & 0x00ffL;
X		}
X		else 
X			break;
X	}
X	if( event->used != 0 )
X		event->type = B_MIDI;
X	return(event->used);
X
X}
X#define LEFTBUTTON 1
X#define RIGHTBUTTON 2
X#define LSHIFT 1
X#define RSHIFT 2
X
Xgetmousevent(event)
XB_MSG *event;
X{
Xstatic int last_status, last_x, last_y;
Xint status, x, y, keys;
X
X	vq_key_s(vdi_handle, &keys);
X	vq_mouse(vdi_handle, &status, &x, &y);
X	
X	if( (last_status & LEFTBUTTON)!= (status & LEFTBUTTON) ) {
X		if( status & LEFTBUTTON) {
X			if( keys & LSHIFT || keys & RSHIFT)
X				event->type = B_MOUSE_DOWN_SHIFT;
X			else {
X				event->type = B_MOUSE_DOWN;
X				if( status & RIGHTBUTTON) {
X					event->type = B_OPEN;
X				}
X				
X			}
X		}
X		else 
X			event->type = B_MOUSE_UP;
X	}
X	else if (last_x != x || last_y != y ) {
X		event->type = B_MOUSE_MOVE;
X	}
X	else
X		return(0);
X
X	event->used = 3;
X	event->data[0]=status;
X	event->data[1]=ELACSX(x);
X	event->data[2]=ELACSY(y);
X	last_status = status;
X	last_x = x;
X	last_y = y;
X	return(1);
X}
Xgetevent(event)
XB_MSG *event;
X{
X
X	event->type = B_NULL_MSG;
X	while( event->type == B_NULL_MSG) {
X		if(getmousevent(event)) {
X			return;
X		}
X		else if( getmidievent(event) ){
X			return;
X		}
X		else if( Bconstat(CON) != 0) {
X			event->type = B_KEYB;
X			event->used = 1;
X			event->data[0] = Bconin(CON); 
X			
X		}
X	}
X}
XEXP bgetevent(args)
XEXP args;
X{
XB_MSG latest;
Xint c;
XEXP type, result;
X
X	getevent( &latest);
X	result = NIL;
X	for( c = latest.used-1; c >= 0 ; c--) {
X		result = cons( newicell(latest.data[c]), result ) ;
X	}
X	switch ( latest.type ) {
X
X		case  B_MOUSE_DOWN :
X				type = lookup("*down*");
X				break;
X		case  B_MOUSE_DOWN_SHIFT :
X				type = lookup("*sdown*");
X				break;
X		case  B_MOUSE_UP :
X				type = lookup("*up*");
X				break;
X		case  B_MOUSE_MOVE :
X				type = lookup("*move*");
X				break;
X		case  B_KEYB 		:
X				type = lookup("*keys*");
X				break;
X		case  B_MIDI		:
X				type = lookup("*midi*");
X				break;
X		case  B_V24 		:
X				type = lookup("*rs232*");
X				break;
X	}
X	return(cons( type, result));
X}
XInitGraph()
X{   
X	set(lookup("*down*"),	lookup("*down*"));
X	set(lookup("*sdown*"),	lookup("*sdown*"));
X	set(lookup("*up*"),		lookup("*up*"));
X	set(lookup("*move*"),	lookup("*move*"));
X	set(lookup("*keys*"),	lookup("*keys*"));
X	set(lookup("*midi*"),	lookup("*midi*"));
X	set(lookup("*rs232*"),	lookup("*rs232*"));
X	set( lookup("line"), newfcell(bpline));
X	set( lookup("button"), newfcell(bdraw_button));
X	set( lookup("getevent"), newfcell(bgetevent));
X	set( lookup("GraphOpen"), newfcell(GraphOpen));
X	set( lookup("GraphClose"), newfcell(GraphStop));
X	set( lookup("colour"), newfcell(bcolour));
X	set( lookup("setlut"), newfcell(bsetlut));
X	set( lookup("mode"), newfcell(bmode));
X
X}
X#endif /* LASER */
X
X
X 
END_OF_FILE
if test 9492 -ne `wc -c <'graph.c'`; then
    echo shar: \"'graph.c'\" unpacked with wrong size!
fi
# end of 'graph.c'
fi
if test -f 'lex.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lex.c'\"
else
echo shar: Extracting \"'lex.c'\" \(8420 characters\)
sed "s/^X//" >'lex.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <math.h>
X#include <ctype.h>
X#include "cells.h"
X
X#define COMMENTCHAR ';'
X
Xextern FILE *input;
Xextern EXP addsym(EXP, EXP);
Xextern void c_warn_header(char *);
X
XEXP cursym = NIL;
Xint ch = ' ';
Xint linecount =1;
X/****************************************************************************
X *   Raise a number to an integer power.
X */
Xfloat lpower(float x,int y)
X{
Xfloat ret = 1.0;
X
X
X     if( y >= 0) {
X          while(y > 0) {
X               ret *= x;
X               y -= 1;
X          }
X     }
X     else { /* -ve power so divide */
X          while(y < 0) {
X               ret /= x;
X               y += 1;
X          }
X     }
X     return(ret);
X}
X/***********************************************************************
X *
X */
Xint asc_to_int( int x )
X{
X
X  	if( x <= '9' && x >= '0' ) {
X      return( x - '0' );
X	}
X  	else {
X		if( x == '.') {
X     		ungetc(x , input);
X   	   		return( 888 ); /* This must be a float ! */
X  		}
X   		else {
X			if( x == 'e' || x == 'E') {
X      			ungetc(x , input);
X      			return( 999 ); /* This must be a mantissa ! */
X   			}
X   			else {
X     			ungetc(x , input);
X      			return( 100 );  /* ie return value is > 9 */
X   			}
X		}
X	}
X#ifdef LASER
X	ungetc(x , input); /* LASER C seems to need this */
X    return( 100 );  /* ie return value is > 9 */
X#endif
X}
X/***********************************************************************
X *
X */
XEXP c_number(int sign)
X{
Xint d;
Xint leading = 0;
Xint mantissa = 0;
Xint mant_sign = 1;
Xfloat trailing = 0.0;
Xfloat place = 0.1;
Xint itsafloat = 0;
X
X   
X   d = asc_to_int( ch );
X   do {
X      leading = 10*leading + d;
X      ch = getc(input);
X      d = asc_to_int(ch);
X   } while( d < 10 );
X
X   if( d == 888) { /* parse the fractional part of a float */
X		itsafloat = 1;
X          ch = getc(input);   /* skip the '.' */
X          ch = getc(input);
X          while( (d = asc_to_int( ch )) < 10) {
X               trailing = trailing + d*place;
X               place = place/10.0;
X               ch = getc(input);
X          }
X   }
X
X   if( d == 999) { /* parse the mantissa part of a float */
X          ch = getc(input);   /* skip the 'e' */
X          ch = getc(input);
X          if( ch == '-' ) {
X               mant_sign = -1;
X               ch = getc(input);
X          }
X          while( (d = asc_to_int( ch )) < 10) {
X               mantissa = mantissa*10 + d;
X               ch = getc(input);
X          }
X          
X   }
X   if( itsafloat ) {
X          /* must be floating-point */
X	float lp = lpower((float)10.0,(int)(mant_sign*mantissa));
X
X          return(newflocell( (float) (sign*(leading+trailing))*lp));
X   }
X   else {
X          /* must be a round integer */
X          return(newicell(sign*leading));
X   }
X}
X/*
X * Predicate tests if char is valid in a symbol.
X  */
Xident_char_p( int c)
X{
Xint retval;
X
X   switch(c ) {
X
X   case '\f':
X   case '\n':
X   case '\t':
X   case ' ' :
X   case '\r':
X   case '(' :
X   case ')':
X  case COMMENTCHAR :
X   case BQUOTECHAR :
X   case QUOTECHAR :
X   case '"':
X	  retval =0;
X	  break;
X
X   default:
X	  retval=  1;
X	  break;
X
X   }
X   return( retval );
X}
X/***********************************************************************
X *
X */
Xinside_identifyer( int c )
X{
Xint retval;
X
X	if( ident_char_p(c) ) {
X	  return(1);
X	}
X	else {
X	  ungetc(c,input);
X	  return(0);
X        }
X}
X
X/***********************************************************************
X *
X */
XEXP c_string()
X{
Xint i=0;
Xchar string[LEN_STRING];
XEXP first = NIL;
XEXP tmp = NIL,last = NIL;
X
X	while( (ch = getc(input)) != '"') {
X		if( ch == ((int)EOF))
X			break;
X		if( ch == '\134') {
X			int ch2;
X	
X			ch2 = getc(input);
X			if( ch2 == EOF) break;
X			switch( ch2) {
X				case 'n' : ch = '\n'; break;
X				case 'r' : ch = '\r'; break;
X				case 't' : ch = '\t'; break;
X				case 'f' : ch = '\f'; break;
X				case '"' : ch = '\"'; break;
X				case 'e' : ch = '\033'; break;
X				case '\134' : ch = '\134'; break; /* ? */
X				default: ch = ch2; /* ungetc(ch2,input); */ break;
X			}
X		}
X		if( i < LEN_STRING -1)
X			string[i++] = ch;
X		else {
X			string[i] = 0;
X			tmp = newbscell(newscell(string));
X			tmp->reg.zpair.zcdr = NIL;
X			if( first == NIL )  {
X				first = tmp;
X				last = tmp;
X			}
X			last->reg.zpair.zcdr = tmp;
X			last = tmp;
X			i = 0;
X			string[i++] = ch;
X		}
X	}
X	string[i] = 0;
X	if( first == NIL ) {
X		first = newscell(string);
X	}
X	else if( i != 0 ) {
X		tmp = newbscell(newscell(string));
X		tmp->reg.zpair.zcdr = NIL;
X		last->reg.zpair.zcdr = tmp;
X	}
X	return( first ); 
X}
X/***********************************************************************
X *
X */
XEXP c_ident()
X{
Xint i = 0;
Xchar string[LEN_STRING];
XEXP tmp = NIL;
XEXP	last = NIL;    /* pointer to last in chain */
XEXP first = NIL;   /* pointer to first in the list */
X
X   while( inside_identifyer(ch) ) {
X	  if( ch == '\\' )
X         ch = getc(input);
X		if( i < LEN_STRING -1)
X			string[i++] = ch;  	/* use the buffer */
X		else {          		/*   buffer full so append another */
X			
X			string[i] = 0; 				/* terminate buffer */
X			tmp = newbscell(newscell(string));
X			tmp->reg.zpair.zcdr = NIL;  	/* last points nowhere */
X			if( first == NIL )  {
X				first = tmp;
X				last = tmp;
X			}
X			last->reg.zpair.zcdr = tmp;    /* append to chain */
X			last = tmp;                    /* update pointer */
X			i = 0;                         /* start from the beginning */
X			string[i++] = ch;              /* add the char */
X		}
X	  ch = tolower(getc(input));
X	}    /* end of loop */
X	string[i] = 0;       /* terminate current buffer */
X	if( first == NIL )  {  /* identifyer length < LEN_STRING */
X		first = newscell(string);
X	}
X	else {
X		if( i != 0 ) {       /* completely fill buffers  */
X			tmp = newbscell(newscell(string));
X			tmp->reg.zpair.zcdr = NIL;
X		}
X		last->reg.zpair.zcdr = tmp;
X	}
X	{
X		EXP retval;
X		reference(first);
X		retval = addsym(first,first) ;
X		purge(first);         /* chuck away the string if possible */
X		return(retval);
X    }
X}
X/***********************************************************************
X *
X */
XEXP oldc_ident()
X{
Xint cntr;
Xchar astring[LEN_STRING];
X
X   cntr = 0;
X   do {
X	  if( ch == '\\' )
X         ch = getc(input);
X      if( cntr < LEN_STRING -1) {
X         astring[cntr] = ch;
X         cntr++;
X      }
X      ch = getc(input);
X   } while( inside_identifyer(ch) );
X   astring[cntr] = '\0';
X   return( lookup(astring) );
X}
X
X/***********************************************************************
X *
X */
Xvoid nextsym()
X{
Xint forever = 1;
X
X   do{
X      ch = getc(input);
X      switch( ch ) {
X         case '\f':
X         case '\n':
X            linecount++;
X         case '\t':
X         case ' ':
X         case '\r':
X            break;
X		 case '-' :
X            ch = getc(input);
X			if( ch >='0' && ch <= '9') {
X 				cursym = c_number((int)-1);
X			}
X			else {
X           		ungetc(ch , input);
X				ch = '-';
X                cursym = c_ident();
X			}
X			return;
X			
X		 case '"' :
X			cursym = c_string();
X			return;
X			
X         case '0' : case '1' : case '2' : case '3' : case '4' :
X         case '5' : case '6' : case '7' : case '8' : case '9' :
X            cursym = c_number((int)1);
X            return;
X            
X		 case '(' : cursym = lpar; return;
X		 case ')' : cursym = rpar; return;
X		 case '.' : cursym = period; return;
X		 case QUOTECHAR : cursym = raw_quote; return;
X		 case BQUOTECHAR : cursym = back_quote; return;
X		 case FUNCCHAR : {
X            ch = getc(input);
X			if( ch == '\'' ) {
X				cursym = raw_func;
X			}
X			else if( ch == USERCHAR2 ) {
X				cursym = raw_uchar2;
X			}
X			else if( ch == USERCHAR1 ) {
X            	cursym = raw_uchar1;
X            }
X			else {
X				ungetc(ch , input);
X				ch = FUNCCHAR;
X                cursym = c_ident();
X			}
X		}
X		return;
X
X		 case COMMACHAR : {
X            ch = getc(input);
X			if( ch == ATCHAR ) {
X				cursym = raw_comma_at;
X			}
X			else {
X           		ungetc(ch , input);
X				ch = COMMACHAR;
X				cursym = raw_comma;
X			}
X		 }
X		 return;
X
X		 case COMMENTCHAR :
X			do {  /* strip comments */
X               ch = getc(input);
X            } while( ch != '\n' && ch != ((int)EOF) );
X            ungetc(ch , input); /* comment line are counted */
X            break;
X
X         case EOF :
X			cursym = beof;
X            return;
X            
X
X         default:
X	 	if( (ch >= ' ') && (ch <= '~') ) {
X			ch = tolower(ch);
X			cursym = c_ident();
X			return;
X		}
X            	else {
X		     c_warn_header("Ignoring Illegal Character");
X		     fprintf(stderr," %dd\n",ch);
X		}
X	 }
X	 } while( forever );
X}
X
X
X 
END_OF_FILE
if test 8420 -ne `wc -c <'lex.c'`; then
    echo shar: \"'lex.c'\" unpacked with wrong size!
fi
# end of 'lex.c'
fi
if test -f 'math.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'math.c'\"
else
echo shar: Extracting \"'math.c'\" \(7522 characters\)
sed "s/^X//" >'math.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <stdlib.h>
X#include <math.h>
X#include <limits.h>
X#include "cells.h"
Xextern int c_lenstr(EXP);
XEXP explength(EXP args)
X{
XEXP list = car(args);
Xint count = 0;
X
X	lif(consp(list)) {
X		lwhile( list ) {
X			count++;
X			list = cdr(list);
X		}
X	}
X	else lif(lor(lor(stringp(list),idp(list)),
X			bigstringp(list))) {
X        	count = c_lenstr(list);
X        }
X	else 
X		count =0;
X
X	return(newicell(count));
X}
X
XEXP bfloat(EXP args)
X{
X	return(newflocell(cflor(car(args))));
X}
XEXP absof(EXP args)
X{
X	lif( floatp( car(args)))
X		return(newflocell(abs(cflor(car(args)))));
X	else
X		return(newicell(abs(cir(car(args)))));
X}
XEXP seed(EXP args)
X{
Xfloat the_seed = 1.0;
X
X	the_seed = (long)cflor(car(args));
X	srand(the_seed);
X	return(newflocell((float)the_seed));
X}
XEXP brandom(EXP args)
X{
Xint range;
X
X	lif( null(args) )
X		range = 32000; 
X	else
X		range = cir(car(args));
X	return( newicell( abs(rand())%(int)range ));
X}
XEXP greaterp(EXP args)
X{
X	lif( lor( floatp( car(args)) , floatp(car(cdr(args))))) {
X		if( cflor( car(args)) > cflor( car(cdr(args))) )
X			return(T);
X		else
X			return(NIL);
X	}
X	else {
X		if( cir( car(args)) > cir( car(cdr(args))) )
X			return(T);
X		else
X			return(NIL);
X	}
X}
XEXP lessp(EXP args)
X{
X	lif( lor(floatp( car(args)) , floatp(car(cdr(args))))) {
X		if( cflor( car(args)) < cflor( car(cdr(args))) )
X			return(T);
X		else
X			return(NIL);
X	}
X	else {
X		if( cir( car(args)) < cir( car(cdr(args))) )
X			return(T);
X		else
X			return(NIL);
X	}
X}
XEXP stringcmp(EXP args)
X{
Xregister char *left, *right;
X
X	lif(idp(car(args)))
X		left = pname(car(args));
X	else lif(stringp(car(args)))
X		left = csr(car(args));
X	else {
X		serr("non-string passed to stringcmp");
X		return(NIL);
X	}
X	lif(idp(car(cdr(args))))
X		right = pname(car(cdr(args)));
X	else lif(stringp(car(cdr(args))))
X		right = csr(car(cdr(args)));
X	else {
X		serr("non-string passed to stringcmp");
X		return(NIL);
X	}
X	if( strcmp(left,right ) < 0 )
X		return(T);
X	else
X		return(NIL);
X}
XEXP difference(EXP args)
X{
X	lif(null(cdr(args)) ) {   /* (minus) logic */
X		lif( floatp( car(args)) ) {
X			return( newflocell( cflor(car(args)) * (float)-1  ) );
X		}
X		else {
X			return( newicell( cir(car(args)) * -1  ) );
X		}
X	}
X	else lif( lor(floatp( car(args)) , floatp(car(cdr(args))))) {
X		return( newflocell( cflor( car(args)) - cflor( car(cdr(args)))   ) );
X	}
X	else {
X		return( newicell( cir( car(args)) - cir( car(cdr(args)))   ) );
X	}
X}
XEXP quotient(EXP args)
X{
X	lif(null(cdr(args)) ) {   /* invert logic */
X		return( newflocell(1.0 / cflor( car(args))   ) );
X    }
X	lif( lor( floatp( car(args)) , floatp(car(cdr(args))))) {
X		return( newflocell( cflor( car(args)) / cflor( car(cdr(args)))   ) );
X	}
X	else {
X		int A = cir(car(args));
X		int B = cir(car(cdr(args)));
X		if(A%B != 0)  {
X			return( newflocell( (float)A / (float)B) );
X		}
X        else
X			return( newicell( cir( car(args)) / cir( car(cdr(args)))   ) );
X	}
X}
XEXP btimes(EXP args)
X{
Xint floatem = 0; /* flag */
Xfloat fresult = 1.0;
Xint iresult =1;
X
X	lif( null(args) )
X		return(newicell((int)1));
X	lwhile( args ) {
X		if( floatem ) {
X				fresult *= cflor( car(args));
X	    	}
X	    	else lif( floatp( car(args))) {
X				floatem = 1;
X				fresult = iresult;
X			fresult *= cflor( car(args));
X		}
X		else {
X			long tmp = (long) iresult;
X			tmp  *= cir(car(args));
X			if(tmp > INT_MAX || tmp <INT_MIN ) {
X				/* to big to contain in an int */
X				floatem = 1;
X				fresult = iresult;
X				fresult *= cflor( car(args));
X            }
X			else  {
X				iresult *= cir(car(args));
X			}
X		}
X		args = cdr(args);
X	}
X
X	return( (floatem?newflocell(fresult):newicell(iresult)) );
X}
XEXP plus(EXP args)
X{
Xint floatem = 0; /* flag */
Xfloat fresult = 0.0;
Xint iresult =0;
X
X	lif( null(args) ) c_error("parameter to + is not a number",args);
X	lwhile( args ) {
X		if( floatem ) {
X				fresult += cflor( car(args));
X	    	}
X			else lif( floatp( car(args))) {
X				floatem = 1;
X				fresult = iresult;
X				fresult += cflor( car(args));
X			}
X		else {
X			iresult += cir(car(args));
X		}
X		args = cdr(args);
X	}
X	return( (floatem?newflocell(fresult):newicell(iresult)) );
X}
XEXP or(EXP args)
X{
XEXP result = NIL;
X
X	lwhile( args ) {
X		result = eval( car(args) );
X		lif( lnot(null(result)) )
X			return(result); 
X		args = cdr(args);
X	}
X	return( NIL );
X}
XEXP and(EXP args)
X{
XEXP result = NIL;
X
X	lif(null(args))
X		return(NIL);
X	lwhile( args ) {
X		result = eval( car(args) );
X		lif( null(result) )
X			return(NIL); 
X		args = cdr(args);
X	}
X	return( result );
X}
XEXP bzerop(EXP args)
X{
X
X	lif( null(args) )
X		c_error("parameter to ZEROP is not a number",args);
X	if( cflor(car(args)) == 0.0 )
X		return(T);
X	else
X		return(NIL);
X
X}
XEXP bfloor(EXP args)
X{
X	lif( floatp( car(args)) ) {
X			return( newicell((int)floor((double)cflor(car(args)))));
X	}
X	else {
X			return( car(args) );
X	}
X}
XEXP remainder(EXP args)
X{
X	lif( bzerop( cdr(args)) ) 
X				c_error("Attempt to divide by zero in REMAINDER",args);
X	lif( lor( floatp( car(args)) , floatp(car(cdr(args))))) {
X		float u,v;
X			u = cflor( car(args));
X			v = cflor( car(cdr(args)));
X			return( newflocell(fmod(u,v)));
X	}
X	else {
X			return( newicell( cir( car(args)) % cir( car(cdr(args)))   ) );
X	}
X}
XEXP bcos(EXP args)
X{
X	lif( floatp( car(args)) ) {
X		return( newflocell( (float)cos( (float)cflor(car(args)))  ) );
X	}
X	else {
X		return( newflocell( (float)cos( (float)cir(car(args)) ) ) );
X	}
X}
XEXP barc_cos(EXP args)
X{
X	lif( floatp( car(args)) ) {
X		return( newflocell( (float)acos( (float)cflor(car(args)))  ) );
X	}
X	else {
X		return( newflocell( (float)acos( (float)cir(car(args)) ) ) );
X	}
X}
XEXP barc_sin(EXP args)
X{
X	lif( floatp( car(args)) ) {
X		return( newflocell( (float)asin( (float)cflor(car(args)))  ) );
X	}
X	else {
X		return( newflocell( (float)asin( (float)cir(car(args)) ) ) );
X	}
X}
XEXP bsin(EXP args)
X{
X	lif( floatp( car(args)) ) {
X		return( newflocell( (float)sin( (float)cflor(car(args)))  ) );
X	}
X	else {
X		return( newflocell( (float)sin( (float)cir(car(args)) ) ) );
X	}
X}
XEXP blog(EXP args)
X{
X	lif( floatp( car(args)) ) {
X		return( newflocell( (float)log( (float)cflor(car(args)))  ) );
X	}
X	else {
X		return( newflocell( (float)log( (float)cir(car(args)) ) ) );
X	}
X}
XEXP blog10(EXP args)
X{
X	lif( floatp( car(args)) ) {
X		return( newflocell( (float)log10( (float)cflor(car(args)))  ) );
X	}
X	else {
X		return( newflocell( (float)log10( (float)cir(car(args)) ) ) );
X	}
X}
XEXP bexp(EXP args)
X{
X	lif( floatp( car(args)) ) {
X		return( newflocell( (float)exp( (float)cflor(car(args)))  ) );
X	}
X	else {
X		return( newflocell( (float)exp( (float)cir(car(args)) ) ) );
X	}
X}
Xvoid InitMath()
X{
X   set( lookup("length"), newfcell(explength));	
X   set( lookup("and"), newffcell(and));
X   set( lookup("or"), newffcell(or));
X   set( lookup("+"), newfcell(plus));
X   set( lookup("-"), newfcell(difference));
X   set( lookup("rem"), newfcell(remainder));
X   set( lookup("floor"), newfcell(bfloor));
X   set( lookup("*"), newfcell(btimes));
X   set( lookup("/"), newfcell(quotient));
X   set( lookup(">"), newfcell(greaterp));
X   set( lookup("<"), newfcell(lessp));
X   set( lookup("string<"), newfcell(stringcmp));
X   set( lookup("abs"), newfcell(absof));
X   set( lookup("random"), newfcell(brandom));
X   set( lookup("seed"), newfcell(seed));
X   set( lookup("float"), newfcell(bfloat));
X   set( lookup("zerop"), newfcell(bzerop));
X   set( lookup("log"), newfcell(blog));
X   set( lookup("log10"), newfcell(blog10));
X   set( lookup("exp"), newfcell(bexp));
X   set( lookup("sin"), newfcell(bsin));
X   set( lookup("cos"), newfcell(bcos));
X   set( lookup("asin"), newfcell(barc_sin));
X   set( lookup("acos"), newfcell(barc_cos));
X}
X 
END_OF_FILE
if test 7522 -ne `wc -c <'math.c'`; then
    echo shar: \"'math.c'\" unpacked with wrong size!
fi
# end of 'math.c'
fi
if test -f 'midi.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'midi.c'\"
else
echo shar: Extracting \"'midi.c'\" \(8226 characters\)
sed "s/^X//" >'midi.c' <<'END_OF_FILE'
X#ifndef LASER
Xvoid InitMidi() {};
X#endif
X#ifdef LASER
X#include <stdio.h>
X#include <math.h>
X#include <osbind.h>
X#include "cells.h"
X
X#define PRT 0
X#define AUX 1
X#define CON 2
X#define MIDI 3
X
X#define DEBUG
X
X/*
X * Global Variables
X */
Xint	tempo = 1000;
X
X
XEXP noteon(args)
XEXP args;
X{
Xint channel, note, velocity;
X
X	channel =   cir(car(args));
X	note =      cir(car(cdr(args)));
X	velocity =  cir(car(cdr(cdr(args))));
X	Bconout(3, (128+16+channel));
X	Bconout(3,note );
X	Bconout(3,velocity );
X	return(T);
X}
XEXP noteoff( args)
XEXP args;
X{
Xint channel, note, velocity;
X
X	channel =  cir(car(args));
X	note =     cir(car(cdr(args)));
X	velocity = cir(car(cdr(cdr(args))));
X	Bconout(3, (128+channel));
X	Bconout(3,note );
X	Bconout(3,velocity );
X	return(T);
X}
Xdelay(length)
Xint length;
X{
Xint d1,d2;
X
X	for( d1 =0; d1 <length*tempo; d1++)
X		for( d2 =0; d2 <8; d2++)
X			d2 = d2;
X}
XEXP edelay(args) 
XEXP args;
X{
X	delay(cir(car(args)));
X	return(T);
X}
XEXP setempo(args) 
XEXP args;
X{
X	tempo = cir(car(args));
X	return(newicell(tempo));
X}
XEXP programchange(args)
XEXP args;
X{
Xint channel, value;
X
X	channel = cir(car(args));
X	value = cir(car(cdr(cdr(args))));
X	Bconout(3, (128+64+channel));
X	Bconout(3,value );
X	return(T);
X}
XEXP playnote(args)
XEXP args;
X{
Xint channel, note, velocity,length;
X
Xtrace("playnote");
Xtrace_exp(args);
Xtrace("\n");
X
X	channel = cir(car(args));
X	note = cir(car(cdr(args)));
X	velocity = cir(car(cdr(cdr(args))));
X	length = cir(car(cdr(cdr(cdr(args)))));
X	Bconout(3, (128+16+channel));
X	Bconout(3,note );
X	Bconout(3,velocity );
X	delay(length);
X	Bconout(3, (128+channel));
X	Bconout(3,note );
X	Bconout(3,velocity );
X	return(T);
X}
XEXP playtune(args)
XEXP args;
X{
XEXP current = NIL;
Xtrace("playtune");
Xtrace_exp(args);
Xtrace("\n");
X
X	current = car(args);
X	while( current != NIL) {
X		playnote( car(current) );
X		current = cdr(current);
X	}
X}
X/*
X * Music.c
X */
X/*
X * scale - fuction to translate from musical scales to MIDI notes
X *
X * where:
X *		scaleptr -	 pointer to an array of int which contains a scale
X * 					 mapping.
X *					 e.g 0,2,4,5,7,9,11 corresponds to a major scale.
X *		octave_size	- no of semitones in the scale eg 12
X *		
X *		scale_size - # of naturals in the scale eg 7
X *	
X *		note -		note in the scale eg. 0-C, 1-D, 2-E ...
X *	
X *		adj -		+1 = sharp, 0 = natural, -1 = flat
X *
X *		key -		starting point of the scale eg. 0-C, 1-D, 2-E ...
X *	
X *		key_adj -		+1 = sharp, 0 = natural, -1 = flat
X */
Xint major_scale[7] = { 0,2,4,5,7,9,11 };
X 
Xint scale( scaleptr, scale_size, octave_size, key, key_adj, note, note_adj)
Xint *scaleptr, scale_size, octave_size, key, key_adj, note, note_adj;
X{
Xint octave;
Xint tone,midi,semi;
X
X	octave = (note-key)/scale_size; /* transpose to down to C */
X	tone = (note-key)%scale_size;
X	semi =	scaleptr[tone % scale_size]; /* semitone */
X	
X	midi = octave*octave_size /* in the octave */
X			+ semi 
X			+ scaleptr[key%scale_size]+key_adj /* transpose up */
X	 + note_adj;	/* accidentals */
X#ifdef DEBUG	 
Xprintf("scale: octave %d tone %d semi %d midi %d\n",
X	 			octave,tone,semi,midi);
X#endif
X	 return(midi); 
X}
X
X/*
X * routine to convert a conventional major scale into MIDI note #
X */
Xint major( note, note_adj, key, key_adj)
Xint note, note_adj, key, key_adj;
X{
X	return(scale(major_scale, 7,12,key,key_adj,note,note_adj));
X}
XEXP emajor(args)
XEXP args;
X{
Xint note, note_adj, key, key_adj;
X
X	note = cir(car(args));
X	note_adj = cir(car(cdr(args)));
X	key = cir(car(cdr(cdr(args))));
X	key_adj = cir(car(cdr(cdr(cdr(args)))));
X
X#ifdef DEBUG	 
Xprintf("emajor: note %d note_adj %d key %d key_adj %d\n",
X	 	note, note_adj, key, key_adj);		
X#endif
X	return( newicell(major( note, note_adj, key, key_adj)));
X
X}
X 				
X
Xint lowest_note = 21; /* MIDI = 36 TANDY Realistic Concertmate-100M */
Xint highest_note = 56; /* MIDI = 96 TANDY Realistic Concertmate-100M */
X
X/*
X * Dumb terminal emulator
X * Copied from the Laser 'C' manual.
X */
X
XEXP emu(args)
XEXP args;
X{
Xchar *outfile;
XFILE *fp = NULL;
Xchar c = 0;
Xint printit = 0;
X
X	lif( null( args))
X		outfile = NULL;
X	else {
X		lif( idp(car(args)) )
X			outfile = pname(car(args));
X		else lif( stringp(car(args)) )
X			outfile = csr(car(args));
X		else
X			return(NIL);
X		if( ( fp = fopen(outfile,"w+")) == NULL) 
X			return(NIL);
X		else
X			printf("saving session to %s\n",outfile);
X	}
X
X
X	
X	while( 1 ) {
X
X		if( Bconstat(AUX)) {
X			c = ((int)Bconin(AUX))&127;
X			Bconout(CON,c);
X			if(outfile) {
X				putc(c,fp);
X			}
X		}
X		if( Bconstat(CON)) {
X			c = (int)Bconin(CON)&127;
X
X			if( c == '~' )  {
X				int c2;
X
X				while( !Bconstat(CON))
X					; 
X				c2 = (int)Bconin(CON)&127;
X				if( c2 != '~' ) {
X					if(outfile) {
X							fclose(fp);
X					}
X					return(NIL);
X				}
X			}
X			while(!Bcostat(AUX))
X				;
X			Bconout(AUX,c);
X		}
X	}
X	return(NIL);
X}
XEXP exbios(args)
XEXP args;
X{
Xint length;
Xlong retval;
XEXP sav = NIL;
X
X	length = cir(sav = explength(args));
X	erase(sav);
X	switch( length) {
X		case 1 :
X			retval = xbios( cir(car(args)) );
X			break;
X		case 2 :
X			retval = xbios( cir(car(args)), cir(car(cdr(args))) );
X			break;
X		case 3 :
X			retval = xbios( cir(car(args)), 
X							cir(car(cdr(args))), 
X							cir(car(cdr(cdr(args)))));
X			break;
X		case 4 :
X			retval = xbios( cir(car(args)), 
X							cir(car(cdr(args))), 
X							cir(car(cdr(cdr(args)))),
X							cir(car(cdr(cdr(cdr(args))))));
X			break;
X		default:
X			return(NIL);
X			break;
X	}
X	return( newicell(retval));
X}
XEXP ebios(args)
XEXP args;
X{
Xint length;
Xlong retval;
XEXP sav = NIL;
X
X	length = cir(sav = explength(args));
X	erase(sav);
X	switch( length) {
X		case 1 :
X			retval = bios( cir(car(args)) );
X			break;
X		case 2 :
X			retval = bios( cir(car(args)), cir(car(cdr(args))) );
X			break;
X		case 3 :
X			retval = bios( cir(car(args)), 
X							cir(car(cdr(args))), 
X							cir(car(cdr(cdr(args)))));
X			break;
X		case 4 :
X			retval = bios( cir(car(args)), 
X							cir(car(cdr(args))), 
X							cir(car(cdr(cdr(args)))),
X							cir(car(cdr(cdr(cdr(args))))));
X		default:
X			return(NIL);
X			break;
X	}
X	return( newicell(retval));
X}
Xtypedef union {
X	struct {
X		unsigned day : 5;
X		unsigned month : 4;
X		unsigned year : 7;
X		unsigned seconds : 5;
X		unsigned minutes : 6;
X		unsigned hours : 5;
X	} part;
X	long realtime;
X} time;
Xtime mytime;
X
XEXP egetstr(args)
XEXP args;
X{
Xint port = cir(car(args));
Xint timeout = cir(car(cdr(args)));
Xchar string[LEN_STRING];
Xint wr, not_ended =1;
Xtime now;
X
X	wr = 0;
X	mytime.realtime = Gettime();
X	while( not_ended ) {
X		while(Bconstat(port) && not_ended) {
X			string[wr] = Bconin(port)&127;
X			if( wr > LEN_STRING-1) {
X				not_ended = 0;
X			}
X			switch( string[wr++] ) {
X					
X				case ' ' : case '\t' : case '\n' : case '\r' :
X					if( wr == 1)
X						wr = 0; /* skip over white space */
X					else
X						not_ended = 0;
X					break;
X				case '(' : case ')' : case '.' : case '\'' :
X				case '[' : case ']' : case '{' : case '}' :
X				case '!' : case '"' :  case '$' :
X				case '%' : case '^' : case '&' : case '*' :
X				case '_' : case '+' : case '=' : case '`' :
X				case '@' : case '<' : case '>' : case '/' :
X				case '\\' : case '|' : case ';' : case '#' :
X				case '~' : 
X					not_ended = 0;
X				break;
X			}
X		}
X	now.realtime = Gettime();
X	if( (now.part.seconds+ now.part.minutes*60) 
X		- (mytime.part.seconds+mytime.part.minutes*60) > timeout/2 ) 
X			return(NIL);
X	}
X	string[wr]=0;
X	return(newscell(string));
X}
XEXP eputstr(args)
XEXP args;
X{
Xint port = cir(car(args));
Xchar *string;
XEXP exstr=car(cdr(args));
X
X	lif( stringp(exstr) )
X		string = csr(exstr);
X	else lif( idp(exstr) )
X		string = pname(exstr);
X	else
X		return(NIL);
X	while( !Bcostat(port)) ;
X	while( *string != 0) {
X		while( !Bcostat(port)) ;
X		Bconout(port, *string++);
X	}
X	return(NIL);
X}
XInitMidi()
X{
X   set( lookup("getstr"), newfcell(egetstr));	
X   set( lookup("putstr"), newfcell(eputstr));	
X   set( lookup("bios"), newfcell(ebios));	
X   set( lookup("xbios"), newfcell(exbios));	
X   set( lookup("delay"), newfcell(edelay));
X   set( lookup("tempo"), newfcell(setempo));
X   set( lookup("noteon"), newfcell(noteon));
X   set( lookup("noteoff"), newfcell(noteoff));
X   set( lookup("programchange"), newfcell(programchange));
X   set( lookup("playnote"), newfcell(playnote));
X   set( lookup("playtune"), newfcell(playtune));
X   set( lookup("major"), newfcell(emajor));
X   set( lookup("emu"), newfcell(emu));
X
X}
X#endif /* LASER */
X
END_OF_FILE
if test 8226 -ne `wc -c <'midi.c'`; then
    echo shar: \"'midi.c'\" unpacked with wrong size!
fi
# end of 'midi.c'
fi
if test -f 'parse.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'parse.c'\"
else
echo shar: Extracting \"'parse.c'\" \(7701 characters\)
sed "s/^X//" >'parse.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "cells.h"
X
Xextern char *strcat(char *, char *);
Xextern EXP cursym;
Xextern void nextsym();
Xextern void fprints(FILE *, EXP, int);
Xextern int linecount;
Xextern long cellcount;
Xextern long totalcells;
X
X
XFILE *input;
X
XEXP c_s_exp();
X
Xvoid prompt() {
X	printf("\n%ld> ",(totalcells-cellcount));
X	fflush(stdout);
X}
X
XEXP brds(EXP args)
X{
XEXP tmp = NIL;
Xtrace("brds: ");
Xtrace_exp(args);
X
X	tmp = newocell(input);
X	input = cor(car(args));
X   	return( tmp );
X}
X
X/*****************************************************************************
X *
X *
X *
X */
XEXP c_m_list()
X{
XEXP tree = NIL;
X
X   nextsym();
X   lif( equal( cursym, rpar) )
X      tree = NIL;
X   else lif( equal( cursym, period ) ) {
X      nextsym();
X      tree = c_s_exp();
X      nextsym();
X   }
X   else {
X      tree = c_s_exp();
X      tree = cons( tree, c_m_list() );
X   }
X   return( tree );
X}
X/*****************************************************************************
X *
X *
X *
X */
XEXP c_s_exp()
X{
XEXP tree = NIL;
X
X   lif( equal( cursym, beof ) ) {
X      fatal_err("unexpected EOF");
X      tree  = NIL;
X   }
X   else lif( equal( cursym, rpar ) ) {
X      serr("unexpected )");
X      tree = NIL;
X   }
X   else if( cursym == raw_quote ) {
X	  nextsym();
X	  tree = cons( quote, cons( c_s_exp(), NIL) );
X   }
X   else if( cursym == back_quote ) {
X	  nextsym();
X	  tree = cons( backquote, cons( c_s_exp(), NIL) );
X   }
X   else if( cursym == raw_comma ) {
X	  nextsym();
X	  tree = cons( comma, cons( c_s_exp(), NIL) );
X   }
X   else if( cursym == raw_comma_at ) {
X	  nextsym();
X	  tree = cons( comma_at, cons( c_s_exp(), NIL) );
X   }
X   else if( cursym == raw_func ) {
X	  nextsym();
X	  tree = cons( func_quote, cons( c_s_exp(), NIL) );
X   }
X   else if( cursym == raw_uchar1 ) {
X	  nextsym();
X	  tree = cons( uchar1, cons( c_s_exp(), NIL) );
X   }
X   else if( cursym == raw_uchar2 ) {
X	  nextsym();
X	  tree = cons( uchar2, cons( c_s_exp(), NIL) );
X   }
X   else lif( equal( cursym, lpar ) ) {
X      tree = c_m_list();
X	  lif( equal( cursym, rpar ) ) {
X      }
X      else {
X         serr(" missing )");
X      }
X   }
X   else {
X      tree = cursym;
X   }
X   return(tree);
X}
X
X/*****************************************************************************
X *
X *
X *
X */
XEXP reads(FILE *stream)
X{
XEXP retval = NIL;
X
X
X   input = stream;
X
X   nextsym();
X   lif( equal( cursym, beof) ) {
X      retval = beof;
X   }
X   else {
X      retval = c_s_exp();
X   }
X   return(retval);
X}
XEXP breads(EXP args)
X{
Xregister EXP filename = NIL;
X
X	lif( null(args) )
X		return(reads(stdin));
X	filename = car(args);
X	lif(lnot(filep(filename))) {
X		serr("non-file passed to read");
X		return(NIL);
X	}
X	return(reads(cor(filename)));
X}
XEXP bgetcs(EXP args)
X{
Xregister EXP filename = NIL;
Xint retval;
XFILE *fd;
X
X	lif( null(args) )
X		fd = stdin;
X	else {
X		filename = car(args);
X		lif(lnot(filep(filename))) {
X			serr("non-file passed to getc");
X			return(NIL);
X		}
X		else 
X			fd = cor(filename);
X	}
X	retval = getc(fd);
X	if( retval == EOF)
X		return(beof);
X	else
X		return(newicell(retval));
X}
X
Xextern EXP reference(EXP);
X
Xvoid readfile(FILE *inpf,FILE *outpf,int load_print, int verbose)
X{
XEXP inpt = NIL, result = NIL;
Xint old_linecount;
Xint prompter =0;
X
X	verbose = verbose;
X	old_linecount = linecount;	/* Save the current file's  */
X	linecount = 1;			/* linecount for restore later */
X
X		if(inpf == stdin) prompter =1;
X		if(prompter) prompt();
X
X
X		lwhile( lnot(equal( (inpt = reads(inpf)), beof)) ) {
X
X		  	inpt = reference( inpt);
X  	    	result = reference( eval(inpt));
X			if( load_print )
X				fprints(outpf, result, PRIN1 );
X
X      		purge(result);
X	  		purge(inpt);
X
X		if(prompter)
X			prompt();
X		else
X			if( load_print )
X				fprintf(outpf,"\n");
X	   }
X	linecount = old_linecount; /* and restore. */
X}
Xint rawread( char *in, char *out, int load_print, int verbose)
X{
XFILE *infd, *outfd;
X
X	if( in == NULL)
X		infd = stdin;
X	else {
X		if( (infd = fopen(in,"r")) == NULL)
X			return(0);
X	}
X	if( out == NULL)
X		outfd = stdout;
X	else {
X		if( (outfd = fopen(out,"w+")) == NULL)
X			return(0);
X	}
X	if(verbose)
X		fprintf(stderr,"; reading %s \n", in);
X	readfile(infd, outfd, load_print, verbose);
X	if(infd != stdin)
X		fclose(infd);
X	if(outfd != stdout)
X		fclose(outfd);
X	return(1);
X}
XEXP rdf(EXP args)
X{
Xchar  *outfile;
Xchar  ibuf[80];
XEXP retval = NIL;
X	
Xint	load_print = 0; /* silent by default */
Xint verbose = 1;
X
X	lif( null(args) )
X		return(NIL);
X	lif( lor(stringp(car(args)), bigstringp(car(args))) ) {
X		c_tostr(ibuf,car(args));
X	}
X	else  {
X    	return(NIL);
X    }
X	lwhile( lnot(null(cdr(args))) ) {
X		args = cdr (args);        /* next key */
X		if( car(args) == lookup(":verbose")  ){
X			args = cdr (args);        /* next argument */
X			if( car(args) == T ) {
X				verbose = 1;
X			}
X			else  {
X				verbose = 0;
X			}
X		}
X		else if( car(args) == lookup(":print")  ){
X			args = cdr (args);        /* next argument */
X			if( car(args) == T ) {
X				load_print = 1;
X			}
X			else  {
X				load_print = 0;
X			}
X		}
X	}
X	outfile = (char *)NULL;
X	if( rawread(ibuf, outfile, load_print, verbose ) != 0)
X		retval = T ;
X	else
X		retval = NIL;
X
X	return(retval);
X}
XEXP bclose(EXP args)
X{
Xregister EXP filename = NIL;
X
X	filename = car(args);
X	lif(lnot(filep(filename))) {
X		serr("non-file passed to close");
X		return(NIL);
X	} 
X	fclose(cor(filename));
X	return(T);
X}
X/*
X(defun reverse-aux (l rev-result)
X	(do-while l
X		(setq rev-result (cons (car l) rev-result))
X		(setq l (cdr l)))
X	rev-result)
X*/
XEXP reverse(EXP s)
X{
XEXP rev_result = NIL;
X
X	lwhile( lnot(null(s))) {
X		rev_result = cons(car(s), rev_result);
X		s = cdr(s);
X	}
X	return(rev_result);
X}
XLISPFUNC(breverse)
X{
X	return(reverse(car(args)));
X}
X/*
X(defun append2 (a b) 
X	(setq a (reverse a))
X	(do-while a
X		(setq b (cons (car a) b))
X		(setq a (cdr a)))
X	b)
X*/
XEXP append(EXP a, EXP b)
X{
X
XEXP tmp, tmp2;
X
X	tmp	= reference(reverse(a));
X	tmp2 = tmp;
X
X	lwhile( lnot(null(tmp2)) ) {
X		b = cons(car(tmp2), b);
X		tmp2 = cdr(tmp2);
X	}
X	reference(b);
X	purge(tmp);
X	dereference(b);
X	return(b);
X}
X/*
X(defun append (a &rest l)
X	(do-while l
X		(setq a (append2 a (car l)))
X		(setq l (cdr l)) )
X	a )
X*/
X
XLISPFUNC(bappend) {
XEXP l = cdr(args);
XEXP result = reference(append(car(args), car(l)));
X
X	l = cdr(l);
X	lwhile( lnot(null(l)) ) {
X		EXP tmp = reference(append(result, car(l)));
X		purge(result);
X		result = tmp;
X		l = cdr(l);
X	}
X	dereference(result);
X	return(result);
X}
X/*
X * (df backquote (_s)
X *	(_bq1 _s) )
X *
X *
X *(defun _bq1 (_s1) 
X *	(cond
X *		((or (null _s1) (atom _s1)) _s1)
X *		((equal (car _s1) 'comma) (eval (cadr _s1)))
X *		((and (not (atom (car _s1))) (equal (caar _s1) 'comma-at))
X *			(append (eval (cadar _s1)) (_bq1 (cdr _s1))))
X *
X *		(t (cons (_bq1 (car _s1)) (_bq1 (cdr _s1)))) ) )
X *
X */
X
XEXP backquote_fn( EXP s)
X{
X	lif(lor(null(s), atom(s))){
X		return(s);
X	}
X	else lif(equal(car(s), comma))  {
X		return(eval(car(cdr(s))));
X	}
X	else lif(land(lnot(atom(car(s))),equal(car(car(s)),comma_at))) {
X        EXP hold = reference(car(cdr(car(s))));
X		EXP tmp = reference(eval(hold));
X		EXP result = reference(append(tmp, backquote_fn(cdr(s))));
X		purge(tmp);
X		dereference(result); dereference(hold);
X		return(result);
X	}
X	else {
X		return(cons(backquote_fn(car(s)),backquote_fn(cdr(s))));
X	}
X}
XLISPFUNC(back)
X{
X	return(backquote_fn(car(args)));
X}
Xvoid InitParse()
X{
X	set(lookup("backquote"), newffcell(back) );
X	set(lookup("reverse"), newfcell(breverse) );
X	set(lookup("append"), newfcell(bappend) );
X
X	set(lookup("close"), newfcell(bclose) );
X	set(lookup("read"), newfcell(breads) );
X	set( lookup("load"), newfcell( rdf ));
X    set( lookup("rds"), newfcell(brds));
X	set(lookup("read-char"), newfcell(bgetcs) );
X	set(lookup("*eof*"), beof );
X
X	set(lookup(":verbose"), lookup(":verbose") );
X	set(lookup(":print"), lookup(":print") );
X}
X
X 
END_OF_FILE
if test 7701 -ne `wc -c <'parse.c'`; then
    echo shar: \"'parse.c'\" unpacked with wrong size!
fi
# end of 'parse.c'
fi
if test -f 'print.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'print.c'\"
else
echo shar: Extracting \"'print.c'\" \(6601 characters\)
sed "s/^X//" >'print.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <setjmp.h>
X#include "cells.h"
X
Xextern int linecount;
Xextern jmp_buf top_level;
Xextern int ident_char_p();
X
Xvoid fprintd(FILE *, EXP, int);
X
X
XFILE *output;
X#ifdef MSDOS
Xextern void AbortGraph();
X#else
Xvoid AbortGraph() { ;; }
X#endif
X/*****************************************************************************
X *
X *
X *
X */
Xextern EXP jmpresult;
X
Xvoid c_warn_header(char *str)
X{
X  	fprintf(stderr, "RefLisp: ***** ");
X	fprintf(stderr," %s at line %d: ", str,linecount);
X}
Xvoid c_warning(char *str, EXP exp)
X{
X        c_warn_header(str);
X	fprints(stderr,exp, PRIN1);
X        fprintf(stderr,"\n");
X	fflush(stderr);
X}
Xvoid c_error(char *str, EXP exp)
X{
X	AbortGraph();
X   	c_warning(str,exp);
X	/* set up the return value */
X	jmpresult = exp;
X
X	/* jump back to the (catch) */
X	longjmp(cvoidr(value(lookup("error-tag"))), (int) 0);
X}
XEXP c_error_func(char *str, EXP exp)
X{
X	c_error(str,exp);
X	return(NIL);
X}
Xvoid serr(char *str)
X{
X   AbortGraph();
X   fprintf(stderr, "RefLisp: ***** %s at line %d\n", str, linecount);
X	longjmp(top_level, 2);
X}
Xvoid fatal_err(char *str)
X{
X   AbortGraph();
X   fprintf(stderr, "RefLisp: %s at line %d\n", str, linecount);
X	longjmp(top_level, 3);
X}
X/*****************************************************************************
X *
X *  Print the CDR side of a list
X *
X */
Xvoid fprintd(FILE *stream, EXP x, int mode)
X{
X   lif( null(x) ){
X   }
X   else lif( consp(x) ) {
X      fprintf(stream, " ");
X      fprints(stream, car(x) , mode );
X      fprintd(stream, cdr(x) , mode);
X   }
X   else {
X      fprintf(stream, " . ");
X      fprints(stream, x, mode);
X   }
X}
X
X/*****************************************************************************
X *
X *  print out a symbol, escaping weird characters.
X *
X */
Xvoid fprin1_ident(FILE *stream, char *c)
X{
X	while( *c != '\0') {
X		if( !ident_char_p( *c ) )
X                	putc( '\\' , stream);
X		putc( *c , stream);
X      		c++;
X        }
X}
XEXP single_form(EXP x)
X{
X	lif( consp(cdr(x)) ) {
X		lif(null(cdr(cdr(x)))) {
X                	return(T);
X		}
X		else {
X                	return(NIL);
X                }
X	}
X        return(T);
X}
X/*****************************************************************************
X *
X *  print out an s-expression
X *
X */
Xvoid fprints(FILE *stream, EXP x, int mode)
X{
X 	lif( null(x) ) {
X	  fprintf(stream, " nil ");
X   }
X	else if( x == PRINTNAME ) {
X      fprintf(stream, "PNAME");
X   }
X	else
X	lif( stringp( x ) ) {
X	  if( mode == PRIN1) fprintf(stream, "\"" );
X	  if( mode == PRINSYMBOL)
X		fprin1_ident(stream, csr(x));
X          else
X		fprintf(stream, "%s", csr(x) );
X	  if( mode == PRIN1) fprintf(stream, "\"" );
X   }
X	else lif( bigstringp( x ) ) {
X
X	  if( mode == PRIN1) fprintf(stream, "\"" );
X		while(x != NIL) {
X	  		if( mode == PRINSYMBOL)
X				fprin1_ident(stream, csr(x->reg.zpair.zcar));
X   		       else
X				fprintf(stream, "%s", csr(x->reg.zpair.zcar) );
X			x = x->reg.zpair.zcdr;
X		}
X	  if( mode == PRIN1) fprintf(stream, "\"" );
X   }
X	else lif( idp( x ) ) {
X		EXP name = nameof(x);
X
X		fprints(stream, name, (mode == PRINC?PRINC:PRINSYMBOL));
X   }
X   else lif( fixp(x) ) {
X      fprintf(stream, "%d", cir(x));
X   }
X   else lif( floatp(x) ) {
X	   fprintf(stream, "%g", cflor(x));
X   }
X   else lif( filep(x) ) {
X      fprintf(stream, "<file:%ld>",cor(x));
X   }
X   else lif( subrp(x) ) {
X      fprintf(stream, "<subr:%ld>",cfr(x));
X   }
X   else lif( fsubrp(x) ) {
X      fprintf(stream, "<fsubr:%ld>",cfr(x));
X   }
X   else lif( consp(x) ) {
X	if( mode == PRIN1) {
X		lif(eq(car(x), quote)) {
X			lif(single_form(x)) {
X				fprintf(stream, "'");
X				fprints(stream, car(cdr(x)),mode);
X				return;
X                        }
X		}
X                else lif(eq(car(x), backquote)) {
X			lif(single_form(x)) {
X				putc(BQUOTECHAR,stream);
X				fprints(stream, car(cdr(x)),mode);
X				return;
X			}
X                }
X		else lif(eq(car(x), comma)) {
X			lif(single_form(x)) {
X				putc(COMMACHAR,stream);
X				fprints(stream, car(cdr(x)),mode);
X				return;
X                	}
X		}
X		else lif(eq(car(x), comma_at)) {
X			lif(single_form(x)) {
X				putc(COMMACHAR,stream);
X				putc(ATCHAR,stream);
X				fprints(stream, car(cdr(x)),mode);
X                                return;
X			}
X		}
X		else lif(eq(car(x), func_quote)) {
X			lif(single_form(x)) {
X				putc(FUNCCHAR,stream);
X				putc(QUOTECHAR,stream);
X				fprints(stream, car(cdr(x)),mode);
X                                return;
X                        }
X		}
X	}
X
X	fprintf(stream, "(");
X	fprints(stream, car(x), mode);
X	fprintd(stream, cdr(x), mode);
X	fprintf(stream, ")");
X
X   }
X
X	else fprintf(stream, " something else");
X
X}
X/*****************************************************************************
X
X *
X *
X *
X */
Xvoid c_prints(EXP x)
X{
X   fprints(stdout, x, PRINC);
X}
X
XEXP bprinc1(EXP args, int mode)
X{
X	lif( consp(args) ) {
X		lif( lnot(null(cdr(args)))) {
X			fprints(cor(car(cdr(args))), car(args), mode);
X		}
X                else {
X			fprints(output, car(args), mode);
X                }
X	}
X   	return( car(args) );
X}
XEXP bprinc(EXP args) 
X{
X	return(bprinc1(args,PRINC));
X}
XEXP bprin1(EXP args) 
X{
X	return(bprinc1(args,PRIN1));
X}
XEXP bwrs(EXP args)
X{ 
XEXP tmp = NIL;
Xtrace("bwrs: ");
Xtrace_exp(args);
X
X	tmp = newocell(output);
X	output = cor(car(args));
X   	return( tmp );
X}
XEXP bwrite(EXP args)
X{
Xregister EXP filename = NIL;
XFILE *fd;
X
X	filename = car(args);
X	lif( lnot(filep(filename))) {
X		c_error("non-file in write",filename);
X		return(NIL);
X	}
X	else 
X		fd = cor(filename);
X
X	args = cdr(args);
X	while( args != NIL) {
X		fprints(fd,car(args) , PRINC);
X		args = cdr(args);
X	}
X	return(T);
X}
XEXP bputcs(EXP args)
X{
Xregister EXP filename= NIL;
XFILE *fd;
X
X	lif( null(cdr(args)) )
X		fd = stdout;
X	else {
X		filename = car(cdr(args));
X		lif(lnot(filep(filename))) {
X			serr("non-file passed to putc");
X			return(NIL);
X		}
X		else 
X			fd = cor(filename);
X	}
X	putc( cir(car(args))&127, fd );
X	return(T);
X}
XEXP bflush(EXP args)
X{
XFILE *fd;
Xregister EXP filename = NIL;
X
X	lif( null(args) )
X		fd = stdout;
X	else {
X		filename = car(args);
X		lif( lnot(filep(filename))) {
X			serr("non-file passed to flush");
X			return(NIL);
X		}
X		fd = cor(filename);
X	} 
X	fflush(fd);
X	return(T);
X}
X
Xvoid InitPrint()
X{
X   output = stdout;
X   set(lookup("force-output"), newfcell(bflush) );
X   set(lookup("*standard-output*"), newocell(stdout));
X   set(lookup("*standard-input*"), newocell(stdin));
X   set(lookup("*error-output*"), newocell(stderr));
X   set(lookup("write-char"), newfcell(bputcs) );
X   set( lookup("prin1"), newfcell(bprin1));
X   set( lookup("princ"), newfcell(bprinc));
X   set( lookup("write"), newfcell(bwrite));
X   set( lookup("wrs"), newfcell(bwrs));
X}
X 
END_OF_FILE
if test 6601 -ne `wc -c <'print.c'`; then
    echo shar: \"'print.c'\" unpacked with wrong size!
fi
# end of 'print.c'
fi
if test -f 'symtab.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'symtab.c'\"
else
echo shar: Extracting \"'symtab.c'\" \(13197 characters\)
sed "s/^X//" >'symtab.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <string.h>
X#include <values.h>
X#include "cells.h"
X
Xextern int trace_on;
X
Xextern EXP UNBOUND;
Xextern EXP PRINTNAME;
X
XEXP oblist = NIL;
XEXP question = NIL;
X
XEXP hashtab[HASHMODULO];
X/*
X * Function hand-builds a symbol, for bootstrap purposes.
X */
Xvoid new_constant(char *str, EXP acell, EXP initial)
X{
X		acell->ztype = CONSTANT;
X		acell->zcount = MAXINT; /* i.e. very big ! */
X		acell->reg.zpair.zcar = initial;
X		acell->reg.zpair.zcdr = reference(cons(cons(PRINTNAME,newscell(str)),NIL));
X}
X/******************************************************************************
X *
X * Basic property list routines.
X *
X */
XEXP eputprop(EXP symbol, EXP val, EXP prop)
X{
XEXP proplist = NIL ,var = NIL,oldhead = NIL,props = NIL;
X
X  /*	lif( lor( null(symbol) , null(prop)) )
X		return(NIL);            */
X
X	oldhead = zprops(symbol);
X	proplist = zprops(symbol);
X	var = symbol;
X
X	val = reference( val);	/* protection */
X	while(proplist != NIL) {
X		if( prop == car(car(proplist)) ) {
X			/* Found the property, so replace the value */
X			purge( cdr(car(proplist)));
X			car(proplist)->reg.zpair.zcdr = val ;
X			return( cdr(car(proplist)));
X		}
X		proplist = cdr(proplist);
X	}
X	/* property not found so add it to the head of the list */
X		
X	dereference(oldhead);
X	props = cons(cons(prop,val),oldhead);
X	var->reg.zpair.zcdr = reference(props) ;
X	dereference(val);
X	return( val );
X	
X}
XEXP bputprop(EXP args) 
X{
X	return(eputprop(car(args),car(cdr(cdr(args))),car(cdr(args))));
X}
XEXP getprop(EXP symbol, EXP prop)
X{
XEXP proplist = NIL;
X
X   /*	if( symbol == NIL || prop == NIL)
X		return(NIL);             */
X	proplist = zprops(symbol);
X
X	while(proplist != NIL) {
X		if( prop == car(car(proplist)) ) {
X			/* Found the property, so return the value */
X			return( cdr(car(proplist)));
X		}
X		proplist = cdr(proplist);
X	}
X	/* property not found so return NIL */
X	return( NIL);
X}
XEXP bgetprop(EXP args)
X{
X	return(getprop(car(args),car(cdr(args))));
X}
X/******************************************************************
X *
X *	Function to completely remove a property from the 
X *	property list of a symbol.
X */
XEXP remprop(EXP symbol, EXP prop)
X{
XEXP result = NIL ,prev = NIL;
XEXP plst = zprops(symbol);	/* point to plist of the symbol */
X
X	lwhile( plst ) {
X	if( car(car(plst)) == prop) {
X			if( prev == NIL ) { 	/* head of list */
X				symbol->reg.zpair.zcdr = cdr(plst);
X			}
X			else {
X				prev->reg.zpair.zcdr = cdr(plst);
X			}
X			plst->reg.zpair.zcdr = NIL;
X			result = reference(cdr(car(plst)));
X			purge(plst);
X			dereference(result);
X			return(result);
X		}
X		prev = plst;
X		plst = cdr(plst);
X	}
X	return(NIL);
X}
XEXP bremprop(EXP args)
X{
X	return(remprop(car(args),car(cdr(args))));
X}
X/******************************************************************************
X *
X *
X *
X */
Xchar *pname(EXP x)
X{
X	lif( land( lnot(null(x)) , idp(x))) {
X		return(csr(getprop(x,PRINTNAME)));
X	}
X	else {
X		serr("nil passed to pname");
X		return((char *)NULL);
X	}
X}
XEXP bplist(EXP args)
X{
XEXP symbol = NIL, result = NIL, tmp = NIL;
X
X	lif( null(args) )
X		return(NIL);
X
X	symbol = car(args);
X /*	lif( null(symbol) )
X		return(NIL);    */
X   	result = NIL;
X   	tmp = zprops(symbol);
X   	while(tmp != NIL ) {
X		result = cons( cdr(car(tmp)), result);
X		result = cons( car(car(tmp)), result);
X		tmp = cdr(tmp);
X   	}
X   return(result);
X
X}
X/******************************************************************************
X *
X *
X *
X */
Xint hashstr(char *str)
X{
Xint i,retval,hashed = 0;
X
X	i=0;
X	while( str[i] != 0 && i <LEN_STRING-1 ) {
X		hashed ^= str[i]; /* exclusive OR */
X		i += 1;
X	}
X	retval = (hashed)%HASHMODULO ;
X	return( retval );
X}
Xint hashbstr(EXP x)
X{
X	EXP tmp = x;
X	int val = 55;
X
X	lwhile( lnot(null(tmp))) {
X			val ^= hashstr(csr(tmp->reg.zpair.zcar));
X			tmp = tmp->reg.zpair.zcdr;
X	}
X	return((val)%HASHMODULO);
X}
XEXP outsym(EXP args, EXP proforma);
XEXP addsym(EXP args, EXP proforma);
X
XEXP lookup(char *str)
X{
XEXP tmp, symname = NIL;
X
X	if((int)strlen(str) < (int)LEN_STRING) {
X		symname = reference(newscell(str));
X	}
X	else {
X		symname = reference(newbigstring(str));
X	}
X	tmp = addsym(symname,symname);
X    purge(symname);
X	return(tmp);
X}
XEXP nameof(EXP x)
X{
X	lif( idp(x) ) {
X		return(getprop(x,PRINTNAME));
X	}
X	else {
X		serr("non-symbol passed to symbol-name");
X		return(NIL);
X	}
X}
XLISPFUNC(bsymval)
X{
XEXP ident = car(args);
X
X   lif( idp(ident) ) {
X	  if( zapval(ident ) != UNBOUND)
X      	 return( zapval(ident) ); /* apval in car */
X	   else {
X		 c_error(":value: cannot value non-symbol",ident);
X		return(NIL);
X	  }
X   }
X   else {
X	  c_error(":value: cannot value non-symbol",ident);
X      return(NIL);
X   }
X}
XLISPFUNC(bnameof)
X{
X	return(nameof(car(args)));
X}
X/*
X * 	Function to provide a hash number for an s-expression.
X */
Xint hashany(EXP x)
X{
X	lif( stringp(x) ) {
X		return(hashstr(csr(x)));
X	}
X	else lif( bigstringp(x) ) {
X		return(hashbstr(x));
X	}
X	else {
X		return( hashanyaux(x) );
X	}
X}
Xint hashanyaux(EXP x)
X{
Xint retval;
X
X	lif( null(x) ) {
X		retval = 0;
X	}
X	else lif( atom(x) ) {
X    	retval = 1;
X	}
X	else {
X		retval = 2*(hashanyaux(car(x)) + hashanyaux(cdr(x)));
X	}
X	return(retval%HASHMODULO) ;
X}
XLISPFUNC(bash)
X{
X	return(newicell(hashany(car(args))));
X}
XEXP newidcell(EXP print_name)
X{
XEXP symbol = NIL;
X
X   symbol = cons(UNBOUND,NIL);
X   symbol->ztype = IDENTIFYER;
X   symbol->zcount = 0;
X#ifndef LINT
X	/* we don't use return so lint objects */
X   eputprop(symbol, print_name, PRINTNAME);
X#else
X   print_name = print_name; /* for lint */
X#endif
X   return(symbol);
X}
XEXP outsym(EXP any, EXP proforma)
X{
XEXP symbol = NIL;
Xint bucket;
X
X   /*
X	* Just add the symbol, even if one is already present.
X	*/
X
X	bucket = hashany(proforma) ;
X	symbol = newidcell(any);
X   hashtab[bucket] = reference(cons(symbol,hashtab[bucket]));
X   return(symbol);
X
X}
Xvoid intern_sym(EXP symbol)
X{
Xint bucket;
X
X   /*
X	* Add a symbol , created manually or not yet interned.
X	*/
X
X	bucket = hashany(nameof(symbol)) ;
X   hashtab[bucket] = reference(cons(symbol,hashtab[bucket]));
X
X}
X
XLISPFUNC(boutsym)
X{
XEXP item = NIL, proforma = NIL;
X
X		  item = car(args);
X		  lif( null(cdr(args)) )
X			proforma = item;
X		  else
X			proforma = car(cdr(args));
X		  return(outsym(item, proforma));
X}
X
XEXP addsym(EXP any, EXP proforma)
X{
XEXP tmp = NIL, symbol = NIL;
Xint bucket;
X
X
X	lif(stringp(any)) {
X		if(strcmp(csr(any), "nil") == (int)0)  {
X			return(NIL);
X		}
X    }
X	lif( idp(any) )
X		return(any);
X	bucket =   hashany(proforma);
X   tmp = hashtab[bucket];
X   while(tmp != NIL ) {
X		symbol = car(tmp);
X		lif( equal(nameof(symbol),any)) {
X		 /*
X		  * The symbol is already in the table
X		  */
X		 return(symbol);
X      }
X   tmp = cdr(tmp);
X
X   }
X   /*
X    * The symbol is not in the symbol table, so add it
X    */
X	return(outsym(any, proforma));
X}
X
XLISPFUNC(baddsym)
X{
XEXP item = NIL, proforma = NIL;
X
X		  item = car(args);
X		  lif( null(cdr(args)) )
X			proforma = item;
X		  else
X			proforma = car(cdr(args));
X		  return(addsym(item, proforma));
X}
X/*
X% Function to compare two s-expressions
X% returns t if there is a match.
X% '? in the mask stands for any value
X%
X*/
XEXP match(EXP mask, EXP y)
X{
X	lif( equal(mask, question) )
X		return(T);
X	else lif( equal( mask, y))
X		return(T);
X	else {
X		lif( land(consp(mask) , consp(y)) ) {
X			lif( land( match(car(mask), car(y)) , match(cdr(mask), cdr(y))))
X				return(T);
X			else
X				return(NIL);
X		}
X		else
X        	return(NIL);
X	}
X
X}
XLISPFUNC(bmatch)
X{
X	return(match(car(args), car(cdr(args))));
X}
XEXP rdsym(EXP mask)
X{
XEXP tmp = NIL,symbol = NIL;
Xint bucket;
X
X	lif( idp(mask) )  {
X		mask = nameof(mask); /* because we want to compare raw names */
X	}
X	bucket =   hashany(mask) ;
X   tmp = hashtab[bucket];
X   while(tmp != NIL ) {
X		symbol = car(tmp);
X		lif( match(mask, nameof(symbol))) {
X		 /*
X		  * A matching symbol is in the table
X		  */
X		 return(symbol);
X      }
X   tmp = cdr(tmp);
X
X   }
X   /*
X	* The symbol is not in the symbol table, so NIL
X    */
X	return(NIL);
X}
XLISPFUNC(brdsym)
X{
X	      return(rdsym(car(args)));
X}
X/*****************************************************************************
X * Doesn't de-allocate memory yet.
X */
XEXP insym(EXP x)
X{
XEXP tmp = NIL, symbol = NIL, prev = NIL;
Xint bucket;
X
X	lif( idp(x) )  {
X		x = nameof(x); /* because we want to compare raw names */
X	}
X	bucket = hashany(x);
X	tmp = hashtab[bucket];
X  	while( tmp != NIL ) {
X	  		symbol = car(tmp);
X		lif( match(x, nameof(symbol)) ) {
X			/* The symbol is in the table, so remove it */
X			EXP retval = NIL;
X
X			if( prev == NIL )       /* Head of the list? */
X				hashtab[bucket] = cdr(tmp);
X			else {
X				prev->reg.zpair.zcdr = cdr(tmp);
X			}
X			retval = reference(nameof(symbol));
X			tmp->reg.zpair.zcdr=NIL; /* so purge doesn't see all symbols */
X			purge(tmp);
X            dereference(retval);
X			return(retval);
X      	}
X      	prev = tmp;
X      	tmp = cdr(tmp);       /* select the next in the list */
X   	}
X     return(NIL);
X}
XLISPFUNC(binsym)
X{
X	return(insym(car(args)));
X}
X/***********************************************************************/
XLISPFUNC(boblist)
X{
XEXP result = NIL,tmp = NIL;
Xint i;
X
X	args = args;   /* shuts up compiler warnings about unused */
X
X   	result = NIL;
X	for(i=0;i<HASHMODULO;i++) {
X   		tmp = hashtab[i];
X
X   		while(tmp != NIL ) {
X			tmp->zcount++; /* What is this for ? */
X			result = cons( car(tmp), result);
X   			tmp = cdr(tmp);
X   		}
X	}
X   	return(result);
X}
X
X/****************************************************************************
X *
X *
X *
X */
Xvoid set( EXP identifyer, EXP valu )
X{
X   lif( land(idp(identifyer),lnot(constantp(identifyer))) ) {
X   
X	  valu = reference( valu);	/* prevent next unlink from deleting valu
X							 * as in (setq x  x)
X							 */
X      purge( zapval(identifyer) ); /* apval in car */
X      identifyer->reg.zpair.zcar = valu ;
X   }
X   else {
X		  c_prints(identifyer);
X	      c_error(" can't set to a nonidentifier or constant",identifyer);
X   }
X}
X/****************************************************************************
X *
X *
X *
X */
X
XEXP value(EXP ident)
X{
X   lif( idp(ident) ) {
X      return( zapval(ident) ); /* apval in car */
X   }
X   else {
X      c_error(":value: cannot value non-identifyer",ident);
X      return(NIL);
X   }
X}
XEXP boundp(EXP ident)
X{
X
X	  if( value(ident ) == UNBOUND)
X			return(NIL);
X	  else
X			return(T);
X}
XLISPFUNC(bboundp)  { return( boundp(car(args)) ); }
XEXP bdefconstant(EXP args)
X{
XEXP result = eval( car(cdr(args)) );
X
X	set( car(args), result );
X    car(args)->ztype = CONSTANT;
X	return( result ); 
X}
XLISPFUNC(bset)
X{ 
X	set(car(args),car(cdr(args)));
X	return(car(cdr(args))); 
X}
X
XLISPFUNC(emksymbol)
X{
X	return( lookup(csr(car(args))) );
X}
X/******************************************************************
X *
X *	Function to create a unique symbol.
X */
Xstatic int new_symbol = 1;
XLISPFUNC(bgensym)
X{
Xchar new_name[LEN_STRING];
X
X	args = args; /* shut up lint */
X	lif(args) {
X		new_symbol = cir(car(args));
X	}
X	sprintf(new_name,"G%d",new_symbol++);
X	return(newidcell(newscell(new_name)));
X}
X/******************************************************************** 
X *
X * Object Oriented Function to search a class tree for a slot.
X */
XEXP quote_class = NIL;
X
XLISPFUNC(bslot)
X{
XEXP object = car(args);
XEXP slot = car(cdr(args));
X
XEXP class = NIL;
XEXP superclass = NIL;
XEXP val = NIL;
X
X		switch( object->ztype ) {
X			case   PAIR : 		class = lookup("cons");			break;
X			case   INTEGER :	class = lookup("fixnum");		break;
X			case   SUBRP :		class = lookup("subr");		break;
X			case   FSUBRP :		class = lookup("fsubr");		break;
X			case   STRING :		class = lookup("string");		break;
X			case   FILEPTR :	class = lookup("stream");		break;
X			case   FLOAT :		class = lookup("float");		break;
X			case   BIGSTRING :	class = lookup("string");	break;
X			case   CONSTANT :
X			case   IDENTIFYER :	class = object;					break;
X		}
X		if( slot == quote_class ) {
X			lif( lnot(idp(object)))
X				return(class);
X			else {
X				lif( null(getprop(class, slot)))
X					return(lookup("symbol"));
X			}
X		}
X		val = getprop(class, slot);
X		lwhile( null(val) ) {
X			superclass = getprop(class, quote_class);
X			lif(null(superclass)) {
X				 c_error("object has no slot",cons(object,slot));
X			}
X			else {
X				class = superclass;
X				val = getprop(class, slot);
X			}
X		}
X		return(val);
X}
Xvoid InitSymtab()
X{
X   set( lookup("defconstant"), newffcell(bdefconstant));
X   set( lookup("set"), newfcell(bset));
X   set( lookup("hash"), newfcell(bash));
X   set( lookup("boundp"), newfcell(bboundp));
X   set( lookup("oblist"), newfcell( boblist ));
X   set( lookup("symbol-plist"), newfcell( bplist ));
X   set( lookup("symbol-name"), newfcell( bnameof ));
X   set( lookup("symbol-value"), newfcell( bsymval ));
X   set( lookup("put"), newfcell(bputprop));
X   set( lookup("get"), newfcell(bgetprop));
X   set( lookup("intern"), newfcell(emksymbol));
X   set(lookup("remprop"), newfcell(bremprop));
X   set(lookup("gensym"), newfcell(bgensym));
X
X   /* linda-esque stuff */
X   question = reference( lookup("*"));
X   set( lookup("_match"), newfcell(bmatch));
X   set( lookup("outsym"), newfcell(boutsym));	
X   set( lookup("addsym"), newfcell(baddsym));
X   set( lookup("rdpsym"), newfcell(brdsym));
X   set( lookup("inpsym"), newfcell(binsym));
X
X/*
X * Object Oriented Stuff 
X */
X   quote_class = reference( lookup("class"));
X	set(lookup("slot"), newfcell(bslot));
X}
X 
END_OF_FILE
if test 13197 -ne `wc -c <'symtab.c'`; then
    echo shar: \"'symtab.c'\" unpacked with wrong size!
fi
# end of 'symtab.c'
fi
if test -f 'unix.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'unix.c'\"
else
echo shar: Extracting \"'unix.c'\" \(7032 characters\)
sed "s/^X//" >'unix.c' <<'END_OF_FILE'
X#include <stdlib.h>
X#include <stdio.h>
X#include "cells.h"
X#include <time.h>
X#include <limits.h>
X#include <setjmp.h>
X#include <errno.h>
X#include <string.h>
X#ifdef MSDOS
X#include <process.h>
X#include <time.h>
X#include <signal.h>
X#include <dir.h>
X#include <dos.h>
X#endif
X#ifdef LASER
X#include <osbind.h>
Xtypedef union {
X	struct {
X		unsigned day : 5;
X		unsigned month :4 ;
X		unsigned year : 7;
X		unsigned seconds :5 ;
X		unsigned minutes : 6;
X		unsigned hours : 5;
X	} part;
X	long realtime;
X} time;
Xtime mytime;
X#endif
Xextern int errno;
Xextern void *malloc(size_t);
X
X
XLISPFUNC(egettime)
X{
X	args = args;     /* ARGSUSED */
X
X#ifdef LASER
X	mytime.realtime = Gettime(); 
X	return(cons(newicell((int)mytime.part.hours),
X	cons(newicell((int)mytime.part.minutes),
X	cons(newicell((int)mytime.part.seconds*2),
X	cons(newicell((int)mytime.part.day),
X	cons(newicell((int)mytime.part.month),
X	cons(newicell((int)mytime.part.year + 80), NIL)))))));
X#else
X	/* ANSI */
X	{  time_t now;
X		struct tm *gmt_now;
X		daylight = 0;
X		time(&now);
X		gmt_now = localtime(&now);
X
X	return(
X	cons(newicell((int)gmt_now->tm_sec),
X	cons(newicell((int)gmt_now->tm_min),
X	cons(newicell((int)gmt_now->tm_hour),
X	cons(newicell((int)gmt_now->tm_mday),
X	cons(newicell((int)gmt_now->tm_mon+1),
X	cons(newicell((int)gmt_now->tm_year),
X	cons(newicell((int)(gmt_now->tm_wday+6)%7),
X	cons(NIL,
X	NIL)))))))));
X	}
X#endif
X}
XLISPFUNC(egetUtime)
X{
X	args = args;     /* ARGSUSED */
X
X#ifdef LASER
X#else
X	/* ANSI */
X	{
X	time_t now = time((time_t *)NULL) ;
X		return(newflocell((float) now ));
X	}
X#endif
X}
Xstatic time_t last_time;
X
XLISPFUNC(egetdifftime)
X{
X	args = args;     /* ARGSUSED */
X
X#ifdef LASER
X#else
X	/* ANSI */
X	{
X	time_t now = time((time_t *)NULL) ;
X	int diff = now - last_time;
X
X		last_time = now;
X		return(newicell(diff));
X	}
X#endif
X}
XLISPFUNC(eatoi)
X{
X	return(newicell(atoi(csr(car(args)))));
X}
XLISPFUNC(eitoa)
X{
Xchar str[40];
X
X	sprintf(str,"%d", cir(car(args)) );
X	return(newscell(str));
X}
XLISPFUNC(efloat_to_ascii)
X{
Xchar format[20];
Xchar str[40];
X
X	int width = cir(nth(1,args));
X	int precision = cir(nth(2,args)) % 40;
X	strcpy(format, "%g");
X	if( nth(3,args) == T)
X		sprintf(format,"%%0%d\.%df", width, precision);
X	else
X		sprintf(format,"%%%d\.%df", width, precision);
X    	
X	sprintf(str, format , cflor(car(args)) );
X	return(newbigstring(str));
X}
X
XLISPFUNC(bsystem)	/* Keep lint happy by always having an extern visible */
X{
X
X#ifdef UNIX
X#define NARGS 20
Xchar *pathname, *argv[NARGS+1];
Xint c = 0;
Xint pid = 0;
X
X	pathname = malloc(c_lenstr(car(args)));
X	c_tostr(pathname ,car(args));
X
X	while( args != NIL && c < NARGS ) {
X		argv[c] =  malloc(c_lenstr(car(args)));
X		c_tostr(argv[c++] ,car(args));
X		args = cdr(args);
X	}
X	argv[c] = NULL;
X	if( (pid = fork()) == 0) { /* child */
X		execvp(pathname,argv);
X	}
X	else {	/* parent */
X	int status;
X		if( pid == -1) {
X			return(newicell(errno));
X		}
X		else {
X			wait(&status);
X			for(c -= 1; c >0 ; c--)
X				free((void *)argv[c]);
X			free((void *)pathname);
X			return(newicell(status));
X		}
X	}
X#else
X#define NARGS 20
Xchar buffer[80],  *pathname, *argv[NARGS+1];
Xint c = 0, retval;
X
X	c_tostr(buffer ,car(args));
X	pathname = malloc((size_t)strlen(buffer));
X	strcpy(pathname, (const char *)buffer);
X
X	while( args != NIL && c < NARGS ) {
X		c_tostr(buffer ,car(args));
X		argv[c] =  malloc((size_t)strlen(buffer));
X		strcpy(argv[c++], (const char *)buffer);
X		args = cdr(args);
X	}
X	argv[c] = NULL;
X#ifdef MSDOS
X	retval = spawnvp((int)0,pathname,argv);
X#else
X	retval = execv(pathname,argv);
X#endif
X	for(c -= 1; c >0 ; c--)
X		free((void *)argv[c]);
X	return(newicell(retval));
X
X#endif
X}
X
XLISPFUNC(bstop)
X{
X	lif(lnot(null(args)))
X		exit(cir(car(args)));
X	else
X		exit((int)0);
X    return(NIL);
X}
XLISPFUNC(bgetenv)
X{
Xchar *envar;
Xchar buffer[80];
X
X	c_tostr(buffer ,car(args));
X
X	envar = getenv(buffer);
X	if( envar == (char *)NULL) {
X		return(NIL);
X	}
X	else {
X		return(newbigstring(envar));
X        }
X}
X
X#ifdef MSDOS
XLISPFUNC(bchdir)
X{
Xchar buffer[MAXPATH];
X
XEXP retval;
X
X	/* get the old directory */
X	getcwd(buffer, MAXPATH);
X	retval = newbigstring(buffer);
X
X	c_tostr(buffer ,car(args));
X	if( chdir(buffer) != 0) {
X		return(NIL);
X	}
X	else {
X		return(retval);
X        }
X}
XLISPFUNC(bdir)
X{
Xchar buffer[MAXPATH];
Xstruct ffblk ffblk;
Xint done;
XEXP retval = NIL;
X
X   c_tostr(buffer ,car(args));
X   done = findfirst(buffer,&ffblk, 0xff);
X   while (!done) {
X      retval = cons( newbigstring(ffblk.ff_name), retval);
X      done = findnext(&ffblk);
X   }
X
X   return(retval);
X
X}
X#endif
XLISPFUNC(bopen)
X{
XFILE *retval;
Xchar name[80],*modus;
XEXP mode = NIL;
X
X	c_tostr(name, car(args));
X	lif( null(cdr(args))) {
X		modus = "r";
X	}
X	else {
X		mode = nth(2, args);
X		lif(equal(mode,lookup(":input"))) {
X			modus = "r";
X		}
X		else lif(equal(mode,lookup(":output"))) {
X			modus = "w";
X		}
X		else {
X			c_error("is not option for OPEN",mode);
X		}
X	}
X	retval = fopen(name,modus);
X#ifndef LINT
X	/* lint complains about "possible pointer alignment problem, o CAST" */
X	if( retval == (FILE *)NULL) {
X		c_error("could not be opened", car(args));
X		return(NIL);
X	}
X	else
X#endif
X		return(newocell(retval));
X}
XEXP jmpresult = NIL;
X
Xextern EXP evprogn(EXP);
XLISPFUNC(bcatch)
X{
Xjmp_buf jumper;
XEXP tag, oldtag, retval;
X
X	tag = eval(car(args));
X        oldtag = reference(value(tag));
X	set( tag , newvoidcell((void *)&jumper));
X	if (setjmp(jumper) != 0) {
X        	dereference(oldtag);
X		set(tag, oldtag);
X		return(jmpresult);
X	}
X	retval = evprogn(cdr(args));
X        dereference(oldtag);
X	set(tag, oldtag);
X	return(retval);
X
X}
XLISPFUNC(bthrow)
X{
XEXP tag = eval(car(args));
X
X	jmpresult = car(cdr(args));
X	longjmp(cvoidr(tag), (int) 0);
X        return(NIL); /* never executed */
X
X}
XLISPFUNC(bstrerrno)
X{
X	args = args;     /* ARGSUSED */
X	return(newbigstring(strerror(errno)));
X}
XLISPFUNC(berrno)
X{
X	args = args;     /* ARGSUSED */
X	return(newicell(errno));
X}
Xchar *InitOS()
X{
X   char *envar;
X
X#ifdef LASER
X#else
X#ifdef MSDOS
X	putenv("TZ=GMT00");
X#endif
X	tzset();
X
X	/* ANSI */
X	last_time = time((time_t *)NULL) ;
X#endif
X
X   set(lookup("strerrno"), newfcell(bstrerrno) );
X   set(lookup("errno"), newfcell(berrno) );
X   set(lookup("open"), newfcell(bopen) );
X   set( lookup("get-universal-time"), newfcell(egetUtime));
X   set( lookup("get-diff-time"), newfcell(egetdifftime));
X   set( lookup("get-decoded-time"), newfcell(egettime));
X   set( lookup("atoi"), newfcell(eatoi));
X   set( lookup("itoa"), newfcell(eitoa));	
X   set( lookup("ftoa"), newfcell(efloat_to_ascii));
X   set( lookup("system"), newfcell(bsystem));	
X   set( lookup("exit"), newfcell(bstop));	
X   set( lookup("getenv"), newfcell(bgetenv));
X
X   set( lookup("catch"), newffcell(bcatch));
X   set( lookup("throw"), newfcell(bthrow));
X#ifdef MSDOS
X   set( lookup("directory"), newfcell(bdir));
X   set( lookup("chdir"), newfcell(bchdir));
X#endif
X
X   set(lookup(":direction"), lookup(":direction") );
X   set(lookup(":input"), lookup(":input") );
X   set(lookup(":output"), lookup(":output") );
X
X	envar = getenv("LISPINIT");
X	if( envar == (char *)NULL) {
X   		return("init.lsp");
X	}
X	else {
X		return(envar);
X        }
X
X}
X
X 
END_OF_FILE
if test 7032 -ne `wc -c <'unix.c'`; then
    echo shar: \"'unix.c'\" unpacked with wrong size!
fi
# end of 'unix.c'
fi
if test -f 'ipc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ipc.c'\"
else
echo shar: Extracting \"'ipc.c'\" \(1499 characters\)
sed "s/^X//" >'ipc.c' <<'END_OF_FILE'
X#ifdef UNIX
X#include <stdlib.h>
X#include <stdio.h>
X#include "cells.h"
X#include <time.h>
X#include <limits.h>
X#include <setjmp.h>
X#include <string.h>
X#include <errno.h>
X#include <sys/types.h>
X#include <sys/ipc.h>
X#include <sys/sem.h>
X
XLISPFUNC(bsemctl)
X{
Xint id = cir(car(args));
Xint num = cir(nth((int)1, args));
Xint cmd = cir(nth((int)2, args));
Xunion semun {
X	int val;
X	struct semid_ds *buf;
X	ushort *array;
X} arg;
Xarg.val = cir(nth((int)3, args));
X
X	return(newicell(semctl(id,num,cmd,arg.val)));
X}
XLISPFUNC(bsemget)
X{
Xkey_t key = cir(car(args));
Xint nsems = cir(nth((int)1, args));
Xint flag = cir(nth((int)2, args));
X
X	return(newicell(semget(key,nsems,flag)));
X}
XLISPFUNC(bsemop)
X{
Xint semid = cir(car(args));
Xstruct sembuf sops[1];
X
Xsops[0].sem_num = cir(nth((int)1, args));
Xsops[0].sem_op = cir(nth((int)2, args));
Xsops[0].sem_flg = cir(nth((int)3, args));
X
X	return(newicell(semop(semid,&sops,(int)1)));
X}
XLISPFUNC(bpipe)
X{
Xint fildes[2];
X
X	args = args;     /* ARGSUSED */
X
X	if(pipe(fildes) != 0) {
X		return(newbigstring(strerror(errno)));
X	}
X	else {
X		return(cons(newocell(fdopen(fildes[0],"r")),
X			newocell(fdopen(fildes[1],"w")) ));
X
X	}
X}
XLISPFUNC(bfork)
X{
X	args = args;     /* ARGSUSED */
X
X	return(newicell(fork()));
X}
X#endif
Xchar *InitIPC()
X{
X#ifdef UNIX
X   set(lookup("pipe"), newfcell(bpipe) );
X
X   set(lookup("fork"), newfcell(bfork) );
X
X   set(lookup("semctl"), newfcell(bsemctl) );
X   set(lookup("semget"), newfcell(bsemget) );
X   set(lookup("semop"), newfcell(bsemop) );
X#endif
X
X}
X
X
END_OF_FILE
if test 1499 -ne `wc -c <'ipc.c'`; then
    echo shar: \"'ipc.c'\" unpacked with wrong size!
fi
# end of 'ipc.c'
fi
if test -f 'view.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'view.c'\"
else
echo shar: Extracting \"'view.c'\" \(10882 characters\)
sed "s/^X//" >'view.c' <<'END_OF_FILE'
X
X#ifdef UNIX
Xvoid InitView() {};
X#endif
X#ifdef MSDOS
X#include <stdio.h>
X#include <math.h>
X#include "cells.h"
X#define DIVIDE_BY_ZERO 99999.9
X
X#define NUMOFFIELDS 8
Xtypedef struct { float x; float y; float z; } coord_3d ;
Xtypedef struct { float x; float y; } coord_2d ;
Xtypedef struct { int x; int y; } pixel_2d;
Xtypedef struct { pixel_2d alpha; pixel_2d beta; } scrvec_2d;
Xtypedef struct { coord_3d alpha; coord_3d beta; } vector_3d;
Xtypedef int pixel;
Xtypedef float ordinate;
X#define pi (3.1415926535)
X#define deg_to_rad ( (2*pi)/360 )
X
Xtypedef float degrees;
X
Xtypedef struct {
X	coord_3d shift;
X	degrees xangle;
X	degrees yangle;
X	degrees zangle;
X	} orientation;
X
Xtypedef struct {
X	ordinate focal_length;
X	float ypixperm;	/* Pixels per metre */
X	float xpixperm;	/* Pixels per metre */
X	pixel offx;
X	pixel offy; 
X	float wheelbase;	/*
X				 * notional distance between camera and rear
X				 * axle of vehicle, used in curved segments
X				 */
X	} calibration;
X
X
Xdouble sinla, /* SinLastAngle */ SinLastResult;
Xdouble cosla, /* CosLastAngle */ CosLastResult;
X#define fpequals(a,b) (a-b<1.0E-10)
X
X#define VPLANE (0.3)  /* 30cm don't show line closer than this */
X
X/*
Xint matherr(x)
Xstruct exception *x;
X{
Xchar *str;
X
Xswitch( x->type) {
Xcase DOMAIN : str = "DOMAIN"; break;
Xcase SING : str = "SING"; break;
Xcase OVERFLOW : str = "OVERFLOW"; break;
Xcase PLOSS : str = "PLOSS"; break;
Xcase TLOSS : str = "TLOSS"; break;
Xcase UNDERFLOW : str = "UNDERFLOW"; break;
X
X}
Xprintf("matherr: %s name %s args %g %g ret %g\n", 
X				str, x->name, x->arg1, x->arg2, x->retval);
Xreturn(1);
X} 
X*/
X
Xvoid v_init_trig()
X{
X	SinLastResult = sin( (double) (sinla = 0));
X	CosLastResult = cos( (double) (cosla = 0));
X}
X
X#ifdef ANSI
Xdouble v_sin( degrees *angle)
X#else
Xdouble v_sin(angle)
Xdegrees *angle;
X#endif
X{
X
X	if( *angle != sinla) {
X		sinla= *angle;
X		SinLastResult = sin( (double) (*angle)*deg_to_rad);
X	}
X
X#ifdef DEBUGTRIG
Xprintf("v_sin: angle %g sin %g\n", sinla*deg_to_rad, SinLastResult);
X#endif
X
X	return( SinLastResult);
X	
X}
X#ifdef ANSI
Xdouble v_cos(degrees *angle)
X#else
Xdouble v_cos(angle)
Xdegrees *angle;
X#endif
X{
X
X	if( *angle != cosla) {
X		cosla= *angle;
X		CosLastResult = cos( (*angle)*deg_to_rad);
X	}
X#ifdef DEBUGTRIG
Xprintf("v_cos: angle %g cos %g\n", cosla*deg_to_rad, CosLastResult);
X#endif
X	return( CosLastResult);
X	
X}
X
X#ifdef ANSI
Xvoid v_topix( coord_2d *view_plane,
Xpixel_2d *screen_coord,
Xfloat *xpixperm, float *ypixperm,
Xpixel offsetx, pixel offsety)
X#else
Xv_topix(view_plane, screen_coord, xpixperm, ypixperm, offsetx, offsety)
Xcoord_2d *view_plane;
Xpixel_2d *screen_coord;
Xfloat *xpixperm, *ypixperm;
Xpixel offsetx, offsety;
X#endif
X{
X	screen_coord->x = view_plane->x * (*xpixperm) + offsetx;
X	screen_coord->y = view_plane->y * (*ypixperm) + offsety;
X}
X#ifdef ANSI
Xv_rot_single( ordinate *old_x, 
X	ordinate *old_y, 
X	ordinate *new_x, 
X	ordinate *new_y,
X	degrees *angle)
X#else
Xv_rot_single(old_x, old_y, new_x, new_y, angle)
Xordinate *old_x, *old_y, *new_x, *new_y;
Xdegrees *angle;
X#endif
X{
Xordinate nx, ny;
X
X	nx = (*old_x)*v_cos(angle) - (*old_y)*v_sin(angle);
X	ny = (*old_x)*v_sin(angle) + (*old_y)*v_cos(angle);
X	*new_x = nx;
X	*new_y = ny;
X
X#ifdef DEBUG
Xprintf("v_rot_single: old_x %f y %f new_x %f y %f angle %f\n",
X	old_x, old_y, *new_x, *new_y, angle);
X#endif
X
X	return;
X
X}
X#ifdef ANSI
Xv_rotate( coord_3d *old, coord_3d *new,
Xdegrees *xangle, degrees *yangle, degrees *zangle)
X#else
Xv_rotate(old, new, xangle, yangle, zangle)
Xcoord_3d *old, *new;
Xdegrees *xangle, *yangle, *zangle;
X#endif
X{
X#ifdef DEBUG
Xprintf("v_rotate: old->x %f ->y %f ->z %f xangle %f yangle %f zangle %f\n",
X		old->x, old->y, old->z, xangle, yangle, zangle);
X#endif
X
X	v_rot_single(&(old->x), &(old->y), &(new->x), &(new->y), zangle);
X	new->z = old->z;
X	v_rot_single(&(new->y), &(new->z), &(new->y), &(new->z), xangle);
X	v_rot_single(&(new->z), &(new->x), &(new->z), &(new->x), yangle);
X	return;
X}
X#ifdef ANSI
Xv_shift(coord_3d *view, coord_3d *object, coord_3d *new)
X#else
Xv_shift(view, object, new )
Xcoord_3d *view, *object, *new;
X#endif
X{
X	new->x = object->x - view->x;
X	new->y = object->y - view->y;
X	new->z = object->z - view->z;
X	return;
X}
X#ifdef ANSI
Xvoid v_perspective( coord_3d *object,
X	coord_2d *view,
X	ordinate *focal_length )
X#else
Xv_perspective(object, view, focal_length)
Xcoord_3d *object;
Xcoord_2d *view;
Xordinate *focal_length ;
X#endif
X{
X#ifdef DEBUG
Xprintf("v_perspective: focal_length %f\n", focal_length);
Xprintf("v_perspective: object->x %f y %f z %f\n", object->x, object->y, object->z);
X#endif
X	if ( !fpequals( object->z , 0.0 ) ) {
X
X		view->x = ((*focal_length) * object->x)/(object->z );
X		view->y = ((*focal_length) * object->y)/(object->z );
X	}
X	else {
X		view->x = DIVIDE_BY_ZERO;
X		view->y = DIVIDE_BY_ZERO;
X	}
X
X
X#ifdef DEBUG
Xprintf("v_perspective: view->x %f y %f \n", view->x, view->y);
X#endif
X	
X}
X
Xcalibration camera;
Xorientation posi;
X
X/*
X (setview 
X	( camera position x y z )
X	( camera angle x y z )
X	focal length
X	pixels per metre y
X	pixels per meter x
X	camer offset in pixels x
X	camer offset in pixels y
X	camer offset from centre line
X)
X*/
X#ifdef ANSI
XEXP bsetpos(EXP args)
X#else
XEXP bsetpos(args)
XEXP args;
X#endif
X{
X	EXP tmp = car(args);
X
X	posi.shift.x = cflor(car(tmp)) ;
X	tmp = cdr(tmp);
X	posi.shift.y = cflor(car(tmp)) ;
X	tmp = cdr(tmp);
X	posi.shift.z = cflor(car(tmp)) ;
X
X	tmp = car(cdr(args));
X	posi.xangle = cflor(car(tmp)) ;
X	tmp = cdr(tmp);
X	posi.yangle = cflor(car(tmp)) ;
X	tmp = cdr(tmp);
X	posi.zangle = cflor(car(tmp)) ;
X
X	tmp = cdr(cdr(args));
X
X	camera.focal_length = cflor(car(tmp));
X	tmp = cdr(tmp);
X	camera.xpixperm 	= cflor(car(tmp));	/* Pixels per metre */
X	tmp = cdr(tmp);
X	camera.ypixperm 	= cflor(car(tmp));	/* Pixels per metre */
X	tmp = cdr(tmp);
X	camera.offx 		= cflor(car(tmp));
X	tmp = cdr(tmp);
X	camera.offy 		= cflor(car(tmp));
X	tmp = cdr(tmp);
X	camera.wheelbase 	= cflor(car(tmp));
X
X	return(args);
X}
X#ifdef ANSI
Xvoid v_view( coord_3d *object,
X	pixel_2d *screen,
X	calibration *camera,
X	orientation *posi)
X#else
Xv_view(object, screen, camera, posi)
Xcoord_3d *object;
Xpixel_2d *screen;
Xcalibration *camera;
Xorientation *posi;
X#endif
X{
Xcoord_3d view1 ,view2;
Xcoord_2d plane;
X
X#ifdef DEBUGVIEW
Xprintf("v_view: object x %f y %f z %f\n", object->x, object->y, object->z);
X#endif
X
X/*
X * First Step: Shift Object Axes to View Axes
X */
X
X	v_shift(&posi->shift, object, &view1);
X#ifdef DEBUGVIEW
Xprintf("v_view: shifted x %f y %f z %f\n", view1.x, view1.y, view1.z);
X#endif
X/*
X * Second Step: Rotate Object Axes to Match Camera Angles
X */
X	v_rotate( &view1, &view2, &(posi->xangle), &(posi->yangle),
X		  &(posi->zangle));
X
X#ifdef DEBUGVIEW
Xprintf("v_view: rotated x %f y %f z %f\n", view2.x, view2.y, view2.z);
X#endif
X
X/*
X * (Object is now mapped intp the viewer's frame of reference)
X */
X/*
X * Third Step: Perspective Projection onto the view plane.
X */
X	v_perspective(&view2, &plane, &(camera->focal_length));
X
X#ifdef DEBUGVIEW
Xprintf("v_view: in 2d x %f y %f \n", plane.x, plane.y);
X#endif
X/*
X * Fourth Step: Correct for Camera Distortions
X */
X/*
X * Fifth Step: Convert to Screen Coordinates
X */
X
X
X	v_topix( &plane, screen, &(camera->xpixperm),
X		 &(camera->ypixperm), camera->offx, camera->offy); 
X
X#ifdef DEBUGVIEW
Xprintf("v_view: onscreen x %d y %d\n", screen->x, screen->y);
X#endif
X}
X
X
X
X#ifdef ANSI
Xint v_front( float vplane, coord_3d *p1, coord_3d *p2)
X#else
Xint v_front( vplane, p1, p2)
Xfloat vplane;
Xcoord_3d *p1; coord_3d *p2;
X#endif
X{
Xfloat my, by, mx, bx;
X
X
X	if( p1->z < vplane  && p2->z < vplane )
X		return( -1 );
X	if( p1->z < vplane  || p2->z < vplane ) {
X		if( fpequals(p1->z, p2->z) ) {
X			my = 1e-10;
X		}
X		else {
X			my = (p1->y -p2->y)/(p1->z - p2->z);	/* slope */ 
X		}
X
X		by = p1->y - my*(p1->z);
X
X		if( fpequals(p1->z, p2->z) )
X			mx = 1e-10;
X		else
X			mx = (p1->x -p2->x)/(p1->z - p2->z);	/* slope */ 
X
X		bx = p1->x - mx*(p1->z);
X
X		if( p1->z < vplane ){
X			p1->x = mx*vplane + bx;
X			p1->y = my*vplane + by;
X			p1->z = vplane;
X		}
X		else  {
X			p2->x = mx*vplane + bx;
X			p2->y = my*vplane + by;
X			p2->z = vplane;
X		}
X		return(0);
X
X	}
X	else return( 0 );
X	
X}
X
X
X#ifdef ANSI
Xint v_lineview( coord_3d *p1, coord_3d *p2,
X	pixel_2d *s1, pixel_2d *s2,
X	calibration *camera,
X	orientation *posi)
X#else
Xv_lineview(p1, p2, s1, s2, camera, posi)
Xcoord_3d *p1, *p2;
Xpixel_2d *s1, *s2;
Xcalibration *camera;
Xorientation *posi;
X#endif
X{
Xcoord_3d view1 ,view2, rot1, rot2;
Xcoord_2d plane1, plane2;
X
X/*
X * First Step: Shift Object Axes to View Axes
X */
X
X	v_shift(&posi->shift, p1, &view1);
X	v_shift(&posi->shift, p2, &view2);
X/*
X * Second Step: Rotate Object Axes to Match Camera Angles
X */
X	v_rotate( &view1, &rot1, &(posi->xangle), &(posi->yangle),
X		  &(posi->zangle));
X	v_rotate( &view2, &rot2, &(posi->xangle), &(posi->yangle),
X		  &(posi->zangle));
X
X/*
X * (Object is now mapped intp the viewer's frame of reference)
X */
X/*
X * Now clip the line to be in front of the camera
X */
X	if( v_front(VPLANE, &rot1 , &rot2) < 0)
X		return(-1);	/* if entire line is behind do nothing */
X/*
X * Third Step: Perspective Projection onto the view plane.
X */
X	v_perspective(&rot1, &plane1, &(camera->focal_length));
X	v_perspective(&rot2, &plane2, &(camera->focal_length));
X
X/*
X * Fourth Step: Convert to Screen Coordinates
X */
X
X	v_topix( &plane1, s1, &(camera->xpixperm),
X		 &(camera->ypixperm), camera->offx, camera->offy); 
X	v_topix( &plane2, s2, &(camera->xpixperm),
X		 &(camera->ypixperm), camera->offx, camera->offy);
X
X	return(0);
X
X}
X/*
X (view (object point x y z)) ==> (x y)
X*/
X#ifdef ANSI
XEXP bview(EXP args)
X#else
XEXP bview(args)
XEXP args;
X#endif
X{
Xcoord_3d object;
Xpixel_2d screen;
X
X	EXP tmp = car(args);
X	object.x = cflor(car(tmp));
X	tmp = cdr(tmp);
X	object.y = cflor(car(tmp));
X	tmp = cdr(tmp);
X	object.z = cflor(car(tmp));
X
X	v_view(&object, &screen, &camera, &posi);
X
X	return( cons( newicell((int)screen.x),
X				  cons(newicell((int)screen.y), NIL)
X				)
X	);
X}
X#ifdef ANSI
XEXP blineview(EXP args)
X#else
XEXP blineview(args)
XEXP args;
X#endif
X{
Xcoord_3d p1, p2;
Xpixel_2d s1, s2;
X
X	EXP tmp = car(args);
X	p1.x = cflor(car(tmp));
X	tmp = cdr(tmp);
X	p1.y = cflor(car(tmp));
X	tmp = cdr(tmp);
X	p1.z = cflor(car(tmp));
X
X    tmp =  car(cdr(args));
X	p2.x = cflor(car(tmp));
X    tmp = cdr(tmp);
X	p2.y = cflor(car(tmp));
X    tmp = cdr(tmp);
X	p2.z = cflor(car(tmp));
X
X	if( v_lineview(&p1, &p2, &s1, &s2, &camera, &posi) < 0)
X			return(NIL); /* line is behind viewer */
X
X	return( cons(newicell((int)s1.x), cons(newicell((int)s1.y),
X		cons(newicell((int)s2.x), cons(newicell((int)s2.y),NIL)))));
X}
Xextern EXP bpline(EXP args);
XEXP bshow( EXP args)
X{
XEXP lines = car(args);
XEXP both2d = NIL;
X
X	lwhile( lines ) {
X		both2d = reference(blineview(car(lines)));
X		if( both2d != NIL ) {
X			bpline( both2d);;
X			purge(both2d);
X		}
X		lines = cdr(lines);
X	}
X	return(T);
X}
Xvoid InitView()
X{
X	v_init_trig();
X	
X	set(lookup("setview"), 	newfcell(bsetpos));
X	set(lookup("view"),	newfcell(bview));
X	set(lookup("lineview"),	newfcell(blineview));
X	set(lookup("show"),	newfcell(bshow));
X}
X
X
X#endif
X
END_OF_FILE
if test 10882 -ne `wc -c <'view.c'`; then
    echo shar: \"'view.c'\" unpacked with wrong size!
fi
# end of 'view.c'
fi
if test -f 'cells.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cells.h'\"
else
echo shar: Extracting \"'cells.h'\" \(5933 characters\)
sed "s/^X//" >'cells.h' <<'END_OF_FILE'
X#define NIL (&real_nil)
X
X#define PAIR 0
X#define IDENTIFYER 1
X#define INTEGER 2
X#define SUBRP 3
X#define FSUBRP 4
X#define STRING 5
X#define FILEPTR 6
X#define FLOAT 7
X#define BIGSTRING 8
X#define NULL_OBJ 9
X#define VOIDPTR 10
X#define CONSTANT 11
X
X#define LEN_STRING 8
X#define POOL_SIZE 3000
X#define HASHMODULO 257
X
X/* #define FILESUFFIX ".lsp"    */
X
Xtypedef struct cell {
X   int zcount ;
X   char ztype ; /* Permitted values:
X				  * NULL_OBJ, PAIR , IDENTIFYER, INTEGER, STRING, SUBRP, FSUBRP,
X		  * FILEPTR, FLOAT, BIGSTRING
X                  */
X   union {
X   		int zinteger;			/* INTEGER */
X		float zfloat;					/* FLOAT */
X   		char zstring[LEN_STRING];		/* STRING */
X   		struct cell *(*zfunction)();	/* SUBRP or FSUBRP */
X		FILE *zfile;					/* FILEPTR */
X                void *zvoid;			/* VOIDPTR */
X		struct {					/* PAIR */
X			struct cell *zcar;	/* also apval in symbols */
X   			struct cell *zcdr;	/* also props in symbols 
X						 		* and BIGSTRING continuation
X						 		*/
X		} zpair;
X	} reg;
X		
X} CELL;
X
X#define zprops(symbol) (symbol->reg.zpair.zcdr)
X#define zapval(symbol) (symbol->reg.zpair.zcar)
X
Xtypedef CELL *EXP;	/* pointer to a cell */
Xtypedef EXP FCELLPTR();	/* function returning pointer to a cell */
Xtypedef FCELLPTR *PTRFCELLPTR; /* pointer to a function returning a
X				pointer to a cell */
X
X#define WEIRDCHAR '|'
X#define USERCHAR1 '!'
X#define USERCHAR2 '?'
X#define BQUOTECHAR '`'
X#define QUOTECHAR '\''
X#define COMMACHAR ','
X#define FUNCCHAR '#'
X#define ATCHAR '@'
X
Xextern int flag_non_standard;
Xextern CELL real_nil;
Xextern EXP T;
Xextern EXP PRINTNAME;
Xextern EXP beof;
Xextern EXP lpar;
Xextern EXP rpar;
Xextern EXP quote;
Xextern EXP raw_quote;
Xextern EXP back_quote;
Xextern EXP backquote;
Xextern EXP raw_func;
Xextern EXP func_quote;
Xextern EXP comma;
Xextern EXP raw_comma;
Xextern EXP comma_at;
Xextern EXP raw_comma_at;
Xextern EXP uchar1;
Xextern EXP raw_uchar1;
Xextern EXP uchar2;
Xextern EXP raw_uchar2;
Xextern EXP period;
Xextern EXP free_list;
Xextern EXP UNBOUND;
X
Xextern int trace_on; /* Flag set when tracing */
Xextern void trace_exp_aux(EXP);
Xextern void traceaux(char *);
Xextern void c_error(char *, EXP);
Xextern EXP c_error_func(char *, EXP);
Xextern void serr(char *);
Xextern void fatal_err(char *);
X
Xextern EXP eq(EXP, EXP);
Xextern EXP equal(EXP, EXP);
Xextern EXP member();
Xextern EXP nth(int, EXP);
X/*
Xextern EXP idp();
Xextern EXP atom();
Xextern EXP stringp();      
Xextern EXP bigstringp();
Xextern EXP numberp();
Xextern EXP floatp();
Xextern EXP fsubrp();
Xextern EXP subrp();
Xextern EXP filep();
X*/
Xextern EXP fixp();
Xextern EXP unboundp();
Xextern EXP value();
Xextern EXP explength();
X
Xextern int c_init();
Xextern void dereference();
Xextern EXP reference();
Xextern void purge();
Xextern void erase();
Xextern EXP c_replace();
Xextern void c_release();
Xextern void c_link();
Xextern EXP c_alink();
Xextern EXP c_dlink();
Xextern void c_unlink();
Xextern void c_decr();
Xextern void c_prints();
Xextern EXP reads();
X/* extern EXP car();         */
X/* extern EXP cdr();       */
Xextern PTRFCELLPTR cfr();
Xextern EXP cons(EXP, EXP);
Xextern EXP append(EXP, EXP);
Xextern EXP get_cell();
Xextern EXP lookup();
Xextern EXP c_oblist();
X
Xextern char *csr();
Xextern char *pname();
Xextern EXP nameof();
Xextern EXP c_tostr();
Xextern void rplci();
Xextern int ccr(EXP);
Xextern int c_lenstr();
Xextern int cir(EXP);
Xextern float cflor(EXP);
Xextern FILE *cor(EXP);
Xextern void *cvoidr(EXP);
Xextern EXP newicell(int);
Xextern EXP newflocell(float);
Xextern EXP newfcell();
Xextern EXP newffcell();
Xextern EXP newscell();
Xextern EXP newbscell();
Xextern EXP newocell();
Xextern EXP newvoidcell(void *);
Xextern EXP newbigstring(char *);
Xextern EXP eval();
Xextern void set(EXP, EXP);
Xextern EXP plus();
Xextern EXP difference();
Xextern EXP remainder();
Xextern EXP times();
Xextern EXP quotient();
Xextern EXP blog();
Xextern EXP blog10();
Xextern EXP bexp();
X
Xvoid fprints(FILE *, EXP, int);
X#define PRIN1 (1)
X#define PRINC ((int)0)
X#define PRINSYMBOL (2)
X/*
X * Macros needed to translate between Lisp Booleans and C.
X * C expects false == 0.
X */
X#define lif(x) if(((x)!=NIL?1:0))  /* convert from Lisp to C if statement */
X#define lwhile(x) while(((x)!=NIL?1:0))  /* Lisp to C while statement */
X#define lor(a,b) ( ((a)!=NIL) ? T : ( ((b)!=NIL) ? T : NIL) )  /* OR */
X#define land(a,b) ( ((a)==NIL) ? NIL : ( ((b)==NIL) ? NIL : T) )   /* AND */
X
X/*
X * Macros introduced after profiling. These speed up the interpreter 
X * by 50% overall. Most frequently used listed first.
X */
X#define null(x) ((x)==NIL?T:NIL)
X#define lnot(x) ((x)==NIL?T:NIL)
X#define consp(x) ((x)==NIL?NIL:((x)->ztype == PAIR?T:NIL))
X#define listp(x) ((x)==NIL?NIL:((x)->ztype == PAIR?T:NIL))
X#define c_unlink(x) if(((x) != NIL? ((x)->zcount -= 1) <= 0 : 0)) c_unlinkaux(x)
X#define trace_exp(x) {if(trace_on) trace_exp_aux(x);}
X#define trace(x) {if(trace_on) traceaux(x);}
X#define dump if(trace_on)
X#ifndef SLOW
X#define car(x) ((x)->ztype == PAIR?(x)->reg.zpair.zcar:\
Xc_error_func("not PAIR for CAR",(x)))
X#define cdr(x) ((x)->ztype == PAIR?(x)->reg.zpair.zcdr:\
Xc_error_func("not PAIR for CDR",(x)))
X#define atom(x) ((x)->ztype != PAIR?T:NIL)
X#define subrp(x) ((x)->ztype == SUBRP?T:NIL)
X#define fsubrp(x) ((x)->ztype == FSUBRP?T:NIL)
X#define numberp(x) ((((x)->ztype == INTEGER)||((x)->ztype == FLOAT))?T:NIL)
X#define floatp(x) ((x)->ztype == FLOAT?T:NIL)
X#define bigstringp(x) ((x)->ztype == BIGSTRING?T:NIL)
X#define stringp(x) ((x)->ztype == STRING?T:NIL)
X#define filep(x) ((x)->ztype == FILEPTR?T:NIL)
X#define constantp(x) ((x)->ztype == CONSTANT?T:NIL)
X#define idp(x) lor(((x)->ztype == IDENTIFYER?T:NIL),constantp((x)))
X
X
X#endif
X/*
X * Macro for declaring functions which are FSUBR or SUBR
X * called by apply(). They all have the same calling convention,
X * the macro allows this to be changed cleanly.
X */
X#define LISPFUNC(name) EXP name(EXP args)
X
X/*
X * Macro to test if Bill Birch's non-standard extensions are to be used.
X */
X#define non_standard if(flag_non_standard)
X
END_OF_FILE
if test 5933 -ne `wc -c <'cells.h'`; then
    echo shar: \"'cells.h'\" unpacked with wrong size!
fi
# end of 'cells.h'
fi
if test -f 'init.lsp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'init.lsp'\"
else
echo shar: Extracting \"'init.lsp'\" \(3758 characters\)
sed "s/^X//" >'init.lsp' <<'END_OF_FILE'
X;;;	init.lsp                     init.lsp
X;;;
X;;;	NAME
X;;;	   init.lsp      Version 1.0
X;;;
X;;;	SYNOPSIS
X;;;	   This file is read every time LISP is run, and contains
X;;;	   defintions of useful functions not in the interpreter.
X;;;
X;;;
X;(ROOM) ; Print out the banner and memory statistics
X;;
X;; Some commonly used functions, not present in the interpreter.
X;
X;	Useful atoms:
X;
X(setq CR "\n")       ; Carriage Return
X(setq *eol* "\n")       ; Carriage Return
X(setq BLANK '\ )    ; Space character
X(setq *tab* "\t")   ; Tab character
X;
X;   LISP Functions
X;
X; Shorthand forms for list components
X(defun caar (x) (car(car x)))
X(defun cdar (x) (cdr(car x)))
X(defun cddr (x) (cdr(cdr x)))
X(defun caaar (x) (car(car(car x))))
X(defun caadr (x) (car(car(cdr x))))
X(defun cadar (x) (car(cdr(car x))))
X(defun cdaar (x) (cdr(car(car x))))
X(defun cdadr (x) (cdr(car(cdr x))))
X(defun cddar (x) (cdr(cdr(car x))))
X(defun cdddr (x) (cdr(cdr(cdr x))))
X;;;
X;;; Scheme style stuff
X(setq else t)
X;;;
X
X(defun min2 ( u v)
X  (cond ((> u v) v) (t u)))
X
X; Other functions
X;
X(defun add1 (x) (+ 1 x))
X(defun sub1 (x) (- x 1))
X(defun minusp (x) (< x 0))
X(defun not (x) (null x))
X
X; useful function to read a file without display of results
X(defun loadquiet (f) (load f :print nil :verbose nil))
X
X;; Editor
X;;
X(defun ed (&rest filenames)
X	(cond
X		((null filenames) (system "emacs"))
X		(t  (system "emacs" (car filenames))) ) )
X
X; Normal & Cattell page 170
X(defun subst (a b s)
X   (cond
X      ((eq s b) a)   
X      ((atom s) s)
X      (t (cons (subst a b (car s))
X             (subst a b (cdr s)) )  ) ) )
X
X; COMMON LISP function which makes a list out of its arguments.
X(defun list (&rest _u) _u)
X
X(defun print (object &optional (stream *standard-output*))
X	(princ "\n" stream)
X	(prin1 object stream)
X	(princ " " stream) )
X
X(defun terpri (&optional (stream *standard-output*)) (princ CR stream))
X
X; (last) returns the last element of a list
X(defun last (_list)
X   (cond
X      ((null (cdr _list)) _list)
X      (t (last (cdr _list)))))
X
X;N&C page 64
X;
X;
X(df print* (&rest x)
X   (princ CR)
X   (do-while x
X      (princ (eval (car x)))
X      (setq x (cdr x)) )
X   (princ " ") )
X
X;N&C page 145
X(defun mapc (l fn)
X   (cond
X      ((null l) ())
X      (t (cons (fn (car l)) 
X             (mapc (cdr l) fn) ) ) ) )
X
X; N&C page 171
X; Debugs ordinary (defun (args ...) ... ) type functions.
X; ie (scope append) will trace append.
X;
X(df trace (&rest fn)
X   (setq fn (car fn))         ; select first parameter
X   (put fn 'olddef (eval fn))   ; save old definition
X   (set fn (subst fn 'fn
X      '(lambdaq (&rest *x)
X         (setq *x (mapc *x eval))
X         (print 'fn)(princ " ")(prin1 *x)
X         (setq *x (apply (get 'fn 'olddef) *x))
X         (print 'fn)(princ "= ")(prin1 *x)
X         *x ) ) )
X   fn )
X
X; N&C page 171
X(df untrace (&rest fn)
X   (setq fn (car fn))
X   (set fn (get fn 'olddef))
X;   (remprop fn 'olddef)
X   (list fn 'untraced))
X
X(setq XOR 3) ; Exclusive or screen writing mode
X; Graphics modes for (GraphOpen) on MS-DOS
X(setq CGA 1)
X(setq MCGA 2)
X(setq EGA 3)
X(setq EGA64 4)
X(setq EGAMONO 5)
X(setq VGA 9)
X
X(df function (_s2) _s2 )
X;;;
X;;; Define #! macro to access arbitrary pname symbols.
X;;;
X(defmacro quser1 (_s) ; 
X	(addsym (_bq1 _s)) )
X;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
X;;;
X;;;		User stuff below here.------>>>
X;;;
X(defun princ* (&rest _sexp)
X	(do-while _sexp
X		(princ (car _sexp))
X		(setq _sexp (cdr _sexp)) ) )
X;;
X(load "common.lsp")
X;;
X;; Treat the command line arguments as a list of files to load.
X;;
X((lambda (argv)
X	(do-while (setq argv (cdr argv))
X		(cond ( (equal (load (car argv)) NIL)
X				(princ "; *** Warning! Could not load: ")
X						(princ (car argv))
X						(terpri)))))
X	command-line-args )
X;;
X;; What's the time?
X;;
X(load "qtime.lsp" :verbose nil)
X(english-time)
END_OF_FILE
if test 3758 -ne `wc -c <'init.lsp'`; then
    echo shar: \"'init.lsp'\" unpacked with wrong size!
fi
# end of 'init.lsp'
fi
if test -f 'times.lsp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'times.lsp'\"
else
echo shar: Extracting \"'times.lsp'\" \(1519 characters\)
sed "s/^X//" >'times.lsp' <<'END_OF_FILE'
X;;;;
X;;;; File contains functions to manipulate time.
X;;;; 
X;;;; Reminder: (get-decoded-time) returns (ss mm hh dd mm yy ..)
X;;;;
X;;
X;; Function to convert decoded-time to seconds since midnight
X;;
X(defun time:convert (dec-time)
X	(+  (nth 0 dec-time)					; seconds
X		(* 60 (+ (nth 1 dec-time)			; minutes
X				(* 60 (nth 2 dec-time))))))	; hours
X;;
X;; Function to get number of seconds since midnight.
X;; 
X;;
X(defun time:get-secs ()
X	 (time:convert (get-decoded-time))) ; fetch the time now, convert
X;;
X;; Function delays for specified time, less than a day.
X;; Does NOT work near midnight! Fixed modulo version needed...
X;;
X(defun time:Delay (secs)
X	 (time:wait  (+ (time:get-secs) secs)))			; timeout time
X
X;;;
X;;; Wait until the appointed time (secs since midnight).
X;;;
X(defun time:wait (end)
X	(do-while (< (time:get-secs) end) t)) ; do nothing loop
X
X;;;
X;;; Wait until a particular date, time
X;;; INPUT: time in decoded-time format.
X;;;
X(defun time:alarm (bing)
X	(do-while (not(equal bing (get-decoded-time))) t))	; do nothing loop
X
X
X;;;
X;;; Function to measure the time taken to execute something.
X;;;
X(defmacro time:perf (&rest forms)
X   `(progn
X		(setq start (get-decoded-time))
X		,@forms
X		(-  (time:convert (get-decoded-time)) (time:convert start))))
X
X;;;
X;;; Function to print out the time in Digital form
X;;;
X(defun time:print ()
X	(time:print-aux (get-decoded-time)))
X
X(defun time:print-aux (time:now)
X	(princ (nth 2 time:now))
X	(princ ":")
X	(princ (nth 1 time:now))
X	(princ ":")
X	(princ (nth 0 time:now)) )
END_OF_FILE
if test 1519 -ne `wc -c <'times.lsp'`; then
    echo shar: \"'times.lsp'\" unpacked with wrong size!
fi
# end of 'times.lsp'
fi
if test -f 'bignum.lsp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bignum.lsp'\"
else
echo shar: Extracting \"'bignum.lsp'\" \(1858 characters\)
sed "s/^X//" >'bignum.lsp' <<'END_OF_FILE'
X'(see chapter (23 . 4) in Norman and Cattell)
X
X'(generalized to allow arbitrary power of 10 as base)
X
X'(to test try (b-power-of-2 12))
X
X
X(setq radix 100)
X(defun // (a b) (floor (/ a b))) ; keep everything integer
X
X
X(defun b-print (n) (cond
X   ((numberp n) (princ n))
X   (t (b-print (cdr n))
X             (b-digits (car n) radix))))
X
X(defun b-digits (n r) (cond
X   ((equal r 10) (princ n))
X   (t (b-digits (// n 10) (// r 10))
X      (princ (rem n 10)))))
X
X(defun b-plus (a b) (cond
X    ((numberp a) (s-plus-b a b))
X    ((numberp b) (s-plus-b b a))
X    (t (join-digit
X         (+ (car a) (car b))
X         (b-plus (cdr a) (cdr b))))))
X
X(defun b-number (n) (cond
X   ((< n radix) n)
X    (t (cons (rem n radix)
X             (b-number (// n radix))))))
X
X(defun s-plus-b (a b) (cond
X   ((numberp b) (b-number (+ a b)))
X   (t (join-digit
X         (+ a (car b))
X         (cdr b)))))
X
X(defun join-digit (n a) (cond
X   ((< n radix) (cons n a))
X   (t (cons
X         (rem n radix)
X         (s-plus-b (// n radix) a)))))
X
X
X(defun b-times (a b) (cond
X   ((numberp a) (s-times-b a b))
X   ((numberp b) (s-times-b b a))
X   (t (b-plus
X         (s-times-b (car b) a)
X         (cons 0 (b-times a (cdr b)))))))
X
X(defun s-times-b (a b) (cond
X   ((numberp b) (b-number (* a b)))
X   (t (join-digit
X         (* a (car b))
X         (s-times-b a (cdr b))))))
X
X(defun b-power-of-2 (n)
X   (terpri)
X   (princ*  "2 to the power " n " is: ")
X   (b-print (b-expt 2 n))
X   (terpri))
X
X(defun b-expt (a n) (cond
X   ((< n 1) 1)
X   (t (_big-expt
X          a
X         (b-expt a (// n 2))
X         (rem n 2)))))
X
X(defun _big-expt (a apower nrem)
X   (cond
X      ((zerop nrem) (b-times apower apower))
X      (t (b-times
X             (b-times a apower)
X             apower))))
X
X(setq bignum '(s-plus-b join-digit b-times b-print 
X	b-digits // b-plus b-number s-times-b b-power-of-2 b-expt _big-expt))
X
END_OF_FILE
if test 1858 -ne `wc -c <'bignum.lsp'`; then
    echo shar: \"'bignum.lsp'\" unpacked with wrong size!
fi
# end of 'bignum.lsp'
fi
if test -f 'qtime.lsp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'qtime.lsp'\"
else
echo shar: Extracting \"'qtime.lsp'\" \(2465 characters\)
sed "s/^X//" >'qtime.lsp' <<'END_OF_FILE'
X;;;/* qtime.lsp	Displays time in real English, also chimes
X;;; ** This version current from 1/7/92
X;;; **
X;;; ** 1 July 92 Bill Birch		Converted to Lisp from qtime.c
X;;; ** 09/89	Ade Lovett		Complete rewrite
X;;; ** 04/86	Mark Dapoz		Converted to C for UNIX
X;;;** 12/79-12/82	Mike Cowlishaw
X;;;**
X;;;*/
X;;
X;;
X;; nth, which numbers from zero rather than one.
X(setq Cnth nth)
X;;
X;; >= predicate
X;;
X(cond ((boundp '>=))(t (defun >= (_a _s) (or (> _a _s)(equal _a _s)))))
X;;
X;; Print a list without braces.
X;;
X(defun no-brace-print (the-list)
X	(cond
X		((null the-list) nil)
X		(t 
X			
X			(cond ((null (car the-list)) nil) 
X				(t (princ (car the-list))
X					(princ " ")
X				) 
X			)
X			(no-brace-print (cdr the-list))
X		)
X	)
X)
X;; 
X;; Static data
X;;
X(setq minutesaying `(,nil "just after" "a little after" "nearly" "almost"))
X(setq fiveminsaying `(
X    ,nil "five past" "ten past" "a quarter past" "twenty past" 
X    "twenty-five past" "half past" "twenty-five to" "twenty to" 
X    "a quarter to" "ten to" "five to" ,nil
X))
X(setq hoursaying '(
X    "one" "two" "three" "four" "five" "six" "seven" "eight" "nine" 
X    "ten" "eleven" ""
X))
X
X;;; Functions to emulate the relational C integer behaviour.
X(defun Clog (x) (cond (x 1) (t 0) ) ) ; t ==> 1 , nil ==> 0
X(defun C> (a b) (Clog (> a b)))
X
X; emulate strcat(qtime,..);
X(defun append-qtime (u) (setq qtime (append qtime (list u))))
X
X;;
X;;	Function tells the time in English.
X;;	It takes the time output from (get-decoded-time)
X;;	as its param eg:
X;;
X;; (cute-time (get-decoded-time))
X;;
X(defun english-time () (cute-time (get-decoded-time)))
X(defun cute-time (tm)
X	(setq mn (+ (car (cdr tm)) 
X		(C> (car tm) 29)
X	))
X	(setq hr (+ (caddr tm)  (C> mn 32) ))
X	(setq qtime nil)
X	(append-qtime "It's")
X	(append-qtime (Cnth (rem mn 5) minutesaying))
X	(append-qtime (Cnth (+ (/ mn 5)   (C> (rem mn 5) 2) ) fiveminsaying ))
X	(cond
X		((not (zerop (rem hr 12)))
X			(append-qtime
X				(Cnth (setq hr (- hr (+ 1 (* 12 (C> hr 12))))) hoursaying)
X			)
X			
X			(append-qtime
X				(cond ((not (zerop (rem mn 60))) ".") (t "o'clock."))
X			)
X		)
X		(t (append-qtime (cond 
X			((equal hr 12 ) "Noon.") 
X			(t "Midnight")))
X			(setq hr 12)
X		)
X	)
X	(cond
X		((zerop (rem mn 15))
X			(cond
X				((not (zerop (rem mn 60))) (princ "Ding-Dong!\n\n"))
X				(t 
X					(princ "[")
X					(setq i hr)
X					(do-while (>= i 0)
X						(princ "Bong,")
X						(setq i (- i 1))
X					)
X					(princ "]\n\n")
X				)
X			)
X		)
X		(t t)
X	)
X	(no-brace-print qtime)
X	(terpri)
X	t
X)
X
END_OF_FILE
if test 2465 -ne `wc -c <'qtime.lsp'`; then
    echo shar: \"'qtime.lsp'\" unpacked with wrong size!
fi
# end of 'qtime.lsp'
fi
echo shar: End of shell archive.
exit 0

