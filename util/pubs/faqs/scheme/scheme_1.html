Subject: FAQ: Scheme Frequently Asked Questions 1/2 [Monthly posting]
Newsgroups: comp.lang.scheme,comp.lang.lisp,news.answers,comp.answers
Summary: 
Distribution: world
Followup-To: poster
Reply-To: ai+lisp-faq@cs.cmu.edu
Approved: news-answers-request@MIT.Edu

Archive-name: scheme-faq/part1
Last-Modified: Wed Apr 30 14:13:24 1997 by Mark Kantrowitz
Version: 1.30
Maintainer: Mark Kantrowitz and Barry Margolin <ai+lisp-faq@cs.cmu.edu>
URL: http://www.cs.cmu.edu/Web/Groups/AI/html/faqs/lang/scheme/top.html
Size: 56149 bytes, 1157 lines

;;; ****************************************************************
;;; Answers to Frequently Asked Questions about Scheme *************
;;; ****************************************************************
;;; Written by Mark Kantrowitz and Barry Margolin
;;; scheme_1.faq 

This post contains part 1 of the Scheme FAQ.

If you think of questions that are appropriate for this FAQ, or would
like to improve an answer, please send email to us at ai+lisp-faq@cs.cmu.edu.

Note that the lisp-faq mailing list is for discussion of the content
of the FAQ posting only.  It is not the place to ask questions about Scheme;
use either the scheme@ai.mit.edu mailing list, the comp.lang.scheme
newsgroup or the Scheme Digest (scheme@mc.lcs.mit.edu) for that. If a
question appears frequently in one of those forums, it will get added
to the FAQ list. 

*** Copyright:

Copyright (c) 1993-94 by Mark Kantrowitz and Barry Margolin. 
All rights reserved. 

This FAQ may be freely redistributed in its entirety without
modification provided that this copyright notice is not removed.  It
may not be sold for profit or incorporated in commercial documents
(e.g., published for sale on CD-ROM, floppy disks, books, magazines,
or other print form) without the prior written permission of the
copyright holder.  Permission is expressly granted for this document
to be made available for file transfer from installations offering
unrestricted anonymous file transfer on the Internet.

If this FAQ is reproduced in offline media (e.g., CD-ROM, print form,
etc.), a complimentary copy should be sent to Mark Kantrowitz, School
of Computer Science, Carnegie Mellon University, 5000 Forbes Avenue,
Pittsburgh, PA 15213-3891 USA.

This article is provided AS IS without any express or implied warranty.

*** Topics Covered:

Topics Covered (Part 1):
  [1-0]   What is the purpose of this newsgroup?
  [1-2]   What is the difference between Scheme and Common Lisp?
  [1-3]   Scheme books, introductions, documentation, periodicals,
          journals, and conference proceedings. 
  [1-4]   Where can I learn about implementing Scheme interpreters and 
          compilers?
  [1-7]   Standards for Scheme -- What are R4RS and IEEE P1178?
  [1-8]   How do I do object-oriented programming in Scheme?
  [1-9]   Repositories of Scheme Software
  [1-10]  Publicly Redistributable Scheme Software
  [1-11]  Formatting code in LaTeX (WEB and other literate programming tools)
  [1-12]  Where can I get an implementation of Prolog in Scheme?
  [1-13]  What does SICP, SCOOPS, R4RS, CAR, CDR, ... mean?
  [1-14]  Why is there no EVAL in Scheme?
  [1-15]  World-Wide Web (WWW) Resources
  [1-16]  Why is Scheme called 'Scheme'?

Topics Covered (Part 2):
  [2-1]   Free Scheme implementations.
  [2-2]   Commercial Scheme implementations.
  [2-3]   What Scheme-related discussion groups and mailing lists exist?

Search for \[#\] to get to question number # quickly.

*** Recent Changes:

;;; 1.19:
;;; 20-OCT-94 mk    Added FTP location for Scheme84.
;;;  3-NOV-94 mk    FTP collections on altdorf.ai.mit.edu have moved to
;;;                 swiss-ftp.ai.mit.edu
;;;  3-NOV-94 mk    Added Christian Queinnec's Lisp book to [1-4].
;;;
;;; 1.20:
;;; 15-NOV-94 mk    Updated location of Ken Dickey article.
;;;
;;; 1.21:
;;; 22-NOV-94 mk    Scheme Repository at Indiana University WWW page.
;;;  7-DEC-94 mk    Updated EdScheme entry in [2-2].
;;;
;;; 1.22:
;;; 16-JAN-95 mk    Updated Schemers entry. 
;;; 31-JAN-95 mk    Added Manis' book to [1-3].
;;;
;;; 1.23:
;;; 13-MAR-95 mk    Updated EdScheme and 3DScheme for Windows in part 2.
;;;  7-APR-95 mk    Added Scsh entry provided by Olin Shivers to [2-1].
;;;
;;; 1.24:
;;; 14-APR-95 mk    Updated description of the Schemer's Guide.
;;;
;;; 1.25:
;;; 13-JUL-95 mk    Updated 3d-Scheme entry in part 2.
;;;
;;; 1.26:
;;; 17-AUG-95 mk    Updated ELK entry in part 2.
;;; 11-SEP-95 mk    Updated EdScheme and 3DScheme for Windows entries in part
;;;                 2.
;;; 19-FEB-96 mk    Updated Schemer's entry in part 2.
;;; 19-MAR-96 mk    Added entry on comp.lang.scheme.scsh to part 2.
;;; 13-NOV-96 mk    Added entry for MzScheme.
;;; 30-APR-97 mk    Added Inlab Scheme to [2-2].

*** Introduction:

Certain questions and topics come up frequently in the various network
discussion groups devoted to and related to Scheme.  This file/article is
an attempt to gather these questions and their answers into a convenient
reference for Scheme programmers.  It (or a reference to it) is posted
periodically.  The hope is that this will cut down on the user time and
network bandwidth used to post, read and respond to the same questions
over and over, as well as providing education by answering questions
some readers may not even have thought to ask.

This is not a Scheme tutorial, nor is it an exhaustive list of all Scheme
intricacies.  Scheme is a very powerful and expressive language, but with
that power comes many complexities.  This list attempts to address the
ones that average Scheme programmers are likely to encounter.  If you are
new to Scheme, see the answer to the question "How can I learn
Scheme?" [1-3].

The latest version of this file is available via anonymous FTP from CMU: 

   To obtain the files from CMU, connect by anonymous FTP to 
      ftp.cs.cmu.edu:/user/ai/pubs/faqs/scheme/  [128.2.206.173]
   using username "anonymous" and password "name@host" (substitute your
   email address) or via AFS in the Andrew File System directory
      /afs/cs.cmu.edu/project/ai-repository/ai/pubs/faqs/scheme/
   and get the files scheme_1.faq and scheme_2.faq.

You can also obtain a copy of the FAQ by sending a message to
ai+query@cs.cmu.edu with 
   Send Scheme FAQ
in the message body.

An automatically generated HTML version of the Scheme FAQ is accessible by
WWW as part of the AI-related FAQs Mosaic page. The URL for this
resource is
   http://www.cs.cmu.edu/Web/Groups/AI/html/faqs/top.html
The direct URL for the Lisp FAQ is
   http://www.cs.cmu.edu/Web/Groups/AI/html/faqs/lang/scheme/top.html

We've tried to minimize the overlap with the FAQ postings to the
comp.lang.lisp, comp.lang.clos and comp.ai newsgroups, so if you don't
find what you're looking for here, we suggest you try the FAQs for
those newsgroups. These FAQs should be available by anonymous ftp from
   rtfm.mit.edu:/pub/usenet/news.answers/ [18.181.0.24]
in the lisp-faq/, ai-faq/ and scheme-faq/ subdirectories or by email.
For instructions on email retrieval, send a mail message to
mail-server@rtfm.mit.edu with "help" and "index" on separate lines in
the body of the message.

If you need to cite the FAQ for some reason, use the following format:
   Mark Kantrowitz and Barry Margolin, "Answers to Frequently Asked
   Questions about Scheme", comp.lang.scheme, <month>, <year>,
   ftp.cs.cmu.edu:/user/ai/pubs/faqs/scheme/scheme_?.faq, 
   ai+lisp-faq@cs.cmu.edu.

----------------------------------------------------------------
Subject: [1-0] What is the purpose of this newsgroup?

The newsgroup comp.lang.scheme exists for general discussion of
topics related to the programming language Scheme. For example, possible
topics can include (but are not necessarily limited to):
   announcements of Scheme books and products
   discussion of programs and utilities written in Scheme
   discussion of portability issues
   questions about possible bugs in Scheme implementations
   problems porting an implementation to some architecture
Postings should be of general interest to the Scheme community. See also
question [2-3].

The comp.lang.scheme newsgroup is archived in
   ftp.cs.cmu.edu:/user/ai/pubs/news/comp.lang.scheme/
on a weekly basis.

Questions about Common Lisp should be directed to the newsgroup
comp.lang.lisp.  Discussion of object oriented programming in Lisp to
the newsgroup comp.lang.clos. Discussion of functional programming
language issues in general should be directed to the newsgroup
comp.lang.functional.  Discussion of AI programs implemented in Scheme
should sometimes be cross-posted to the newsgroup comp.ai.

----------------------------------------------------------------
Subject: [1-2] What is the difference between Scheme and Common Lisp?

Scheme is a dialect of Lisp that stresses conceptual elegance and
simplicity. It is specified in R4RS and IEEE standard P1178. (See
question [1-7] for details on standards for Scheme.) Scheme is much
smaller than Common Lisp; the specification is about 50 pages,
compared to Common Lisp's 1300 page draft standard. (See the Lisp FAQ
for details on standards for Common Lisp.) Advocates of Scheme often
find it amusing that the entire Scheme standard is shorter than the
index to Guy Steele's "Common Lisp: the Language, 2nd Edition".

Scheme is often used in computer science curricula and programming
language research, due to its ability to represent many programming
abstractions with its simple primitives. Common Lisp is often used for
real world programming because of its large library of utility
functions, a standard object-oriented programming facility (CLOS), and
a sophisticated condition handling system.

See question [1-8] for information about object-oriented programming
in Scheme. 

In Common Lisp, a simple program would look something like the
following:

   (defun fact (n)
     (if (< n 2)
         1
         (* n (fact (1- n)))))

In Scheme, the equivalent program would like like this:

   (define fact
     (lambda (n)
       (if (< n 2)
           1
         (* n (fact (- n 1))))))

Experienced Lisp programmers might write this program as follows in order
to allow it to run in constant space:

   (defun fact (n)
     (labels ((tail-recursive-fact (counter accumulator)
                (if (> counter n)
                    accumulator
                    (tail-recursive-fact (1+ counter)
                                         (* counter accumulator)))))
       (tail-recursive-fact 1 1)))

Whereas in Scheme the same computation could be written as follows:

   (define fact
     (lambda (n)
       (letrec ((tail-recursive-fact
                 (lambda (counter accumulator)
                   (if (> counter n)
                       accumulator
                     (tail-recursive-fact (+ counter 1)
                                          (* counter accumulator))))))
               (tail-recursive-fact 1 1))))

or perhaps (using IEEE named LETs):

   (define fact
     (lambda (n)
       (let loop ((counter n)
                  (accumulator 1))
            (if (< counter 2)
                accumulator
              (loop (- counter 1)
                    (* accumulator counter))))))

Some Schemes allow one to use the syntax (define (fact n) ...) instead
of (define fact (lambda (n) ...)).

----------------------------------------------------------------
Subject: [1-3] Scheme books, introductions, documentation, periodicals, 
               journals, and conference proceedings.

Introductions to Scheme:

   The following four books from MIT Press are listed in order of
   increasing difficulty. The first is good for the complete novice,
   the second for students with little or no previous exposure to programming,
   and the third and fourth for more advanced students. The third and
   fourth may also be used to learn a variety of powerful programming
   language concepts. One of these books will suit your needs.

   1. Daniel P. Friedman and M. Felleisen.
      "The Little LISPer"
      MIT Press (Cambridge, MA), 3rd printing, 1989. ISBN 0-262-56038-0.
      Science Research Associates (Chicago), 3rd ed, 1989. 206 pages.

      Good for a quick introduction. Uses Scheme instead of Common Lisp.
      (The book uses a dialect of Scheme with footnotes about translating to
      Scheme or Common Lisp. The footnotes won't allow a non-expert to use
      Common Lisp for the advanced chapters because of the complexity.)

   2. Brian Harvey and Matthew Wright
      "Simply Scheme: Introducing Computer Science"
      MIT Press, Cambridge, MA, 1994. 583 pages. 
      ISBN 0-262-08226-8. $49.95.

      This book is ideal for students with little or no previous exposure to
      programming. The book is designed to be used before SICP (the authors
      call it a SICP "prequel"), and makes Scheme fun by sheltering the
      students from potentially confusing technical details. Unlike Pascal
      or C, the emphasis is on ideas, not obscure matters of syntax and
      arbitrary rules of style.  High schools who have shied away from using
      Scheme because they found SICP to be too challenging should consider
      using this book instead.

      The text gradually and gently introduces students to some of the key
      concepts of programming in Scheme. It starts off with functions and
      function composition and continues with the notion of functions as
      data (first-class functions) and programs that write programs
      (higher-order functions).  Since the complexity of the language is
      hidden, students can get involved in some of the more interesting and
      fun aspects of the language earlier than in other texts.  Then the
      book progresses through the more complicated concepts of lambda,
      recursion, data abstraction and procedural abstraction, and concludes
      with sequential techniques, but with careful attention to topics
      students often find difficult.  There are five chapters on recursion
      alone! There's also a pitfalls section at the end of most chapters to
      help students recognize and avoid common errors.

      The book uses several programs as examples, including a tic-tac-toe
      program, a pattern matcher, a miniature spreadsheet, and a simple
      database program.  Source code for the programs is available by
      anonymous ftp from anarres.cs.berkeley.edu:/pub/scheme/, or for $10 on
      IBM or Macintosh diskettes from the publisher.

   3. Harold Abelson and Gerald Jay Sussman, with Julie Sussman.
      "Structure and Interpretation of Computer Programs"
      MIT Press (Cambridge, MA) and McGraw-Hill (New York), 1985.
      542 pages. ISBN 0-262-01077-1, $55. The teacher's manual, which is
      also available from MIT Press (ISBN 0-262-51046-4 $20), does NOT
      contain solutions to the exercises, but does contain hints on
      teaching with the book. 

      Starts off introductory, but rapidly gets into powerful
      Lisp-particular constructs, such as using closures,
      building interpreters, compilers and object-oriented systems.  Often
      referred to by its acronym, SICP, which is pronounced "Sick-Pee". This
      is the classical text for teaching program design using Scheme,
      and everybody should read it at least once. MIT problem sets are
      available from the repositories, and materials from Gustavus
      Adolphus College are available from ftp.gac.edu:/pub/SICP/. 

   4. George Springer and Daniel P. Friedman
      "Scheme and the Art of Programming" 
      MIT Press and McGraw Hill, 1990, 596 pages.
      ISBN 0-262-19288-8, $50.

      Introduces basic concepts of programming in Scheme. Also deals with
      object oriented programming, co-routining, continuations.  Gives
      numerous examples. Has more of an emphasis on teaching Scheme than
      SICP, and can be seen as an alternative to SICP.  Source code from the
      chapters is available from 
          ftp.cs.indiana.edu:/pub/scheme-repository/doc/lit/sap/

   5. Iain Ferguson, Edward Martin and Burt Kaufman.  
      Foreword by Daniel Friedman.
      "The Schemer's Guide: Second Edition"
      Schemers Inc., Ft. Lauderdale, FL, 1995. (see EdScheme entry in [2-2])
      330 pages, ISBN 0-9628745-2-3, $35.95.

      This book assumes no previous programming experience and is ideal 
      for high school or college students.  The book presents
      the elements of modern computer programming in an easy-to-follow and
      entertaining manner.  It gently introduces students to the Scheme
      programming language, guiding them through such concepts as
      functional programming, recursion, data structures, higher order
      functions, delayed evaluation, and object-oriented programming.  The
      text concludes with a significant game-playing project
      involving artificial intelligence. The book strikes a good balance
      between theory and practice, while nurturing good programming
      practices.  The Schemer's Guide has a proven track record of several
      years use in teaching the art of Scheme programming to high school
      students and college undergraduates. A comprehensive teacher's guide
      and an additional set of resource materials including worksheets,
      quizzes, projects, and exams are available to instructors using this
      text. (A Spanish translation will be available by August 1995.)

Older Introductions to Scheme:

   1. Smith, Jerry D.
      "Introduction to Scheme"
       Prentice Hall (Englewood Cliffs, NJ), 1988, 324 pages.
           Focuses on PC Scheme.

   2. Michael Eisenberg 
      "Programming in Scheme"
      Scientific Press (Redwood City, CA), 1988. 304 pages.

   3. Two articles in BYTE Magazine, February 1988, by Abelson and
      Sussman, and Clinger.

Online Introductions to Scheme:

   1. The Ken Dickey article, "The Scheme Programming Language", in
      COMPUTER LANGUAGES magazine, June 1992, is available from the
      Scheme Repository at 
          ftp.cs.indiana.edu:/pub/scheme-repository/doc/pubs/intro.txt
      The Revised^4 Report on the Algorithmic Language Scheme is also 
      available from the Scheme Repository.

   2. The Info files from the MIT Scheme implementation.
      ftp.cs.indiana.edu:/pub/scheme-repository/imp/MIT-Scheme-7.3/doc

   3. "Introductory Scheme" by Joseph W. Lavinus and James D. Arthur,
       <lavinus@virginia.edu>. Available from the Lisp Utilities
       Repository as ftp.cs.cmu.edu:/user/ai/lang/scheme/doc/intro/ 
       as scmintro.tgz.

Scheme and Artificial Intelligence:

   1. Wolfgang Kreutzer and Bruce McKenzie
      "Programming for Artificial Intelligence: 
       Methods, Tools and Applications"
      Addison-Wesley (Reading, MA), 1990. 682 pages. 
      ISBN 0-201-41621-2.
           Discusses Scheme, Prolog, and Smalltalk, gives an overview of
           the history and philosophy of AI, surveys three major
           programming paradigms (procedural, declarative, and
           object-oriented), and metaphors to AI programming.
           Source code from the chapters is available from 
              ftp.cs.indiana.edu:/pub/scheme-repository/lit/
           as aibook.tar.Z. Some of the programs will only run under MacScheme.

Scheme-based Computer Science Texts:

   1. Vincent Manis and James Little
      "The Schematics of Computation"
      Prentice-Hall, Inc., 1995. 848 pages
      ISBN 0-13-834284-9 (North America), $41
      ISBN 0-13-433772-7 (International).

      For a copy of the publication announcement, see 
         ftp.cs.cmu.edu:/user/ai/pubs/books/announce/manis95

General Scheme reference books include:

   1. K. Dybvig
      "The Scheme programming language"
      Prentice Hall, 1987.
         Good reference for Scheme.

Scheme-related periodicals include:
        
   1. LISP Pointers.
      Published by ACM SIGPLAN six times a year. Volume 1, Number 1
      was April-May 1987. 
      Subscriptions: ACM Members $12; ACM Student Members $7; Non-ACM
      members $25. Mail checks payable to the ACM to ACM Inc., PO Box
      12115, Church Street Station, New York, NY 10249.

   2. LISP and Symbolic Computation, Kluwer Academic Press. Volume 1
      was published in 1989. (jlz@lucid.com is the editor).  ISSN 0892-4635.
      Subscriptions: Institutions $169; Individuals $80. Add $8 for
      air mail. Kluwer Academic Publishers, PO Box 322, 3300 AH Dordrecht, 
      The Netherlands, or Kluwer Academic Publishers, PO Box 358, Accord
      Station, Hingham, MA 02018-0358. 

   3. Proceedings of the biannual ACM Lisp and Functional Programming
      Conference. (First one was in 1980.)

   4. Proceedings of the annual Lisp Users and Vendors Conference.

See also the Scheme Bibliography from the Scheme Repository
(ftp.cs.indiana.edu:/pub/scheme-repository/) for additional readings.
A large number of technical reports on Scheme are now available in the
text section (ftp.cs.indiana.edu:/pub/scheme-repository/txt/).

----------------------------------------------------------------
Subject: [1-4] Where can I learn about implementing Scheme interpreters  
               and compilers?

There is no single book that is really comprehensive, so you will have
to combine reading the sources to the various free implementations
(e.g., Gambit [Feeley] and S48 [Rees]) with bits and pieces of tech
reports and various books.

Books about Scheme implementation include:

   1. John Allen
      "Anatomy of Lisp"
      McGraw-Hill, 1978. 446 pages. ISBN 0-07-001115-X

   2. Samuel Kamin
      "Programming Languages, An Interpreter-Based Approach"
      Addison-Wesley, Reading, Mass., 1990. ISBN 0-201-06824-9
           Includes sources to several interpreters for Lisp-like
           languages, and a pointer to sources via anonymous ftp.

   3. Sharam Hekmatpour
      "Lisp: A Portable Implementation"
      Prentice Hall, 1985. ISBN 0-13-537490-X.
           Describes a portable implementation of a small dynamic
           Lisp interpreter (including C source code). 

   4. Peter Henderson
      "Functional Programming: Application and Implementation"
      Prentice-Hall (Englewood Cliffs, NJ), 1980. 355 pages.

   5. Peter M. Kogge
      "The Architecture of Symbolic Computers"
      McGraw-Hill, 1991. ISBN 0-07-035596-7.
           Includes sections on memory management, the SECD and
           Warren Abstract Machines, and overviews of the various
           Lisp Machine architectures.
   
   6. Daniel P. Friedman, Mitchell Wand, and Christopher T. Haynes
      "Essentials of Programming Languages"
      MIT Press, 1992, 536 pages. ISBN 0-262-06145-7, $55.
           Teaches fundamental concepts of programming language
           design by using small interpreters as examples. Covers
           most of the features of Scheme. Includes a discussion
           of parameter passing techniques, object oriented languages,
           and techniques for transforming interpreters to allow
           their implementation in terms of any low-level language.
           Also discusses scanners, parsers, and the derivation of
           a compiler and virtual machine from an interpreter.
           Source files available by anonymous ftp from 
              ftp.cs.indiana.edu:/pub/eopl/ (129.79.254.191) or from the
           Scheme Repository in 
              ftp.cs.indiana.edu:/pub/scheme-repository/doc/lit/eopl

   7. Peter Lee, editor, "Topics in Advanced Language Implementation",
      The MIT Press, Cambridge, Mass., 1991.
           Articles relevant to the implementation of functional
           programming languages.

   8. Also see the proceedings of the biannual ACM Lisp and Functional
      Programming conferences, the implementation notes for CMU Common Lisp,
      Peter Norvig's book ("Paradigms of AI Programming: Case Studies
      in Common Lisp", Morgan Kaufmann, 1992. 946 pages. ISBN
      1-55860-191-0), and SICP (Abelson & Sussman). 

   9. Christian Queinnec
      "Les Langages Lisp"
      InterEditions (in French), 1994. 500 pages.
      ISBN 2-7296-0549-5, 61-2448-1. (?)

      The book covers Lisp, Scheme and other related dialects,
      their interpretation, semantics and compilation.

      All of the programs described in the book are available by
      anonymous ftp from
         ftp.inria.fr:/INRIA/Projects/icsla/Books/LiSP94Sep05.tar.gz
      For more information, see the book's URL
         file://ftp.inria.fr/INRIA/Projects/icsla/WWW/LiSP.html
      or contact the author at Christian.Queinnec@inria.fr

Technical reports and journal articles about Scheme implementation include:

   Mitchell Wand and Daniel P. Friedman, "Compiling Lambda Expressions
   Using Continuations and Factorizations", Journal of Computer Languages
   3(1978), 241-263.

   Guy Lewis Steele Jr., "Rabbit: A Compiler for Scheme", MIT AI Memo
   474, Massachusetts Institute of Technology, Cambridge, MA, May 1978.

   Guy Lewis Steele Jr., "Compiler Optimization Based on Viewing LAMBDA
   as RENAME + GOTO", in "Artificial Intelligence: An MIT Perspective",
   Patrick Henry Winston and Richard Henry Brown (eds.), MIT Press,
   Cambridge, MA, 1980.

   Jonathan A. Rees and Norman I. Adams, "T: A Dialect of Lisp or,
   LAMBDA: The Ultimate Software Tool", Conference Record of the 1982 ACM
   Symposium on Lisp and Functional Programming, 1982, 114-122.

   R. Kent Dybvig, "C-Scheme", Computer Science Department Technical
   Report #149 (MS Thesis), Indiana University, Bloomington, IA, 1983.

   William Clinger, "The Scheme 311 compiler: An Exercise in Denotational
   Semantics", Conference Record of the 1984 ACM Symposium on Lisp and
   Functional Programming, 1984, 356-364.

   Guillermo J. Rozas, "Liar, an Algol-like Compiler for Scheme", S.B.
   Thesis, Department of Electrical Engineering and Computer Science,
   Massachusetts Institute of Technology, January 1984.

   David H. Bartley and John C. Jensen, "The Implementation of PC
   Scheme", Proceedings of the 1986 ACM Conference on Lisp and Functional
   Programming, 1986, 86-93.

   David Kranz, Richard Kelsey, Jonathan A. Rees, Paul Hudak, James
   Philbin and Norman I. Adams, "Orbit: An Optimizing Compiler for
   Scheme", Proceedings of the SIGPLAN Notices '86 Symposium on Compiler
   Construction, June 1986, 219-233.  Published as SIGPLAN Notices 21(7),
   July 1986.

   Marc Feeley, "Deux Approches a' L'implantation du Language Scheme",
   M.Sc. Thesis, De'partement d'Informatique et de Recherche
   Ope'rationelle, University of Montreal, May 1986.

   R. Kent Dybvig, "Three Implementation Models for Scheme", Department
   of Computer Science Technical Report #87-011 (Ph.D. Dissertation),
   University of North Carolina at Chapel Hill, Chapel Hill, North
   Carolina, April 1987.

   William D. Clinger, Anne H. Hartheimer and Eric M. Ost,
   "Implementation Strategies for Continuations", Conference Record of
   the 1988 ACM Conference on Lisp and Functional Programming, August
   1988, 124-131.

   David Kranz, "Orbit: An Optimizing Compiler for Scheme", Computer
   Science Technical report #632 (Ph.D. Dissertation), Yale University,
   1988.

   Joel F. Bartlett, "SCHEME->C a Portable Scheme-to-C Compiler",
   Research Report 89/1, Dec. Western Research Laboratory, Palo Alto, CA,
   January 1989.

   Marc Feeley and James S. Miller, "A Parallel Virtual Machine for
   Efficient Scheme Compilation", Proceedings of the 1990 ACM Conference
   on Lisp and Functional Programming, Nice, France, June 1990.

   Chris Hanson, "Efficient Stack Allocation for Tail-Recursive
   Languages", Proceedings of the 1990 ACM Conference on Lisp and
   Functional Programming, Nice, France, June 1990.

   Robert Hieb, R. Kent Dybvig and Carl Bruggeman, "Representing Control
   in the Presence of First-Class Continuations", Proceedings of the
   SIGPLAN Notices '90 Conference on Programming Language Design and
   Implementation, White Plains, New York, June 1990, 66-77.

   Guillermo Rozas, "Taming the Y Operator", Proceedings of the 1992 ACM
   Conference on Lisp and Functional Programming, San Francisco, CA,
   June 1992, 226-234.

   Dan Teodosiu, "HARE: An Optimizing Portable Compiler for Scheme", ACM
   Sigplan Notices 26(1), January 1991.

----------------------------------------------------------------
Subject: [1-7] Standards for Scheme -- What are R4RS and IEEE P1178?

R4RS is the Revised^4 Report on the Algorithmic Language Scheme,
edited by W. Clinger and J. Rees. It appeared in ACM Lisp Pointers IV,
July-September 1991, and also as MIT AI Memo 848b. It serves as a kind
of standard for the language. It can be obtained by anonymous ftp at
the two Scheme Repositories, swiss-ftp.ai.mit.edu and ftp.cs.indiana.edu.
A HTML version is available as
   ftp://swiss-ftp.ai.mit.edu/pub/scm/HTML/r4rs_toc.html
or
   http://www.maths.tcd.ie/scrg/scheme/index.html

IEEE P1178 is IEEE Standard 1178-1990, "IEEE Standard for the Scheme
Programming Language", published by IEEE in 1991. ISBN 1-55937-125-0.
It is now also an ANSI standard. It may be ordered from IEEE by
calling 1-800-678-IEEE or 908-981-1393 or writing IEEE Service
Center, 445 Hoes Lane, P.O. Box 1331, Piscataway, NJ 08855-1331, 
and using order number SH14209 ($28 for IEEE members, $40 others).

----------------------------------------------------------------
Subject: [1-8] How do I do object-oriented programming in Scheme?

Some Scheme implementations (for example, MacScheme, Feel, Oaklisp, XScheme,
and PC-Scheme) include built-in object-oriented extensions.  

BOS (Bryan's Object System) is a very small object system for Scheme.
It is based around generic functions and multiple inheritance.  BOS
provides more or less the same features as Meroon and the Tiny CLOS
base language. Even though it has not been optimised, it should be
quite a bit faster than those because it does not include a MOP.
BOS has been tested under Scheme 48 and SCM, and should run under any
fairly modern Scheme implementation (especially any which runs SLIB)
with little or no change.  It is available by anonymous ftp from
   ftp.maths.tcd.ie:/pub/bosullvn/misc/bos.tar.gz
and the CMU AI Repository in
   ftp.cs.cmu.edu:/user/ai/lang/scheme/oop/bos/
For more information, write to Bryan O'Sullivan <bosullvn@maths.tcd.ie>.

MEROON is a package written in Scheme to provide the basic facilities
of an object-oriented programming style through three macros:
define-class, define-generic, and define-method. MEROON offers simple
inheritance, reflective metaclasses and simple dispatching generic
functions with support for multimethods. MEROON also offers indexed
fields subsuming Scheme vectors without inheritance restrictions.
Meroon runs in Scheme->C, PC-Scheme, Chez Scheme, Elk, Bigloo, SCM
with SLIB, and MacGambit. MEROON sources and documentation may be
found in the Scheme Repository as
   ftp.cs.indiana.edu:/pub/scheme-repository/new/meroon.*.tar.Z
and also from
   ftp.inria.fr:/pub/INRIA/icsla/Programs/MeroonV3*.tar.gz [128.93.1.26]
The file meroonet*.tar.gz is a toy version of meroon. For more
information, contact Christian Queinnec <queinnec@polytechnnique.fr>
or <Christian.Queinnec@inria.fr>.

SCOOPS (Scheme Object Oriented Programming System) is an object system
for Scheme written by Amitabh Srivastava/Texas Instruments with 
re-writes by Steve Sherin <sherin@linc.cis.upenn.edu>. [Email to this
address bounced 7/7/93.] This package needs first-class environments.
It is available from the Scheme Repository as
/pub/scheme-repository/scm/scoops.sha. 

Tiny CLOS is a Scheme implementation of a `kernelized' CLOS, with a
metaobject protocol. The implementation is even simpler than the
simple CLOS found in `The Art of the Metaobject Protocol,' weighing in
at around 850 lines of code, including (some) comments and
documentation. Tiny CLOS is available by anonymous ftp from
parcftp.xerox.com:/pub/mops/. Tiny CLOS runs in MIT Scheme 11.74 and
should run with only minor modifications in other Schemes as well. If
you want to be added to the mops@parc.xerox.com mailing list
(technical questions and discussion only), send mail to Gregor Kiczales
<gregor@parc.xerox.com>.

YASOS (Yet Another Scheme Object System) is fairly functional in style
and uses delegation.  The implementation includes multiple inheritance
and "send to super" and is much smaller than class-based OO systems.
See Ken Dickey, "Scheming with Objects", AI Expert 7(10):24-33,
October 1992. A copy of the article and YASOS code is available from
the Scheme Repository in pub/scheme-repository/txt/swob.txt. YASOS is also
included as part of SLIB. For further information, contact Ken Dickey
<kend@newton.apple.com>.

----------------------------------------------------------------
Subject: [1-9] Repositories of Scheme Software

There are several repositories of publicly redistributable and
public domain Scheme code. 

CMU AI Repository, Scheme Section:

   The Scheme Section of the CMU Artificial Intelligence Repository
   is accessible by anonymous ftp to
      ftp.cs.cmu.edu:/user/ai/lang/scheme/ [128.2.206.173]
   through the AFS directory
      /afs/cs.cmu.edu/project/ai-repository/ai/lang/scheme/
   or by WWW from the URL   
      http://www.cs.cmu.edu/Web/Groups/AI/html/repository.html
   and includes more than 200 megabytes of sources and other materials
   of interest to Scheme programmers, including all freely
   distributable implementations and many programs.  Unlike the Scheme
   Repository at Indiana University, the entire contents of the CMU AI
   Repository has been keyword indexed to provide convenient browsing
   of the contents.

   The repository has standardized on using 'tar' for producing
   archives of files and 'gzip' for compression.

   To search the keyword index by mail, send a message to:
      ai+query@cs.cmu.edu
   with one or more lines containing calls to the keys command, such as:
      keys scheme awk
   in the message body.  Keywords may be regular expressions and are
   compared with the index in a case-insensitive conjunctive fashion.  
   You'll get a response by return mail. Do not include anything else in 
   the Subject line of the message or in the message body.  For help on
   the query mail server, include: 
      help
   instead. 

   A Mosaic interface to the keyword searching program is in the
   works.  We also plan to make the source code (including indexes) to
   this program available, as soon as it is stable.

   Most of the Scheme Section of the AI Repository appears on Prime Time 
   Freeware for AI, Issue 1-1, a mixed-media book/CD-ROM publication. It
   includes two ISO-9660 CD-ROMs bound into a 224 page book and sells
   (list) for US$60 plus applicable sales tax and shipping and handling
   charges. Payable through Visa, Mastercard, postal money orders in US
   funds, and checks in US funds drawn on a US bank. For more
   information write to Prime Time Freeware, 370 Altair Way, Suite 150,
   Sunnyvale, CA  94086  USA, call 408-433-9662, 408-433-0727 (fax),
   or send email to ptf@cfcl.com.

   Contributions of software and other materials are always welcome but
   must be accompanied by an unambiguous copyright statement that grants
   permission for free use, copying, and distribution -- either a
   declaration by the author that the materials are in the public domain,
   that the materials are subject to the GNU General Public License (cite
   version), or that the materials are subject to copyright, but the
   copyright holder grants permission for free use, copying, and
   distribution. (We will tell you if the copying permissions are too
   restrictive for us to include the materials in the repository.)
   Inclusion of materials in the repository does not modify their
   copyright status in any way. Materials may be placed in:
      ftp.cs.cmu.edu:/user/ai/new/
   When you put anything in this directory, please send mail to
      ai+contrib@cs.cmu.edu
   giving us permission to distribute the files, and state whether
   this permission is just for the AI Repository, or also includes
   publication on the CD-ROM version (Prime Time Freeware for AI).
   We would also appreciate if you would include a 0.doc file for your
   package; see /user/ai/new/package.doc for a template. (If you don't
   have the time to write your own, we can write it for you based on
   the information in your package.)

   The Scheme Section of the AI Repository is maintained by Mark Kantrowitz 
   <AI.Repository@cs.cmu.edu>. 

Scheme Repository at Indiana University:

   The Scheme Repository at Indiana University contains a Scheme
   bibliography, copies of the R4RS report and other papers, sample
   Scheme code for a variety of purposes, several utilities, and some
   implementations. The Scheme code includes code for calendar
   calculations, Earley parser, FORMAT for Scheme, a scheme version of
   the Gabriel benchmarks, Marc Feeley's minimal object support for
   Scheme, a Scheme pretty-printer, a Prolog interpreter written in
   Scheme, a random number generator in Scheme, an implementation of
   SCOOPS, code from Abelson and Sussman's SICP book, Aubrey Jaffer's
   IEEE/R4RS compliance test, an implementation of matrices, a Scheme
   implementation of the Common Lisp FORMAT function, a Scheme front end
   to Adobe Illustrator PostScript, and a LALR(1) parser (ZEBU).  The
   repository was established by Ozan S. Yigit and is currently
   maintained by David Eby and John Zuckerman. Send administrative
   requests to
      scheme-repository-request@cs.indiana.edu
   The repository is accessible by anonymous ftp at 
      ftp.cs.indiana.edu:/pub/scheme-repository/   [129.79.254.191]
   or by WWW to
      http://www.cs.indiana.edu/scheme-repository/home.html
   The repository is mirrored in INRIA, courtesy of Christian Queinnec
   [Ecole Polytechnique and INRIA-Rocquencourt], ftp.inria.fr:/lang/Scheme/
   and also faui80.informatik.uni-erlangen.de:/pub/scheme/yorku

Other Scheme Collections:

   Scheme Implementations may also be found at swiss-ftp.ai.mit.edu:/archive/ 
   The R4RS report is available in 
      swiss-ftp.ai.mit.edu:/archive/scheme-reports/
   or as MIT AI Memo 848b (email publications@ai.mit.edu for more information).
   The swiss-ftp archive includes SCOOPS, CL2Scheme, extend-syntax,
   btree, Gabriel benchmarks, FORMAT for Scheme, etc.

   The GI (German Computer Science Society) Scheme Archive contains a
   variety of scheme programs, utilities, code from theses, and other
   materials. It also mirrors the Scheme Repository.  It is
   accessible by anonymous ftp to faui80.informatik.uni-erlangen.de
   (login as 'ftp', giving your email address as the password).
      pub/scheme/gi                # GI Scheme Archive
      pub/scheme/yorku             # Internet Scheme Repository
   Direct questions to scheme@faui80.informatik.uni-erlangen.de.
   The GI Scheme Archive is supported by the German Computer Society Special
   Interest Group on AI programming and sponsored by the Bavarian AI Center
   FORWISS -- Research Institute for Knowledge Based Systems.

----------------------------------------------------------------
Subject: [1-10] Publicly Redistributable Scheme Software

   SLIB (Standard Scheme Library) is a portable scheme library that
   provides compatibility and utility functions for many of the
   standard scheme implementations, including Chez, ELK 2.1, GAMBIT,
   MITScheme, scheme->C, Scheme48, T3.1, VSCM and Scm4e. It is available by
   anonymous ftp from 
       swiss-ftp.ai.mit.edu:/archive/scm/slib2a1.tar.gz
       prep.ai.mit.edu:/pub/gnu/jacal/slib2a1.tar.gz
       ftp.cs.indiana.edu:/pub/scheme-repository/new/slib2a1.tar.gz
   Now includes a FAQ file.

   TEST.SCM is an IEEE and R4RS conformance test suite.  It is available
   from 
      swiss-ftp.ai.mit.edu:/archive/scm/test.scm
      prep.ai.mit.edu:/pub/gnu/jacal/test.scm
      ftp.cs.indiana.edu:/pub/scheme-repository/new/test.scm

   PSD (Portable Scheme Debugger) is available by anonymous ftp
   from Tampere University of Technology, Finland,
      ftp.cs.tut.fi:/pub/src/languages/schemes/psd-1.1.tar.Z
   With PSD, you can run a Scheme program in an Emacs buffer, set
   breakpoints, single step evaluation and access and modify the
   program's variables. It works by instrumenting the original source
   code, so it should run with any R4RS compliant Scheme. It has been
   tested with SCM and Elk 1.5, but should work with other Schemes with a
   minimal amount of porting, if at all. Includes documentation and
   user's manual. Written by Pertti Kellom\"aki, pk@cs.tut.fi
   The Lisp Pointers article describing PSD (Lisp Pointers VI(1):15-23,
   January-March 1993) is available as 
      http://www.cs.tut.fi/staff/pk/scheme/psd/article/article.html

   SCLINT is a lint-like program for Scheme. It checks for consistency of
   indentation, syntax of special forms, and the number of arguments to
   primitive and most user-defined procedures. This is not a full
   implementation, but rather a quick hack. It is used in teaching
   programming at the Tampere University of Technology. It is available
   by anonymous ftp from 
      ftp.cs.tut.fi:/pub/src/languages/schemes/sclint-0.9.tar.Z.
   For further information, write to Pertti Kellom\"aki <pk@cs.tut.fi>.

   A bibliography of work in functional programming can be obtained by 
   anonymous ftp from tamdhu.dcs.st-andrews.ac.uk:/pub/staple/pubs.txt
   (138.251.192.40). It uses a refer-like format with %T for title, %A
   for authors %I for a unique index entry %S for source (possibly a
   reference to another index) %K for keywords and %C for comments.
   Compiled by Tony Davie, <ajtd@honey.st-and.ac.uk>. [Email bounced, 7/7/93.]

   Scheme Utilities -- brokaw.lcs.mit.edu:/pub/scmutils.tar  18.30.0.33
   [This collection seems to no longer be located on brokaw -- does
   anybody know the current location?]

   A collection of Scheme implementations of data structures and
   algorithms is available by anonymous ftp from 
      ftp.cs.tut.fi:/pub/src/languages/schemes/
   as the file scheme-algorithms.tar. For more information, contact
   Pertti Kellom\"aki <pk@cs.tut.fi>. 

   6.001. The User's Manual, example code, and problem sets from MIT's
   course "Structure and Interpretation of Computer Programs" are 
   available by anonymous ftp from swiss-ftp.ai.mit.edu:/archive/6.001/
   [18.23.0.16].

   Steele's Constraint System. Chris Hanson's implementation of Steele's
   constraint system is available for anonymous ftp from
      swiss-ftp.ai.mit.edu:/archive/cph/constraint.tar [18.23.0.16]
      ftp.cs.indiana.edu:/pub/scheme-repository/new/constraint.tar.Z
   A compressed version is also stored there. The software is source code
   for MIT Scheme. It should run in release 7.1.3. Most of the MIT Scheme
   dependencies could be eliminated, but it also uses the following
   procedures which aren't in standard Scheme: error, bkpt, macros,
   dynamic binding, and string output ports. The code corresponds pretty
   closely to Guy Steele's PhD thesis implementation, which you can
   obtain in printed form from the MIT AI Lab publications office as
   AI-TR-595 for $15.00 (email publications@ai.mit.edu for more
   information). For more information, send email to Chris Hanson
   <cph@martigny.ai.mit.edu>.

   JACAL is a symbolic mathematics system for the simplification and
   manipulation of equations and single and multiple valued algebraic
   expressions constructed of numbers, variables, radicals, and algebraic
   functions, differential, and holonomic functions. In addition, vectors
   and matrices of the above objects are included.  JACAL is written in
   Scheme and requires SLIB. JACAL source is available via anonymous FTP
   from
      swiss-ftp.ai.mit.edu:/archive/scm/jacal1a4.tar.Z,
      prep.ai.mit.edu:/pub/gnu/jacal/jacal1a4.tar.Z, and
      ftp.cs.indiana.edu:/pub/scheme-repository/new/jacal1a4.tar.Z
   Contact jaffer@altdorf.ai.mit.edu for more information.
  
   Zebu 0.9 is an LALR(1) parser generator for Scheme written by 
   William M. Wells III. It lives in the Scheme Repository 
      ftp.cs.indiana.edu:/pub/scheme-repository/scm/
   and works with PC-Scheme from TI and MIT C-Scheme 6.2 (but not with
   anything after 7.0). 

   Thomas is a compiler for the Dylan programming language.  The Thomas
   system is written in Scheme and runs under MIT's CScheme, DEC's
   Scheme->C, and Marc Feeley's Gambit.  It can run on a wide range of
   machines including the Macintosh, PC compatibles, Vax, MIPS, Alpha,
   and 680x0.  Thomas generates IEEE compatible Scheme code.  Thomas is
   available to the public by anonymous ftp at
      crl.dec.com:/pub/DEC/Thomas
      gatekeeper.pa.dec.com:/pub/DEC/Thomas
      swiss-ftp.ai.mit.edu:/archive/Thomas
   For more information on Thomas and Dylan, see part 4 of the Lisp FAQ.

   MATCH is a pattern matching macro package for Scheme.  Pattern
   matching allows complicated control decisions based on data structure
   to be expressed in a concise manner. This document describes several
   pattern matching macros for Scheme, and an associated mechanism for
   defining new forms of structured data. This macro package works with
   any Scheme that supports defmacro (which is obtainable by loading
   SLIB), such as Chez Scheme (release 4 or greater). MATCH is available
   by anonymous ftp from titan.cs.rice.edu:/public/wright/match.tar.Z
   [128.42.1.30] and includes the macro source code and documentation. A
   copy should be available from the Scheme Repository shortly.  For
   further information, write to Andrew Wright, <wright@cs.rice.edu>.

   Soft Scheme provides the benefits of static typing for dynamically
   typed Scheme.  Like a static type checker, a soft type checker infers
   types for variables and expressions.  But rather than reject programs
   containing untypable fragments, a soft type checker inserts explicit
   run-time checks to transform untypable programs to typable form.
   These run-time checks indicate potential program errors, enabling
   programmers to detect errors prior to program execution.  Soft type
   checking minimizes the number of run-time checks in the compiled code,
   enabling dynamically typed languages to attain the efficiency of
   statically typed languages like ML. Soft Scheme is available by
   anonymous ftp from
      titan.cs.rice.edu:public/wright/softscheme.tar.Z [128.42.1.30]
   For more information, write to Andrew Wright <wright@cs.rice.edu>.

   ChezSybase is a Chez Scheme interface to the Sybase database.
   It uses the Chez Scheme foreign function interface to provide a
   high-level Scheme interface to the Sybase db-lib (the API to the
   Sybase database). Most of the db-lib calls and datatypes are
   supported, with the possible exception of spotty support for text and
   image data, and there is no analog to the datetime datatype. It is
   available by anonymous ftp from
      ftp.cs.cmu.edu:/user/ai/lang/scheme/code/io/chez_syb/
   For more information, write to Karl O. Pinc <kop@acm.org>.

----------------------------------------------------------------
Subject: [1-11] Formatting code in LaTeX

SLaTeX is a R4RS-compliant Scheme program that allows you to write
program code "as is" in your LaTeX or TeX source.  It is particularly
geared to the programming languages Scheme and Common Lisp, and has
been tested in Chez Scheme, Common Lisp, MIT C Scheme, Elk, Scheme->C,
SCM and UMB Scheme on Unix; and MIT C Scheme and SCM on MSDOS.  The
formatting of the code includes assigning appropriate fonts to the
various tokens in the code (keywords, variables, constants, data), at
the same time retaining the proper indentation when going to the
non-monospace (non-typewriter) provided by TeX.  SLaTeX comes with two
databases that recognize the standard keywords/variables/constants of
Scheme and Common Lisp respectively.  These can be modified by the
user using easy TeX commands.  In addition, the user can inform SLaTeX
to typeset arbitrary identifiers as specially suited TeX expressions
(i.e., beyond just fonting them).  The code-typesetting program SLaTeX
is available by anonymous ftp from 
   cs.rice.edu:/public/dorai/slatex23.tar.gz
Send bug reports to dorai@cs.rice.edu.

SchemeWEB provides simple support for literate programming in Lisp.
SchemeWEB version 2.0 is a Unix filter that allows you to generate
both Lisp and LaTeX code from one source file.  The generated LaTeX
code formats Lisp programs in typewriter font obeying the spacing in
the source file.  Comments can include arbitrary LaTeX commands.
SchemeWEB was originally developed for the Scheme dialect of Lisp, but
it can easily be used with most other dialects.  Version 2.0 is
available in the Scheme Repository as
   ftp.cs.indiana.edu:/pub/scheme-repository/new/schemeweb.sh
or in the Comprehensive TeX Archive Network (CTAN) in the directory
   ftp.shsu.edu:/tex-archive/web/schemeweb 

The Literate Programming FAQ lists a number of alternatives, both
language-independent and Scheme-specific. The Literate Programming FAQ
is posted once a quarter to the comp.programming.literate newsgroup
and is available by anonymous ftp from rtfm.mit.edu. A copy may also be
requested by sending an email message to fileserv@shsu.edu
   sendme litprog.faq
in the body of the message.

----------------------------------------------------------------
Subject: [1-12] Where can I get an implementation of Prolog in Scheme?

   Prolog in Scheme is a collection of macros that expand syntax for
   clauses, elations, and so on. It is written in Scheme and has support
   for delayed goals and interval arithmetic. It is known to run in Chez
   Scheme and in Elk, and is intended to be portable to other Scheme
   implementations. It relies on continuations, and so is not easily
   ported to Common Lisp. Available from the University of Calgary by
   anonymous ftp from
      ftp.cpsc.ucalgary.ca:/pub/projects/prolog1.2/prolog12.tar.Z
   Questions and comments may be addressed to Alan Dewar
   <dewar@cpsc.ucalgary.ca> or John Cleary <jcleary@waikato.ac.nz>.

   Schelog is an embedding of Prolog in Scheme. It represents Prolog
   goals as procedures in Scheme, and includes macros to simulate a
   Prolog-style syntax for clauses, relations and queries.  The embedding
   permits the user to combine Prolog and Scheme code freely, in the same
   s-expression, if desired.  Documentation and examples are included.
   Schelog should run in any R4RS Scheme, has been tested in SCM and Chez
   Scheme, and will run in any Scheme implementation that supports SLIB (see
   entry in [1-10] above).  Schelog (version 2) is available by anonymous
   ftp from titan.cs.rice.edu:/public/dorai/schelog2.tar.Z.  Its use of
   higher-order continuations is probably a major obstacle to porting it
   to Common Lisp.  For more information, please contact the author Dorai
   Sitaram <dorai@cs.rice.edu>.

----------------------------------------------------------------
Subject: [1-13]  What does SICP, SCOOPS, R4RS, CAR, CDR, ... mean?

Glossary of acronyms:
   CAR             Originally meant "Contents of Address portion of Register",
                   which is what CAR actually did on the IBM 704.
   CDR             Originally meant "Contents of Decrement portion of 
                   Register", which is what CDR actually did
                   on the IBM 704. Pronounced "Cudder".
   ANSI            American National Standards Institute
   SICP            Abelson and Sussman's book "Structure and
                   Interpretation of Computer Programs".
   EOPL            Essentials of Programming Languages 
   SCOOPS          An experimental object-oriented programming
                   language for Scheme.
   R3RS            Revised^3 Report on the Algorithmic Language Scheme.
   R4RS            Revised^4 Report on the Algorithmic Language Scheme.

----------------------------------------------------------------
Subject: [1-14] Why is there no EVAL in Scheme?

The answer to this question is based on information provided by 
Guillermo J. Rozas and Aubrey Jaffer.

There are three major positions in the Scheme community regarding EVAL:

   1. No EVAL: EVAL is antithetical to a Pascal-like (compiler based,
      externally statically linked) implementation for Scheme, such as
      some people have or wish to see. 

   2. Single Argument: There is a single distinguished top-level
      environment, and EVAL always evaluates its argument there. 
      (This is the approach taken in Common Lisp, where EVAL evaluates
      its argument in the current dynamic environment and in a null
      lexical environment.) 

   3. Two Arguments: There are multiple environments in which
      the user might want to evaluate expressions, so EVAL should take
      two arguments, the second being an environment.  In particular,
      in some systems with first-class environments, there is no
      a-priori single distinguished top-level environment, and
      defaulting the environment does not fit those dialects well.

Not every dialect of Scheme has EVAL. Most do, but some with different
names and arguments. Jaffer's SLIB package uses LOAD as defined in
R4RS to define EVAL for those implementations that don't support EVAL
(e.g., by writing the code out to a file and then loading it).
Rozas's compromise proposal for EVAL was accepted for R5RS, but it is
unclear whether there will ever be a R5RS.

----------------------------------------------------------------
Subject: [1-15] World-Wide Web (WWW) Resources

The World Wide Web (WWW) is a hypermedia document that spans the
Internet.  It uses the http (HyperText Transfer Protocol) for the
light-weight exchange of files over the Internet.  NCSA Mosaic is a
World Wide Web browser developed at the National Center for
Supercomputing Applications (NCSA). 

Mosaic's popularity derives, in part, from its ability to communicate
using more traditional Internet protocols like FTP, Gopher, WAIS, and
NNTP, in addition to http. Mosaic can display text, hypertext links,
and inlined graphics directly. When Mosaic encounters a file type it
can't handle internally, such as Postscript documents, mpeg movies,
sound files, and JPEG images, it uses an external viewer (or player)
like Ghostscript to handle the file. Mosaic also includes facilities
for exploring the Internet. In other words, Mosaic is an multimedia
interface to the Internet.

The hypertext documents viewed with Mosaic are written in HTML
(HyperText Markup Language), which is a subset of SGML (Standard
Generalized Markup Language).  All that is needed is just a few more
improvements, such as the ability to format tables and mathematics,
and a WYSIWYG editor, for HTML to greatly facilitate electronic
journals and other publications.

NCSA Mosaic for the X Window System is available by anonymous ftp from  
   ftp.ncsa.uiuc.edu:/Mosaic/
as source code and binaries for Sun, SGI, IBM RS/6000, DEC Alpha OSF/1, DEC
Ultrix, and HP-UX. Questions about NCSA Mosaic should be directed to 
mosaic-x@ncsa.uiuc.edu (X-Windows version), mosaic-mac@ncsa.uiuc.edu
(Macintosh), and mosaic-win@ncsa.uiuc.edu (Microsoft Windows).

A simple HTML version of the Scheme FAQ (this FAQ) is available as
   http://www.cs.cmu.edu/Web/Groups/AI/html/faqs/lang/scheme/top.html

The Scheme home page at MIT is
    http://www-swiss.ai.mit.edu/scheme-home.html
It includes a nifty little form that lets you execute small examples
of Scheme code.

The Scheme Underground web page is
    http://www.ai.mit.edu/projects/su/su.html

----------------------------------------------------------------
Subject: [1-16] Why is Scheme called 'Scheme'?

According to Steele and Gabriel's "The Evolution of Lisp" paper,
Scheme was originally called Schemer, in the tradition of the AI
languages Planner and Conniver. But the ITS operating system had a
6-character limitation of file names, so the names were shortened to
PLNR, CNVR, and SCHEME. Eventually the truncated name Scheme stuck.

----------------------------------------------------------------
;;; *EOF*

