...........................................................................

VHDL'92 


by


Jean-Michel Berge
CNET, France Telecom, France
Alain Fonkoua
Institut Mediterraneen de Technologie, France
Serge Maginot
LEDA S.A., France
Jacques Rouillard
Institut Mediterraneen de Technologie, France

#012#TABLE OF CONTENTS

Introduction	

1.	Designer's Concerns	1
1.1.	Analog(Mixed-Mode Simulation)	1
1.2.	Backannotation	2
1.3.	Compatibility Problems Versus VHDL'87	3
1.4.	Development Phase	3
1.5.	Determinism	4
1.6.	Device Modeling	4
1.7.	Formal Proof	4
1.8.	Implementation Problems	5
1.9.	Portability	5
1.10.	Readability	6
1.11.	Simulation Efficiency	6
1.12.	Synthesis	7
1.13.	System Modeling	8
2.	Spirit of VHDL'92	9
2.1.	Introduction	9
2.2. 	Motivations for Revision	10
2.2.1.	Implementations	10
2.2.2. 	New Application Domains	10
2.3.	The Formal Process	11
2.3.1.	The Standardization Bodies	11
2.3.2.	The Standardization Committees	11
2.3.3.	The Standardization Process	11
2.4.	The Technical Process	13
2.4.1.	Guidelines for Restandardization	13
2.4.1.1.	Ensure Upward Compatibility	14
2.4.1.2.	Preserve Strong Typing	14
2.4.1.3.	Separate Declaration and Functionality	15
2.4.1.4.	Ensure Unification of Timing Semantics	15
2.4.1.5.	Preserve Determinism	15
2.4.1.6.	Preserve Generality	16
2.4.1.7.	Preserve (at Least) a Gate (Circuit) System Scope	17
2.4.1.8.	Preserve Intermixed Levels of Abstraction	17
2.4.1.9.	Preserve Concurrency	17
2.4.1.10.	Preserve (Improve?) Language Consistency	17
2.4.1.11.	Preserve (Improve?) Portability	18
2.4.1.12.	No Application-Specific Packages in the LRM	18
2.4.1.13.	Minimize Implementation Impact	18
2.4.1.14.	Maximize Implementation Efficiency	19
2.4.2.	Requirement Analysis	19
2.4.3.	Language Design	20
2.4.4.	Documentation	20
2.4.4.1. First Considerations	20
2.4.4.2. Documentation Process	21
2.4.5.	Validation	21
2.4.6. 	Negative Ballot Responses	22

New Simulation Mechanisms	

3.	Last-Delta Activation: Postponed Process	25
3.1.	Background	25
3.2.	Description	25
3.3.	Using the Feature	27
3.3.1.	Examples	27
3.3.1.1.	Assertion Statement	27
3.3.1.2.	Process Statement	28
3.3.1.3.	Concurrent Procedure Call Statement	29
3.3.1.4.	Concurrent Signal Assignment	29
3.3.2.	Some Traps	30
3.3.2.1.	My Debugger Is Crazy	30
3.3.2.2.	When Will It Wake Up Again?	30
4.	Shared (Global) Variables	31
4.1.	Background	31
4.2.	Description	33
4.2.1.	Determinism Issues	33
4.3.	Using the Feature	34
4.3.1.	Open Traps	34
4.3.2.	Reasonable Uses of Shared Variables	35
4.3.2.1.	OOP Modeling	35
4.3.2.2.	Conventional Programming Techniques	36

New Structuring Mechanisms	

5.	Direct Instantiation	39
5.1.	Background	39
5.2.	Description	39
5.3.	Using the Feature	41
5.3.1.	Right Use of Direct Instantiation?	41
5.3.2.	Wrong Use of Direct Instantiation?	43
6.	Incremental Binding	47
6.1.	Background	47
6.2.	Description	48
6.3.	Using the Feature	50
6.4.	Related Topics	52
6.4.1.	Default Binding	52
6.4.2.	Binding Time	54
7.	Groups	57
7.1.	Background	57
7.2.	Description	57
7.2.1.	Syntax	58
7.3.	Using the Feature	59
7.3.1.	Timing Constraint	59
7.3.2.	Resource Allocation	60




New Interfacing Mechanisms	

8.	FOREIGN Interfaces	63
8.1.	Background	63
8.2.	Description	64
8.2.1.	The Attribute FOREIGN	64
8.2.2.	FOREIGN Subprograms	64
8.2.3.	Foreign Architectures	65
8.3.	Using the Feature	65
8.3.1.	Security	65
8.3.2.	Do Not Look For It	66
9.	Reading & Writing Files	67
9.1.	Background	67
9.2.	Description	68
9.2.1.	Open and Close Operations	69
9.2.2.	Package TEXTIO	69
9.3.	Using the Feature	70
10.	Impure Functions	73
10.1.	Background	73
10.2.	Description	74
10.3.	Using the Feature	75

New Predefined Operators, Functions & Attributes

11.	Shift and Rotate Operators	77
11.1.	Background	77
11.2.	Description	77
11.3.	Using the Feature	79
12.	XNOR Operator	81
12.1.	Background	81
12.2.	Description	81
12.3.	Using the Feature	82
13.	Predefined Attribute DRIVING_VALUE (and 'DRIVING)	85
13.1.	Background	85
13.2.	Description	86
13.3.	Using the Feature	87
13.3.1. An Example	87
13.3.2.	Another Example	89
13.3.3.	Limit of 'DRIVING_VALUE	89
14.	Predefined Attribute 'ASCENDING	91
14.1.	Background	91
14.2.	Description	92
14.3.	Using the Feature	92
14.3.1.	An Initial Example	92
14.3.2.	Overloading of the VHDL'87 Concatenation Operator	92
15.	Predefined Attributes 'BEHAVIOR & 'STRUCTURE	95
15.1.	Background	95
15.2.	Description	95
15.3.	Using the (Absence of) Feature	96



16.	Predefined Attributes 'IMAGE & 'VALUE	97
16.1.	Background	97
16.2.	Description	97
16.3.	Using the Feature	98
16.3.1.	Displaying Values	98
16.3.2.	Reading and Writing ASCII Files	98
17.	Attributes 'PATH_NAME 'INSTANCE_NAME 'SIMPLE_NAME	101
17.1.	Background	101
17.2.	Description	101
17.3.	Using the feature	103

Slight Enhancements

18.	Inertial Signal Assignment Statement	107
18.1.	Background	107
18.2.	Description	108
18.3.	Using the Feature	109
19.	Declarative Part in Generate Statements	111
19.1.	Background	111
19.2.	Description	114
19.3.	Using the Feature	115
20.	Mapping Expressions to Input Ports	119
20.1.	Background	119
20.2.	Description	120
20.3.	Using the Feature	122
21.	The New Character Set	123
21.1.	Background	123
21.2.	VHDL'87/VHDL'92	124
21.3.	Using the Feature	126
21.4.	Trick	128
22.	Identifier Generalization	129
22.1.	Background	129
22.2.	Description	129
22.3.	Using the Feature	130
23.	Alias Generalization	133
23.1.	Background	133
23.2.	Description	133
23.3.	Using the Feature	134
24.	Access to Predefined Operators	137
24.1.	Background	137
24.2.	Description	139
25.	Extension of Bit String Literals	141
25.1.	Background	141
25.2.	Description	141

#012#Language Simplifications

26.	Concurrent Signal Assignment	145
26.1.	Background	145
26.2.	Description	146
26.3.	Using the Feature	148
26.4.	Performance Implication	148
27.	Report Statement	151
27.1.	Background	151
27.2.	Description	152
27.3.	Using the Feature	152
28.	Concatenation Operator	155
28.1.	Background	155
28.2.	Description	156
29.	Bracketing: Syntax Consistency	157
29.1.	Background	157
29.2.	Description	158
29.2.1.	Design Unit Declaration Syntax	158
29.2.2.	Component Declaration Syntax	159
29.2.3.	Block and Process Declaration Syntax	160
29.2.4.	Record Type Declaration Syntax	161
29.2.5.	Labeled Sequential Statements Syntax	161
29.2.6.	Subprogram Body Syntax	162
29.2.7.	Syntax Exceptions	163
29.3.	Using the Feature	163

Clarifications

30.	Static Expressions	167
30.1.	Background	167
30.1.1.	Static Expressions	168
30.1.2.	Static Names	169
30.2.	Description	170
30.2.1.	Staticness of Physical Literals	170
30.2.1.1.	VHDL'87 Problem	170
30.2.1.2.	VHDL'92 Solution	171
30.2.2.	Staticness of Names Denoting Access Values	171
30.2.2.1.	VHDL'87 Problem	171
30.2.2.2.	VHDL'92 Solution	171
30.2.3.	Aliases as Static Names	172
30.2.3.1.	VHDL'87 Problem	172
30.2.3.2.	VHDL'92 Solution	172
30.2.4.	Staticness of Subprogram Resident Constants	172
30.2.4.1.	VHDL'87 Problem	172
30.2.4.2.	VHDL'92 Solution	173
30.2.5.	Staticness of Discrete Ranges	174
30.2.5.1.	VHDL'87 Problem	174
30.2.5.2.	VHDL'92 Solution	175
30.2.6.	Staticness of Predefined Attributes	176
30.2.6.1.	VHDL'87 Problem	176
30.2.6.2.	VHDL'92 Solution	176
30.2.7.	Extensions to the Notion of Static Expression	177
30.3.	VHDL'87 / VHDL'92	177
30.4.	Using the Feature	177
31.	Run-Time Checks	181
31.1.	Background	181
31.2.	Description	182
31.2.1.	Run-Time Check of Non-Signal Parameters	182
31.2.1.1.	VHDL'87 Inconsistency	182
31.2.1.2.	VHDL'92 Solution	183
31.2.2.	Run-Time Checks of Signal Parameters	183
31.2.2.1.	VHDL'92 Solution	184
31.2.3.	VHDL'87/VHDL'92	184
32.	Interface List	187
32.1.	Background	187
32.2.	Description	188
32.3.	Using the Feature	188
33.	Association List	189
33.1.	Background	189
33.2.	Description	190
34.	Resolved Subelements in Composites	191
34.1.	Background	191
34.2.	Description	192
34.2.1.	VHDL'92 Solution	194
34.3.	VHDL'87/VHDL'92	194
34.4.	Using the Feature	195
35.	LABELS & User-defined Attributes	197
35.1.	Background	197
35.2.	Description	198
35.3.	Using the Feature	199
36.	Miscellaneous	201
36.1.	No Non-Language Defined Units in STD	201
36.2.	Generics in Root	201
36.3.	New TIME Subtype	202
36.4.	Clarification of Some Names	202
36.4.1.	Selected Against Expanded	202
36.4.2.	Using The Feature	203
36.5.	Presentation of the LRM	204

Annex	

37.	List of Reserved Words	207
38.	Informal Glossary	209
39.	Index	213




#012#
LIST OF FIGURES

Fig 2.1	Restandardization Process	12
Fig 2.2	IEEE Balloting Process	13
Fig 3.1	False Alarm Generation	26
Fig 5.1	Component Declaration, Configuration, and Instantiation	40
Fig 5.2	Direct Entity Instantiation Mechanism	41
Fig 5.3	Direct Configuration Instantiation Mechanism	42
Fig 11.1	Shift and Rotate Operator Semantics	78
Fig 12.1	Xnor Operator Truth Tables	82
Fig 13.1	No Reading Output Ports	85
Fig 13.2	Reasons for a Restriction	86
Fig 13.3	S and S'DRIVING_VALUE	87
Fig 18.1	Different Signal Assignment Capabilities	109
Fig 20.1	Mapping Expression to the input Port	120
Fig 20.2	Illegal Mapping of Expression to Input Ports	121
Fig 21.1	The VHDL'87 Character Type	124
Fig 21.2	The VHDL'92 Character Type	125
Fig 21.3	VHDL'87 Versus VHDL'92 Attributes	127
Fig 26.1	Use of the Reserved Word unaffected	147
Fig 28.1	Principle of Concatenation in VHDL'92	156
Fig 29.1	Examples of Architecture Body Syntax	158
Fig 29.2	Examples of Component Declaration Syntax	160
Fig 29.3	Examples of Block and Process Syntax	160
Fig 29.4	Examples of Record Type Declaration Syntax	161
Fig 29.5	Examples of if and case Statement Syntax	162
Fig 29.6 	Examples of procedure Body Syntax	163
Fig 30.1	Expression Classification	168
Fig 35.1	Difference Between Declarative Part & Declarative Region	199

#012#

Foreword
This book is not, in any respect, a reference manual for the VHDL language.
That purpose is served by the VHDL Language Reference Manual (LRM), which
defines the language in a formal, contractual, and unambiguous manner. Each
feature of the language is carefully described in the LRM, but the reader of
that manual is expected to be a tool builder or an experienced designer.

The present book gives an introduction to new VHDL language constructs and
illustrates some of their possible uses. The reader should be able to use the
construct and to understand the LRM where these new features are defined. This
will allow him or her to locate all the already existing details of the
language that are outside the scope of this book.

Reading this book from beginning to end is certainly an effective way to reach
a better understanding of the new possibilities of VHDL'92. Nevertheless, since
VHDL is not only a hardware description language but also an environment, the
reader may be more interested in a particular topic or domain of application.
Chapter 1 lists many of these concerns and can guide the reader to the more
pertinent features in his or her domain.

The terms VHDL'87 and VHDL'92 as used in this book need preliminary
explanation. VHDL'92 is the IEEE standard 1076, balloted in 1993. Since VHDL'92
is a new version of standard 1076, this vote renders the previous standard
(IEEE 1076/87) obsolete. Basically, there will not be two standards (VHDL'87
and VHDL'92), but only one. However, since the purpose of this book is to
present the new features to people aware of IEEE 1076/87, we will nevertheless
refer to this old version as VHDL'87.
#012#Acknowledgments

This book has been made possible thanks to:
o The European ESPRIT/ECIP2 project in which the CNET  and the IMT  are
involved.
o The sponsorship of ECIP by CEC , and of VHDL standardization activities by
France Telecom and LEDA .
o The support the authors received from their management,  Pierre Doucelance,
Roland Gerber, Jean-Louis Lardy, Jacques Lecourvoisier, Christian Maresca, Jean
Mermet, Jean Pierre Noblanc, Joel Rodriguez, from Robin Lafontaine who runs the
ECIP project and from Mike Newman of the CEC.
o The fruitful preliminary review of Roland Airiau, Vincent Olive, Jacques
Pulou, Anne Robert, Denis Rouquier.
o The very useful comments given by Maureen Timmins, by the anonymous reviewers provided
by Kluwer Academic Publishers, and by Mike Casey, editor at Kluwer.
o The excellent copy-editing provided by Gerry Geer.

The authors would also like to highlight that all the IEEE standardization
work, supported by companies and institutions in terms of traveling and time,
has been carried out by individuals under their own responsibility; that many
meetings and workshops have been held at weekends, many emails have been dated
after midnight. We acknowledge all our friends, colleagues and relations who
are already listed in the foreword of the LRM, and their families who are not.
#012#
=>	Introduction	
	New Simulation Mechanisms	
	New Structuring Mechanisms	
	New Interfacing Mechanisms	
	New Predefined Operators, Functions & Attributes
	Slight Enhancements
	Language Simplifications
	Clarifications
	Annex
#012#1.	Designer's Concerns

Since it is difficult to find a logical order for classifying application
domains such as synthesis or system design, or pragmatic considerations such as
portability or compatibility with VHDL'87, the following sections are presented
in alphabetical order.
1.1.	Analog (Mixed-Mode Simulation)
Among all the requests from users for a VHDL'92 standardization, the
requirements concerning analog domain, and more precisely mixed-mode
simulation, were most numerous: about one fifth of the total. Europeans are
particularly interested in this field.
In the very early stages of the standardization process, it became apparent
that it would not be possible, due to the very different levels of requests as
well as to scheduling, for analog extension to be included in VHDL'92. However,
because of the interest of designers in this topic, a PAR (a Project
Authorization Request) of VHDL has been launched. It is expected to be balloted
at the end of 1993 or at the beginning of 1994. The main characteristic of this
PAR is that it will be an overset of the language, that includes VHDL'92 as the
digital part.
Thus, VHDL'92 (like VHDL'87) does not cover the analog domain. Nevertheless, it
is easy to find many papers and even tutorials explaining how to model analog
parts in VHDL'87. For limited purposes, this has been done with VHDL'87 and, of
course, is possible with VHDL'92.
Indeed, VHDL'92 offers some new possibilities for this purpose. The main one is
the introduction of a foreign "mechanism" (see chapter 8) that allows foreign
models to be interfaced. These models can potentially be described in an analog
modeling language. This is not a "pure" VHDL solution, and the interface is
described so briefly that problems of portability and dependency on tool
vendors are inevitable. Nevertheless, this interface does exist, which is an
important advantage.
For people in search of a "pure" VHDL solution, one of the main problems is to
identify the "steady states" of the digital world during which the analog
kernel may execute. Last-delta activation processes (see chapter 3) should
solve this. It is also possible to imagine calling foreign subprograms
(chapter 8) from these processes to activate an external analog kernel.
Analog modeling very often depends on parameters that can vary dynamically
during simulation. One example of this is temperature. The dynamic
characteristics of such parameters cannot be represented by the use of generic
parameters. Their representation as global signals or specific ports is
definitely not satisfying. Shared variables (see chapter 4), which are in fact
global variables, have been introduced into VHDL'92 and are adapted to this
description.
1.2.	Backannotation
A global mechanism for backannotation has not been introduced into VHDL'92.
Despite much effort, all the studies in this domain result either in specific
solutions that do not cover all possible cases, or in flexible and complex
solutions that break the consistency of the language. Furthermore, a consensus
has never been reached on the nature of the problem itself: must the
backannotation mechanism be included in the language, or is it an external
tool, like a debugger ? (We do not handle breakpoints in the language.)
In the past, some papers [MAG] have shown how to build the backannotation
mechanism into the language itself. Although not very efficient in terms of
performance, and very often cumbersome to write, these solutions work. Certain
VHDL'92 features contribute to their implementation.
Incremental configuration (see chapter 6) provides a flexible way to delay the
binding of the generics related to backannotation until very late in the
elaboration phase.
It can be useful, from within an architecture body, to know which instantiation
is modeled. This information was only obtainable in VHDL by using an extra
generic parameter: the instantiation identity. A predefined attribute PATH_NAME
(chapter 17) returns a string including this information.
Backannotation mechanisms usually read the timing values from a file during
elaboration (i.e., before simulation, but when the network is known). Most of
the VHDL'87 implementations allow objects to be initialized by calling a
function reading a file. The VHDL'87 LRM is unclear on this point. This feature
is explicitly possible in VHDL'92 and therefore portable. 
It should also be noted that a standardization group defines a format to store
backannotation information in a file. Whatever the tool may be, VHDL written or
external, this format, when adopted, should be taken into account.
1.3.	Compatibility Problems Versus VHDL'87
Ensuring upward compatibility has been a serious concern of the language design
team. Indeed, for obvious industrial reasons, accomplishing this goal was the
first guideline of the standardization process.
Although if, strictly speaking, VHDL'92 is not fully compatible, the changes to
be made on a VHDL'87 source code to produce a legal VHDL'92 code are few and
simple.
As shown in the list of reserved words (chapter 37), some new reserved words
have been added. Therefore, a VHDL'87 identifier whose name is one of the new
reserved words is now illegal. The chapter discussing identifier generalization
syntax (see chapter 22) proposes a strategy for the renaming of identifiers
without loss of readability.
The attributes 'STRUCTURE and 'BEHAVIOR have been removed from the language.
This is a potential source of non-compatibility, but a quick survey of people
involved in the standardization process has shown that, due to the poor
definitions of these attributes, nobody actually used them.
The extension of the character set, type CHARACTER of the package STANDARD, is
described in chapter 21. The extension can lead to incompatibility when using
some predefined attributes on this type.
The semantics of the concatenation operator (&) has been changed according to
the index subtype of the result base type (see chapter 28). Potential problems
of compatibility may occur here also.
A large number of changes that have been made, but upward compatibility is
assured; most lines of VHDL'87 source code will run immediately in the VHDL'92
environment, and the few remaining lines can be easily corrected.
1.4.	Development Phase
Independent of the debugging tools, which are proprietary tools and therefore
outside the scope of the language, some new features in VHDL'92 can improve the
design development phase.
The attribute 'PATH_NAME (see chapter 17) returns a string describing "where we
are" in source code. Associating this feature with an assert statement, or
possibly with the new report statement (see chapter 27), provides a useful aid
for tracing the source code. 
1.5.	Determinism
VHDL'87 is deterministic if we exclude some marginal constructs such as
non-associative or non-commutative resolution functions. VHDL'92 clearly
encompasses two new sources of non-determinism. 
Due to major requests in system modeling, global variables (called "shared
variables"; see chapter 4) have been introduced. Misuse of this feature quickly
leads to non-deterministic behavior of the design.
The second source of non-determinism is related to files: it is now possible to
OPEN and CLOSE a file. This apparently slight enhancement makes it possible to
communicate between processes through files. In VHDL'87, it was theoretically
possible to achieve the same <<functionality>>, but one had to use files only
from within subprograms, and the semantics was not clearly stated. Actually,
most implementations simply disallowed it. 
Although these notions are among the most important added to the language, it
is easy not to use them in order to ensure the determinism of a design.
1.6.	Device Modeling
Some device modeling requires checking the consistency of the port values. It
is often necessary, in order to avoid "false alarms," to only perform these
checks at a steady state, i.e., just before simulation time advances. The
notion of postponed process (chapter 3) allows this, both from within the
architecture body and  from the entity declaration.
When modeling an existing device, it is desirable to use its real name as an
identifier. VHDL'92 relaxes the constraints on identifier syntax (chapter 22)
and offers an extended character set (chapter 21)  for this purpose.
1.7.	Formal Proof
Formal proof concerns are very close to those of synthesis. The problems of
pattern recognition are about the same in both domains. (Please refer to
section 1.12 of this chapter for further information.)
1.8.	Implementation Problems
It may seem amazing to find implementation considerations in a chapter entitled
"Designer's Concerns." These preoccupations are usually left to the tool
builder, and the designer ignores them. This is an error. Implementation
problems represent a cost, and this cost is paid by the end user, the designer.

For example, the notion of overloading, generally well accepted and popular
among users, is one of the most expensive implementation problems of VHDL'87.
It burdens front-ends (compile-time) and debuggers (run-time). As a result, the
price of tools is higher, good tools appear on the market later and performance
(compilation time in this case) is lower than it would be if this notion did
not exist.
Are there new notions of this kind in VHDL'92? We hope not. Implementation
impact was taken into account very early in the language design process and is
even one of the guidelines (section 2.4.1.13). Nevertheless, new concepts such
as the notion of signature (chapter 23) do not simplify the source code
analysis and probably represent a significant cost on implementation.
1.9.	Portability
Although VHDL'87 is a standard, it is not fully portable. For example, real
numbers may have different degrees of accuracy depending on implementation, and
computation results may be affected. Although it may be difficult to workaround
real number portability, there are numerous cases in which non-portability
depends on modeling practices and can be avoided.
VHDL'92 clearly states that generics for roots (see section 36.2) are legal in
VHDL but that a given implementation may prohibit them. This is a portability
issue, and the correct modeling practice is not to use generics on roots.
On the other hand, reading a file during the elaboration phase in VHDL'87 was
not portable, due to unclear assertions in the LRM. VHDL'92 explicitly allows
for such a modeling practice (see chapter 10) which, in fact, becomes portable.
The concatenation mechanism (&) of VHDL'87 was so restrictive in its use with
subtypes that some vendors allowed some digression. The result was a more
suitable (but not portable) concatenation operator. In chapter 28, the new
strategy of the operator & is detailed. Its new definition makes it both usable
and portable. Compatibility with VHDL'87 is another problem.
1.10.	Readability
VHDL'87 source code was severely criticized for its verbosity. VHDL'92 does not
fundamentally differ in this regard but some improvements should be mentioned.
Although the powerful configuration mechanism (component declaration,
instantiation, and configuration) has been retained, a notion called "direct
instantiation" (see chapter 5) has been introduced for simple cases. This new
kind of configuration allows the notion of component to be ignored in some
cases, and thereby makes unnecessary the writing of the component declaration
and configuration.
The restriction on the reading of output ports in VHDL'87 very often led to the
creation of a local variable or a global signal used only for this purpose .
This does not enhance the readability of the code. A new attribute
DRIVING_VALUE (see chapter 13) allows access to the contributing values of such
ports and should eliminate artificial variables and signals.
A new identifier syntax (chapter 22) gives more freedom in their choice and
should also contribute to a more readable code.
A new bracketing (chapter 29), in its extended form, should also result in more
readable source code, because it is syntactically more consistent.
1.11.	Simulation Efficiency
A major criticism of VHDL'87 was the lack of a sufficiently predefined
environment. VHDL'92 fills this gap by offering new operators (xnor (chapter
12), shift (chapter 11)) and attributes (IMAGE (chapter 16), VALUE (chapter
16), DRIVING_VALUE (chapter 13)) that are "wired" into the simulator, and
consequently may be efficient in terms of performance.
The attribute DRIVING_VALUE also contribute to simulation efficiency by
preventing the creation of local variables or global signals when reading an
output port (chapter 13).
The new "unaffected" clause of the concurrent signal assignment statement
(chapter 26) prevents the execution of useless transactions.
The "reject" clause (chapter 18) also avoids signal assignments.
In specific cases (for example, at the system modeling level), global variables
(shared variables chapter 4) allow replacement of global signals. The cost of a
variable in terms of simulation performance is more acceptable than the cost of
a signal (a driver to store, a scheduler to manage).
 The foreign mechanism (chapter 8), can also be used to call external programs
or models, thereby accelerating a small part of code requiring optimization.
The notion of postponed process (chapter 3) allows certain checks to be
performed on signal values only once per time point, during the last delta.
This avoids often senseless multiple checks each time a signal value varies
during certain delta delays.
1.12.	Synthesis
We can summarize the concerns in the synthesis domain as follows:
o How can a pattern be recognized?
o How can a constraint be expressed?
o What is predefined?
o What are the modeling practices?

One of the main demands of synthesis users was to add a finite-state machine
statement to the language. This demand has not been taken into account in
VHDL'92. Indeed, many methods still exist to describe a finite-state machine
(e.g.process with case statement, guarded blocks, etc. [BER]), and adding a new
one would be redundant. Nevertheless, VHDL'92 provides features for annotating
any portion of code (see chapter 7), and it is possible to indicate that such a
part of a program is supposed to be an automaton, a RAM, or an ALU.
Furthermore, the notion of a group (chapter 7) allows global annotation of a
collection of entities (e.g.blocks) in order to specify a piece of information
(e.g."they must not be synthetized"). The introduction of the new predefined
attribute 'DRIVING_VALUE (see chapter 13) will also simplify recognition by
avoiding local variables whose only purpose was to provide a means of reading
output port values.

Putting a constraint in the language was already possible in VHDL'87 by using
the attribute mechanism. This mechanism has been extended in VHDL'92. For
example, due to the notion of signature (see chapter 23), one can attribute an
enumerated type subelement in order to specify, for instance, a specific
coding. State coding is an application. The generalization of labels (see
chapter 35) to all sequential statements also allows the use of attributes for
specifying a timing constraint or a resource allocation for this operation. Of
course, these practices have to be standardized, but the possibility is now
offered by the language.

The predefined environment has been enriched by the addition of new operators
like xnor (chapter 12) or shift and rotate operations (chapter 11). No doubt
these operators will be overloaded in synthesis environment packages. The
semantics will be the same. 

Modeling practices are also a sensitive topic in the synthesis field. As is the
case for the logic type definition (package STD_LOGIC_1164), they will rely on
standard packages that are not defined within the LRM. One of the language
design guidelines explicitly disallows the introduction of an
application-specific package within the standard (see section 2.4.1.12). A very
active standardization group is currently working towards issuing standard
packages for synthesis, but this work is outside the scope of the VHDL'92
standardization.
1.13.	System Modeling
Programming languages are (or were, before VHDL) commonly used for system
modeling. VHDL'92 adds certain aspects of programming languages to VHDL.
Global variables (called "shared variables" (chapter 4)) are among these
additions.
Impure functions (chapter 10) are also a real help for system designers. By
allowing functions to have a memory or to perform read/write operations on
files, this feature introduces real non-determinism. Seen as a major problem at
a lower level of design (i.e., the gate or RTL level), this property is very
useful at the system level, where synchronization problems are not the main
issue and where the concerns are to profile a model, to make a stochastic
simulation, to find bottlenecks, etc. In this world, determinism is
overspecification.




-------------------------------------ORDER FORM------------------------------

Ref:  ftpser

Please send me: 
VHDL '92, by Berge, Fonfoua, Maginot and Rouillard
_____copy(ies) HB, ISBN 0-7923-9356-2,  $ 87.50  Dfl 180.00  GBP 65.50

  Payment enclosed to the amount of ___________________________

* Please invoice me 

* Please charge my credit card 

  Name of Card Holder: ______________________________________  

  Card. no.: ________________________________________________

  Expiry Date:______________________________________________

     Am. Ex.*          Visa*           Diners Club*           Mastercard*

Delivery address: 

Name: ___________________________________________________________________

Address: ________________________________________________________________

         ________________________________________________________________

         ________________________________________________________________

         ________________________________________________________________


Date:________________     Signature:_______________________________

To be sent to:


Outside North America                         In USA and Canada

KLUWER ACADEMIC PUBLISHERS GROUP              KLUWER ACADEMIC PUBLISHERS 
Order Dept.                                   Order Dept
P.O. Box 322                                  101 Philip Drive
3300 AH Dordrecht, The Netherlands            Norwell, 02016 MA
Tel: +31-78-524400                            Tel: 617-871-6600
Fax +31-78-524474.                            Fax: 617-871-6528
email:  vanderlinden@wkap.nl                  email: kluwer@world.std.com

Orders from individuals accompanied by payment or authorization to
charge a credit card account will ensure prompt delivery. Postage and
handling charges will be absorbed by the Publisher on all such orders.
Payment will be accepted in any convertible currency. Please check the
rate of exchange at your bank. For sales within the Netherlands please
add 6% VAT (BTW). Prices are subject to change without notice.

* Delete those that do not apply.

